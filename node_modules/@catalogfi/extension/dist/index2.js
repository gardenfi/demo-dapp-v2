class d {
  /**
   * Initializes a new instance of the class.
   *
   * @param {Object} catalog - An optional object with an `id` property representing the catalog ID injected by the extension.
   * @throws {Error} If the catalog wallet extension is not found.
   */
  constructor(o) {
    if (o)
      this.extensionId = o.id;
    else if (m())
      this.extensionId = c("chrome");
    else if (u())
      this.extensionId = c("window");
    else
      throw new Error("Catalog wallet extension not found");
  }
  send(o, l) {
    return new Promise((a, i) => {
      const n = { url: "", favicon: "" }, s = window.location.href.split("://")[1].replace(/\/$/, "");
      n.url = s;
      let e = document.querySelector("link[rel='icon']");
      if (e || (e = document.querySelector(
        "link[rel='shortcut icon']"
      )), e || (e = document.querySelector(
        "link[rel='apple-touch-icon']"
      )), e || (e = document.querySelector(
        "meta[property='og:image']"
      )), e)
        n.favicon = e instanceof HTMLMetaElement ? e.content : e.href;
      else {
        const t = new URL(window.location.href);
        n.favicon = `${t.protocol}//${t.hostname}/favicon.ico`;
      }
      chrome.runtime.sendMessage(
        this.extensionId,
        {
          method: o,
          params: l,
          metadata: n
        },
        (t) => chrome.runtime.lastError ? i(chrome.runtime.lastError) : typeof t == "object" && t && "error" in t ? i(t.error) : a(t)
      );
    });
  }
}
const u = () => {
  try {
    const r = window;
    return r && r.catalog && r.catalog.id;
  } catch {
    return !1;
  }
}, c = (r) => {
  if (r === "chrome")
    return chrome.runtime.id;
  if (r === "window")
    return window.catalog.id;
  throw new Error("Invalid medium to get wallet id");
}, m = () => {
  try {
    return chrome && !!chrome.runtime && !!chrome.runtime.id;
  } catch {
    return !1;
  }
};
export {
  d as Connector,
  u as isCatalogWalletInstalled
};
