import{sleep as h,Fetcher as g,ensureVal as K}from"@catalogfi/utils";import*as w from"bip39";import{HDKey as P}from"./index27.js";import{hdKeyToAccount as v}from"./index28.js";class T{constructor(t){this.endpoint=t}async getTransactions(t){for(let e=1;e<=10;e++){const a=await this._getTransactions(t);if(typeof a.result!="string")return a.result;await h(1e3*e)}throw new Error("Unable to fetch transactions.")}async _getTransactions(t){try{const e=new URL(this.endpoint);return e.searchParams.append("module","account"),e.searchParams.append("address",t),e.searchParams.append("startblock","0"),e.searchParams.append("endblock","latest"),e.searchParams.append("offset","1"),e.searchParams.append("action","txlist"),await g.get(e)}catch(e){return{status:"0",message:e.message,result:"Failed to fetch transactions"}}}}const b=(s,t)=>`m/44'/60'/${s}'/0/${t}`,l=(s,t,e)=>{const a=b(t,s),r=v(e,{path:a});return{address:r.address,path:a,publicKey:r.publicKey,privateKey:"0x"+Buffer.from(K(r.getHdKey().privateKey,"HDKey doesn't have a private key")).toString("hex")}},x=(s,t,e,a,r)=>{const o=[];for(let n=t;n<e;n++){const{address:c,path:p,privateKey:i}=l(n,s,a),f=new Promise((u,y)=>{r.getTransactions(c).then(d=>u({address:c,path:p,privateKey:i,transactions:d})).catch(d=>y(d))});o.push(f)}return o},m=s=>P.fromMasterSeed(w.mnemonicToSeedSync(s)),k=async(s,t)=>{const e=m(s);let a=[];for(let r=0;;r++){const o=[];let n=0;for(let c=0;n<=20;c+=5){const p=await Promise.all(x(r,c,c+5,e,t));await h(1500);for(const i of p)i.transactions.length===0?n++:(o.push(i),n>0&&(n=0))}if(o.length===0)break;a.push(...o)}return a};export{T as EtherscanTxProvider,k as discover,m as generateRootNode,l as getKeysFromAddress};
