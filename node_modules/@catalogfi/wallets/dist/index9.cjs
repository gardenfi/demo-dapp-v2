"use strict";var x=Object.create;var v=Object.defineProperty;var A=Object.getOwnPropertyDescriptor;var B=Object.getOwnPropertyNames;var N=Object.getPrototypeOf,b=Object.prototype.hasOwnProperty;var O=(n,t,e,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of B(t))!b.call(n,r)&&r!==e&&v(n,r,{get:()=>t[r],enumerable:!(s=A(t,r))||s.enumerable});return n};var P=(n,t,e)=>(e=n!=null?x(N(n)):{},O(t||!n||!n.__esModule?v(e,"default",{value:n,enumerable:!0}):e,n));Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const S=require("./index8.cjs"),W=require("./index20.cjs"),o=require("bitcoinjs-lib"),q=require("ecpair"),m=require("./index6.cjs"),U=require("./index5.cjs"),C=require("@catalogfi/utils"),T=require("./index12.cjs"),E=require("./index21.cjs"),D=require("viem");class F extends U.AbstractBitcoinWallet{constructor(t,e,s,r){if(super(),this.minAmt=1e3,!e.signTypedData)throw new Error("Signer must have signTypedData method");this.jsonRPCSigner=e,this.evmNetwork=s,this.nonce=r||0,this.provider=t,this.network=t.getNetwork()===S.BitcoinNetwork.Mainnet?o.networks.bitcoin:t.getNetwork()===S.BitcoinNetwork.Testnet?o.networks.testnet:o.networks.regtest}async getSigner(){return this.signer||(this.signer=await this.getBitcoinSigner()),this.signer}getProvider(){return Promise.resolve(this.provider)}async getAddress(){const t=await this.getSigner(),e=o.payments.p2wpkh({pubkey:t.publicKey,network:this.network}).address;if(!e)throw new Error("failed to generate address");return e}async getBalance(){const t=await this.getAddress();return this.provider.getBalance(t)}async sign(t){return t=C.trim0x(t),(await this.getSigner()).sign(Buffer.from(t,"hex")).toString("hex")}async signSchnorr(t){return(await this.getSigner()).signSchnorr(t)}async getPublicKey(){return(await this.getSigner()).publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}walletConfig(){return{network:this.provider.getNetwork(),path:""}}async getBitcoinSigner(){const t={Data:[{name:"Message",type:"string"},{name:"Version",type:"string"},{name:"Nonce",type:"uint256"}]},e={Message:"Initialize your swap",Version:"1.1.0",Nonce:this.nonce},s={name:"CATALOG x WBTC GARDEN",version:"1",chainId:this.evmNetwork},r=await this.jsonRPCSigner.signTypedData({domain:s,types:t,message:e,primaryType:"Data"}),u=await import("tiny-secp256k1");return q.ECPairFactory(u).fromPrivateKey(Buffer.from(D.sha256(r).slice(2),"hex"),{network:this.network})}async send(t,e,s){const r=await this.getSigner();if(s||(s=await this.provider.suggestFee(await this.getAddress(),e,S.Urgency.FAST)),s>e)throw new Error(m.BWErrors.FEE_EXCEEDS_AMOUNT(s,e));if(e<this.minAmt)throw new Error(m.BWErrors.MIN_AMOUNT(this.minAmt));const u=await this.getAddress(),p=await this.provider.getUTXOs(u,e+s),l=p.reduce((i,d)=>i+d.value,0),a=new o.Psbt({network:this.network});for(const i of p){const d=await this.provider.getTransactionHex(i.txid);a.addInput({hash:W.reversify(i.txid),index:i.vout,nonWitnessUtxo:Buffer.from(d,"hex")})}const c=l-e-s;return a.addOutput({address:t,value:e}),c>0&&a.addOutput({address:u,value:c}),a.signAllInputs(r).finalizeAllInputs(),this.provider.broadcast(a.extractTransaction().toHex())}async spend(t,e,{toAddress:s,fee:r,nSequence:u,unlockScript:p,witness:l}){const a=this.getScriptType(e,this.network),c=await this.provider.getBalance(e);if(c===0)throw new Error(m.BWErrors.SCRIPT_NOT_FUNDED);let i=new o.Transaction;if(i.version=2,r??=await this.provider.suggestFee(e,c,S.Urgency.FAST),r>c)throw new Error(m.BWErrors.FEE_EXCEEDS_AMOUNT(r,c));const d=await this.provider.getUTXOs(e);i=await this.addAllInputs(i,e,this.provider,{nSequence:u,utxos:d}),i.addOutput(await this.toOutputScript(s??await this.getAddress()),c-r);for(let h=0;h<i.ins.length;h++)if(a===E.ScriptType.P2SH){if(!p)throw new Error("Unlock script is required for p2sh");const g=[];for(const w of p)if(w instanceof T.AddSignature){const y=w.sigHashType,k=i.hashForSignature(h,t,y);g.push(o.script.signature.encode(Buffer.from(await this.sign(k.toString("hex")),"hex"),y))}else g.push(w);const f=o.payments.p2sh({redeem:{input:o.script.compile(g),output:t},network:this.network}).redeem?.input;i.setInputScript(h,f)}else if(a===E.ScriptType.P2WSH){if(!l)throw new Error("Witness is required for p2wsh");const g=[];for(const f of l)if(f instanceof T.AddSignature){const w=f.sigHashType,y=i.hashForWitnessV0(h,t,d[h].value,w);g.push(o.script.signature.encode(Buffer.from(await this.sign(y.toString("hex")),"hex"),w))}else g.push(f);i.setWitness(h,g)}else throw new Error("Invalid script type "+a);return this.provider.broadcast(i.toHex())}}exports.BitcoinOTA=F;
