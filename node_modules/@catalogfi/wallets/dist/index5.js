import{address as n,payments as o,script as u}from"bitcoinjs-lib";import{reversify as f}from"./index20.js";import{getHTLCScript as S}from"./index24.js";import{BitcoinHTLCErrors as a}from"./index6.js";import{trim0x as d}from"@catalogfi/utils";import{AddSignature as w,SigHashType as c}from"./index12.js";import{ScriptType as p}from"./index21.js";import{WalletChain as E}from"./index2.js";class A{addSignatureSegwitV0(e=c.ALL){return new w("segwitV0",e)}addSignatureP2sh(e=c.ALL){return new w("p2shSignature",e)}addSignatureSegwitV1(e=c.ALL){return new w("segwitV1",e)}chain(){return E.Bitcoin}async addAllInputs(e,t,r,s){const i=(s==null?void 0:s.utxos)||await r.getUTXOs(t);for(const h of i){const m=await r.getTxIndex(h.txid,t);e.addInput(f(h.txid),m,s==null?void 0:s.nSequence)}return e}async suggestFee(e,t){const r=await this.getAddress();return(await this.getProvider()).suggestFee(r,e,t)}async toOutputScript(e){return n.toOutputScript(e,await this.getNetwork())}totalValueFromUTXOs(e){return e.reduce((t,r)=>t+r.value,0)}async scriptToAddress(e){const t=o.p2wsh({redeem:{output:e},network:await this.getNetwork()});if(!t.address)throw new Error("Could not generate p2wsh address");return t.address}async newSwap(e){if(e.secretHash=d(e.secretHash),e.secretHash.length!==64)throw new Error(a.INVALID_SECRET_HASH);const{script:t,address:r}=S(e,await this.getNetwork());return new l(this,{...e,redeemScript:t,scriptAddress:r})}getScriptType(e,t){try{if(n.fromBase58Check(e).version===t.scriptHash)return p.P2SH}catch{const r=n.fromBech32(e);if(r.prefix!==t.bech32)throw new Error("Invalid address");if(r.version===0){if(r.data.length===32)return p.P2WSH}else if(r.version===1&&r.data.length===32)return p.P2TR}throw new Error("Unsupported script type")}}class l{constructor(e,t){if(t.secretHash=d(t.secretHash),t.secretHash.length!==64)throw new Error(a.INVALID_SECRET_HASH);this.wallet=e,this.swap=t}id(){return this.swap.scriptAddress}async init(){return this.wallet.send(this.swap.scriptAddress,+this.swap.amount.toString())}async redeem(e,t){e=d(e);const r=[this.wallet.addSignatureSegwitV0(),Buffer.from(await this.wallet.getPublicKey(),"hex"),Buffer.from(e,"hex"),u.number.encode(1),this.swap.redeemScript],s=o.p2wsh({redeem:{output:this.swap.redeemScript},network:await this.wallet.getNetwork()}).address;if(!s)throw new Error("Could not generate p2wsh address for redeem script");try{return await this.wallet.spend(this.swap.redeemScript,s,{witness:r,toAddress:t})}catch(i){throw i.message.includes("OP_EQUALVERIFY")?new Error(a.INVALID_PUBKEY_OR_SECRET):new Error(i.message)}}async refund(e){const t=[this.wallet.addSignatureSegwitV0(),Buffer.from(await this.wallet.getPublicKey(),"hex"),u.number.encode(0),this.swap.redeemScript];try{const r=o.p2wsh({redeem:{output:this.swap.redeemScript},network:await this.wallet.getNetwork()}).address;if(!r)throw new Error("Could not generate p2wsh address for refund script");return await this.wallet.spend(this.swap.redeemScript,r,{toAddress:e,witness:t,nSequence:this.swap.expiryBlocks})}catch(r){throw r.message.includes("OP_EQUALVERIFY")?new Error(a.INVALID_PUBKEY):r.message.includes("BIP")?new Error(a.ORDER_NOT_EXPIRED):new Error(r.message)}}}export{A as AbstractBitcoinWallet,l as BitcoinHTLC};
