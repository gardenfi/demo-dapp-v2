import{BytesSizeMismatchError as v}from"./index108.js";import{InvalidAddressError as l}from"./index52.js";import{isAddress as E}from"./index53.js";import{size as y}from"./index74.js";import{numberToHex as x}from"./index42.js";import{integerRegex as z,bytesRegex as D}from"./index109.js";function w(e){const{domain:a,message:d,primaryType:m,types:s}=e,o=(c,g)=>{for(const I of c){const{name:u,type:i}=I,n=g[u],t=i.match(z);if(t&&(typeof n=="number"||typeof n=="bigint")){const[b,r,h]=t;x(n,{signed:r==="int",size:Number.parseInt(h)/8})}if(i==="address"&&typeof n=="string"&&!E(n))throw new l({address:n});const p=i.match(D);if(p){const[b,r]=p;if(r&&y(n)!==Number.parseInt(r))throw new v({expectedSize:Number.parseInt(r),givenSize:y(n)})}const f=s[i];f&&o(f,n)}};s.EIP712Domain&&a&&o(s.EIP712Domain,a),m!=="EIP712Domain"&&o(s[m],d)}function P({domain:e}){return[typeof(e==null?void 0:e.name)=="string"&&{name:"name",type:"string"},(e==null?void 0:e.version)&&{name:"version",type:"string"},typeof(e==null?void 0:e.chainId)=="number"&&{name:"chainId",type:"uint256"},(e==null?void 0:e.verifyingContract)&&{name:"verifyingContract",type:"address"},(e==null?void 0:e.salt)&&{name:"salt",type:"bytes32"}].filter(Boolean)}export{P as getTypesForEIP712Domain,w as validateTypedData};
