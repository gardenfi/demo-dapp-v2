/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const x=BigInt(0),h=BigInt(1),I=BigInt(2);function l(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function p(e){if(!l(e))throw new Error("Uint8Array expected")}const T=Array.from({length:256},(e,r)=>r.toString(16).padStart(2,"0"));function d(e){p(e);let r="";for(let o=0;o<e.length;o++)r+=T[e[o]];return r}function B(e){const r=e.toString(16);return r.length&1?`0${r}`:r}function w(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}const u={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function E(e){if(e>=u._0&&e<=u._9)return e-u._0;if(e>=u._A&&e<=u._F)return e-(u._A-10);if(e>=u._a&&e<=u._f)return e-(u._a-10)}function b(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const r=e.length,o=r/2;if(r%2)throw new Error("padded hex string expected, got unpadded hex of length "+r);const t=new Uint8Array(o);for(let n=0,i=0;n<o;n++,i+=2){const c=E(e.charCodeAt(i)),s=E(e.charCodeAt(i+1));if(c===void 0||s===void 0){const a=e[i]+e[i+1];throw new Error('hex string expected, got non-hex character "'+a+'" at index '+i)}t[n]=c*16+s}return t}function v(e){return w(d(e))}function S(e){return p(e),w(d(Uint8Array.from(e).reverse()))}function A(e,r){return b(e.toString(16).padStart(r*2,"0"))}function L(e,r){return A(e,r).reverse()}function N(e){return b(B(e))}function j(e,r,o){let t;if(typeof r=="string")try{t=b(r)}catch(i){throw new Error(`${e} must be valid hex string, got "${r}". Cause: ${i}`)}else if(l(r))t=Uint8Array.from(r);else throw new Error(`${e} must be hex string or Uint8Array`);const n=t.length;if(typeof o=="number"&&n!==o)throw new Error(`${e} expected ${o} bytes, got ${n}`);return t}function _(...e){let r=0;for(let t=0;t<e.length;t++){const n=e[t];p(n),r+=n.length}const o=new Uint8Array(r);for(let t=0,n=0;t<e.length;t++){const i=e[t];o.set(i,n),n+=i.length}return o}function F(e,r){if(e.length!==r.length)return!1;let o=0;for(let t=0;t<e.length;t++)o|=e[t]^r[t];return o===0}function O(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function C(e){let r;for(r=0;e>x;e>>=h,r+=1);return r}function H(e,r){return e>>BigInt(r)&h}function q(e,r,o){return e|(o?h:x)<<BigInt(r)}const V=e=>(I<<BigInt(e-1))-h,m=e=>new Uint8Array(e),$=e=>Uint8Array.from(e);function k(e,r,o){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof r!="number"||r<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");let t=m(e),n=m(e),i=0;const c=()=>{t.fill(1),n.fill(0),i=0},s=(...f)=>o(n,t,...f),a=(f=m())=>{n=s($([0]),f),t=s(),f.length!==0&&(n=s($([1]),f),t=s())},U=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const g=[];for(;f<r;){t=s();const y=t.slice();g.push(y),f+=t.length}return _(...g)};return(f,g)=>{c(),a(f);let y;for(;!(y=g(U()));)a();return c(),y}}const D={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||l(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,r)=>r.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function G(e,r,o={}){const t=(n,i,c)=>{const s=D[i];if(typeof s!="function")throw new Error(`Invalid validator "${i}", expected function`);const a=e[n];if(!(c&&a===void 0)&&!s(a,e))throw new Error(`Invalid param ${String(n)}=${a} (${typeof a}), expected ${i}`)};for(const[n,i]of Object.entries(r))t(n,i,!1);for(const[n,i]of Object.entries(o))t(n,i,!0);return e}export{p as abytes,H as bitGet,C as bitLen,V as bitMask,q as bitSet,d as bytesToHex,v as bytesToNumberBE,S as bytesToNumberLE,_ as concatBytes,k as createHmacDrbg,j as ensureBytes,F as equalBytes,b as hexToBytes,w as hexToNumber,l as isBytes,A as numberToBytesBE,L as numberToBytesLE,B as numberToHexUnpadded,N as numberToVarBytesBE,O as utf8ToBytes,G as validateObject};
