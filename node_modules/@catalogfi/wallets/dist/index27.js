import{hmac as b}from"./index35.js";import{ripemd160 as x}from"./index30.js";import{sha256 as m}from"./index31.js";import{sha512 as g}from"./index36.js";import{bytes as y}from"./index37.js";import{utf8ToBytes as C,concatBytes as d,createView as v,bytesToHex as H,hexToBytes as B}from"./index38.js";import{secp256k1 as a}from"./index39.js";import{mod as k}from"./index40.js";import{createBase58check as N}from"./index41.js";/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const c=a.ProjectivePoint,w=N(m);function E(s){return BigInt(`0x${H(s)}`)}function S(s){return B(s.toString(16).padStart(64,"0"))}const P=C("Bitcoin seed"),K={private:76066276,public:76067358},u=2147483648,U=s=>x(m(s)),D=s=>v(s).getUint32(0,!1),l=s=>{if(!Number.isSafeInteger(s)||s<0||s>2**32-1)throw new Error(`Invalid number=${s}. Should be from 0 to 2 ** 32 - 1`);const e=new Uint8Array(4);return v(e).setUint32(0,s,!1),e};class p{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return D(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return w.encode(this.serialize(this.versions.private,d(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return w.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(e,t=K){if(y(e),8*e.length<128||8*e.length>512)throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const i=b(g,P,e);return new p({versions:t,chainCode:i.slice(32),privateKey:i.slice(0,32)})}static fromExtendedKey(e,t=K){const i=w.decode(e),n=v(i),o=n.getUint32(0,!1),h={versions:t,depth:i[4],parentFingerprint:n.getUint32(5,!1),index:n.getUint32(9,!1),chainCode:i.slice(13,45)},r=i.slice(45),f=r[0]===0;if(o!==t[f?"private":"public"])throw new Error("Version mismatch");return f?new p({...h,privateKey:r.slice(1)}):new p({...h,publicKey:r})}static fromJSON(e){return p.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||K,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!a.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey=typeof e.privateKey=="bigint"?e.privateKey:E(e.privateKey),this.privKeyBytes=S(this.privKey),this.pubKey=a.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this.pubKey=c.fromHex(e.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=U(this.pubKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let i=this;for(const n of t){const o=/^(\d+)('?)$/.exec(n),h=o&&o[1];if(!o||o.length!==3||typeof h!="string")throw new Error(`Invalid child index: ${n}`);let r=+h;if(!Number.isSafeInteger(r)||r>=u)throw new Error("Invalid index");o[2]==="'"&&(r+=u),i=i.deriveChild(r)}return i}deriveChild(e){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let t=l(e);if(e>=u){const r=this.privateKey;if(!r)throw new Error("Could not derive hardened child key");t=d(new Uint8Array([0]),r,t)}else t=d(this.pubKey,t);const i=b(g,this.chainCode,t),n=E(i.slice(0,32)),o=i.slice(32);if(!a.utils.isValidPrivateKey(n))throw new Error("Tweak bigger than curve order");const h={versions:this.versions,chainCode:o,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e};try{if(this.privateKey){const r=k(this.privKey+n,a.CURVE.n);if(!a.utils.isValidPrivateKey(r))throw new Error("The tweak was out of range or the resulted private key is invalid");h.privateKey=r}else{const r=c.fromHex(this.pubKey).add(c.fromPrivateKey(n));if(r.equals(c.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");h.publicKey=r.toRawBytes(!0)}return new p(h)}catch{return this.deriveChild(e+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return y(e,32),a.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if(y(e,32),y(t,64),!this.publicKey)throw new Error("No publicKey set!");let i;try{i=a.Signature.fromCompact(t)}catch{return!1}return a.verify(i,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return y(t,33),d(l(e),new Uint8Array([this.depth]),l(this.parentFingerprint),l(this.index),this.chainCode,t)}}export{u as HARDENED_OFFSET,p as HDKey};
