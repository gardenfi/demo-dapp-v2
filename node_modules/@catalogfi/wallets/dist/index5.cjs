"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const i=require("bitcoinjs-lib"),l=require("./index20.cjs"),g=require("./index24.cjs"),a=require("./index6.cjs"),d=require("@catalogfi/utils"),n=require("./index12.cjs"),c=require("./index21.cjs"),S=require("./index2.cjs");class m{addSignatureSegwitV0(e=n.SigHashType.ALL){return new n.AddSignature("segwitV0",e)}addSignatureP2sh(e=n.SigHashType.ALL){return new n.AddSignature("p2shSignature",e)}addSignatureSegwitV1(e=n.SigHashType.ALL){return new n.AddSignature("segwitV1",e)}chain(){return S.WalletChain.Bitcoin}async addAllInputs(e,t,r,s){const o=s?.utxos||await r.getUTXOs(t);for(const u of o){const p=await r.getTxIndex(u.txid,t);e.addInput(l.reversify(u.txid),p,s?.nSequence)}return e}async suggestFee(e,t){const r=await this.getAddress();return(await this.getProvider()).suggestFee(r,e,t)}async toOutputScript(e){return i.address.toOutputScript(e,await this.getNetwork())}totalValueFromUTXOs(e){return e.reduce((t,r)=>t+r.value,0)}async scriptToAddress(e){const t=i.payments.p2wsh({redeem:{output:e},network:await this.getNetwork()});if(!t.address)throw new Error("Could not generate p2wsh address");return t.address}async newSwap(e){if(e.secretHash=d.trim0x(e.secretHash),e.secretHash.length!==64)throw new Error(a.BitcoinHTLCErrors.INVALID_SECRET_HASH);const{script:t,address:r}=g.getHTLCScript(e,await this.getNetwork());return new w(this,{...e,redeemScript:t,scriptAddress:r})}getScriptType(e,t){try{if(i.address.fromBase58Check(e).version===t.scriptHash)return c.ScriptType.P2SH}catch{const s=i.address.fromBech32(e);if(s.prefix!==t.bech32)throw new Error("Invalid address");if(s.version===0){if(s.data.length===32)return c.ScriptType.P2WSH}else if(s.version===1&&s.data.length===32)return c.ScriptType.P2TR}throw new Error("Unsupported script type")}}class w{constructor(e,t){if(t.secretHash=d.trim0x(t.secretHash),t.secretHash.length!==64)throw new Error(a.BitcoinHTLCErrors.INVALID_SECRET_HASH);this.wallet=e,this.swap=t}id(){return this.swap.scriptAddress}async init(){return this.wallet.send(this.swap.scriptAddress,+this.swap.amount.toString())}async redeem(e,t){e=d.trim0x(e);const r=[this.wallet.addSignatureSegwitV0(),Buffer.from(await this.wallet.getPublicKey(),"hex"),Buffer.from(e,"hex"),i.script.number.encode(1),this.swap.redeemScript],s=i.payments.p2wsh({redeem:{output:this.swap.redeemScript},network:await this.wallet.getNetwork()}).address;if(!s)throw new Error("Could not generate p2wsh address for redeem script");try{return await this.wallet.spend(this.swap.redeemScript,s,{witness:r,toAddress:t})}catch(o){throw o.message.includes("OP_EQUALVERIFY")?new Error(a.BitcoinHTLCErrors.INVALID_PUBKEY_OR_SECRET):new Error(o.message)}}async refund(e){const t=[this.wallet.addSignatureSegwitV0(),Buffer.from(await this.wallet.getPublicKey(),"hex"),i.script.number.encode(0),this.swap.redeemScript];try{const r=i.payments.p2wsh({redeem:{output:this.swap.redeemScript},network:await this.wallet.getNetwork()}).address;if(!r)throw new Error("Could not generate p2wsh address for refund script");return await this.wallet.spend(this.swap.redeemScript,r,{toAddress:e,witness:t,nSequence:this.swap.expiryBlocks})}catch(r){throw r.message.includes("OP_EQUALVERIFY")?new Error(a.BitcoinHTLCErrors.INVALID_PUBKEY):r.message.includes("BIP")?new Error(a.BitcoinHTLCErrors.ORDER_NOT_EXPIRED):new Error(r.message)}}}exports.AbstractBitcoinWallet=m;exports.BitcoinHTLC=w;
