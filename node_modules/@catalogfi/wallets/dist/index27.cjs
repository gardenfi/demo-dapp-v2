"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const b=require("./index35.cjs"),m=require("./index30.cjs"),E=require("./index31.cjs"),K=require("./index36.cjs"),u=require("./index37.cjs"),o=require("./index38.cjs"),c=require("./index39.cjs"),x=require("./index40.cjs"),k=require("./index41.cjs");/*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */const y=c.secp256k1.ProjectivePoint,v=k.createBase58check(E.sha256);function g(s){return BigInt(`0x${o.bytesToHex(s)}`)}function C(s){return o.hexToBytes(s.toString(16).padStart(64,"0"))}const B=o.utf8ToBytes("Bitcoin seed"),w={private:76066276,public:76067358},l=2147483648,S=s=>m.ripemd160(E.sha256(s)),N=s=>o.createView(s).getUint32(0,!1),d=s=>{if(!Number.isSafeInteger(s)||s<0||s>2**32-1)throw new Error(`Invalid number=${s}. Should be from 0 to 2 ** 32 - 1`);const e=new Uint8Array(4);return o.createView(e).setUint32(0,s,!1),e};class p{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return N(this.pubHash)}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return v.encode(this.serialize(this.versions.private,o.concatBytes(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return v.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(e,t=w){if(u.bytes(e),8*e.length<128||8*e.length>512)throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const i=b.hmac(K.sha512,B,e);return new p({versions:t,chainCode:i.slice(32),privateKey:i.slice(0,32)})}static fromExtendedKey(e,t=w){const i=v.decode(e),n=o.createView(i),a=n.getUint32(0,!1),h={versions:t,depth:i[4],parentFingerprint:n.getUint32(5,!1),index:n.getUint32(9,!1),chainCode:i.slice(13,45)},r=i.slice(45),f=r[0]===0;if(a!==t[f?"private":"public"])throw new Error("Version mismatch");return f?new p({...h,privateKey:r.slice(1)}):new p({...h,publicKey:r})}static fromJSON(e){return p.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||typeof e!="object")throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||w,this.depth=e.depth||0,this.chainCode=e.chainCode||null,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!c.secp256k1.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey=typeof e.privateKey=="bigint"?e.privateKey:g(e.privateKey),this.privKeyBytes=C(this.privKey),this.pubKey=c.secp256k1.getPublicKey(e.privateKey,!0)}else if(e.publicKey)this.pubKey=y.fromHex(e.publicKey).toRawBytes(!0);else throw new Error("HDKey: no public or private key provided");this.pubHash=S(this.pubKey)}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let i=this;for(const n of t){const a=/^(\d+)('?)$/.exec(n),h=a&&a[1];if(!a||a.length!==3||typeof h!="string")throw new Error(`Invalid child index: ${n}`);let r=+h;if(!Number.isSafeInteger(r)||r>=l)throw new Error("Invalid index");a[2]==="'"&&(r+=l),i=i.deriveChild(r)}return i}deriveChild(e){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let t=d(e);if(e>=l){const r=this.privateKey;if(!r)throw new Error("Could not derive hardened child key");t=o.concatBytes(new Uint8Array([0]),r,t)}else t=o.concatBytes(this.pubKey,t);const i=b.hmac(K.sha512,this.chainCode,t),n=g(i.slice(0,32)),a=i.slice(32);if(!c.secp256k1.utils.isValidPrivateKey(n))throw new Error("Tweak bigger than curve order");const h={versions:this.versions,chainCode:a,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e};try{if(this.privateKey){const r=x.mod(this.privKey+n,c.secp256k1.CURVE.n);if(!c.secp256k1.utils.isValidPrivateKey(r))throw new Error("The tweak was out of range or the resulted private key is invalid");h.privateKey=r}else{const r=y.fromHex(this.pubKey).add(y.fromPrivateKey(n));if(r.equals(y.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");h.publicKey=r.toRawBytes(!0)}return new p(h)}catch{return this.deriveChild(e+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return u.bytes(e,32),c.secp256k1.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if(u.bytes(e,32),u.bytes(t,64),!this.publicKey)throw new Error("No publicKey set!");let i;try{i=c.secp256k1.Signature.fromCompact(t)}catch{return!1}return c.secp256k1.verify(i,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return u.bytes(t,33),o.concatBytes(d(e),new Uint8Array([this.depth]),d(this.parentFingerprint),d(this.index),this.chainCode,t)}}exports.HARDENED_OFFSET=l;exports.HDKey=p;
