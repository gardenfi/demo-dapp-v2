"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const et=require("./index93.cjs"),J=require("./index40.cjs"),h=require("./index67.cjs");/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function at(v){const n=et.validateBasic(v);h.validateObject(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:x,a:N}=n;if(t){if(!x.eql(N,x.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:ct,hexToBytes:ut}=h,k={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(v){const{Err:n}=k;if(v.length<2||v[0]!==2)throw new n("Invalid signature integer tag");const t=v[1],x=v.subarray(2,t+2);if(!t||x.length!==t)throw new n("Invalid signature integer: wrong length");if(x[0]&128)throw new n("Invalid signature integer: negative");if(x[0]===0&&!(x[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:ct(x),l:v.subarray(t+2)}},toSig(v){const{Err:n}=k,t=typeof v=="string"?ut(v):v;h.abytes(t);let x=t.length;if(x<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==x-2)throw new n("Invalid signature: incorrect length");const{d:N,l:Z}=k._parseInt(t.subarray(2)),{d:Y,l:R}=k._parseInt(Z);if(R.length)throw new n("Invalid signature: left bytes after parsing");return{r:N,s:Y}},hexFromSig(v){const n=S=>Number.parseInt(S[0],16)&8?"00"+S:S,t=S=>{const V=S.toString(16);return V.length&1?`0${V}`:V},x=n(t(v.s)),N=n(t(v.r)),Z=x.length/2,Y=N.length/2,R=t(Z),L=t(Y);return`30${t(Y+Z+4)}02${L}${N}02${R}${x}`}},C=BigInt(0),F=BigInt(1);BigInt(2);const ot=BigInt(3);BigInt(4);function it(v){const n=at(v),{Fp:t}=n,x=n.toBytes||((m,r,i)=>{const o=r.toAffine();return h.concatBytes(Uint8Array.from([4]),t.toBytes(o.x),t.toBytes(o.y))}),N=n.fromBytes||(m=>{const r=m.subarray(1),i=t.fromBytes(r.subarray(0,t.BYTES)),o=t.fromBytes(r.subarray(t.BYTES,2*t.BYTES));return{x:i,y:o}});function Z(m){const{a:r,b:i}=n,o=t.sqr(m),u=t.mul(o,m);return t.add(t.add(u,t.mul(m,r)),i)}if(!t.eql(t.sqr(n.Gy),Z(n.Gx)))throw new Error("bad generator point: equation left != right");function Y(m){return typeof m=="bigint"&&C<m&&m<n.n}function R(m){if(!Y(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function L(m){const{allowedPrivateKeyLengths:r,nByteLength:i,wrapPrivateKey:o,n:u}=n;if(r&&typeof m!="bigint"){if(h.isBytes(m)&&(m=h.bytesToHex(m)),typeof m!="string"||!r.includes(m.length))throw new Error("Invalid key");m=m.padStart(i*2,"0")}let f;try{f=typeof m=="bigint"?m:h.bytesToNumberBE(h.ensureBytes("private key",m,i))}catch{throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof m}`)}return o&&(f=J.mod(f,u)),R(f),f}const S=new Map;function V(m){if(!(m instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(r,i,o){if(this.px=r,this.py=i,this.pz=o,r==null||!t.isValid(r))throw new Error("x required");if(i==null||!t.isValid(i))throw new Error("y required");if(o==null||!t.isValid(o))throw new Error("z required")}static fromAffine(r){const{x:i,y:o}=r||{};if(!r||!t.isValid(i)||!t.isValid(o))throw new Error("invalid affine point");if(r instanceof w)throw new Error("projective point not allowed");const u=f=>t.eql(f,t.ZERO);return u(i)&&u(o)?w.ZERO:new w(i,o,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(r){const i=t.invertBatch(r.map(o=>o.pz));return r.map((o,u)=>o.toAffine(i[u])).map(w.fromAffine)}static fromHex(r){const i=w.fromAffine(N(h.ensureBytes("pointHex",r)));return i.assertValidity(),i}static fromPrivateKey(r){return w.BASE.multiply(L(r))}_setWindowSize(r){this._WINDOW_SIZE=r,S.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:r,y:i}=this.toAffine();if(!t.isValid(r)||!t.isValid(i))throw new Error("bad point: x or y not FE");const o=t.sqr(i),u=Z(r);if(!t.eql(o,u))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:r}=this.toAffine();if(t.isOdd)return!t.isOdd(r);throw new Error("Field doesn't support isOdd")}equals(r){V(r);const{px:i,py:o,pz:u}=this,{px:f,py:g,pz:y}=r,a=t.eql(t.mul(i,y),t.mul(f,u)),c=t.eql(t.mul(o,y),t.mul(g,u));return a&&c}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:r,b:i}=n,o=t.mul(i,ot),{px:u,py:f,pz:g}=this;let y=t.ZERO,a=t.ZERO,c=t.ZERO,d=t.mul(u,u),z=t.mul(f,f),B=t.mul(g,g),p=t.mul(u,f);return p=t.add(p,p),c=t.mul(u,g),c=t.add(c,c),y=t.mul(r,c),a=t.mul(o,B),a=t.add(y,a),y=t.sub(z,a),a=t.add(z,a),a=t.mul(y,a),y=t.mul(p,y),c=t.mul(o,c),B=t.mul(r,B),p=t.sub(d,B),p=t.mul(r,p),p=t.add(p,c),c=t.add(d,d),d=t.add(c,d),d=t.add(d,B),d=t.mul(d,p),a=t.add(a,d),B=t.mul(f,g),B=t.add(B,B),d=t.mul(B,p),y=t.sub(y,d),c=t.mul(B,z),c=t.add(c,c),c=t.add(c,c),new w(y,a,c)}add(r){V(r);const{px:i,py:o,pz:u}=this,{px:f,py:g,pz:y}=r;let a=t.ZERO,c=t.ZERO,d=t.ZERO;const z=n.a,B=t.mul(n.b,ot);let p=t.mul(i,f),q=t.mul(o,g),I=t.mul(u,y),D=t.add(i,o),e=t.add(f,g);D=t.mul(D,e),e=t.add(p,q),D=t.sub(D,e),e=t.add(i,u);let s=t.add(f,y);return e=t.mul(e,s),s=t.add(p,I),e=t.sub(e,s),s=t.add(o,u),a=t.add(g,y),s=t.mul(s,a),a=t.add(q,I),s=t.sub(s,a),d=t.mul(z,e),a=t.mul(B,I),d=t.add(a,d),a=t.sub(q,d),d=t.add(q,d),c=t.mul(a,d),q=t.add(p,p),q=t.add(q,p),I=t.mul(z,I),e=t.mul(B,e),q=t.add(q,I),I=t.sub(p,I),I=t.mul(z,I),e=t.add(e,I),p=t.mul(q,e),c=t.add(c,p),p=t.mul(s,e),a=t.mul(D,a),a=t.sub(a,p),p=t.mul(D,q),d=t.mul(s,d),d=t.add(d,p),new w(a,c,d)}subtract(r){return this.add(r.negate())}is0(){return this.equals(w.ZERO)}wNAF(r){return U.wNAFCached(this,S,r,i=>{const o=t.invertBatch(i.map(u=>u.pz));return i.map((u,f)=>u.toAffine(o[f])).map(w.fromAffine)})}multiplyUnsafe(r){const i=w.ZERO;if(r===C)return i;if(R(r),r===F)return this;const{endo:o}=n;if(!o)return U.unsafeLadder(this,r);let{k1neg:u,k1:f,k2neg:g,k2:y}=o.splitScalar(r),a=i,c=i,d=this;for(;f>C||y>C;)f&F&&(a=a.add(d)),y&F&&(c=c.add(d)),d=d.double(),f>>=F,y>>=F;return u&&(a=a.negate()),g&&(c=c.negate()),c=new w(t.mul(c.px,o.beta),c.py,c.pz),a.add(c)}multiply(r){R(r);let i=r,o,u;const{endo:f}=n;if(f){const{k1neg:g,k1:y,k2neg:a,k2:c}=f.splitScalar(i);let{p:d,f:z}=this.wNAF(y),{p:B,f:p}=this.wNAF(c);d=U.constTimeNegate(g,d),B=U.constTimeNegate(a,B),B=new w(t.mul(B.px,f.beta),B.py,B.pz),o=d.add(B),u=z.add(p)}else{const{p:g,f:y}=this.wNAF(i);o=g,u=y}return w.normalizeZ([o,u])[0]}multiplyAndAddUnsafe(r,i,o){const u=w.BASE,f=(y,a)=>a===C||a===F||!y.equals(u)?y.multiplyUnsafe(a):y.multiply(a),g=f(this,i).add(f(r,o));return g.is0()?void 0:g}toAffine(r){const{px:i,py:o,pz:u}=this,f=this.is0();r==null&&(r=f?t.ONE:t.inv(u));const g=t.mul(i,r),y=t.mul(o,r),a=t.mul(u,r);if(f)return{x:t.ZERO,y:t.ZERO};if(!t.eql(a,t.ONE))throw new Error("invZ was invalid");return{x:g,y}}isTorsionFree(){const{h:r,isTorsionFree:i}=n;if(r===F)return!0;if(i)return i(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:r,clearCofactor:i}=n;return r===F?this:i?i(w,this):this.multiplyUnsafe(n.h)}toRawBytes(r=!0){return this.assertValidity(),x(w,this,r)}toHex(r=!0){return h.bytesToHex(this.toRawBytes(r))}}w.BASE=new w(n.Gx,n.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const X=n.nBitLength,U=et.wNAF(w,n.endo?Math.ceil(X/2):X);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:L,weierstrassEquation:Z,isWithinCurveOrder:Y}}function lt(v){const n=et.validateBasic(v);return h.validateObject(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ft(v){const n=lt(v),{Fp:t,n:x}=n,N=t.BYTES+1,Z=2*t.BYTES+1;function Y(e){return C<e&&e<t.ORDER}function R(e){return J.mod(e,x)}function L(e){return J.invert(e,x)}const{ProjectivePoint:S,normPrivateKeyToScalar:V,weierstrassEquation:w,isWithinCurveOrder:X}=it({...n,toBytes(e,s,l){const b=s.toAffine(),E=t.toBytes(b.x),O=h.concatBytes;return l?O(Uint8Array.from([s.hasEvenY()?2:3]),E):O(Uint8Array.from([4]),E,t.toBytes(b.y))},fromBytes(e){const s=e.length,l=e[0],b=e.subarray(1);if(s===N&&(l===2||l===3)){const E=h.bytesToNumberBE(b);if(!Y(E))throw new Error("Point is not on curve");const O=w(E);let A;try{A=t.sqrt(O)}catch(P){const K=P instanceof Error?": "+P.message:"";throw new Error("Point is not on curve"+K)}const T=(A&F)===F;return(l&1)===1!==T&&(A=t.neg(A)),{x:E,y:A}}else if(s===Z&&l===4){const E=t.fromBytes(b.subarray(0,t.BYTES)),O=t.fromBytes(b.subarray(t.BYTES,2*t.BYTES));return{x:E,y:O}}else throw new Error(`Point of length ${s} was invalid. Expected ${N} compressed bytes or ${Z} uncompressed bytes`)}}),U=e=>h.bytesToHex(h.numberToBytesBE(e,n.nByteLength));function m(e){const s=x>>F;return e>s}function r(e){return m(e)?R(-e):e}const i=(e,s,l)=>h.bytesToNumberBE(e.slice(s,l));class o{constructor(s,l,b){this.r=s,this.s=l,this.recovery=b,this.assertValidity()}static fromCompact(s){const l=n.nByteLength;return s=h.ensureBytes("compactSignature",s,l*2),new o(i(s,0,l),i(s,l,2*l))}static fromDER(s){const{r:l,s:b}=k.toSig(h.ensureBytes("DER",s));return new o(l,b)}assertValidity(){if(!X(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!X(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(s){return new o(this.r,this.s,s)}recoverPublicKey(s){const{r:l,s:b,recovery:E}=this,O=c(h.ensureBytes("msgHash",s));if(E==null||![0,1,2,3].includes(E))throw new Error("recovery id invalid");const A=E===2||E===3?l+n.n:l;if(A>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const T=E&1?"03":"02",j=S.fromHex(T+U(A)),P=L(A),K=R(-O*P),Q=R(b*P),$=S.BASE.multiplyAndAddUnsafe(j,K,Q);if(!$)throw new Error("point at infinify");return $.assertValidity(),$}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new o(this.r,R(-this.s),this.recovery):this}toDERRawBytes(){return h.hexToBytes(this.toDERHex())}toDERHex(){return k.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return h.hexToBytes(this.toCompactHex())}toCompactHex(){return U(this.r)+U(this.s)}}const u={isValidPrivateKey(e){try{return V(e),!0}catch{return!1}},normPrivateKeyToScalar:V,randomPrivateKey:()=>{const e=J.getMinHashLength(n.n);return J.mapHashToField(n.randomBytes(e),n.n)},precompute(e=8,s=S.BASE){return s._setWindowSize(e),s.multiply(BigInt(3)),s}};function f(e,s=!0){return S.fromPrivateKey(e).toRawBytes(s)}function g(e){const s=h.isBytes(e),l=typeof e=="string",b=(s||l)&&e.length;return s?b===N||b===Z:l?b===2*N||b===2*Z:e instanceof S}function y(e,s,l=!0){if(g(e))throw new Error("first arg must be private key");if(!g(s))throw new Error("second arg must be public key");return S.fromHex(s).multiply(V(e)).toRawBytes(l)}const a=n.bits2int||function(e){const s=h.bytesToNumberBE(e),l=e.length*8-n.nBitLength;return l>0?s>>BigInt(l):s},c=n.bits2int_modN||function(e){return R(a(e))},d=h.bitMask(n.nBitLength);function z(e){if(typeof e!="bigint")throw new Error("bigint expected");if(!(C<=e&&e<d))throw new Error(`bigint expected < 2^${n.nBitLength}`);return h.numberToBytesBE(e,n.nByteLength)}function B(e,s,l=p){if(["recovered","canonical"].some(W=>W in l))throw new Error("sign() legacy options not supported");const{hash:b,randomBytes:E}=n;let{lowS:O,prehash:A,extraEntropy:T}=l;O==null&&(O=!0),e=h.ensureBytes("msgHash",e),A&&(e=h.ensureBytes("prehashed msgHash",b(e)));const j=c(e),P=V(s),K=[z(P),z(j)];if(T!=null&&T!==!1){const W=T===!0?E(t.BYTES):T;K.push(h.ensureBytes("extraEntropy",W))}const Q=h.concatBytes(...K),$=j;function tt(W){const G=a(W);if(!X(G))return;const rt=L(G),H=S.BASE.multiply(G).toAffine(),M=R(H.x);if(M===C)return;const _=R(rt*R($+M*P));if(_===C)return;let nt=(H.x===M?0:2)|Number(H.y&F),st=_;return O&&m(_)&&(st=r(_),nt^=1),new o(M,st,nt)}return{seed:Q,k2sig:tt}}const p={lowS:n.lowS,prehash:!1},q={lowS:n.lowS,prehash:!1};function I(e,s,l=p){const{seed:b,k2sig:E}=B(e,s,l),O=n;return h.createHmacDrbg(O.hash.outputLen,O.nByteLength,O.hmac)(b,E)}S.BASE._setWindowSize(8);function D(e,s,l,b=q){const E=e;if(s=h.ensureBytes("msgHash",s),l=h.ensureBytes("publicKey",l),"strict"in b)throw new Error("options.strict was renamed to lowS");const{lowS:O,prehash:A}=b;let T,j;try{if(typeof E=="string"||h.isBytes(E))try{T=o.fromDER(E)}catch(H){if(!(H instanceof k.Err))throw H;T=o.fromCompact(E)}else if(typeof E=="object"&&typeof E.r=="bigint"&&typeof E.s=="bigint"){const{r:H,s:M}=E;T=new o(H,M)}else throw new Error("PARSE");j=S.fromHex(l)}catch(H){if(H.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(O&&T.hasHighS())return!1;A&&(s=n.hash(s));const{r:P,s:K}=T,Q=c(s),$=L(K),tt=R(Q*$),W=R(P*$),G=S.BASE.multiplyAndAddUnsafe(j,tt,W)?.toAffine();return G?R(G.x)===P:!1}return{CURVE:n,getPublicKey:f,getSharedSecret:y,sign:I,verify:D,ProjectivePoint:S,Signature:o,utils:u}}exports.DER=k;exports.weierstrass=ft;exports.weierstrassPoints=it;
