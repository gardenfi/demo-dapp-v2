import{BitcoinNetwork as v,Urgency as k}from"./index8.js";import{reversify as B}from"./index20.js";import{networks as l,payments as T,Psbt as O,Transaction as P,script as y}from"bitcoinjs-lib";import{ECPairFactory as _}from"ecpair";import{BWErrors as m}from"./index6.js";import{AbstractBitcoinWallet as b}from"./index5.js";import{trim0x as C}from"@catalogfi/utils";import{AddSignature as A}from"./index12.js";import{ScriptType as E}from"./index21.js";import{sha256 as D}from"viem";let x,F=(async()=>{x=class extends b{constructor(t,e,s,i){if(super(),this.minAmt=1e3,!e.signTypedData)throw new Error("Signer must have signTypedData method");this.jsonRPCSigner=e,this.evmNetwork=s,this.nonce=i||0,this.provider=t,this.network=t.getNetwork()===v.Mainnet?l.bitcoin:t.getNetwork()===v.Testnet?l.testnet:l.regtest}async getSigner(){return this.signer||(this.signer=await this.getBitcoinSigner()),this.signer}getProvider(){return Promise.resolve(this.provider)}async getAddress(){const t=await this.getSigner(),e=T.p2wpkh({pubkey:t.publicKey,network:this.network}).address;if(!e)throw new Error("failed to generate address");return e}async getBalance(){const t=await this.getAddress();return this.provider.getBalance(t)}async sign(t){return t=C(t),(await this.getSigner()).sign(Buffer.from(t,"hex")).toString("hex")}async signSchnorr(t){return(await this.getSigner()).signSchnorr(t)}async getPublicKey(){return(await this.getSigner()).publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}walletConfig(){return{network:this.provider.getNetwork(),path:""}}async getBitcoinSigner(){const t={Data:[{name:"Message",type:"string"},{name:"Version",type:"string"},{name:"Nonce",type:"uint256"}]},e={Message:"Initialize your swap",Version:"1.1.0",Nonce:this.nonce},s={name:"CATALOG x WBTC GARDEN",version:"1",chainId:this.evmNetwork},i=await this.jsonRPCSigner.signTypedData({domain:s,types:t,message:e,primaryType:"Data"}),c=await import("tiny-secp256k1").then(async o=>(await o.__tla,o));return _(c).fromPrivateKey(Buffer.from(D(i).slice(2),"hex"),{network:this.network})}async send(t,e,s){const i=await this.getSigner();if(s||(s=await this.provider.suggestFee(await this.getAddress(),e,k.FAST)),s>e)throw new Error(m.FEE_EXCEEDS_AMOUNT(s,e));if(e<this.minAmt)throw new Error(m.MIN_AMOUNT(this.minAmt));const c=await this.getAddress(),o=await this.provider.getUTXOs(c,e+s),w=o.reduce((r,g)=>r+g.value,0),n=new O({network:this.network});for(const r of o){const g=await this.provider.getTransactionHex(r.txid);n.addInput({hash:B(r.txid),index:r.vout,nonWitnessUtxo:Buffer.from(g,"hex")})}const a=w-e-s;return n.addOutput({address:t,value:e}),a>0&&n.addOutput({address:c,value:a}),n.signAllInputs(i).finalizeAllInputs(),this.provider.broadcast(n.extractTransaction().toHex())}async spend(t,e,{toAddress:s,fee:i,nSequence:c,unlockScript:o,witness:w}){var S;const n=this.getScriptType(e,this.network),a=await this.provider.getBalance(e);if(a===0)throw new Error(m.SCRIPT_NOT_FUNDED);let r=new P;if(r.version=2,i??(i=await this.provider.suggestFee(e,a,k.FAST)),i>a)throw new Error(m.FEE_EXCEEDS_AMOUNT(i,a));const g=await this.provider.getUTXOs(e);r=await this.addAllInputs(r,e,this.provider,{nSequence:c,utxos:g}),r.addOutput(await this.toOutputScript(s??await this.getAddress()),a-i);for(let h=0;h<r.ins.length;h++)if(n===E.P2SH){if(!o)throw new Error("Unlock script is required for p2sh");const p=[];for(const d of o)if(d instanceof A){const f=d.sigHashType,N=r.hashForSignature(h,t,f);p.push(y.signature.encode(Buffer.from(await this.sign(N.toString("hex")),"hex"),f))}else p.push(d);const u=(S=T.p2sh({redeem:{input:y.compile(p),output:t},network:this.network}).redeem)==null?void 0:S.input;r.setInputScript(h,u)}else if(n===E.P2WSH){if(!w)throw new Error("Witness is required for p2wsh");const p=[];for(const u of w)if(u instanceof A){const d=u.sigHashType,f=r.hashForWitnessV0(h,t,g[h].value,d);p.push(y.signature.encode(Buffer.from(await this.sign(f.toString("hex")),"hex"),d))}else p.push(u);r.setWitness(h,p)}else throw new Error("Invalid script type "+n);return this.provider.broadcast(r.toHex())}}})();export{x as BitcoinOTA,F as __tla};
