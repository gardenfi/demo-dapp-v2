import{exists as l,output as d}from"./index37.js";import{Hash as g,createView as a,toBytes as b}from"./index38.js";function L(h,s,t,i){if(typeof h.setBigUint64=="function")return h.setBigUint64(s,t,i);const n=BigInt(32),o=BigInt(4294967295),e=Number(t>>n&o),r=Number(t&o),u=i?4:0,c=i?0:4;h.setUint32(s+u,e,i),h.setUint32(s+c,r,i)}const w=(h,s,t)=>h&s^~h&t,y=(h,s,t)=>h&s^h&t^s&t;class m extends g{constructor(s,t,i,n){super(),this.blockLen=s,this.outputLen=t,this.padOffset=i,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(s),this.view=a(this.buffer)}update(s){l(this);const{view:t,buffer:i,blockLen:n}=this;s=b(s);const o=s.length;for(let e=0;e<o;){const r=Math.min(n-this.pos,o-e);if(r===n){const u=a(s);for(;n<=o-e;e+=n)this.process(u,e);continue}i.set(s.subarray(e,e+r),this.pos),this.pos+=r,e+=r,this.pos===n&&(this.process(t,0),this.pos=0)}return this.length+=s.length,this.roundClean(),this}digestInto(s){l(this),d(s,this),this.finished=!0;const{buffer:t,view:i,blockLen:n,isLE:o}=this;let{pos:e}=this;t[e++]=128,this.buffer.subarray(e).fill(0),this.padOffset>n-e&&(this.process(i,0),e=0);for(let f=e;f<n;f++)t[f]=0;L(i,n-8,BigInt(this.length*8),o),this.process(i,0);const r=a(s),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const c=u/4,p=this.get();if(c>p.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<c;f++)r.setUint32(4*f,p[f],o)}digest(){const{buffer:s,outputLen:t}=this;this.digestInto(s);const i=s.slice(0,t);return this.destroy(),i}_cloneInto(s){s||(s=new this.constructor),s.set(...this.get());const{blockLen:t,buffer:i,length:n,finished:o,destroyed:e,pos:r}=this;return s.length=n,s.pos=r,s.finished=o,s.destroyed=e,n%t&&s.buffer.set(i),s}}export{w as Chi,m as HashMD,y as Maj};
