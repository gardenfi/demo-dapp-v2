"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("@catalogfi/utils"),n=require("./index8.cjs"),u=require("./index22.cjs"),m=require("./index6.cjs");class F{constructor(t,e){this.cacheTimeout=2e3,this.utxosCache=new Map,this.APIs=e?u.verifyAPIs([e]):u.getAPIs(t),this.network=t}async getTxIndex(t,e){const s=this.APIs.map(i=>`${i}/tx/${t}`),{vout:r}=await a.Fetcher.getWithFallback(s);for(let i=0;i<r.length;i++)if(r[i].scriptpubkey_address===e)return i;throw new Error("failed to get tx index")}async broadcast(t){if(!/^[0-9a-fA-F]+$/.test(t))throw new Error("invalid tx hex");for(let e=0;e<5;e++)try{return a.Fetcher.postWithFallback(this.APIs.map(s=>`${s}/tx`),{body:t})}catch(s){if(e===4)throw s;await new Promise(r=>setTimeout(r,500))}throw new Error("failed to broadcast tx")}async getBalance(t){return(await this.getUTXOs(t)).reduce((e,s)=>e+s.value,0)}setTimeoutForCache(t){this.cacheTimeout=t}async getUTXOs(t,e){const s=this.utxosCache.get(t);if(s&&Date.now()-s.timestamp<this.cacheTimeout)return f(s.utxos,e);const r=await a.Fetcher.getWithFallback(this.APIs.map(i=>`${i}/address/${t}/utxo`));return this.utxosCache.set(t,{timestamp:Date.now(),utxos:r}),f(r,e)}async getTransactionHex(t){return a.Fetcher.getWithFallback(this.APIs.map(e=>`${e}/tx/${t}/hex`))}async getTransaction(t){return a.Fetcher.getWithFallback(this.APIs.map(e=>`${e}/tx/${t}`))}async getConfirmations(t){const e=await this.getTransaction(t);return!e.status.confirmed||!e.status.block_height?0:await this.getLatestTip()-e.status.block_height+1}async getFeeRates(){if(this.network===n.BitcoinNetwork.Regtest)return{fastestFee:8,halfHourFee:7,hourFee:6,economyFee:4,minimumFee:2};let t="";this.network===n.BitcoinNetwork.Testnet&&(t="testnet4/");const e=`https://mempool.space/${t}api/v1/fees/recommended`,s=`https://blockstream.info/${t}api/fee-estimates`,r=await a.Fetcher.getWithFallback([e,s]);return"fastestFee"in r?r.fastestFee===1?{fastestFee:5,halfHourFee:5,hourFee:5,economyFee:5,minimumFee:5}:r:{fastestFee:r[1],halfHourFee:r[5],hourFee:r[10],economyFee:r[20],minimumFee:r[25]}}async getTransactions(t,e){const s=await a.Fetcher.getWithFallback(this.APIs.map(r=>`${r}/address/${t}/txs`));if(e===n.BitcoinTxType.ALL)return s;if(e===n.BitcoinTxType.IN)return s.filter(r=>r.vout.find(i=>i.scriptpubkey_address===t));if(e===n.BitcoinTxType.OUT)return s.filter(r=>r.vin.find(i=>i.prevout.scriptpubkey_address===t));throw new Error("failed to get transactions: invalid bitcoin tx type")}getNetwork(){return this.network}async getLatestTip(){return a.Fetcher.getWithFallback(this.APIs.map(t=>`${t}/blocks/tip/height`))}async suggestFee(t,e,s){const i=(await this.getUTXOs(t,e)).length,c=2,l=await this.getFeeRates();return Math.floor(l[n.UrgencyToFeeRateKey[s]]*1.05)*(i*70+c*31+10)}}const h=o=>o.sort((t,e)=>t.status.confirmed!=e.status.confirmed?t.status.confirmed?-1:1:e.value-t.value),f=(o,t)=>{if(Array.isArray(o)){if(t){const e=o.reduce((i,c)=>i+c.value,0);if(e<t)throw new Error(m.BWErrors.INSUFFICIENT_FUNDS(e,t));let s=BigInt(0);o.sort((i,c)=>c.value-i.value);const r=[];for(const i of o)if(s+=BigInt(i.value),r.push(i),s>=t)break;return h(r)}return h(o)}return[]};exports.BitcoinProvider=F;
