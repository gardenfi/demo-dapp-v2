"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const T=BigInt(0),g=BigInt(1),$=BigInt(2);function b(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function d(t){if(!b(t))throw new Error("Uint8Array expected")}const S=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function w(t){d(t);let e="";for(let o=0;o<t.length;o++)e+=S[t[o]];return e}function A(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function h(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const c={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function B(t){if(t>=c._0&&t<=c._9)return t-c._0;if(t>=c._A&&t<=c._F)return t-(c._A-10);if(t>=c._a&&t<=c._f)return t-(c._a-10)}function p(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,o=e/2;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(o);for(let r=0,i=0;r<o;r++,i+=2){const a=B(t.charCodeAt(i)),s=B(t.charCodeAt(i+1));if(a===void 0||s===void 0){const f=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+i)}n[r]=a*16+s}return n}function I(t){return h(w(t))}function v(t){return d(t),h(w(Uint8Array.from(t).reverse()))}function _(t,e){return p(t.toString(16).padStart(e*2,"0"))}function N(t,e){return _(t,e).reverse()}function H(t){return p(A(t))}function O(t,e,o){let n;if(typeof e=="string")try{n=p(e)}catch(i){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${i}`)}else if(b(e))n=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const r=n.length;if(typeof o=="number"&&r!==o)throw new Error(`${t} expected ${o} bytes, got ${r}`);return n}function x(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];d(r),e+=r.length}const o=new Uint8Array(e);for(let n=0,r=0;n<t.length;n++){const i=t[n];o.set(i,r),r+=i.length}return o}function k(t,e){if(t.length!==e.length)return!1;let o=0;for(let n=0;n<t.length;n++)o|=t[n]^e[n];return o===0}function F(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function j(t){let e;for(e=0;t>T;t>>=g,e+=1);return e}function V(t,e){return t>>BigInt(e)&g}function C(t,e,o){return t|(o?g:T)<<BigInt(e)}const M=t=>($<<BigInt(t-1))-g,m=t=>new Uint8Array(t),E=t=>Uint8Array.from(t);function D(t,e,o){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof o!="function")throw new Error("hmacFn must be a function");let n=m(t),r=m(t),i=0;const a=()=>{n.fill(1),r.fill(0),i=0},s=(...u)=>o(r,n,...u),f=(u=m())=>{r=s(E([0]),u),n=s(),u.length!==0&&(r=s(E([1]),u),n=s())},U=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const l=[];for(;u<e;){n=s();const y=n.slice();l.push(y),u+=n.length}return x(...l)};return(u,l)=>{a(),f(u);let y;for(;!(y=l(U()));)f();return a(),y}}const G={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||b(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function L(t,e,o={}){const n=(r,i,a)=>{const s=G[i];if(typeof s!="function")throw new Error(`Invalid validator "${i}", expected function`);const f=t[r];if(!(a&&f===void 0)&&!s(f,t))throw new Error(`Invalid param ${String(r)}=${f} (${typeof f}), expected ${i}`)};for(const[r,i]of Object.entries(e))n(r,i,!1);for(const[r,i]of Object.entries(o))n(r,i,!0);return t}exports.abytes=d;exports.bitGet=V;exports.bitLen=j;exports.bitMask=M;exports.bitSet=C;exports.bytesToHex=w;exports.bytesToNumberBE=I;exports.bytesToNumberLE=v;exports.concatBytes=x;exports.createHmacDrbg=D;exports.ensureBytes=O;exports.equalBytes=k;exports.hexToBytes=p;exports.hexToNumber=h;exports.isBytes=b;exports.numberToBytesBE=_;exports.numberToBytesLE=N;exports.numberToHexUnpadded=A;exports.numberToVarBytesBE=H;exports.utf8ToBytes=F;exports.validateObject=L;
