import{BIP32Factory as T}from"bip32";import*as y from"bip39";import{networks as f,payments as l}from"bitcoinjs-lib";import*as A from"tiny-secp256k1";import{BitcoinPaths as u}from"./index19.js";import{BitcoinNetwork as k,BitcoinTxType as B}from"./index8.js";import{AddressType as g}from"./index14.js";const S={p2pk:u.bip44,p2pkh:u.bip44,"p2wpkh-p2sh":u.bip49,p2wpkh:u.bip84};function b(t){return{[k.Mainnet]:f.bitcoin,[k.Testnet]:f.testnet,[k.Regtest]:f.regtest}[t]}function w(t,e,o,s,r){var m;const a=b(r.getNetwork()),i=S[t],p=i(r.getNetwork(),e,o),n=s.derivePath(p);let c;return t.split("-").length>1?c=l.p2sh({network:a,redeem:l.p2wpkh({network:a,pubkey:n.publicKey})}).address:c=l[t]({network:a,pubkey:n.publicKey}).address,{address:c,privateKey:((m=n.privateKey)==null?void 0:m.toString("hex"))||"",type:t,path:p}}function x(t,e,o,s,r){const a=[];for(let i=e;i<o;i++)for(const p of Object.values(g)){const{address:n,type:c,path:m,privateKey:v}=w(p,i,t,s,r),N=new Promise((K,P)=>{r.getTransactions(n,B.ALL).then(d=>K({address:n,path:m,type:c,privateKey:v,transactions:d})).catch(d=>P(d))});a.push(N)}return a}const h=(t,e)=>{if(!y.validateMnemonic(t))throw new Error("Invalid mnemonic");const o=y.mnemonicToSeedSync(t);return T(A).fromSeed(o,b(e))},I=(t,e,o=0)=>{const s=h(t,e.getNetwork());return Object.values(g).map(r=>w(r,0,o,s,e))},M=(t,e,o,s=0)=>{const r=h(t,e.getNetwork());return w(o,0,s,r,e)},O=async(t,e)=>{const o=h(t,e.getNetwork()),s=20;let r=[];for(let a=0;;a++){const i=[];let p=0;for(let n=0;p<=s;n+=s){const c=await Promise.all(x(a,n,n+s,o,e));for(const m of c)m.transactions.length===0?p++:(i.push(m),p>0&&(p=0))}if(i.length===0)break;r.push(...i)}return r};export{O as discover,h as generateRootNode,M as getAccount,I as getInitialAccounts};
