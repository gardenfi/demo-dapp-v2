import{Fetcher as o}from"@catalogfi/utils";import{BitcoinNetwork as h,BitcoinTxType as c,UrgencyToFeeRateKey as l}from"./index8.js";import{verifyAPIs as f,getAPIs as g}from"./index22.js";import{BWErrors as p}from"./index6.js";class F{constructor(t,e){this.cacheTimeout=2e3,this.utxosCache=new Map,this.APIs=e?f([e]):g(t),this.network=t}async getTxIndex(t,e){const a=this.APIs.map(r=>`${r}/tx/${t}`),{vout:s}=await o.getWithFallback(a);for(let r=0;r<s.length;r++)if(s[r].scriptpubkey_address===e)return r;throw new Error("failed to get tx index")}async broadcast(t){if(!/^[0-9a-fA-F]+$/.test(t))throw new Error("invalid tx hex");for(let e=0;e<5;e++)try{return o.postWithFallback(this.APIs.map(a=>`${a}/tx`),{body:t})}catch(a){if(e===4)throw a;await new Promise(s=>setTimeout(s,500))}throw new Error("failed to broadcast tx")}async getBalance(t){return(await this.getUTXOs(t)).reduce((e,a)=>e+a.value,0)}setTimeoutForCache(t){this.cacheTimeout=t}async getUTXOs(t,e){const a=this.utxosCache.get(t);if(a&&Date.now()-a.timestamp<this.cacheTimeout)return m(a.utxos,e);const s=await o.getWithFallback(this.APIs.map(r=>`${r}/address/${t}/utxo`));return this.utxosCache.set(t,{timestamp:Date.now(),utxos:s}),m(s,e)}async getTransactionHex(t){return o.getWithFallback(this.APIs.map(e=>`${e}/tx/${t}/hex`))}async getTransaction(t){return o.getWithFallback(this.APIs.map(e=>`${e}/tx/${t}`))}async getConfirmations(t){const e=await this.getTransaction(t);return!e.status.confirmed||!e.status.block_height?0:await this.getLatestTip()-e.status.block_height+1}async getFeeRates(){if(this.network===h.Regtest)return{fastestFee:8,halfHourFee:7,hourFee:6,economyFee:4,minimumFee:2};let t="";this.network===h.Testnet&&(t="testnet4/");const e=`https://mempool.space/${t}api/v1/fees/recommended`,a=`https://blockstream.info/${t}api/fee-estimates`,s=await o.getWithFallback([e,a]);return"fastestFee"in s?s.fastestFee===1?{fastestFee:5,halfHourFee:5,hourFee:5,economyFee:5,minimumFee:5}:s:{fastestFee:s[1],halfHourFee:s[5],hourFee:s[10],economyFee:s[20],minimumFee:s[25]}}async getTransactions(t,e){const a=await o.getWithFallback(this.APIs.map(s=>`${s}/address/${t}/txs`));if(e===c.ALL)return a;if(e===c.IN)return a.filter(s=>s.vout.find(r=>r.scriptpubkey_address===t));if(e===c.OUT)return a.filter(s=>s.vin.find(r=>r.prevout.scriptpubkey_address===t));throw new Error("failed to get transactions: invalid bitcoin tx type")}getNetwork(){return this.network}async getLatestTip(){return o.getWithFallback(this.APIs.map(t=>`${t}/blocks/tip/height`))}async suggestFee(t,e,a){const s=(await this.getUTXOs(t,e)).length,r=2,n=await this.getFeeRates();return Math.floor(n[l[a]]*1.05)*(s*70+r*31+10)}}const u=i=>i.sort((t,e)=>t.status.confirmed!=e.status.confirmed?t.status.confirmed?-1:1:e.value-t.value),m=(i,t)=>{if(Array.isArray(i)){if(t){const e=i.reduce((r,n)=>r+n.value,0);if(e<t)throw new Error(p.INSUFFICIENT_FUNDS(e,t));let a=BigInt(0);i.sort((r,n)=>n.value-r.value);const s=[];for(const r of i)if(a+=BigInt(r.value),s.push(r),a>=t)break;return u(s)}return u(i)}return[]};export{F as BitcoinProvider};
