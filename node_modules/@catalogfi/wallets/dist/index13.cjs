"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("./index8.cjs"),P=require("./index29.cjs"),M=require("./index3.cjs"),T=require("./index11.cjs"),h=require("./index23.cjs"),l=require("bitcoinjs-lib"),v=require("./index20.cjs"),g=require("./index14.cjs"),B=require("./index30.cjs"),x=require("./index31.cjs"),f=require("./index32.cjs"),k=require("./index33.cjs"),S=require("@catalogfi/utils"),b=require("./index34.cjs");class w{#e;#t;#n;#s;constructor(t,e,a){this.#e=t,this.#t=e,this.#n=a,this.#s=new f.WalletDetailsStore(a,e.getNetwork())}async getAccounts(){const t=[];let e=-1;const a=S.ensureVal(await this.#s.getMnemonic(),b.MultiKeyWalletErrors.MissingMnemonic),o=h.generateRootNode(a,this.#t.getNetwork());for(;++e>=0;){const s=await this.#s.getAccounts(e);if(s instanceof Error)break;for(const n of s){const r=o.derivePath(n.path).privateKey;if(!r)throw new Error("Unable to generate private key");const c=T.BitcoinWallet.fromPrivateKey(r.toString("hex"),this.#t,{pkType:n.addressType,pkPath:n.path});t.push({...n,accountNumber:k.Path.getAccountNumber(n.path),address:await c.getAddress()})}}return t}async getMnemonic(){return S.ensureVal(await this.#s.getMnemonic(),b.MultiKeyWalletErrors.MissingMnemonic)}get provider(){return this.#t}wallets(){return Array.from(this.#e.values())}walletByAddress(t){const e=this.#e.get(t);if(!e)throw new Error("Wallet not found");return e}walletByType(t){for(const e of this.#e.values())if(e.walletConfig().addressType===t)return e}getNetwork(){return K(this.#t.getNetwork())}async getAddresses(){const t=this.#e.keys(),e=[];for(const a of t){const o=this.#e.get(a);if(!o)throw new Error("Wallet not found");const s=o.walletConfig().addressType;e.push({address:a,type:s})}return e}async getBalance(){let t=0;for(const e of this.wallets())t+=await e.getBalance();return t}async nextAccount(t){if(t??=k.Path.getAccountNumber(this.wallets()[0].walletConfig().path)+1,!(await this.#s.getAccounts(t)instanceof Error))return this.nextAccount(t+1);const a=h.getInitialAccounts(await this.getMnemonic(),this.#t,t),o=a.map(n=>({...n,transactions:[]})),s=A(o,this.#t);return await this.#s.save(await this.getMnemonic(),a.map(n=>({path:n.path,addressType:n.type}))),new w(s,this.#t,this.#n)}static async createRandom(t,e){const a=M.generateMnemonic(),o=new P.WalletMemoryStore,s=h.getInitialAccounts(a,t),n=s.map(c=>({...c,transactions:[]})),r=A(n,t);return await f.WalletDetailsStore.save(a,s.map(c=>({path:c.path,addressType:c.type})),o,t.getNetwork()),new w(r,t,o)}static async fromDisk(t,e,a=0){const o=S.ensureVal(await f.WalletDetailsStore.getMnemonic(e),b.MultiKeyWalletErrors.MissingMnemonic),s=await f.WalletDetailsStore.getAccounts(e,a,t.getNetwork());if(s instanceof Error){const r=h.getInitialAccounts(o,t,a),c=A(r,t);return await f.WalletDetailsStore.save(o,r.map(i=>({path:i.path,addressType:i.type})),e,t.getNetwork()),new w(c,t,e)}const n=new Map;for(const r of s){const i=h.generateRootNode(o,t.getNetwork()).derivePath(r.path).privateKey;if(!i)throw new Error("Unable to generate private key");const u=T.BitcoinWallet.fromPrivateKey(i.toString("hex"),t,{pkType:r.addressType,pkPath:r.path});n.set(await u.getAddress(),u)}return new w(n,t,e)}static async fromMnemonic(t,e,a){if(await f.WalletDetailsStore.getMnemonic(a)&&e.getNetwork()===m.BitcoinNetwork.Mainnet)throw new Error("Wallet already exists in store");const s=await h.discover(t,e);if(s.length===0){const i=h.getInitialAccounts(t,e);s.push(...i.map(u=>({...u})))}const n=s.map(i=>i.type);for(const i of Object.values(g.AddressType))if(!n.includes(i)){const u=h.getAccount(t,e,i);s.push({...u})}const r=[];for(const i of s){const u=k.Path.getAccountNumber(i.path),y=s.filter(d=>k.Path.getAccountNumber(d.path)===u).map(d=>d.type);if(y.length!==Object.values(g.AddressType).length){for(const d of Object.values(g.AddressType))if(!y.includes(d)){const N=h.getAccount(t,e,d,u);r.push(N)}}}s.push(...r);const c=A(s,e);return await f.WalletDetailsStore.save(t,s.map(i=>({path:i.path,addressType:i.type})),a,e.getNetwork()),new w(c,e,a)}static async fromPrivateKeys(t,e){const a=new Map;for(const o of t)for(const s of Object.values(g.AddressType)){const n=T.BitcoinWallet.fromPrivateKey(o,e,{pkType:s});a.set(await n.getAddress(),n)}return new w(a,e,new P.WalletMemoryStore)}async sanityChecksBeforeSend(t){if(await this.getBalance()<t)throw new Error("Insufficient balance")}async getUTXOs(t,e){try{return await this.provider.getUTXOs(t,e)}catch{return await this.getUTXOs(t,0)}}async getPayouts(t,e){const a=await this.getAddresses();let o=t;const s=[];for(const r of a){const c=this.walletByAddress(r.address),i=await this.getUTXOs(r.address,o);if(i.length===0)continue;const u=i.reduce((y,d)=>y+d.value,0);if(o>u){s.push({address:r.address,amt:u,fee:0,change:0}),o-=u;continue}else if(e??=await c.suggestFee(o,m.Urgency.FAST),e+o>u){s.push({address:r.address,amt:o,fee:u-o,change:0}),o-=u;continue}else{s.push({address:r.address,amt:o>0?o:0,fee:o>0?e:e+o,change:u-o-e});break}}const n=s.reduce((r,c)=>r+c.amt+c.fee,0);if(n!==t+e)throw new Error("Amounts do not match: Expected "+(t+e)+" but got "+n);return s}async addPayoutsToTx(t,e,a){const o=[];for(const n of e){const r=await this.provider.getUTXOs(n.address,n.amt+n.fee+n.change);for(const c of r)t.addInput(v.reversify(c.txid),c.vout),o.push({address:n.address,val:c.value})}const s=e.reduce((n,r)=>n+r.amt,0);t.addOutput(l.address.toOutputScript(a,this.getNetwork()),s);for(const n of e)n.change>0&&t.addOutput(l.address.toOutputScript(n.address,this.getNetwork()),n.change);return o}async handleP2wpkh(t,e,a,o){const s=Buffer.from(await e.getPublicKey(),"hex"),n=l.Transaction.SIGHASH_ALL,r=l.payments.p2pkh({pubkey:s,network:await e.getNetwork()}),c=t.hashForWitnessV0(a,r.output,o,n),i=await e.sign(c.toString("hex")),u=[l.script.signature.encode(Buffer.from(i,"hex"),n),s];return t.setWitness(a,u),t}async handleP2pkh(t,e,a){const o=Buffer.from(await e.getPublicKey(),"hex"),s=l.payments.p2pkh({pubkey:o,network:this.getNetwork()}),n=l.Transaction.SIGHASH_ALL,r=t.hashForSignature(a,s.output,n),c=await e.sign(r.toString("hex")),i=l.payments.p2pkh({pubkey:o,redeem:{input:l.script.compile([l.script.signature.encode(Buffer.from(c,"hex"),n),o]),output:s.output},network:this.getNetwork()}).redeem?.input;if(!i)throw new Error("Redeem script not found");return t.setInputScript(a,i),t}async handleP2wpkhP2sh(t,e,a,o){const s=Buffer.from(await e.getPublicKey(),"hex"),n=l.payments.p2pkh({network:await e.getNetwork(),pubkey:s}),r=`160014${E(s).toString("hex")}`,c=l.Transaction.SIGHASH_ALL,i=t.hashForWitnessV0(a,n.output,o,c),u=await e.sign(i.toString("hex")),y=[l.script.signature.encode(Buffer.from(u,"hex"),c),s];t.setInputScript(a,Buffer.from(r,"hex")),t.setWitness(a,y)}async send(t,e,a){await this.sanityChecksBeforeSend(e);const o=await this.getPayouts(e,a);let s=W();const n=await this.addPayoutsToTx(s,o,t);for(let r=0;r<n.length;r++){const c=n[r],i=this.walletByAddress(c.address);switch(i.walletConfig().addressType){case g.AddressType.p2pkh:s=await this.handleP2pkh(s,i,r);break;case g.AddressType.p2wpkh:s=await this.handleP2wpkh(s,i,r,c.val);break;case g.AddressType["p2wpkh-p2sh"]:await this.handleP2wpkhP2sh(s,i,r,c.val);break}}return await this.provider.broadcast(s.toHex())}}function W(){const p=new l.Transaction;return p.version=2,p}function E(p){return Buffer.from(B.ripemd160(x.sha256(Uint8Array.from(p))))}function K(p){switch(p){case m.BitcoinNetwork.Mainnet:return l.networks.bitcoin;case m.BitcoinNetwork.Testnet:return l.networks.testnet;case m.BitcoinNetwork.Regtest:return l.networks.regtest;default:throw new Error("Invalid network")}}function A(p,t){const e=new Map;for(const a of p){const o=T.BitcoinWallet.fromPrivateKey(a.privateKey,t,{pkType:a.type,pkPath:a.path});e.set(a.address,o)}return e}exports.BitcoinMultiKeyWallet=w;
