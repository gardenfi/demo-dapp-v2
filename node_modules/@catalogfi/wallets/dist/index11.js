import{Urgency as A}from"./index8.js";import{ECPairFactory as T}from"ecpair";import*as x from"tiny-secp256k1";import{Transaction as F,script as E,payments as f,Psbt as N}from"bitcoinjs-lib";import{BWErrors as v}from"./index6.js";import{AbstractBitcoinWallet as B}from"./index5.js";import{getBitcoinNetwork as S,reversify as I}from"./index20.js";import{mnemonicToPrivateKey as W}from"./index3.js";import{BitcoinPaths as O}from"./index19.js";import{AddSignature as P}from"./index12.js";import{ScriptType as K}from"./index21.js";import{AddressType as g}from"./index14.js";class k extends B{constructor({privateKey:t,provider:e,pkPath:r,pkType:s}){const n=T(x),a=S(e.getNetwork()),o=Buffer.from(t,"hex");if(o.length===0)throw new Error("invalid private key");super(),this.minAmt=1e3,this.path=r||"",this.pkType=s,this.signer=n.fromPrivateKey(o,{network:a}),this.provider=e,this.network=a}static fromMnemonic(t,e,r){const s=O.bip84(e.getNetwork(),r==null?void 0:r.index),n=W(t,e.getNetwork(),{path:s});return new k({privateKey:n,provider:e,pkType:g.p2wpkh,pkPath:s})}static fromPrivateKey(t,e,r){return new k({privateKey:t,provider:e,pkType:(r==null?void 0:r.pkType)??g.p2wpkh,pkPath:(r==null?void 0:r.pkPath)??"unknown"})}static createRandom(t){const e=T(x),r=S(t.getNetwork()),s=e.makeRandom({network:r});if(!s.privateKey)throw new Error("Failed to create random key");return new k({privateKey:s.privateKey.toString("hex"),provider:t,pkType:g.p2wpkh,pkPath:"unknown"})}static fromWIF(t,e,r){const s=T(x),n=S(e.getNetwork()),a=s.fromWIF(t,n);if(!a.privateKey)throw new Error("Invalid WIF");return k.fromPrivateKey(a.privateKey.toString("hex"),e,r)}walletConfig(){return{network:this.provider.getNetwork(),path:this.path,addressType:this.pkType}}async spend(t,e,{toAddress:r,fee:s,nSequence:n,unlockScript:a,witness:o}){var y;const w=this.getScriptType(e,this.network),h=await this.provider.getBalance(e);if(h===0)throw new Error(v.SCRIPT_NOT_FUNDED);let i=new F;if(i.version=2,s??(s=await this.provider.suggestFee(e,h,A.FAST)),s>h)throw new Error(v.FEE_EXCEEDS_AMOUNT(s,h));const c=await this.provider.getUTXOs(e);i=await this.addAllInputs(i,e,this.provider,{nSequence:n,utxos:c}),i.addOutput(await this.toOutputScript(r??await this.getAddress()),h-s);for(let p=0;p<i.ins.length;p++)if(w===K.P2SH){if(!a)throw new Error("Unlock script is required for p2sh");const d=[];for(const u of a)if(u instanceof P){const l=u.sigHashType,b=i.hashForSignature(p,t,l);d.push(E.signature.encode(Buffer.from(await this.sign(b.toString("hex")),"hex"),l))}else d.push(u);const m=(y=f.p2sh({redeem:{input:E.compile(d),output:t},network:this.network}).redeem)==null?void 0:y.input;i.setInputScript(p,m)}else if(w===K.P2WSH){if(!o)throw new Error("Witness is required for p2wsh");const d=[];for(const m of o)if(m instanceof P){const u=m.sigHashType,l=i.hashForWitnessV0(p,t,c[p].value,u);d.push(E.signature.encode(Buffer.from(await this.sign(l.toString("hex")),"hex"),u))}else d.push(m);i.setWitness(p,d)}else throw new Error("Invalid script type "+w);return this.provider.broadcast(i.toHex())}async getAddress(){if(this.pkType===g["p2wpkh-p2sh"]){const{address:e}=f.p2sh({redeem:f.p2wpkh({pubkey:this.signer.publicKey,network:this.network}),network:this.network});if(!e)throw new Error("failed to get the p2wpkh-p2sh address");return e}const{address:t}=f[this.pkType]({pubkey:this.signer.publicKey,network:this.network});if(!t)throw new Error("failed to get the p2wpkh address");return t}getProvider(){return Promise.resolve(this.provider)}async getBalance(){return this.provider.getBalance(await this.getAddress())}async getPublicKey(){return this.signer.publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}async _send(t,e,r){var h;if(r||(r=await this.provider.suggestFee(await this.getAddress(),e,A.FAST)),r>e)throw new Error(v.FEE_EXCEEDS_AMOUNT(r,e));if(e<this.minAmt)throw new Error(v.MIN_AMOUNT(this.minAmt));const s=await this.getAddress(),n=await this.provider.getUTXOs(s,e+r),a=n.reduce((i,c)=>i+c.value,0),o=new N({network:this.network});for(const i of n){const c=await this.provider.getTransactionHex(i.txid),y=await this.provider.getTransaction(i.txid);let p;this.pkType===g["p2wpkh-p2sh"]&&(p={witnessUtxo:{script:Buffer.from(y.vout[i.vout].scriptpubkey,"hex"),value:i.value},redeemScript:(h=f.p2sh({redeem:f.p2wpkh({pubkey:this.signer.publicKey,network:this.network}),network:this.network}).redeem)==null?void 0:h.output}),o.addInput({hash:I(i.txid),index:i.vout,nonWitnessUtxo:Buffer.from(c,"hex"),...p})}const w=a-e-r;return o.addOutput({address:t,value:e}),w>0&&o.addOutput({address:s,value:w}),o.signAllInputs(this.signer).finalizeAllInputs(),o.extractTransaction().toHex()}async send(t,e,r){const s=await this._send(t,e,r);return this.provider.broadcast(s)}async sign(t){return t=t.startsWith("0x")?t.slice(2):t,this.signer.sign(Buffer.from(t,"hex")).toString("hex")}async signSchnorr(t){return this.signer.signSchnorr(t)}}export{k as BitcoinWallet};
