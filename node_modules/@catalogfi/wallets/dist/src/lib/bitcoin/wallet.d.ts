import { AddSignature } from './sig';
import { AddressType } from './multi-key';
import { BitcoinWalletConfig } from './wallet.interface';
import { AbstractBitcoinWallet } from './abstractWallet';
import { networks, payments } from 'bitcoinjs-lib';
import { IBitcoinProvider } from './provider.interface';

export type BitcoinWalletOpts = {
    privateKey: string;
    provider: IBitcoinProvider;
    pkPath: string;
    pkType: AddressType;
};
/**
 * //TODO: add docs
 */
export declare class BitcoinWallet extends AbstractBitcoinWallet {
    private readonly provider;
    private signer;
    private readonly minAmt;
    private readonly network;
    private pkType;
    private readonly path;
    /**
     * @constructor
     * @param {BitcoinWalletOpts} opts
     * @param {string} opts.privateKey
     * @param {IBitcoinProvider} opts.provider
     * @param {number} opts.pkIndex - The address_index as per BIP44
     */
    constructor({ privateKey, provider, pkPath, pkType }: BitcoinWalletOpts);
    /**
     * @deprecated
     * Switch to `fromPrivateKey` if you have the private key
     * else use multi-key wallet's `fromMnemonic`
     */
    static fromMnemonic(mnemonic: string, provider: IBitcoinProvider, opts?: {
        index: number;
    }): BitcoinWallet;
    /**
     * Initiates a Bitcoin wallet from a private key
     *
     * @param {string} privateKey - The private key
     * @param {IBitcoinProvider} provider - The Bitcoin provider
     *
     * Note: Make sure to pass the pkType if you want to use a specific address type (p2wpkh(segwit), p2sh-p2wpkh, p2pkh(legacy))
     */
    static fromPrivateKey(privateKey: string, provider: IBitcoinProvider, opts?: {
        /**
         * The address type - p2wpkh (segwit), p2sh-p2wpkh, p2pkh(legacy)
         */
        pkType?: AddressType;
        pkPath?: string;
    }): BitcoinWallet;
    /**
     * Creates a random Bitcoin wallet
     */
    static createRandom(provider: IBitcoinProvider): BitcoinWallet;
    static fromWIF(wif: string, provider: IBitcoinProvider, opts?: {
        pkType?: AddressType;
        pkPath?: string;
    }): BitcoinWallet;
    /**
     * @override
     * @returns {Promise<BitcoinWalletConfig>} Bitcoin wallet config including network, derivation path, and index
     */
    walletConfig(): BitcoinWalletConfig;
    /**
     * Spends bitcoin from a script to a given address.
     *
     * @param {Buffer} script - The locking script
     * @param {string} scriptAddress - The address of the script
     * @param {Object} opts - The options
     * @param {string} [opts.toAddress] - The address of the recipient. If not provided then the wallet address is used as the recipient.
     * @param {number} [opts.fee] - The fee
     * @param {number} [opts.nSequence] - The sequence number
     * @param {Buffer[]} [opts.unlockScript] - The unlock script. Required for p2sh
     * @param {Buffer[]} [opts.witness] - The witness. Required for p2wsh, p2tr
     * @returns {Promise<string>} Transaction ID
     */
    spend(script: Buffer, scriptAddress: string, { toAddress, fee, nSequence, unlockScript, // only for p2sh
    witness, }: {
        toAddress?: string;
        fee?: number;
        nSequence?: number;
        witness?: (Buffer | AddSignature)[];
        unlockScript?: (payments.StackElement | AddSignature)[];
    }): Promise<string>;
    /**
     * Returns the address of the wallet
     * @returns {Promise<string>}
     */
    getAddress(): Promise<string>;
    getProvider(): Promise<IBitcoinProvider>;
    getBalance(): Promise<number>;
    getPublicKey(): Promise<string>;
    getNetwork(): Promise<networks.Network>;
    private _send;
    send(toAddress: string, amt: number, fee?: number): Promise<string>;
    sign(hexMsg: string): Promise<string>;
    signSchnorr(buf: Buffer): Promise<Buffer>;
}
