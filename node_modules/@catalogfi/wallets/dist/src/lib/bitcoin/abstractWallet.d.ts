import { WalletChain } from '../baseWallet';
import { ScriptType } from './script';
import { AddSignature, SigHashType } from './sig';
import { AtomicSwapConfig } from '../ASConfig';
import { BitcoinUTXO, IBitcoinProvider, Urgency } from './provider.interface';
import { IHTLCWallet } from '../htlc';
import { Network, Transaction, payments } from 'bitcoinjs-lib';
import { BitcoinWalletConfig, IBitcoinWallet } from './wallet.interface';

/**
 * //TODO: Add docs
 */
export declare abstract class AbstractBitcoinWallet implements IBitcoinWallet {
    abstract getAddress(): Promise<string>;
    abstract getBalance(): Promise<number>;
    abstract sign(hexString: string): Promise<string>;
    abstract getPublicKey(): Promise<string>;
    abstract getNetwork(): Promise<Network>;
    abstract getProvider(): Promise<IBitcoinProvider>;
    abstract send(toAddress: string, amt: number, fee?: number): Promise<string>;
    abstract spend(script: Buffer, scriptAddress: string, { toAddress, fee, nSequence, unlockScript, // only for p2sh
    witness, }: {
        toAddress?: string;
        fee?: number;
        nSequence?: number;
        witness?: (Buffer | AddSignature)[];
        unlockScript?: (payments.StackElement | AddSignature)[];
    }): Promise<string>;
    abstract walletConfig(): BitcoinWalletConfig;
    abstract signSchnorr(buf: Buffer): Promise<Buffer>;
    addSignatureSegwitV0(type?: SigHashType): AddSignature;
    addSignatureP2sh(type?: SigHashType): AddSignature;
    addSignatureSegwitV1(type?: SigHashType): AddSignature;
    /**
     * Returns the chain of the wallet. It can be Bitcoin or EVM
     */
    chain(): WalletChain;
    /**
     * Add all inputs to a transaction
     * @param {Transaction} tx
     * @param {string} address - The address whose UTXOs you want to include
     * @param {IBitcoinProvider} provider
     * @param {Object} opts - Optional
     * @param {BitcoinUTXO[]} opts.utxos - List of UTXOs to include in the transaction. Optional. If not provide then the UTXOs belong to the specified address will be used
     * @param {number} opts.nSequence - The sequence number. Optional
     *
     */
    addAllInputs(tx: Transaction, address: string, provider: IBitcoinProvider, opts?: {
        utxos?: BitcoinUTXO[];
        nSequence?: number;
    }): Promise<Transaction>;
    /**
     * Fee suggested by the provided
     *
     * @override
     * @param {number} amount - in satoshis
     * @param {Urgency} urgency - urgency of the fee
     * @returns {Promise<number>}
     *
     */
    suggestFee(amount: number, urgency: Urgency): Promise<number>;
    /**
     * Converts an address to its corresponding output script.
     *
     * @param {string} address - The address to convert.
     * @return {Promise<Buffer>} The output script corresponding to the address.
     *
     */
    toOutputScript(address: string): Promise<Buffer>;
    /**
     * Calculates the total value (balance) from an array of Bitcoin UTXOs.
     *
     * @param {BitcoinUTXO[]} utxos - The array of Bitcoin UTXOs.
     * @return {number} The total value of the UTXOs.
     *
     */
    totalValueFromUTXOs(utxos: BitcoinUTXO[]): number;
    /**
     * Converts a script to an p2wsh address.
     *
     * @param {Buffer} script - The script to convert.
     * @return {Promise<string>} The generated address.
     *
     */
    scriptToAddress(script: Buffer): Promise<string>;
    /**
     * Creates an HTLC wallet.
     *
     * @param {AtomicSwapConfig} swapConfig - The swap configuration for the HTLC wallet.
     * @returns {Promise<IHTLCWallet>}
     *
     */
    newSwap(swapConfig: AtomicSwapConfig): Promise<IHTLCWallet>;
    /**
     * Given a script address and network, returns the type of the script.
     *
     * @returns {ScriptType} The type of the script (P2SH, P2WSH, P2TR)
     */
    getScriptType(scriptAddress: string, network: Network): ScriptType;
}
type AtomicSwap = AtomicSwapConfig & {
    redeemScript: Buffer;
    scriptAddress: string;
};
export declare class BitcoinHTLC implements IHTLCWallet {
    private readonly wallet;
    private readonly swap;
    /**
     * @constructor
     * @param {IBitcoinWallet} wallet
     * @param {AtomicSwap} swap - Atomic swap config
     *
     */
    constructor(wallet: IBitcoinWallet, swap: AtomicSwap);
    /**
     * Returns the script address
     *
     * @returns {string}
     *
     */
    id(): string;
    /**
     * Initiate the HTLC by sending bitcoin to the HTLC script
     *
     * @returns {Promise<string>} Transaction ID
     *
     */
    init(): Promise<string>;
    /**
     * Redeems the HTLC by spending all bitcoin from the given script.
     *
     * @param {string} secret - The secret for the atomic swap
     * @param {string} [receiver] - The address of the receiver. If not provided then the wallet address is used as the receiver.
     *
     * @returns {Promise<string>} Transaction ID
     *
     */
    redeem(secret: string, receiver?: string): Promise<string>;
    /**
     * Refunds the HTLC by spending all bitcoin from the given script.
     *
     * @param {string} [receiver] - The address of the receiver. If not provided then the wallet address is used as the receiver.
     * @returns {Promise<string>} Transaction ID
     *
     */
    refund(receiver?: string): Promise<string>;
}
export {};
