import { Account } from 'viem';
import { AddSignature } from './sig';
import { BitcoinWalletConfig } from './wallet.interface';
import { AbstractBitcoinWallet } from './abstractWallet';
import { networks, payments } from 'bitcoinjs-lib';
import { IBitcoinProvider } from './provider.interface';

/**
 * Bitcoin OTA Wallet (only supports p2wpkh / native segwit)
 *
 * Provides the same functionality as a Bitcoin Wallet but uses a different way to get the signer.
 * The signer is derived from the signature of a message. The signature is generated by an Ethereum wallet.
 * This ethereum wallet can be a wallet with private key or a wallet connected to a provider (metamask).
 *
 * Checkout the [OTA Wallets](../../../../../docs/docs/Packages/Wallets/BitcoinOTA.md) for more details.
 */
export declare class BitcoinOTA extends AbstractBitcoinWallet {
    private readonly jsonRPCSigner;
    private readonly evmNetwork;
    private readonly provider;
    private nonce;
    private readonly minAmt;
    private network;
    private signer;
    /**
     * @constructor
     * @param {IBitcoinProvider} provider
     * @param {JsonRpcSigner | Wallet} jsonRPCSigner
     * @param {number} evmNetwork - The network id of the evm chain
     * @param {number} [nonce] - The nonce used for signing
     */
    constructor(provider: IBitcoinProvider, jsonRPCSigner: Account, evmNetwork: number, nonce?: number);
    /**
     * @returns {ECPairInterface} whose private key is derived from sha256 of the evm signature
     */
    private getSigner;
    getProvider(): Promise<IBitcoinProvider>;
    /**
     * Uses the signer whose private key is generated by sha256 of the signature and generates an address
     *
     * @returns {Promise<string>} p2wpkh address of the wallet
     */
    getAddress(): Promise<string>;
    getBalance(): Promise<number>;
    sign(hexMsg: string): Promise<string>;
    signSchnorr(buf: Buffer): Promise<Buffer>;
    getPublicKey(): Promise<string>;
    getNetwork(): Promise<networks.Network>;
    walletConfig(): BitcoinWalletConfig;
    /**
     *
     *
     * @returns {ECPairInterface} whose private key is derived from hash256 of the signature
     */
    private getBitcoinSigner;
    send(toAddress: string, amt: number, fee?: number): Promise<string>;
    /**
     * Spends bitcoin from a script to a given address.
     *
     * @param {Buffer} script - The locking script
     * @param {string} scriptAddress - The address of the script
     * @param {Object} opts - The options
     * @param {string} [opts.toAddress] - The address of the recipient. If not provided then the wallet address is used as the recipient.
     * @param {number} [opts.fee] - The fee
     * @param {number} [opts.nSequence] - The sequence number
     * @param {Buffer[]} [opts.unlockScript] - The unlock script. Required for p2sh
     * @param {Buffer[]} [opts.witness] - The witness. Required for p2wsh, p2tr
     * @returns {Promise<string>} Transaction ID
     */
    spend(script: Buffer, scriptAddress: string, { toAddress, fee, nSequence, unlockScript, // only for p2sh
    witness, }: {
        toAddress?: string;
        fee?: number;
        nSequence?: number;
        witness?: (Buffer | AddSignature)[];
        unlockScript?: (payments.StackElement | AddSignature)[];
    }): Promise<string>;
}
