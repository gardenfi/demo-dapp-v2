import{mod as at,getMinHashLength as pt,mapHashToField as wt,invert as yt}from"./index68.js";import*as mt from"./index95.js";import{bytesToNumberBE as tt,bitMask as gt,concatBytes as rt,validateObject as ut,ensureBytes as k,hexToBytes as ct,createHmacDrbg as Et,isBytes as nt,abytes as bt,bytesToHex as it,numberToBytesBE as lt}from"./index95.js";import{wNAF as vt,validateBasic as ft}from"./index97.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Bt(v){const n=ft(v);ut(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:t,Fp:B,a:O}=n;if(t){if(!B.eql(O,B.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof t!="object"||typeof t.beta!="bigint"||typeof t.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:St,hexToBytes:xt}=mt,j={Err:class extends Error{constructor(v=""){super(v)}},_parseInt(v){const{Err:n}=j;if(v.length<2||v[0]!==2)throw new n("Invalid signature integer tag");const t=v[1],B=v.subarray(2,t+2);if(!t||B.length!==t)throw new n("Invalid signature integer: wrong length");if(B[0]&128)throw new n("Invalid signature integer: negative");if(B[0]===0&&!(B[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:St(B),l:v.subarray(t+2)}},toSig(v){const{Err:n}=j,t=typeof v=="string"?xt(v):v;bt(t);let B=t.length;if(B<2||t[0]!=48)throw new n("Invalid signature tag");if(t[1]!==B-2)throw new n("Invalid signature: incorrect length");const{d:O,l:T}=j._parseInt(t.subarray(2)),{d:K,l:x}=j._parseInt(T);if(x.length)throw new n("Invalid signature: left bytes after parsing");return{r:O,s:K}},hexFromSig(v){const n=S=>Number.parseInt(S[0],16)&8?"00"+S:S,t=S=>{const H=S.toString(16);return H.length&1?`0${H}`:H},B=n(t(v.s)),O=n(t(v.r)),T=B.length/2,K=O.length/2,x=t(T),C=t(K);return`30${t(K+T+4)}02${C}${O}02${x}${B}`}},L=BigInt(0),z=BigInt(1);BigInt(2);const dt=BigInt(3);BigInt(4);function ht(v){const n=Bt(v),{Fp:t}=n,B=n.toBytes||((p,r,s)=>{const o=r.toAffine();return rt(Uint8Array.from([4]),t.toBytes(o.x),t.toBytes(o.y))}),O=n.fromBytes||(p=>{const r=p.subarray(1),s=t.fromBytes(r.subarray(0,t.BYTES)),o=t.fromBytes(r.subarray(t.BYTES,2*t.BYTES));return{x:s,y:o}});function T(p){const{a:r,b:s}=n,o=t.sqr(p),c=t.mul(o,p);return t.add(t.add(c,t.mul(p,r)),s)}if(!t.eql(t.sqr(n.Gy),T(n.Gx)))throw new Error("bad generator point: equation left != right");function K(p){return typeof p=="bigint"&&L<p&&p<n.n}function x(p){if(!K(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function C(p){const{allowedPrivateKeyLengths:r,nByteLength:s,wrapPrivateKey:o,n:c}=n;if(r&&typeof p!="bigint"){if(nt(p)&&(p=it(p)),typeof p!="string"||!r.includes(p.length))throw new Error("Invalid key");p=p.padStart(s*2,"0")}let f;try{f=typeof p=="bigint"?p:tt(k("private key",p,s))}catch{throw new Error(`private key must be ${s} bytes, hex or bigint, not ${typeof p}`)}return o&&(f=at(f,c)),x(f),f}const S=new Map;function H(p){if(!(p instanceof w))throw new Error("ProjectivePoint expected")}class w{constructor(r,s,o){if(this.px=r,this.py=s,this.pz=o,r==null||!t.isValid(r))throw new Error("x required");if(s==null||!t.isValid(s))throw new Error("y required");if(o==null||!t.isValid(o))throw new Error("z required")}static fromAffine(r){const{x:s,y:o}=r||{};if(!r||!t.isValid(s)||!t.isValid(o))throw new Error("invalid affine point");if(r instanceof w)throw new Error("projective point not allowed");const c=f=>t.eql(f,t.ZERO);return c(s)&&c(o)?w.ZERO:new w(s,o,t.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(r){const s=t.invertBatch(r.map(o=>o.pz));return r.map((o,c)=>o.toAffine(s[c])).map(w.fromAffine)}static fromHex(r){const s=w.fromAffine(O(k("pointHex",r)));return s.assertValidity(),s}static fromPrivateKey(r){return w.BASE.multiply(C(r))}_setWindowSize(r){this._WINDOW_SIZE=r,S.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!t.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:r,y:s}=this.toAffine();if(!t.isValid(r)||!t.isValid(s))throw new Error("bad point: x or y not FE");const o=t.sqr(s),c=T(r);if(!t.eql(o,c))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:r}=this.toAffine();if(t.isOdd)return!t.isOdd(r);throw new Error("Field doesn't support isOdd")}equals(r){H(r);const{px:s,py:o,pz:c}=this,{px:f,py:g,pz:h}=r,a=t.eql(t.mul(s,h),t.mul(f,c)),u=t.eql(t.mul(o,h),t.mul(g,c));return a&&u}negate(){return new w(this.px,t.neg(this.py),this.pz)}double(){const{a:r,b:s}=n,o=t.mul(s,dt),{px:c,py:f,pz:g}=this;let h=t.ZERO,a=t.ZERO,u=t.ZERO,d=t.mul(c,c),Z=t.mul(f,f),E=t.mul(g,g),y=t.mul(c,f);return y=t.add(y,y),u=t.mul(c,g),u=t.add(u,u),h=t.mul(r,u),a=t.mul(o,E),a=t.add(h,a),h=t.sub(Z,a),a=t.add(Z,a),a=t.mul(h,a),h=t.mul(y,h),u=t.mul(o,u),E=t.mul(r,E),y=t.sub(d,E),y=t.mul(r,y),y=t.add(y,u),u=t.add(d,d),d=t.add(u,d),d=t.add(d,E),d=t.mul(d,y),a=t.add(a,d),E=t.mul(f,g),E=t.add(E,E),d=t.mul(E,y),h=t.sub(h,d),u=t.mul(E,Z),u=t.add(u,u),u=t.add(u,u),new w(h,a,u)}add(r){H(r);const{px:s,py:o,pz:c}=this,{px:f,py:g,pz:h}=r;let a=t.ZERO,u=t.ZERO,d=t.ZERO;const Z=n.a,E=t.mul(n.b,dt);let y=t.mul(s,f),P=t.mul(o,g),I=t.mul(c,h),$=t.add(s,o),e=t.add(f,g);$=t.mul($,e),e=t.add(y,P),$=t.sub($,e),e=t.add(s,c);let i=t.add(f,h);return e=t.mul(e,i),i=t.add(y,I),e=t.sub(e,i),i=t.add(o,c),a=t.add(g,h),i=t.mul(i,a),a=t.add(P,I),i=t.sub(i,a),d=t.mul(Z,e),a=t.mul(E,I),d=t.add(a,d),a=t.sub(P,d),d=t.add(P,d),u=t.mul(a,d),P=t.add(y,y),P=t.add(P,y),I=t.mul(Z,I),e=t.mul(E,e),P=t.add(P,I),I=t.sub(y,I),I=t.mul(Z,I),e=t.add(e,I),y=t.mul(P,e),u=t.add(u,y),y=t.mul(i,e),a=t.mul($,a),a=t.sub(a,y),y=t.mul($,P),d=t.mul(i,d),d=t.add(d,y),new w(a,u,d)}subtract(r){return this.add(r.negate())}is0(){return this.equals(w.ZERO)}wNAF(r){return U.wNAFCached(this,S,r,s=>{const o=t.invertBatch(s.map(c=>c.pz));return s.map((c,f)=>c.toAffine(o[f])).map(w.fromAffine)})}multiplyUnsafe(r){const s=w.ZERO;if(r===L)return s;if(x(r),r===z)return this;const{endo:o}=n;if(!o)return U.unsafeLadder(this,r);let{k1neg:c,k1:f,k2neg:g,k2:h}=o.splitScalar(r),a=s,u=s,d=this;for(;f>L||h>L;)f&z&&(a=a.add(d)),h&z&&(u=u.add(d)),d=d.double(),f>>=z,h>>=z;return c&&(a=a.negate()),g&&(u=u.negate()),u=new w(t.mul(u.px,o.beta),u.py,u.pz),a.add(u)}multiply(r){x(r);let s=r,o,c;const{endo:f}=n;if(f){const{k1neg:g,k1:h,k2neg:a,k2:u}=f.splitScalar(s);let{p:d,f:Z}=this.wNAF(h),{p:E,f:y}=this.wNAF(u);d=U.constTimeNegate(g,d),E=U.constTimeNegate(a,E),E=new w(t.mul(E.px,f.beta),E.py,E.pz),o=d.add(E),c=Z.add(y)}else{const{p:g,f:h}=this.wNAF(s);o=g,c=h}return w.normalizeZ([o,c])[0]}multiplyAndAddUnsafe(r,s,o){const c=w.BASE,f=(h,a)=>a===L||a===z||!h.equals(c)?h.multiplyUnsafe(a):h.multiply(a),g=f(this,s).add(f(r,o));return g.is0()?void 0:g}toAffine(r){const{px:s,py:o,pz:c}=this,f=this.is0();r==null&&(r=f?t.ONE:t.inv(c));const g=t.mul(s,r),h=t.mul(o,r),a=t.mul(c,r);if(f)return{x:t.ZERO,y:t.ZERO};if(!t.eql(a,t.ONE))throw new Error("invZ was invalid");return{x:g,y:h}}isTorsionFree(){const{h:r,isTorsionFree:s}=n;if(r===z)return!0;if(s)return s(w,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:r,clearCofactor:s}=n;return r===z?this:s?s(w,this):this.multiplyUnsafe(n.h)}toRawBytes(r=!0){return this.assertValidity(),B(w,this,r)}toHex(r=!0){return it(this.toRawBytes(r))}}w.BASE=new w(n.Gx,n.Gy,t.ONE),w.ZERO=new w(t.ZERO,t.ONE,t.ZERO);const W=n.nBitLength,U=vt(w,n.endo?Math.ceil(W/2):W);return{CURVE:n,ProjectivePoint:w,normPrivateKeyToScalar:C,weierstrassEquation:T,isWithinCurveOrder:K}}function Rt(v){const n=ft(v);return ut(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function At(v){const n=Rt(v),{Fp:t,n:B}=n,O=t.BYTES+1,T=2*t.BYTES+1;function K(e){return L<e&&e<t.ORDER}function x(e){return at(e,B)}function C(e){return yt(e,B)}const{ProjectivePoint:S,normPrivateKeyToScalar:H,weierstrassEquation:w,isWithinCurveOrder:W}=ht({...n,toBytes(e,i,l){const b=i.toAffine(),m=t.toBytes(b.x),R=rt;return l?R(Uint8Array.from([i.hasEvenY()?2:3]),m):R(Uint8Array.from([4]),m,t.toBytes(b.y))},fromBytes(e){const i=e.length,l=e[0],b=e.subarray(1);if(i===O&&(l===2||l===3)){const m=tt(b);if(!K(m))throw new Error("Point is not on curve");const R=w(m);let q;try{q=t.sqrt(R)}catch(F){const N=F instanceof Error?": "+F.message:"";throw new Error("Point is not on curve"+N)}const A=(q&z)===z;return(l&1)===1!==A&&(q=t.neg(q)),{x:m,y:q}}else if(i===T&&l===4){const m=t.fromBytes(b.subarray(0,t.BYTES)),R=t.fromBytes(b.subarray(t.BYTES,2*t.BYTES));return{x:m,y:R}}else throw new Error(`Point of length ${i} was invalid. Expected ${O} compressed bytes or ${T} uncompressed bytes`)}}),U=e=>it(lt(e,n.nByteLength));function p(e){const i=B>>z;return e>i}function r(e){return p(e)?x(-e):e}const s=(e,i,l)=>tt(e.slice(i,l));class o{constructor(i,l,b){this.r=i,this.s=l,this.recovery=b,this.assertValidity()}static fromCompact(i){const l=n.nByteLength;return i=k("compactSignature",i,l*2),new o(s(i,0,l),s(i,l,2*l))}static fromDER(i){const{r:l,s:b}=j.toSig(k("DER",i));return new o(l,b)}assertValidity(){if(!W(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!W(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(i){return new o(this.r,this.s,i)}recoverPublicKey(i){const{r:l,s:b,recovery:m}=this,R=u(k("msgHash",i));if(m==null||![0,1,2,3].includes(m))throw new Error("recovery id invalid");const q=m===2||m===3?l+n.n:l;if(q>=t.ORDER)throw new Error("recovery id 2 or 3 invalid");const A=m&1?"03":"02",F=S.fromHex(A+U(q)),N=C(q),G=x(-R*N),X=x(b*N),Y=S.BASE.multiplyAndAddUnsafe(F,G,X);if(!Y)throw new Error("point at infinify");return Y.assertValidity(),Y}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new o(this.r,x(-this.s),this.recovery):this}toDERRawBytes(){return ct(this.toDERHex())}toDERHex(){return j.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ct(this.toCompactHex())}toCompactHex(){return U(this.r)+U(this.s)}}const c={isValidPrivateKey(e){try{return H(e),!0}catch{return!1}},normPrivateKeyToScalar:H,randomPrivateKey:()=>{const e=pt(n.n);return wt(n.randomBytes(e),n.n)},precompute(e=8,i=S.BASE){return i._setWindowSize(e),i.multiply(BigInt(3)),i}};function f(e,i=!0){return S.fromPrivateKey(e).toRawBytes(i)}function g(e){const i=nt(e),l=typeof e=="string",b=(i||l)&&e.length;return i?b===O||b===T:l?b===2*O||b===2*T:e instanceof S}function h(e,i,l=!0){if(g(e))throw new Error("first arg must be private key");if(!g(i))throw new Error("second arg must be public key");return S.fromHex(i).multiply(H(e)).toRawBytes(l)}const a=n.bits2int||function(e){const i=tt(e),l=e.length*8-n.nBitLength;return l>0?i>>BigInt(l):i},u=n.bits2int_modN||function(e){return x(a(e))},d=gt(n.nBitLength);function Z(e){if(typeof e!="bigint")throw new Error("bigint expected");if(!(L<=e&&e<d))throw new Error(`bigint expected < 2^${n.nBitLength}`);return lt(e,n.nByteLength)}function E(e,i,l=y){if(["recovered","canonical"].some(D=>D in l))throw new Error("sign() legacy options not supported");const{hash:b,randomBytes:m}=n;let{lowS:R,prehash:q,extraEntropy:A}=l;R==null&&(R=!0),e=k("msgHash",e),q&&(e=k("prehashed msgHash",b(e)));const F=u(e),N=H(i),G=[Z(N),Z(F)];if(A!=null&&A!==!1){const D=A===!0?m(t.BYTES):A;G.push(k("extraEntropy",D))}const X=rt(...G),Y=F;function et(D){const M=a(D);if(!W(M))return;const J=C(M),V=S.BASE.multiply(M).toAffine(),Q=x(V.x);if(Q===L)return;const _=x(J*x(Y+Q*N));if(_===L)return;let ot=(V.x===Q?0:2)|Number(V.y&z),st=_;return R&&p(_)&&(st=r(_),ot^=1),new o(Q,st,ot)}return{seed:X,k2sig:et}}const y={lowS:n.lowS,prehash:!1},P={lowS:n.lowS,prehash:!1};function I(e,i,l=y){const{seed:b,k2sig:m}=E(e,i,l),R=n;return Et(R.hash.outputLen,R.nByteLength,R.hmac)(b,m)}S.BASE._setWindowSize(8);function $(e,i,l,b=P){var J;const m=e;if(i=k("msgHash",i),l=k("publicKey",l),"strict"in b)throw new Error("options.strict was renamed to lowS");const{lowS:R,prehash:q}=b;let A,F;try{if(typeof m=="string"||nt(m))try{A=o.fromDER(m)}catch(V){if(!(V instanceof j.Err))throw V;A=o.fromCompact(m)}else if(typeof m=="object"&&typeof m.r=="bigint"&&typeof m.s=="bigint"){const{r:V,s:Q}=m;A=new o(V,Q)}else throw new Error("PARSE");F=S.fromHex(l)}catch(V){if(V.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(R&&A.hasHighS())return!1;q&&(i=n.hash(i));const{r:N,s:G}=A,X=u(i),Y=C(G),et=x(X*Y),D=x(N*Y),M=(J=S.BASE.multiplyAndAddUnsafe(F,et,D))==null?void 0:J.toAffine();return M?x(M.x)===N:!1}return{CURVE:n,getPublicKey:f,getSharedSecret:h,sign:I,verify:$,ProjectivePoint:S,Signature:o,utils:c}}export{j as DER,At as weierstrass,ht as weierstrassPoints};
