"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const x=require("./index8.cjs"),E=require("ecpair"),N=require("tiny-secp256k1"),a=require("bitcoinjs-lib"),v=require("./index6.cjs"),O=require("./index5.cjs"),T=require("./index20.cjs"),B=require("./index3.cjs"),F=require("./index19.cjs"),P=require("./index12.cjs"),b=require("./index21.cjs"),k=require("./index14.cjs");function K(y){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(y){for(const t in y)if(t!=="default"){const r=Object.getOwnPropertyDescriptor(y,t);Object.defineProperty(e,t,r.get?r:{enumerable:!0,get:()=>y[t]})}}return e.default=y,Object.freeze(e)}const S=K(N);class g extends O.AbstractBitcoinWallet{constructor({privateKey:e,provider:t,pkPath:r,pkType:s}){const p=E.ECPairFactory(S),c=T.getBitcoinNetwork(t.getNetwork()),o=Buffer.from(e,"hex");if(o.length===0)throw new Error("invalid private key");super(),this.minAmt=1e3,this.path=r||"",this.pkType=s,this.signer=p.fromPrivateKey(o,{network:c}),this.provider=t,this.network=c}static fromMnemonic(e,t,r){const s=F.BitcoinPaths.bip84(t.getNetwork(),r?.index),p=B.mnemonicToPrivateKey(e,t.getNetwork(),{path:s});return new g({privateKey:p,provider:t,pkType:k.AddressType.p2wpkh,pkPath:s})}static fromPrivateKey(e,t,r){return new g({privateKey:e,provider:t,pkType:r?.pkType??k.AddressType.p2wpkh,pkPath:r?.pkPath??"unknown"})}static createRandom(e){const t=E.ECPairFactory(S),r=T.getBitcoinNetwork(e.getNetwork()),s=t.makeRandom({network:r});if(!s.privateKey)throw new Error("Failed to create random key");return new g({privateKey:s.privateKey.toString("hex"),provider:e,pkType:k.AddressType.p2wpkh,pkPath:"unknown"})}static fromWIF(e,t,r){const s=E.ECPairFactory(S),p=T.getBitcoinNetwork(t.getNetwork()),c=s.fromWIF(e,p);if(!c.privateKey)throw new Error("Invalid WIF");return g.fromPrivateKey(c.privateKey.toString("hex"),t,r)}walletConfig(){return{network:this.provider.getNetwork(),path:this.path,addressType:this.pkType}}async spend(e,t,{toAddress:r,fee:s,nSequence:p,unlockScript:c,witness:o}){const d=this.getScriptType(t,this.network),i=await this.provider.getBalance(t);if(i===0)throw new Error(v.BWErrors.SCRIPT_NOT_FUNDED);let n=new a.Transaction;if(n.version=2,s??=await this.provider.suggestFee(t,i,x.Urgency.FAST),s>i)throw new Error(v.BWErrors.FEE_EXCEEDS_AMOUNT(s,i));const l=await this.provider.getUTXOs(t);n=await this.addAllInputs(n,t,this.provider,{nSequence:p,utxos:l}),n.addOutput(await this.toOutputScript(r??await this.getAddress()),i-s);for(let h=0;h<n.ins.length;h++)if(d===b.ScriptType.P2SH){if(!c)throw new Error("Unlock script is required for p2sh");const u=[];for(const w of c)if(w instanceof P.AddSignature){const m=w.sigHashType,A=n.hashForSignature(h,e,m);u.push(a.script.signature.encode(Buffer.from(await this.sign(A.toString("hex")),"hex"),m))}else u.push(w);const f=a.payments.p2sh({redeem:{input:a.script.compile(u),output:e},network:this.network}).redeem?.input;n.setInputScript(h,f)}else if(d===b.ScriptType.P2WSH){if(!o)throw new Error("Witness is required for p2wsh");const u=[];for(const f of o)if(f instanceof P.AddSignature){const w=f.sigHashType,m=n.hashForWitnessV0(h,e,l[h].value,w);u.push(a.script.signature.encode(Buffer.from(await this.sign(m.toString("hex")),"hex"),w))}else u.push(f);n.setWitness(h,u)}else throw new Error("Invalid script type "+d);return this.provider.broadcast(n.toHex())}async getAddress(){if(this.pkType===k.AddressType["p2wpkh-p2sh"]){const{address:t}=a.payments.p2sh({redeem:a.payments.p2wpkh({pubkey:this.signer.publicKey,network:this.network}),network:this.network});if(!t)throw new Error("failed to get the p2wpkh-p2sh address");return t}const{address:e}=a.payments[this.pkType]({pubkey:this.signer.publicKey,network:this.network});if(!e)throw new Error("failed to get the p2wpkh address");return e}getProvider(){return Promise.resolve(this.provider)}async getBalance(){return this.provider.getBalance(await this.getAddress())}async getPublicKey(){return this.signer.publicKey.toString("hex")}getNetwork(){return Promise.resolve(this.network)}async _send(e,t,r){if(r||(r=await this.provider.suggestFee(await this.getAddress(),t,x.Urgency.FAST)),r>t)throw new Error(v.BWErrors.FEE_EXCEEDS_AMOUNT(r,t));if(t<this.minAmt)throw new Error(v.BWErrors.MIN_AMOUNT(this.minAmt));const s=await this.getAddress(),p=await this.provider.getUTXOs(s,t+r),c=p.reduce((i,n)=>i+n.value,0),o=new a.Psbt({network:this.network});for(const i of p){const n=await this.provider.getTransactionHex(i.txid),l=await this.provider.getTransaction(i.txid);let h;this.pkType===k.AddressType["p2wpkh-p2sh"]&&(h={witnessUtxo:{script:Buffer.from(l.vout[i.vout].scriptpubkey,"hex"),value:i.value},redeemScript:a.payments.p2sh({redeem:a.payments.p2wpkh({pubkey:this.signer.publicKey,network:this.network}),network:this.network}).redeem?.output}),o.addInput({hash:T.reversify(i.txid),index:i.vout,nonWitnessUtxo:Buffer.from(n,"hex"),...h})}const d=c-t-r;return o.addOutput({address:e,value:t}),d>0&&o.addOutput({address:s,value:d}),o.signAllInputs(this.signer).finalizeAllInputs(),o.extractTransaction().toHex()}async send(e,t,r){const s=await this._send(e,t,r);return this.provider.broadcast(s)}async sign(e){return e=e.startsWith("0x")?e.slice(2):e,this.signer.sign(Buffer.from(e,"hex")).toString("hex")}async signSchnorr(e){return this.signer.signSchnorr(e)}}exports.BitcoinWallet=g;
