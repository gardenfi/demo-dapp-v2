var U=(h,t,e)=>{if(!t.has(h))throw TypeError("Cannot "+e)};var p=(h,t,e)=>(U(h,t,"read from private field"),e?e.call(h):t.get(h)),k=(h,t,e)=>{if(t.has(h))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(h):t.set(h,e)},v=(h,t,e,r)=>(U(h,t,"write to private field"),r?r.call(h,e):t.set(h,e),e);var w,f,A,g;import{BitcoinNetwork as b,Urgency as X}from"./index8.js";import{WalletMemoryStore as H}from"./index29.js";import{generateMnemonic as j}from"./index3.js";import{BitcoinWallet as T}from"./index11.js";import{generateRootNode as C,getInitialAccounts as P,discover as R,getAccount as L}from"./index23.js";import{address as F,Transaction as M,payments as N,script as x,networks as K}from"bitcoinjs-lib";import{reversify as G}from"./index20.js";import{AddressType as m}from"./index14.js";import{ripemd160 as V}from"./index30.js";import{sha256 as D}from"./index31.js";import{WalletDetailsStore as y}from"./index32.js";import{Path as S}from"./index33.js";import{ensureVal as O}from"@catalogfi/utils";import{MultiKeyWalletErrors as W}from"./index34.js";const l=class l{constructor(t,e,r){k(this,w,void 0);k(this,f,void 0);k(this,A,void 0);k(this,g,void 0);v(this,w,t),v(this,f,e),v(this,A,r),v(this,g,new y(r,e.getNetwork()))}async getAccounts(){const t=[];let e=-1;const r=O(await p(this,g).getMnemonic(),W.MissingMnemonic),s=C(r,p(this,f).getNetwork());for(;++e>=0;){const a=await p(this,g).getAccounts(e);if(a instanceof Error)break;for(const o of a){const i=s.derivePath(o.path).privateKey;if(!i)throw new Error("Unable to generate private key");const n=T.fromPrivateKey(i.toString("hex"),p(this,f),{pkType:o.addressType,pkPath:o.path});t.push({...o,accountNumber:S.getAccountNumber(o.path),address:await n.getAddress()})}}return t}async getMnemonic(){return O(await p(this,g).getMnemonic(),W.MissingMnemonic)}get provider(){return p(this,f)}wallets(){return Array.from(p(this,w).values())}walletByAddress(t){const e=p(this,w).get(t);if(!e)throw new Error("Wallet not found");return e}walletByType(t){for(const e of p(this,w).values())if(e.walletConfig().addressType===t)return e}getNetwork(){return z(p(this,f).getNetwork())}async getAddresses(){const t=p(this,w).keys(),e=[];for(const r of t){const s=p(this,w).get(r);if(!s)throw new Error("Wallet not found");const a=s.walletConfig().addressType;e.push({address:r,type:a})}return e}async getBalance(){let t=0;for(const e of this.wallets())t+=await e.getBalance();return t}async nextAccount(t){if(t??(t=S.getAccountNumber(this.wallets()[0].walletConfig().path)+1),!(await p(this,g).getAccounts(t)instanceof Error))return this.nextAccount(t+1);const e=P(await this.getMnemonic(),p(this,f),t),r=e.map(a=>({...a,transactions:[]})),s=B(r,p(this,f));return await p(this,g).save(await this.getMnemonic(),e.map(a=>({path:a.path,addressType:a.type}))),new l(s,p(this,f),p(this,A))}static async createRandom(t,e){const r=j(),s=new H,a=P(r,t),o=a.map(n=>({...n,transactions:[]})),i=B(o,t);return await y.save(r,a.map(n=>({path:n.path,addressType:n.type})),s,t.getNetwork()),new l(i,t,s)}static async fromDisk(t,e,r=0){const s=O(await y.getMnemonic(e),W.MissingMnemonic),a=await y.getAccounts(e,r,t.getNetwork());if(a instanceof Error){const i=P(s,t,r),n=B(i,t);return await y.save(s,i.map(c=>({path:c.path,addressType:c.type})),e,t.getNetwork()),new l(n,t,e)}const o=new Map;for(const i of a){const n=C(s,t.getNetwork()).derivePath(i.path).privateKey;if(!n)throw new Error("Unable to generate private key");const c=T.fromPrivateKey(n.toString("hex"),t,{pkType:i.addressType,pkPath:i.path});o.set(await c.getAddress(),c)}return new l(o,t,e)}static async fromMnemonic(t,e,r){if(await y.getMnemonic(r)&&e.getNetwork()===b.Mainnet)throw new Error("Wallet already exists in store");const s=await R(t,e);if(s.length===0){const n=P(t,e);s.push(...n.map(c=>({...c})))}const a=s.map(n=>n.type);for(const n of Object.values(m))if(!a.includes(n)){const c=L(t,e,n);s.push({...c})}const o=[];for(const n of s){const c=S.getAccountNumber(n.path),u=s.filter(d=>S.getAccountNumber(d.path)===c).map(d=>d.type);if(u.length!==Object.values(m).length){for(const d of Object.values(m))if(!u.includes(d)){const E=L(t,e,d,c);o.push(E)}}}s.push(...o);const i=B(s,e);return await y.save(t,s.map(n=>({path:n.path,addressType:n.type})),r,e.getNetwork()),new l(i,e,r)}static async fromPrivateKeys(t,e){const r=new Map;for(const s of t)for(const a of Object.values(m)){const o=T.fromPrivateKey(s,e,{pkType:a});r.set(await o.getAddress(),o)}return new l(r,e,new H)}async sanityChecksBeforeSend(t){if(await this.getBalance()<t)throw new Error("Insufficient balance")}async getUTXOs(t,e){try{return await this.provider.getUTXOs(t,e)}catch{return await this.getUTXOs(t,0)}}async getPayouts(t,e){const r=await this.getAddresses();let s=t;const a=[];for(const i of r){const n=this.walletByAddress(i.address),c=await this.getUTXOs(i.address,s);if(c.length===0)continue;const u=c.reduce((d,E)=>d+E.value,0);if(s>u){a.push({address:i.address,amt:u,fee:0,change:0}),s-=u;continue}else if(e??(e=await n.suggestFee(s,X.FAST)),e+s>u){a.push({address:i.address,amt:s,fee:u-s,change:0}),s-=u;continue}else{a.push({address:i.address,amt:s>0?s:0,fee:s>0?e:e+s,change:u-s-e});break}}const o=a.reduce((i,n)=>i+n.amt+n.fee,0);if(o!==t+e)throw new Error("Amounts do not match: Expected "+(t+e)+" but got "+o);return a}async addPayoutsToTx(t,e,r){const s=[];for(const o of e){const i=await this.provider.getUTXOs(o.address,o.amt+o.fee+o.change);for(const n of i)t.addInput(G(n.txid),n.vout),s.push({address:o.address,val:n.value})}const a=e.reduce((o,i)=>o+i.amt,0);t.addOutput(F.toOutputScript(r,this.getNetwork()),a);for(const o of e)o.change>0&&t.addOutput(F.toOutputScript(o.address,this.getNetwork()),o.change);return s}async handleP2wpkh(t,e,r,s){const a=Buffer.from(await e.getPublicKey(),"hex"),o=M.SIGHASH_ALL,i=N.p2pkh({pubkey:a,network:await e.getNetwork()}),n=t.hashForWitnessV0(r,i.output,s,o),c=await e.sign(n.toString("hex")),u=[x.signature.encode(Buffer.from(c,"hex"),o),a];return t.setWitness(r,u),t}async handleP2pkh(t,e,r){var u;const s=Buffer.from(await e.getPublicKey(),"hex"),a=N.p2pkh({pubkey:s,network:this.getNetwork()}),o=M.SIGHASH_ALL,i=t.hashForSignature(r,a.output,o),n=await e.sign(i.toString("hex")),c=(u=N.p2pkh({pubkey:s,redeem:{input:x.compile([x.signature.encode(Buffer.from(n,"hex"),o),s]),output:a.output},network:this.getNetwork()}).redeem)==null?void 0:u.input;if(!c)throw new Error("Redeem script not found");return t.setInputScript(r,c),t}async handleP2wpkhP2sh(t,e,r,s){const a=Buffer.from(await e.getPublicKey(),"hex"),o=N.p2pkh({network:await e.getNetwork(),pubkey:a}),i=`160014${q(a).toString("hex")}`,n=M.SIGHASH_ALL,c=t.hashForWitnessV0(r,o.output,s,n),u=await e.sign(c.toString("hex")),d=[x.signature.encode(Buffer.from(u,"hex"),n),a];t.setInputScript(r,Buffer.from(i,"hex")),t.setWitness(r,d)}async send(t,e,r){await this.sanityChecksBeforeSend(e);const s=await this.getPayouts(e,r);let a=$();const o=await this.addPayoutsToTx(a,s,t);for(let i=0;i<o.length;i++){const n=o[i],c=this.walletByAddress(n.address);switch(c.walletConfig().addressType){case m.p2pkh:a=await this.handleP2pkh(a,c,i);break;case m.p2wpkh:a=await this.handleP2wpkh(a,c,i,n.val);break;case m["p2wpkh-p2sh"]:await this.handleP2wpkhP2sh(a,c,i,n.val);break}}return await this.provider.broadcast(a.toHex())}};w=new WeakMap,f=new WeakMap,A=new WeakMap,g=new WeakMap;let I=l;function $(){const h=new M;return h.version=2,h}function q(h){return Buffer.from(V(D(Uint8Array.from(h))))}function z(h){switch(h){case b.Mainnet:return K.bitcoin;case b.Testnet:return K.testnet;case b.Regtest:return K.regtest;default:throw new Error("Invalid network")}}function B(h,t){const e=new Map;for(const r of h){const s=T.fromPrivateKey(r.privateKey,t,{pkType:r.type,pkPath:r.path});e.set(r.address,s)}return e}export{I as BitcoinMultiKeyWallet};
