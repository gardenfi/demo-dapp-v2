import{number as d,exists as k,bytes as F,output as X}from"./index37.js";import{split as A,rotlBH as E,rotlSH as S,rotlBL as U,rotlSL as H}from"./index64.js";import{wrapConstructor as M,Hash as C,u32 as P,isLE as w,byteSwap32 as b,toBytes as _}from"./index38.js";const y=[],I=[],L=[],j=BigInt(0),u=BigInt(1),q=BigInt(2),v=BigInt(7),z=BigInt(256),D=BigInt(113);for(let o=0,t=u,s=1,n=0;o<24;o++){[s,n]=[n,(2*s+3*n)%5],y.push(2*(5*n+s)),I.push((o+1)*(o+2)/2%64);let e=j;for(let r=0;r<7;r++)t=(t<<u^(t>>v)*D)%z,t&q&&(e^=u<<(u<<BigInt(r))-u);L.push(e)}const[G,K]=A(L,!0),O=(o,t,s)=>s>32?E(o,t,s):S(o,t,s),g=(o,t,s)=>s>32?U(o,t,s):H(o,t,s);function x(o,t=24){const s=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let i=0;i<10;i++)s[i]=o[i]^o[i+10]^o[i+20]^o[i+30]^o[i+40];for(let i=0;i<10;i+=2){const h=(i+8)%10,c=(i+2)%10,f=s[c],a=s[c+1],B=O(f,a,1)^s[h],m=g(f,a,1)^s[h+1];for(let l=0;l<50;l+=10)o[i+l]^=B,o[i+l+1]^=m}let e=o[2],r=o[3];for(let i=0;i<24;i++){const h=I[i],c=O(e,r,h),f=g(e,r,h),a=y[i];e=o[a],r=o[a+1],o[a]=c,o[a+1]=f}for(let i=0;i<50;i+=10){for(let h=0;h<10;h++)s[h]=o[i+h];for(let h=0;h<10;h++)o[i+h]^=~s[(h+2)%10]&s[(h+4)%10]}o[0]^=G[n],o[1]^=K[n]}s.fill(0)}class p extends C{constructor(t,s,n,e=!1,r=24){if(super(),this.blockLen=t,this.suffix=s,this.outputLen=n,this.enableXOF=e,this.rounds=r,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,d(n),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=P(this.state)}keccak(){w||b(this.state32),x(this.state32,this.rounds),w||b(this.state32),this.posOut=0,this.pos=0}update(t){k(this);const{blockLen:s,state:n}=this;t=_(t);const e=t.length;for(let r=0;r<e;){const i=Math.min(s-this.pos,e-r);for(let h=0;h<i;h++)n[this.pos++]^=t[r++];this.pos===s&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:t,suffix:s,pos:n,blockLen:e}=this;t[n]^=s,s&128&&n===e-1&&this.keccak(),t[e-1]^=128,this.keccak()}writeInto(t){k(this,!1),F(t),this.finish();const s=this.state,{blockLen:n}=this;for(let e=0,r=t.length;e<r;){this.posOut>=n&&this.keccak();const i=Math.min(n-this.posOut,r-e);t.set(s.subarray(this.posOut,this.posOut+i),e),this.posOut+=i,e+=i}return t}xofInto(t){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(t)}xof(t){return d(t),this.xofInto(new Uint8Array(t))}digestInto(t){if(X(t,this),this.finished)throw new Error("digest() was already called");return this.writeInto(t),this.destroy(),t}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(t){const{blockLen:s,suffix:n,outputLen:e,rounds:r,enableXOF:i}=this;return t||(t=new p(s,n,e,i,r)),t.state32.set(this.state32),t.pos=this.pos,t.posOut=this.posOut,t.finished=this.finished,t.rounds=r,t.suffix=n,t.outputLen=e,t.enableXOF=i,t.destroyed=this.destroyed,t}}const Q=(o,t,s)=>M(()=>new p(t,o,s)),R=Q(1,136,256/8);export{p as Keccak,x as keccakP,R as keccak_256};
