import { createCipheriv as s, createDecipheriv as o, pbkdf2Sync as p, randomBytes as d } from "crypto";
import y from "./index5.mjs";
const n = class n {
  /**
   * Encrypts the data with a key generated from password and salt
   * @param data json stringified data or string to encrypt
   * @param password user password
   * @returns `EncryptionDetails` object containing encryptedData, key and salt
   */
  static encrypt(c, e) {
    const t = this.generateSalt(), r = this.generateKey(e, t);
    return {
      encryptedData: this.encryptAES(c, r, t),
      key: r,
      salt: t
    };
  }
  /**
   * Encrypts the data with a key
   * Use this method, when you have the salt and key received by `encrypt` method
   * @param data json stringified data or string to encrypt
   * @param key encryption key
   * @param salt encryption salt
   * @returns
   */
  static encryptWithKey(c, e, t) {
    return {
      encryptedData: this.encryptAES(c, e, t),
      key: e,
      salt: t
    };
  }
  /**
   * Decrypts the data with a key generated from password and salt
   * @param data data to decrypt
   * @param password user password
   * @param salt salt used to encrypting the data
   * @returns `DecryptionDetails` object containing decryptedData, key and salt
   */
  static decrypt(c, e, t) {
    const r = this.generateKey(e, t);
    return {
      decryptedData: this.decryptAES(c, r, t),
      key: r,
      salt: t
    };
  }
  /**
   *
   * @param data data to decrypt
   * @param key encryption key
   * @param salt salt used for encrypting the data
   * @returns
   */
  static decryptWithKey(c, e, t) {
    return {
      decryptedData: this.decryptAES(c, e, t),
      key: e,
      salt: t
    };
  }
  static encryptAES(c, e, t) {
    const r = s(this.algorithm, e, t), a = r.update(c);
    return Buffer.concat([a, r.final()]).toString("hex");
  }
  static decryptAES(c, e, t) {
    try {
      const r = o(this.algorithm, e, t), a = r.update(Buffer.from(c, "hex"));
      return Buffer.concat([a, r.final()]).toString();
    } catch (r) {
      throw r.message.includes("bad decrypt") ? new Error(y.INVALID_PASSWORD) : r;
    }
  }
  static generateKey(c, e) {
    return p(c, e, 1e3, 32, "sha512").toString("hex").slice(0, 32);
  }
  static generateSalt() {
    return d(16).toString("hex").slice(0, 16);
  }
};
n.algorithm = "aes-256-cbc";
let i = n;
export {
  i as default
};
