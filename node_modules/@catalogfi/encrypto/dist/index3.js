"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const y=require("./index2.js"),d=require("./index5.js"),o=require("./index6.js"),n=class n{constructor(t){this._storage=t}async verifyPassword(t){try{return await this.unlock(t),!0}catch{return!1}}async lock(t,e){const r=o.stringify(t);if(e){let a=this.encryptData(r,e);if(a.error)throw new Error(a.error);const{encryptedData:s,key:c,salt:i}=a,h={salt:i,loginToken:c,timestamp:o.currentTimeInSeconds()};await this.updateStorage(h,s,i)}else{const a=await this.getMetadata(),s=o.currentTimeInSeconds();if(Math.abs(s-a.timestamp)>24*60*60)throw new Error(d.REQ_PASSWORD);const{encryptedData:c}=y.encryptWithKey(r,a.loginToken,a.salt);await this.storeEncryptedData(c,a.salt)}}async unlock(t){if(t){const[e,r]=await Promise.all([this.getEncryptedData(),this.getLastUsedSalt()]),{decryptedData:a}=y.decrypt(e,t,r),{encryptedData:s,key:c,salt:i,error:h}=this.encryptData(a,t);if(h)throw new Error(h);return await this.updateStorage({salt:i,loginToken:c,timestamp:o.currentTimeInSeconds()},s,i),JSON.parse(a)}else{const e=o.currentTimeInSeconds(),r=await this.getMetadata();if(Math.abs(e-r.timestamp)>24*60*60)throw new Error(d.REQ_PASSWORD);const a=await this.getEncryptedData(),{decryptedData:s}=y.decryptWithKey(a,r.loginToken,r.salt);return JSON.parse(s)}}async changePassword(t,e){const r=await this.getEncryptedData(),{decryptedData:a}=y.decrypt(r,t,await this.getLastUsedSalt()),{encryptedData:s,key:c,salt:i}=y.encrypt(a,e);await this.updateStorage({salt:i,loginToken:c,timestamp:o.currentTimeInSeconds()},s,i)}async update(t){const e=await this.getMetadata(),r=o.currentTimeInSeconds();if(Math.abs(r-e.timestamp)>24*60*60)throw new Error(d.REQ_PASSWORD);const a=await this.unlock(),{encryptedData:s}=y.encryptWithKey(o.stringify({...a,...t}),e.loginToken,e.salt);await this.storeEncryptedData(s,e.salt)}async updateStorage(t,e,r){await Promise.all([this.updateAndStoreMetadata(t),this.storeEncryptedData(e,r)])}encryptData(t,e){try{return{...y.encrypt(t,e)}}catch(r){return{encryptedData:"",key:"",salt:"",error:r.message}}}async updateAndStoreMetadata(t){this._metadata=t,await this._storage.setInSession(n._storageKeySession,o.stringify(t))}async storeEncryptedData(t,e){await Promise.all([this._storage.set(n._storageKey,t),this._storage.set(n._storageKey+"-salt",e)])}async getEncryptedData(){const t=await this._storage.get(n._storageKey);if(!t)throw new Error(d.NO_DATA);return t}async getLastUsedSalt(){const t=await this._storage.get(n._storageKey+"-salt");if(!t)throw new Error(d.NO_SALT);return t}async getMetadata(){if(!this._metadata){const t=await this._storage.getFromSession(n._storageKeySession);if(!t)throw new Error(d.NO_METADATA);const e=JSON.parse(t);return this._metadata=e,e}return this._metadata}};n._storageKey="vault",n._storageKeySession="vault-session";let g=n;exports.Vault=g;
