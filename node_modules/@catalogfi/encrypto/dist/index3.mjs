import c from "./index2.mjs";
import y from "./index5.mjs";
import { stringify as h, currentTimeInSeconds as d } from "./index6.mjs";
const n = class n {
  constructor(t) {
    this._storage = t;
  }
  async verifyPassword(t) {
    try {
      return await this.unlock(t), !0;
    } catch {
      return !1;
    }
  }
  async lock(t, a) {
    const r = h(t);
    if (a) {
      let e = this.encryptData(r, a);
      if (e.error)
        throw new Error(e.error);
      const { encryptedData: s, key: i, salt: o } = e, p = {
        salt: o,
        loginToken: i,
        timestamp: d()
      };
      await this.updateStorage(p, s, o);
    } else {
      const e = await this.getMetadata(), s = d();
      if (Math.abs(s - e.timestamp) > 24 * 60 * 60)
        throw new Error(y.REQ_PASSWORD);
      const { encryptedData: i } = c.encryptWithKey(
        r,
        e.loginToken,
        e.salt
      );
      await this.storeEncryptedData(i, e.salt);
    }
  }
  async unlock(t) {
    if (t) {
      const [a, r] = await Promise.all([
        this.getEncryptedData(),
        this.getLastUsedSalt()
      ]), { decryptedData: e } = c.decrypt(
        a,
        t,
        r
      ), {
        encryptedData: s,
        key: i,
        salt: o,
        error: p
      } = this.encryptData(e, t);
      if (p)
        throw new Error(p);
      return await this.updateStorage(
        {
          salt: o,
          loginToken: i,
          timestamp: d()
        },
        s,
        o
      ), JSON.parse(e);
    } else {
      const a = d(), r = await this.getMetadata();
      if (Math.abs(a - r.timestamp) > 24 * 60 * 60)
        throw new Error(y.REQ_PASSWORD);
      const e = await this.getEncryptedData(), { decryptedData: s } = c.decryptWithKey(
        e,
        r.loginToken,
        r.salt
      );
      return JSON.parse(s);
    }
  }
  async changePassword(t, a) {
    const r = await this.getEncryptedData(), { decryptedData: e } = c.decrypt(
      r,
      t,
      await this.getLastUsedSalt()
    ), {
      encryptedData: s,
      key: i,
      salt: o
    } = c.encrypt(e, a);
    await this.updateStorage(
      {
        salt: o,
        loginToken: i,
        timestamp: d()
      },
      s,
      o
    );
  }
  async update(t) {
    const a = await this.getMetadata(), r = d();
    if (Math.abs(r - a.timestamp) > 24 * 60 * 60)
      throw new Error(y.REQ_PASSWORD);
    const e = await this.unlock(), { encryptedData: s } = c.encryptWithKey(
      h({ ...e, ...t }),
      a.loginToken,
      a.salt
    );
    await this.storeEncryptedData(s, a.salt);
  }
  async updateStorage(t, a, r) {
    await Promise.all([
      this.updateAndStoreMetadata(t),
      this.storeEncryptedData(a, r)
    ]);
  }
  encryptData(t, a) {
    try {
      return { ...c.encrypt(t, a) };
    } catch (r) {
      return {
        encryptedData: "",
        key: "",
        salt: "",
        error: r.message
      };
    }
  }
  async updateAndStoreMetadata(t) {
    this._metadata = t, await this._storage.setInSession(
      n._storageKeySession,
      h(t)
    );
  }
  async storeEncryptedData(t, a) {
    await Promise.all([
      this._storage.set(n._storageKey, t),
      this._storage.set(n._storageKey + "-salt", a)
    ]);
  }
  async getEncryptedData() {
    const t = await this._storage.get(n._storageKey);
    if (!t)
      throw new Error(y.NO_DATA);
    return t;
  }
  async getLastUsedSalt() {
    const t = await this._storage.get(n._storageKey + "-salt");
    if (!t)
      throw new Error(y.NO_SALT);
    return t;
  }
  async getMetadata() {
    if (!this._metadata) {
      const t = await this._storage.getFromSession(
        n._storageKeySession
      );
      if (!t)
        throw new Error(y.NO_METADATA);
      const a = JSON.parse(t);
      return this._metadata = a, a;
    }
    return this._metadata;
  }
};
n._storageKey = "vault", n._storageKeySession = "vault-session";
let g = n;
export {
  g as Vault
};
