import { IBitcoinWallet, IHTLCWallet } from '@catalogfi/wallets';

export declare enum Leaf {
    REFUND = 0,
    REDEEM = 1,
    INSTANT_REFUND = 2
}
export declare class GardenHTLC implements IHTLCWallet {
    /**
     * Signer of the HTLC can be either the initiator or the redeemer
     */
    private signer;
    private secretHash;
    /**
     * redeemer's x-only public key without 02 or 03 prefix
     */
    private redeemerPubkey;
    /**
     * initiator's x-only public key without 02 or 03 prefix
     */
    private initiatorPubkey;
    private expiry;
    /**
     * NUMS internal key which blocks key path spending
     */
    private internalPubkey;
    private network;
    private initiateAmount;
    private utxoHashes?;
    /**
     * Note: redeemerAddress and initiatorAddress should be x-only public key without 02 or 03 prefix
     */
    private constructor();
    /**
     * Creates a GardenHTLC instance
     * @param signer Bitcoin wallet of the initiator or redeemer
     * @param secretHash 32 bytes secret hash
     * @param initiatorPubkey initiator's x-only public key without 02 or 03 prefix
     * @param redeemerPubkey redeemer's x-only public key without 02 or 03 prefix
     * @param expiry block height after which the funds can be refunded
     * @returns GardenHTLC instance
     *
     *
     * Note: When the signer is the initiator, only refund and instant refund can be done
     * When the signer is the redeemer, only redeem can be done
     */
    static from(signer: IBitcoinWallet, initiateAmount: number, secretHash: string, initiatorPubkey: string, redeemerPubkey: string, expiry: number, utxoHashes?: string[]): Promise<GardenHTLC>;
    /**
     * Generates a taproot address for receiving the funds
     */
    address(): string;
    /**
     * returns the address of the HTLC
     */
    id(): string;
    private _buildRawTx;
    /**
     * Builds a raw unsigned transaction with utxos from gardenHTLC address
     * and uses signer's address as the output address
     */
    private buildRawTx;
    /**
     * prevout script for the gardenHTLC address
     */
    private getOutputScript;
    init(fee?: number): Promise<string>;
    /**
     * Instantly refunds the funds to the initiator given the counterparty's signatures and pubkey
     *
     * Note: If there are multiple UTXOs being spend, there should be a signature for each UTXO in counterPartySigs
     */
    instantRefund(counterPartySigs: {
        utxo: string;
        sig: string;
    }[], fee?: number): Promise<string>;
    /**
     * Reveals the secret and redeems the HTLC
     */
    redeem(secret: string, receiver?: string, fee?: number): Promise<string>;
    /**
     * Refunds the funds back to the initiator if the expiry block height + 1 is reached
     */
    refund(receiver?: string, fee?: number): Promise<string>;
    /**
     * Given a list of UTXOs, checks if the HTLC can be refunded
     */
    private canRefund;
    /**
     * Given a leaf, generates the control block necessary for spending the leaf
     */
    private generateControlBlockFor;
    /**
     * Generates the hash of the leaf script
     * @param leaf Use leaf enum or pass 0 for refund, 1 for redeem, 2 for instant refund
     * @returns hash of the leaf script
     */
    leafHash(leaf: Leaf): Buffer;
    private refundLeaf;
    private redeemLeaf;
    private instantRefundLeaf;
    private leaves;
    /**
     * Generates the merkle proof for the leaf script
     */
    private generateMerkleProofFor;
}
