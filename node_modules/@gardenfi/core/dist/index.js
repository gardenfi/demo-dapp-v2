var zs = Object.defineProperty;
var js = (e, t, r) => t in e ? zs(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var bt = (e, t, r) => js(e, typeof t != "symbol" ? t + "" : t, r);
import { Ok as ue, Err as N, Fetcher as _t, trim0x as nt } from "@catalogfi/utils";
import { EthereumLocalnet as Gs, ArbitrumLocalnet as Ws, Orderbook as qs, isMainnet as rr, isBitcoin as nr, getBlockchainType as Lt, BlockchainType as ke } from "@gardenfi/orderbook";
import { Url as dn, with0x as fr, checkAllowanceAndApprove as Vs, Authorization as Pn, sleep as Ks, fetchBitcoinBlockNumber as Cn, fetchEVMBlockNumber as Ln } from "@gardenfi/utils";
import { createWalletClient as kn, custom as Fn, getContract as Ys, sha256 as ir } from "viem";
import * as On from "varuint-bitcoin";
import * as st from "tiny-secp256k1";
import * as fe from "bitcoinjs-lib";
import { crypto as Js } from "bitcoinjs-lib";
import { Urgency as Un } from "@catalogfi/wallets";
import Xs from "bignumber.js";
var en = /* @__PURE__ */ ((e) => (e[e.evm = 14400] = "evm", e[e.btc = 288] = "btc", e))(en || {}), le = /* @__PURE__ */ ((e) => (e.Idle = "Idle", e.Initiate = "Initiate", e.Redeem = "Redeem", e.Refund = "Refund", e))(le || {});
function qt(e) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e
  };
}
const Ii = "2.21.30";
let kt = {
  getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: r }) => t ? `${e ?? "https://viem.sh"}${t}${r ? `#${r}` : ""}` : void 0,
  version: `viem@${Ii}`
};
class X extends Error {
  constructor(t, r = {}) {
    var u;
    const n = (() => {
      var l;
      return r.cause instanceof X ? r.cause.details : (l = r.cause) != null && l.message ? r.cause.message : r.details;
    })(), i = r.cause instanceof X && r.cause.docsPath || r.docsPath, a = (u = kt.getDocsUrl) == null ? void 0 : u.call(kt, { ...r, docsPath: i }), f = [
      t || "An error occurred.",
      "",
      ...r.metaMessages ? [...r.metaMessages, ""] : [],
      ...a ? [`Docs: ${a}`] : [],
      ...n ? [`Details: ${n}`] : [],
      ...kt.version ? [`Version: ${kt.version}`] : []
    ].join(`
`);
    super(f, r.cause ? { cause: r.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = n, this.docsPath = i, this.metaMessages = r.metaMessages, this.name = r.name ?? this.name, this.shortMessage = t, this.version = Ii;
  }
  walk(t) {
    return Ai(this, t);
  }
}
function Ai(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause" in e ? Ai(e.cause, t) : t ? null : e;
}
class Qs extends X {
  constructor({ max: t, min: r, signed: n, size: i, value: a }) {
    super(`Number "${a}" is not in safe ${i ? `${i * 8}-bit ${n ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${r} to ${t})` : `(above ${r})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class Zs extends X {
  constructor({ givenSize: t, maxSize: r }) {
    super(`Size cannot exceed ${r} bytes. Given size: ${t} bytes.`, { name: "SizeOverflowError" });
  }
}
function Vt(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x");
}
function vt(e) {
  return Vt(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
function lr(e, { dir: t = "left" } = {}) {
  let r = typeof e == "string" ? e.replace("0x", "") : e, n = 0;
  for (let i = 0; i < r.length - 1 && r[t === "left" ? i : r.length - i - 1].toString() === "0"; i++)
    n++;
  return r = t === "left" ? r.slice(n) : r.slice(0, r.length - n), typeof e == "string" ? (r.length === 1 && t === "right" && (r = `${r}0`), `0x${r.length % 2 === 1 ? `0${r}` : r}`) : r;
}
class eo extends X {
  constructor({ offset: t, position: r, size: n }) {
    super(`Slice ${r === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${n}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class Ri extends X {
  constructor({ size: t, targetSize: r, type: n }) {
    super(`${n.charAt(0).toUpperCase()}${n.slice(1).toLowerCase()} size (${t}) exceeds padding size (${r}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
function It(e, { dir: t, size: r = 32 } = {}) {
  return typeof e == "string" ? to(e, { dir: t, size: r }) : ro(e, { dir: t, size: r });
}
function to(e, { dir: t, size: r = 32 } = {}) {
  if (r === null)
    return e;
  const n = e.replace("0x", "");
  if (n.length > r * 2)
    throw new Ri({
      size: Math.ceil(n.length / 2),
      targetSize: r,
      type: "hex"
    });
  return `0x${n[t === "right" ? "padEnd" : "padStart"](r * 2, "0")}`;
}
function ro(e, { dir: t, size: r = 32 } = {}) {
  if (r === null)
    return e;
  if (e.length > r)
    throw new Ri({
      size: e.length,
      targetSize: r,
      type: "bytes"
    });
  const n = new Uint8Array(r);
  for (let i = 0; i < r; i++) {
    const a = t === "right";
    n[a ? i : r - i - 1] = e[a ? i : e.length - i - 1];
  }
  return n;
}
const no = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function W(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? Ti(e, t) : typeof e == "string" ? oo(e, t) : typeof e == "boolean" ? io(e, t) : Qe(e, t);
}
function io(e, t = {}) {
  const r = `0x${Number(e)}`;
  return typeof t.size == "number" ? (At(r, { size: t.size }), It(r, { size: t.size })) : r;
}
function Qe(e, t = {}) {
  let r = "";
  for (let i = 0; i < e.length; i++)
    r += no[e[i]];
  const n = `0x${r}`;
  return typeof t.size == "number" ? (At(n, { size: t.size }), It(n, { dir: "right", size: t.size })) : n;
}
function Ti(e, t = {}) {
  const { signed: r, size: n } = t, i = BigInt(e);
  let a;
  n ? r ? a = (1n << BigInt(n) * 8n - 1n) - 1n : a = 2n ** (BigInt(n) * 8n) - 1n : typeof e == "number" && (a = BigInt(Number.MAX_SAFE_INTEGER));
  const f = typeof a == "bigint" && r ? -a - 1n : 0;
  if (a && i > a || i < f) {
    const l = typeof e == "bigint" ? "n" : "";
    throw new Qs({
      max: a ? `${a}${l}` : void 0,
      min: `${f}${l}`,
      signed: r,
      size: n,
      value: `${e}${l}`
    });
  }
  const u = `0x${(r && i < 0 ? (1n << BigInt(n * 8)) + BigInt(i) : i).toString(16)}`;
  return n ? It(u, { size: n }) : u;
}
const so = /* @__PURE__ */ new TextEncoder();
function oo(e, t = {}) {
  const r = so.encode(e);
  return Qe(r, t);
}
const ao = /* @__PURE__ */ new TextEncoder();
function Pi(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? uo(e, t) : typeof e == "boolean" ? fo(e, t) : Vt(e) ? ot(e, t) : Ci(e, t);
}
function fo(e, t = {}) {
  const r = new Uint8Array(1);
  return r[0] = Number(e), typeof t.size == "number" ? (At(r, { size: t.size }), It(r, { size: t.size })) : r;
}
const Me = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Nn(e) {
  if (e >= Me.zero && e <= Me.nine)
    return e - Me.zero;
  if (e >= Me.A && e <= Me.F)
    return e - (Me.A - 10);
  if (e >= Me.a && e <= Me.f)
    return e - (Me.a - 10);
}
function ot(e, t = {}) {
  let r = e;
  t.size && (At(r, { size: t.size }), r = It(r, { dir: "right", size: t.size }));
  let n = r.slice(2);
  n.length % 2 && (n = `0${n}`);
  const i = n.length / 2, a = new Uint8Array(i);
  for (let f = 0, u = 0; f < i; f++) {
    const l = Nn(n.charCodeAt(u++)), b = Nn(n.charCodeAt(u++));
    if (l === void 0 || b === void 0)
      throw new X(`Invalid byte sequence ("${n[u - 2]}${n[u - 1]}" in "${n}").`);
    a[f] = l * 16 + b;
  }
  return a;
}
function uo(e, t) {
  const r = Ti(e, t);
  return ot(r);
}
function Ci(e, t = {}) {
  const r = ao.encode(e);
  return typeof t.size == "number" ? (At(r, { size: t.size }), It(r, { dir: "right", size: t.size })) : r;
}
function At(e, { size: t }) {
  if (vt(e) > t)
    throw new Zs({
      givenSize: vt(e),
      maxSize: t
    });
}
function mt(e, t = {}) {
  const { signed: r } = t;
  t.size && At(e, { size: t.size });
  const n = BigInt(e);
  if (!r)
    return n;
  const i = (e.length - 2) / 2, a = (1n << BigInt(i) * 8n - 1n) - 1n;
  return n <= a ? n : n - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function hr(e, t = {}) {
  return Number(mt(e, t));
}
function pn(e, t) {
  return ({ exclude: r, format: n }) => ({
    exclude: r,
    format: (i) => {
      const a = t(i);
      if (r)
        for (const f of r)
          delete a[f];
      return {
        ...a,
        ...n(i)
      };
    },
    type: e
  });
}
const Li = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function bn(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? hr(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
    nonce: e.nonce ? hr(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? Li[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0
  };
  return e.authorizationList && (t.authorizationList = lo(e.authorizationList)), t.yParity = (() => {
    if (e.yParity)
      return Number(e.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n)
        return 0;
      if (t.v === 1n || t.v === 28n)
        return 1;
      if (t.v >= 35n)
        return t.v % 2n === 0n ? 1 : 0;
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t.type === "eip1559" && delete t.maxFeePerBlobGas, t;
}
const co = /* @__PURE__ */ pn("transaction", bn);
function lo(e) {
  return e.map((t) => ({
    contractAddress: t.address,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    r: t.r,
    s: t.s,
    yParity: Number(t.yParity)
  }));
}
function ho(e) {
  var r;
  const t = (r = e.transactions) == null ? void 0 : r.map((n) => typeof n == "string" ? n : bn(n));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  };
}
const po = /* @__PURE__ */ pn("block", ho);
function bo(e, { args: t, eventName: r } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...r ? { args: t, eventName: r } : {}
  };
}
const yo = {
  "0x0": "reverted",
  "0x1": "success"
};
function go(e) {
  const t = {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((r) => bo(r)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? hr(e.transactionIndex) : null,
    status: e.status ? yo[e.status] : null,
    type: e.type ? Li[e.type] || e.type : null
  };
  return e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)), e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)), t;
}
const mo = /* @__PURE__ */ pn("transactionReceipt", go), yn = 2n ** 256n - 1n;
function Kt(e) {
  return `0x${e.reduce((t, r) => t + r.replace("0x", ""), "")}`;
}
class Mn extends X {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class _o extends X {
  constructor({ length: t, position: r }) {
    super(`Position \`${r}\` is out of bounds (\`0 < position < ${t}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class wo extends X {
  constructor({ count: t, limit: r }) {
    super(`Recursive read limit of \`${r}\` exceeded (recursive read count: \`${t}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const xo = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new wo({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1)
      throw new _o({
        length: this.bytes.length,
        position: e
      });
  },
  decrementPosition(e) {
    if (e < 0)
      throw new Mn({ offset: e });
    const t = this.position - e;
    this.assertPosition(t), this.position = t;
  },
  getReadCount(e) {
    return this.positionReadCount.get(e || this.position) || 0;
  },
  incrementPosition(e) {
    if (e < 0)
      throw new Mn({ offset: e });
    const t = this.position + e;
    this.assertPosition(t), this.position = t;
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(e, t) {
    const r = t ?? this.position;
    return this.assertPosition(r + e - 1), this.bytes.subarray(r, r + e);
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2);
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length;
  },
  pushUint8(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2;
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, e & 255), this.position += 3;
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectByte();
    return this.position++, e;
  },
  readBytes(e, t) {
    this.assertReadLimit(), this._touch();
    const r = this.inspectBytes(e);
    return this.position += t ?? e, r;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint8();
    return this.position += 1, e;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint16();
    return this.position += 2, e;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint24();
    return this.position += 3, e;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint32();
    return this.position += 4, e;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e) {
    const t = this.position;
    return this.assertPosition(e), this.position = e, () => this.position = t;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e = this.getReadCount();
    this.positionReadCount.set(this.position, e + 1), e > 0 && this.recursiveReadCount++;
  }
};
function ki(e, { recursiveReadLimit: t = 8192 } = {}) {
  const r = Object.create(xo);
  return r.bytes = e, r.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), r.positionReadCount = /* @__PURE__ */ new Map(), r.recursiveReadLimit = t, r;
}
function at(e, t = "hex") {
  const r = Fi(e), n = ki(new Uint8Array(r.length));
  return r.encode(n), t === "hex" ? Qe(n.bytes) : n.bytes;
}
function Fi(e) {
  return Array.isArray(e) ? vo(e.map((t) => Fi(t))) : Eo(e);
}
function vo(e) {
  const t = e.reduce((i, a) => i + a.length, 0), r = Oi(t);
  return {
    length: t <= 55 ? 1 + t : 1 + r + t,
    encode(i) {
      t <= 55 ? i.pushByte(192 + t) : (i.pushByte(247 + r), r === 1 ? i.pushUint8(t) : r === 2 ? i.pushUint16(t) : r === 3 ? i.pushUint24(t) : i.pushUint32(t));
      for (const { encode: a } of e)
        a(i);
    }
  };
}
function Eo(e) {
  const t = typeof e == "string" ? ot(e) : e, r = Oi(t.length);
  return {
    length: t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + r + t.length,
    encode(i) {
      t.length === 1 && t[0] < 128 ? i.pushBytes(t) : t.length <= 55 ? (i.pushByte(128 + t.length), i.pushBytes(t)) : (i.pushByte(183 + r), r === 1 ? i.pushUint8(t.length) : r === 2 ? i.pushUint16(t.length) : r === 3 ? i.pushUint24(t.length) : i.pushUint32(t.length), i.pushBytes(t));
    }
  };
}
function Oi(e) {
  if (e < 2 ** 8)
    return 1;
  if (e < 2 ** 16)
    return 2;
  if (e < 2 ** 24)
    return 3;
  if (e < 2 ** 32)
    return 4;
  throw new X("Length is too large.");
}
const Bo = {
  ether: -9,
  wei: 9
};
function So(e, t) {
  let r = e.toString();
  const n = r.startsWith("-");
  n && (r = r.slice(1)), r = r.padStart(t, "0");
  let [i, a] = [
    r.slice(0, r.length - t),
    r.slice(r.length - t)
  ];
  return a = a.replace(/(0+)$/, ""), `${n ? "-" : ""}${i || "0"}${a ? `.${a}` : ""}`;
}
function tn(e, t = "wei") {
  return So(e, Bo[t]);
}
function Io(e) {
  const t = Object.entries(e).map(([n, i]) => i === void 0 || i === !1 ? null : [n, i]).filter(Boolean), r = t.reduce((n, [i]) => Math.max(n, i.length), 0);
  return t.map(([n, i]) => `  ${`${n}:`.padEnd(r + 1)}  ${i}`).join(`
`);
}
class Ao extends X {
  constructor({ v: t }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class Ro extends X {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Io(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class To extends X {
  constructor({ storageKey: t }) {
    super(`Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
function Ui(e) {
  const { kzg: t } = e, r = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), n = typeof e.blobs[0] == "string" ? e.blobs.map((a) => ot(a)) : e.blobs, i = [];
  for (const a of n)
    i.push(Uint8Array.from(t.blobToKzgCommitment(a)));
  return r === "bytes" ? i : i.map((a) => Qe(a));
}
function Ni(e) {
  const { kzg: t } = e, r = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), n = typeof e.blobs[0] == "string" ? e.blobs.map((f) => ot(f)) : e.blobs, i = typeof e.commitments[0] == "string" ? e.commitments.map((f) => ot(f)) : e.commitments, a = [];
  for (let f = 0; f < n.length; f++) {
    const u = n[f], l = i[f];
    a.push(Uint8Array.from(t.computeBlobKzgProof(u, l)));
  }
  return r === "bytes" ? a : a.map((f) => Qe(f));
}
function Dn(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function Po(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function gn(e, ...t) {
  if (!Po(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function dr(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function Mi(e, t) {
  gn(e);
  const r = t.outputLen;
  if (e.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Co = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), Or = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), Fe = (e, t) => e << 32 - t | e >>> t, $n = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, Lo = (e) => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function Hn(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = Lo(e[t]);
}
function ko(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function mn(e) {
  return typeof e == "string" && (e = ko(e)), gn(e), e;
}
let Di = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function $i(e) {
  const t = (n) => e().update(mn(n)).digest(), r = e();
  return t.outputLen = r.outputLen, t.blockLen = r.blockLen, t.create = () => e(), t;
}
function Fo(e, t, r, n) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, r, n);
  const i = BigInt(32), a = BigInt(4294967295), f = Number(r >> i & a), u = Number(r & a), l = n ? 4 : 0, b = n ? 0 : 4;
  e.setUint32(t + l, f, n), e.setUint32(t + b, u, n);
}
const Oo = (e, t, r) => e & t ^ ~e & r, Uo = (e, t, r) => e & t ^ e & r ^ t & r;
class No extends Di {
  constructor(t, r, n, i) {
    super(), this.blockLen = t, this.outputLen = r, this.padOffset = n, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Or(this.buffer);
  }
  update(t) {
    dr(this);
    const { view: r, buffer: n, blockLen: i } = this;
    t = mn(t);
    const a = t.length;
    for (let f = 0; f < a; ) {
      const u = Math.min(i - this.pos, a - f);
      if (u === i) {
        const l = Or(t);
        for (; i <= a - f; f += i)
          this.process(l, f);
        continue;
      }
      n.set(t.subarray(f, f + u), this.pos), this.pos += u, f += u, this.pos === i && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    dr(this), Mi(t, this), this.finished = !0;
    const { buffer: r, view: n, blockLen: i, isLE: a } = this;
    let { pos: f } = this;
    r[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > i - f && (this.process(n, 0), f = 0);
    for (let m = f; m < i; m++)
      r[m] = 0;
    Fo(n, i - 8, BigInt(this.length * 8), a), this.process(n, 0);
    const u = Or(t), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const b = l / 4, g = this.get();
    if (b > g.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let m = 0; m < b; m++)
      u.setUint32(4 * m, g[m], a);
  }
  digest() {
    const { buffer: t, outputLen: r } = this;
    this.digestInto(t);
    const n = t.slice(0, r);
    return this.destroy(), n;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: r, buffer: n, length: i, finished: a, destroyed: f, pos: u } = this;
    return t.length = i, t.pos = u, t.finished = a, t.destroyed = f, i % r && t.buffer.set(n), t;
  }
}
const Mo = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), Ke = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), Ye = /* @__PURE__ */ new Uint32Array(64);
class Do extends No {
  constructor() {
    super(64, 32, 8, !1), this.A = Ke[0] | 0, this.B = Ke[1] | 0, this.C = Ke[2] | 0, this.D = Ke[3] | 0, this.E = Ke[4] | 0, this.F = Ke[5] | 0, this.G = Ke[6] | 0, this.H = Ke[7] | 0;
  }
  get() {
    const { A: t, B: r, C: n, D: i, E: a, F: f, G: u, H: l } = this;
    return [t, r, n, i, a, f, u, l];
  }
  // prettier-ignore
  set(t, r, n, i, a, f, u, l) {
    this.A = t | 0, this.B = r | 0, this.C = n | 0, this.D = i | 0, this.E = a | 0, this.F = f | 0, this.G = u | 0, this.H = l | 0;
  }
  process(t, r) {
    for (let m = 0; m < 16; m++, r += 4)
      Ye[m] = t.getUint32(r, !1);
    for (let m = 16; m < 64; m++) {
      const v = Ye[m - 15], I = Ye[m - 2], B = Fe(v, 7) ^ Fe(v, 18) ^ v >>> 3, P = Fe(I, 17) ^ Fe(I, 19) ^ I >>> 10;
      Ye[m] = P + Ye[m - 7] + B + Ye[m - 16] | 0;
    }
    let { A: n, B: i, C: a, D: f, E: u, F: l, G: b, H: g } = this;
    for (let m = 0; m < 64; m++) {
      const v = Fe(u, 6) ^ Fe(u, 11) ^ Fe(u, 25), I = g + v + Oo(u, l, b) + Mo[m] + Ye[m] | 0, P = (Fe(n, 2) ^ Fe(n, 13) ^ Fe(n, 22)) + Uo(n, i, a) | 0;
      g = b, b = l, l = u, u = f + I | 0, f = a, a = i, i = n, n = I + P | 0;
    }
    n = n + this.A | 0, i = i + this.B | 0, a = a + this.C | 0, f = f + this.D | 0, u = u + this.E | 0, l = l + this.F | 0, b = b + this.G | 0, g = g + this.H | 0, this.set(n, i, a, f, u, l, b, g);
  }
  roundClean() {
    Ye.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const $o = /* @__PURE__ */ $i(() => new Do());
function Ho(e, t) {
  return $o(Vt(e, { strict: !1 }) ? Pi(e) : e);
}
function zo(e) {
  const { commitment: t, version: r = 1 } = e, n = e.to ?? (typeof t == "string" ? "hex" : "bytes"), i = Ho(t);
  return i.set([r], 0), n === "bytes" ? i : Qe(i);
}
function jo(e) {
  const { commitments: t, version: r } = e, n = e.to ?? (typeof t[0] == "string" ? "hex" : "bytes"), i = [];
  for (const a of t)
    i.push(zo({
      commitment: a,
      to: n,
      version: r
    }));
  return i;
}
const zn = 6, Hi = 32, _n = 4096, zi = Hi * _n, jn = zi * zn - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * _n * zn, ji = 1;
class Go extends X {
  constructor({ maxSize: t, size: r }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${r} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class Gi extends X {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class Wo extends X {
  constructor({ hash: t, size: r }) {
    super(`Versioned hash "${t}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${r}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class qo extends X {
  constructor({ hash: t, version: r }) {
    super(`Versioned hash "${t}" version is invalid.`, {
      metaMessages: [
        `Expected: ${ji}`,
        `Received: ${r}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function Vo(e) {
  const t = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), r = typeof e.data == "string" ? ot(e.data) : e.data, n = vt(r);
  if (!n)
    throw new Gi();
  if (n > jn)
    throw new Go({
      maxSize: jn,
      size: n
    });
  const i = [];
  let a = !0, f = 0;
  for (; a; ) {
    const u = ki(new Uint8Array(zi));
    let l = 0;
    for (; l < _n; ) {
      const b = r.slice(f, f + (Hi - 1));
      if (u.pushByte(0), u.pushBytes(b), b.length < 31) {
        u.pushByte(128), a = !1;
        break;
      }
      l++, f += 31;
    }
    i.push(u);
  }
  return t === "bytes" ? i.map((u) => u.bytes) : i.map((u) => Qe(u.bytes));
}
function Ko(e) {
  const { data: t, kzg: r, to: n } = e, i = e.blobs ?? Vo({ data: t, to: n }), a = e.commitments ?? Ui({ blobs: i, kzg: r, to: n }), f = e.proofs ?? Ni({ blobs: i, commitments: a, kzg: r, to: n }), u = [];
  for (let l = 0; l < i.length; l++)
    u.push({
      blob: i[l],
      commitment: a[l],
      proof: f[l]
    });
  return u;
}
function Yo(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (const r of e) {
    const { contractAddress: n, chainId: i, nonce: a, ...f } = r;
    t.push([
      W(i),
      n,
      a ? W(a) : "0x",
      ...Yt({}, f)
    ]);
  }
  return t;
}
class ft extends X {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class wr extends X {
  constructor({ chainId: t }) {
    super(typeof t == "number" ? `Chain ID "${t}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
class xr extends X {
  constructor({ cause: t, maxFeePerGas: r } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r ? ` = ${tn(r)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(xr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Wi extends X {
  constructor({ cause: t, maxPriorityFeePerGas: r, maxFeePerGas: n } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r ? ` = ${tn(r)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n ? ` = ${tn(n)} gwei` : ""}).`
    ].join(`
`), {
      cause: t,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Wi, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class qi extends Map {
  constructor(t) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = t;
  }
  get(t) {
    const r = super.get(t);
    return super.has(t) && r !== void 0 && (this.delete(t), super.set(t, r)), r;
  }
  set(t, r) {
    if (super.set(t, r), this.maxSize && this.size > this.maxSize) {
      const n = this.keys().next().value;
      n && this.delete(n);
    }
    return this;
  }
}
const sr = /* @__PURE__ */ BigInt(2 ** 32 - 1), Gn = /* @__PURE__ */ BigInt(32);
function Jo(e, t = !1) {
  return t ? { h: Number(e & sr), l: Number(e >> Gn & sr) } : { h: Number(e >> Gn & sr) | 0, l: Number(e & sr) | 0 };
}
function Xo(e, t = !1) {
  let r = new Uint32Array(e.length), n = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: a, l: f } = Jo(e[i], t);
    [r[i], n[i]] = [a, f];
  }
  return [r, n];
}
const Qo = (e, t, r) => e << r | t >>> 32 - r, Zo = (e, t, r) => t << r | e >>> 32 - r, ea = (e, t, r) => t << r - 32 | e >>> 64 - r, ta = (e, t, r) => e << r - 32 | t >>> 64 - r, Vi = [], Ki = [], Yi = [], ra = /* @__PURE__ */ BigInt(0), Ft = /* @__PURE__ */ BigInt(1), na = /* @__PURE__ */ BigInt(2), ia = /* @__PURE__ */ BigInt(7), sa = /* @__PURE__ */ BigInt(256), oa = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = Ft, r = 1, n = 0; e < 24; e++) {
  [r, n] = [n, (2 * r + 3 * n) % 5], Vi.push(2 * (5 * n + r)), Ki.push((e + 1) * (e + 2) / 2 % 64);
  let i = ra;
  for (let a = 0; a < 7; a++)
    t = (t << Ft ^ (t >> ia) * oa) % sa, t & na && (i ^= Ft << (Ft << /* @__PURE__ */ BigInt(a)) - Ft);
  Yi.push(i);
}
const [aa, fa] = /* @__PURE__ */ Xo(Yi, !0), Wn = (e, t, r) => r > 32 ? ea(e, t, r) : Qo(e, t, r), qn = (e, t, r) => r > 32 ? ta(e, t, r) : Zo(e, t, r);
function ua(e, t = 24) {
  const r = new Uint32Array(10);
  for (let n = 24 - t; n < 24; n++) {
    for (let f = 0; f < 10; f++)
      r[f] = e[f] ^ e[f + 10] ^ e[f + 20] ^ e[f + 30] ^ e[f + 40];
    for (let f = 0; f < 10; f += 2) {
      const u = (f + 8) % 10, l = (f + 2) % 10, b = r[l], g = r[l + 1], m = Wn(b, g, 1) ^ r[u], v = qn(b, g, 1) ^ r[u + 1];
      for (let I = 0; I < 50; I += 10)
        e[f + I] ^= m, e[f + I + 1] ^= v;
    }
    let i = e[2], a = e[3];
    for (let f = 0; f < 24; f++) {
      const u = Ki[f], l = Wn(i, a, u), b = qn(i, a, u), g = Vi[f];
      i = e[g], a = e[g + 1], e[g] = l, e[g + 1] = b;
    }
    for (let f = 0; f < 50; f += 10) {
      for (let u = 0; u < 10; u++)
        r[u] = e[f + u];
      for (let u = 0; u < 10; u++)
        e[f + u] ^= ~r[(u + 2) % 10] & r[(u + 4) % 10];
    }
    e[0] ^= aa[n], e[1] ^= fa[n];
  }
  r.fill(0);
}
class wn extends Di {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, r, n, i = !1, a = 24) {
    if (super(), this.blockLen = t, this.suffix = r, this.outputLen = n, this.enableXOF = i, this.rounds = a, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Dn(n), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Co(this.state);
  }
  keccak() {
    $n || Hn(this.state32), ua(this.state32, this.rounds), $n || Hn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    dr(this);
    const { blockLen: r, state: n } = this;
    t = mn(t);
    const i = t.length;
    for (let a = 0; a < i; ) {
      const f = Math.min(r - this.pos, i - a);
      for (let u = 0; u < f; u++)
        n[this.pos++] ^= t[a++];
      this.pos === r && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: r, pos: n, blockLen: i } = this;
    t[n] ^= r, r & 128 && n === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    dr(this, !1), gn(t), this.finish();
    const r = this.state, { blockLen: n } = this;
    for (let i = 0, a = t.length; i < a; ) {
      this.posOut >= n && this.keccak();
      const f = Math.min(n - this.posOut, a - i);
      t.set(r.subarray(this.posOut, this.posOut + f), i), this.posOut += f, i += f;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return Dn(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (Mi(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: r, suffix: n, outputLen: i, rounds: a, enableXOF: f } = this;
    return t || (t = new wn(r, n, i, f, a)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = a, t.suffix = n, t.outputLen = i, t.enableXOF = f, t.destroyed = this.destroyed, t;
  }
}
const ca = (e, t, r) => $i(() => new wn(t, e, r)), la = /* @__PURE__ */ ca(1, 136, 256 / 8);
function ha(e, t) {
  return la(Vt(e, { strict: !1 }) ? Pi(e) : e);
}
const Ur = /* @__PURE__ */ new qi(8192);
function da(e, t) {
  if (Ur.has(`${e}.${t}`))
    return Ur.get(`${e}.${t}`);
  const r = e.substring(2).toLowerCase(), n = ha(Ci(r)), i = r.split("");
  for (let f = 0; f < 40; f += 2)
    n[f >> 1] >> 4 >= 8 && i[f] && (i[f] = i[f].toUpperCase()), (n[f >> 1] & 15) >= 8 && i[f + 1] && (i[f + 1] = i[f + 1].toUpperCase());
  const a = `0x${i.join("")}`;
  return Ur.set(`${e}.${t}`, a), a;
}
const pa = /^0x[a-fA-F0-9]{40}$/, Nr = /* @__PURE__ */ new qi(8192);
function ut(e, t) {
  const { strict: r = !0 } = t ?? {}, n = `${e}.${r}`;
  if (Nr.has(n))
    return Nr.get(n);
  const i = pa.test(e) ? e.toLowerCase() === e ? !0 : r ? da(e) === e : !0 : !1;
  return Nr.set(n, i), i;
}
function ba(e, t, r, { strict: n } = {}) {
  return Vt(e, { strict: !1 }) ? ga(e, t, r, {
    strict: n
  }) : ya(e, t, r, {
    strict: n
  });
}
function Ji(e, t, r) {
  if (vt(e) !== r - t)
    throw new eo({
      offset: r,
      position: "end",
      size: vt(e)
    });
}
function ya(e, t, r, { strict: n } = {}) {
  const i = e.slice(t, r);
  return n && Ji(i, t, r), i;
}
function ga(e, t, r, { strict: n } = {}) {
  const i = `0x${e.replace("0x", "").slice(t * 2, r * 2)}`;
  return n && Ji(i, t, r), i;
}
function ma(e) {
  const { authorizationList: t } = e;
  if (t)
    for (const r of t) {
      const { contractAddress: n, chainId: i } = r;
      if (!ut(n))
        throw new ft({ address: n });
      if (i <= 0)
        throw new wr({ chainId: i });
    }
  xn(e);
}
function _a(e) {
  const { blobVersionedHashes: t } = e;
  if (t) {
    if (t.length === 0)
      throw new Gi();
    for (const r of t) {
      const n = vt(r), i = hr(ba(r, 0, 1));
      if (n !== 32)
        throw new Wo({ hash: r, size: n });
      if (i !== ji)
        throw new qo({
          hash: r,
          version: i
        });
    }
  }
  xn(e);
}
function xn(e) {
  const { chainId: t, maxPriorityFeePerGas: r, maxFeePerGas: n, to: i } = e;
  if (t <= 0)
    throw new wr({ chainId: t });
  if (i && !ut(i))
    throw new ft({ address: i });
  if (n && n > yn)
    throw new xr({ maxFeePerGas: n });
  if (r && n && r > n)
    throw new Wi({ maxFeePerGas: n, maxPriorityFeePerGas: r });
}
function wa(e) {
  const { chainId: t, maxPriorityFeePerGas: r, gasPrice: n, maxFeePerGas: i, to: a } = e;
  if (t <= 0)
    throw new wr({ chainId: t });
  if (a && !ut(a))
    throw new ft({ address: a });
  if (r || i)
    throw new X("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (n && n > yn)
    throw new xr({ maxFeePerGas: n });
}
function xa(e) {
  const { chainId: t, maxPriorityFeePerGas: r, gasPrice: n, maxFeePerGas: i, to: a } = e;
  if (a && !ut(a))
    throw new ft({ address: a });
  if (typeof t < "u" && t <= 0)
    throw new wr({ chainId: t });
  if (r || i)
    throw new X("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (n && n > yn)
    throw new xr({ maxFeePerGas: n });
}
function va(e) {
  if (e.type)
    return e.type;
  if (typeof e.authorizationList < "u")
    return "eip7702";
  if (typeof e.blobs < "u" || typeof e.blobVersionedHashes < "u" || typeof e.maxFeePerBlobGas < "u" || typeof e.sidecars < "u")
    return "eip4844";
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new Ro({ transaction: e });
}
function vr(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (let r = 0; r < e.length; r++) {
    const { address: n, storageKeys: i } = e[r];
    for (let a = 0; a < i.length; a++)
      if (i[a].length - 2 !== 64)
        throw new To({ storageKey: i[a] });
    if (!ut(n, { strict: !1 }))
      throw new ft({ address: n });
    t.push([n, i]);
  }
  return t;
}
function Ea(e, t) {
  const r = va(e);
  return r === "eip1559" ? Ia(e, t) : r === "eip2930" ? Aa(e, t) : r === "eip4844" ? Sa(e, t) : r === "eip7702" ? Ba(e, t) : Ra(e, t);
}
function Ba(e, t) {
  const { authorizationList: r, chainId: n, gas: i, nonce: a, to: f, value: u, maxFeePerGas: l, maxPriorityFeePerGas: b, accessList: g, data: m } = e;
  ma(e);
  const v = vr(g), I = Yo(r);
  return Kt([
    "0x04",
    at([
      W(n),
      a ? W(a) : "0x",
      b ? W(b) : "0x",
      l ? W(l) : "0x",
      i ? W(i) : "0x",
      f ?? "0x",
      u ? W(u) : "0x",
      m ?? "0x",
      v,
      I,
      ...Yt(e, t)
    ])
  ]);
}
function Sa(e, t) {
  const { chainId: r, gas: n, nonce: i, to: a, value: f, maxFeePerBlobGas: u, maxFeePerGas: l, maxPriorityFeePerGas: b, accessList: g, data: m } = e;
  _a(e);
  let v = e.blobVersionedHashes, I = e.sidecars;
  if (e.blobs && (typeof v > "u" || typeof I > "u")) {
    const k = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((S) => Qe(S)), L = e.kzg, O = Ui({
      blobs: k,
      kzg: L
    });
    if (typeof v > "u" && (v = jo({
      commitments: O
    })), typeof I > "u") {
      const S = Ni({ blobs: k, commitments: O, kzg: L });
      I = Ko({ blobs: k, commitments: O, proofs: S });
    }
  }
  const B = vr(g), P = [
    W(r),
    i ? W(i) : "0x",
    b ? W(b) : "0x",
    l ? W(l) : "0x",
    n ? W(n) : "0x",
    a ?? "0x",
    f ? W(f) : "0x",
    m ?? "0x",
    B,
    u ? W(u) : "0x",
    v ?? [],
    ...Yt(e, t)
  ], T = [], C = [], F = [];
  if (I)
    for (let k = 0; k < I.length; k++) {
      const { blob: L, commitment: O, proof: S } = I[k];
      T.push(L), C.push(O), F.push(S);
    }
  return Kt([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    at(I ? [P, T, C, F] : P)
  ]);
}
function Ia(e, t) {
  const { chainId: r, gas: n, nonce: i, to: a, value: f, maxFeePerGas: u, maxPriorityFeePerGas: l, accessList: b, data: g } = e;
  xn(e);
  const m = vr(b), v = [
    W(r),
    i ? W(i) : "0x",
    l ? W(l) : "0x",
    u ? W(u) : "0x",
    n ? W(n) : "0x",
    a ?? "0x",
    f ? W(f) : "0x",
    g ?? "0x",
    m,
    ...Yt(e, t)
  ];
  return Kt([
    "0x02",
    at(v)
  ]);
}
function Aa(e, t) {
  const { chainId: r, gas: n, data: i, nonce: a, to: f, value: u, accessList: l, gasPrice: b } = e;
  wa(e);
  const g = vr(l), m = [
    W(r),
    a ? W(a) : "0x",
    b ? W(b) : "0x",
    n ? W(n) : "0x",
    f ?? "0x",
    u ? W(u) : "0x",
    i ?? "0x",
    g,
    ...Yt(e, t)
  ];
  return Kt([
    "0x01",
    at(m)
  ]);
}
function Ra(e, t) {
  const { chainId: r = 0, gas: n, data: i, nonce: a, to: f, value: u, gasPrice: l } = e;
  xa(e);
  let b = [
    a ? W(a) : "0x",
    l ? W(l) : "0x",
    n ? W(n) : "0x",
    f ?? "0x",
    u ? W(u) : "0x",
    i ?? "0x"
  ];
  if (t) {
    const g = (() => {
      if (t.v >= 35n)
        return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
      if (r > 0)
        return BigInt(r * 2) + BigInt(35n + t.v - 27n);
      const I = 27n + (t.v === 27n ? 0n : 1n);
      if (t.v !== I)
        throw new Ao({ v: t.v });
      return I;
    })(), m = lr(t.r), v = lr(t.s);
    b = [
      ...b,
      W(g),
      m === "0x00" ? "0x" : m,
      v === "0x00" ? "0x" : v
    ];
  } else r > 0 && (b = [
    ...b,
    W(r),
    "0x",
    "0x"
  ]);
  return at(b);
}
function Yt(e, t) {
  const r = t ?? e, { v: n, yParity: i } = r;
  if (typeof r.r > "u")
    return [];
  if (typeof r.s > "u")
    return [];
  if (typeof n > "u" && typeof i > "u")
    return [];
  const a = lr(r.r), f = lr(r.s);
  return [typeof i == "number" ? i ? W(1) : "0x" : n === 0n ? "0x" : n === 1n ? W(1) : n === 27n ? "0x" : W(1), a === "0x00" ? "0x" : a, f === "0x00" ? "0x" : f];
}
const Ta = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, Pa = {
  block: /* @__PURE__ */ po({
    format(e) {
      var r;
      return {
        transactions: (r = e.transactions) == null ? void 0 : r.map((n) => {
          if (typeof n == "string")
            return n;
          const i = bn(n);
          return i.typeHex === "0x7e" && (i.isSystemTx = n.isSystemTx, i.mint = n.mint ? mt(n.mint) : void 0, i.sourceHash = n.sourceHash, i.type = "deposit"), i;
        }),
        stateRoot: e.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ co({
    format(e) {
      const t = {};
      return e.type === "0x7e" && (t.isSystemTx = e.isSystemTx, t.mint = e.mint ? mt(e.mint) : void 0, t.sourceHash = e.sourceHash, t.type = "deposit"), t;
    }
  }),
  transactionReceipt: /* @__PURE__ */ mo({
    format(e) {
      return {
        l1GasPrice: e.l1GasPrice ? mt(e.l1GasPrice) : null,
        l1GasUsed: e.l1GasUsed ? mt(e.l1GasUsed) : null,
        l1Fee: e.l1Fee ? mt(e.l1Fee) : null,
        l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null
      };
    }
  })
};
function Ca(e, t) {
  return Fa(e) ? ka(e) : Ea(e, t);
}
const La = {
  transaction: Ca
};
function ka(e) {
  Oa(e);
  const { sourceHash: t, data: r, from: n, gas: i, isSystemTx: a, mint: f, to: u, value: l } = e, b = [
    t,
    n,
    u ?? "0x",
    f ? W(f) : "0x",
    l ? W(l) : "0x",
    i ? W(i) : "0x",
    a ? "0x1" : "0x",
    r ?? "0x"
  ];
  return Kt([
    "0x7e",
    at(b)
  ]);
}
function Fa(e) {
  return e.type === "deposit" || typeof e.sourceHash < "u";
}
function Oa(e) {
  const { from: t, to: r } = e;
  if (t && !ut(t))
    throw new ft({ address: t });
  if (r && !ut(r))
    throw new ft({ address: r });
}
const Vn = {
  contracts: Ta,
  formatters: Pa,
  serializers: La
}, Ua = /* @__PURE__ */ qt({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), Na = /* @__PURE__ */ qt({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: !0
}), Ot = 11155111, Ma = /* @__PURE__ */ qt({
  ...Vn,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...Vn.contracts,
    disputeGameFactory: {
      [Ot]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [Ot]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [Ot]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [Ot]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: !0,
  sourceId: Ot
}), Da = /* @__PURE__ */ qt({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), $a = /* @__PURE__ */ qt({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc2.sepolia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: !0
});
function rn(e) {
  return typeof e == "string" && (e = Buffer.from(e, "hex")), e.length === 32 ? e : e.subarray(1, 33);
}
function yt(e, t) {
  if (!e) throw new Error(t);
}
function Ha(e) {
  return Buffer.concat([
    Uint8Array.from([192]),
    za(e)
  ]);
}
function za(e) {
  const t = On.encodingLength(e.length), r = Buffer.allocUnsafe(t);
  return On.encode(e.length, r), Buffer.concat([r, e]);
}
function ja(e, t) {
  if (e.compare(t) > 0) {
    const r = e;
    e = t, t = r;
  }
  return [e, t];
}
const Ut = (e) => e.length === 64 ? e : e.slice(2), Ga = (e) => {
  if (!e) return !1;
  try {
    const t = Buffer.from(e, "hex");
    return st.isPoint(t);
  } catch {
    return !1;
  }
}, Wa = {
  ...$a,
  rpcUrls: {
    default: {
      http: ["https://ethereum-sepolia-rpc.publicnode.com"]
    }
  }
}, qa = {
  ethereum: Da,
  ethereum_arbitrum: Ua,
  ethereum_sepolia: Wa,
  arbitrum_sepolia: Na,
  ethereum_localnet: Gs,
  arbitrum_localnet: Ws,
  base_sepolia: Ma
}, dl = async (e, t) => {
  var n;
  const r = qa[e];
  if (r)
    try {
      if (r.id === ((n = t.chain) == null ? void 0 : n.id))
        return ue({ message: "Already on the network", walletClient: t });
      await t.switchChain({ id: r.id });
      const i = kn({
        account: t.account,
        chain: r,
        transport: Fn(window.ethereum)
      });
      return ue({
        message: "Switched chain",
        walletClient: i
      });
    } catch (i) {
      if (Va(i))
        try {
          await t.addChain({ chain: r });
          const a = kn({
            account: t.account,
            chain: r,
            transport: Fn(window.ethereum)
          });
          return ue({
            message: "Added network",
            walletClient: a
          });
        } catch {
          return N("Failed to add network");
        }
      else
        return N("Failed to switch network");
    }
  else
    return N("Chain not supported");
}, Va = (e) => typeof e == "object" && e !== null && "code" in e && e.code === 4902, Ka = (e, t, r, n) => e + ":" + t.toLowerCase() + "::" + r + ":" + n.toLowerCase();
function pl(e, t) {
  if (!e) return !1;
  const r = t === "mainnet" ? fe.networks.bitcoin : fe.networks.testnet;
  fe.initEccLib(st);
  try {
    return fe.address.toOutputScript(e, r), !0;
  } catch {
    return !1;
  }
}
var te = /* @__PURE__ */ ((e) => (e.Created = "Created", e.Matched = "Matched", e.InitiateDetected = "InitiateDetected", e.Initiated = "Initiated", e.CounterPartyInitiateDetected = "CounterPartyInitiateDetected", e.CounterPartyInitiated = "CounterPartyInitiated", e.RedeemDetected = "RedeemDetected", e.Redeemed = "Redeemed", e.CounterPartyRedeemDetected = "CounterPartyRedeemDetected", e.CounterPartyRedeemed = "CounterPartyRedeemed", e.Completed = "Completed", e.CounterPartySwapExpired = "CounterPartySwapExpired", e.Expired = "Expired", e.RefundDetected = "RefundDetected", e.Refunded = "Refunded", e.CounterPartyRefundDetected = "CounterPartyRefundDetected", e.CounterPartyRefunded = "CounterPartyRefunded", e.Cancelled = "Cancelled", e.DeadLineExceeded = "DeadLineExceeded", e))(te || {}), re = /* @__PURE__ */ ((e) => (e.Idle = "Idle", e.InitiateDetected = "InitiateDetected", e.Initiated = "Initiated", e.RedeemDetected = "RedeemDetected", e.Redeemed = "Redeemed", e.RefundDetected = "RefundDetected", e.Refunded = "Refunded", e.Expired = "Expired", e))(re || {});
const Xi = (e, t, r) => {
  const n = Kn(
    e.source_swap,
    t
  ), i = Kn(
    e.destination_swap,
    r
  );
  if (i === re.RedeemDetected)
    return te.RedeemDetected;
  if (n === re.Redeemed)
    return te.CounterPartyRedeemed;
  if (n === re.RedeemDetected)
    return te.CounterPartyRedeemDetected;
  if (i === re.Redeemed) return te.Redeemed;
  if (n === re.Refunded) return te.Refunded;
  if (n === re.RefundDetected)
    return te.RefundDetected;
  if (i === re.Expired)
    return te.CounterPartySwapExpired;
  if (n === re.Expired) return te.Expired;
  if (i === re.Refunded)
    return te.CounterPartyRefunded;
  if (i === re.RefundDetected)
    return te.CounterPartyRefundDetected;
  const a = Number(
    e.create_order.additional_data.deadline
  );
  return i === re.Initiated ? te.CounterPartyInitiated : i === re.InitiateDetected ? te.CounterPartyInitiateDetected : pr(a, 12) ? te.DeadLineExceeded : n === re.Initiated ? te.Initiated : pr(a, 1) ? te.DeadLineExceeded : n === re.InitiateDetected ? te.InitiateDetected : te.Matched;
}, Kn = (e, t) => {
  if (e.redeem_tx_hash)
    return Number(e.redeem_block_number) ? re.Redeemed : re.RedeemDetected;
  if (e.refund_tx_hash)
    return Number(e.refund_block_number) ? re.Refunded : re.RefundDetected;
  if (Number(e.initiate_block_number)) {
    const r = Number(e.initiate_block_number) + e.timelock;
    if (t > r) return re.Expired;
  }
  return e.initiate_tx_hash ? Number(e.initiate_block_number) ? re.Initiated : re.InitiateDetected : re.Idle;
}, bl = (e, t, r) => {
  const n = Xi(
    e,
    t,
    r
  );
  return Qi(n);
}, Qi = (e) => {
  switch (e) {
    case te.Matched:
      return le.Initiate;
    case te.CounterPartyInitiated:
    case te.CounterPartyInitiateDetected:
    case te.RedeemDetected:
      return le.Redeem;
    case te.Expired:
      return le.Refund;
    default:
      return le.Idle;
  }
}, pr = (e, t = 0) => {
  const r = Date.now(), n = e * 1e3 + t * 36e5;
  return r >= n;
}, Ya = (e) => e.filter((t) => {
  const { source_swap: r, create_order: n } = t, { initiate_tx_hash: i, initiate_block_number: a } = r, { deadline: f } = n.additional_data;
  return i && Number(a) ? !0 : i && !Number(a) ? !pr(Number(f), 12) : i ? !0 : !pr(Number(f), 1);
}), Ja = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token_",
        type: "address"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Initiated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "secret",
        type: "bytes"
      }
    ],
    name: "Redeemed",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      }
    ],
    name: "Refunded",
    type: "event"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      }
    ],
    name: "initiate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "initiateWithSignature",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "instantRefund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "redeemer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "secretHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct HTLC.InitWithSig[]",
        name: "inits",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "orderID",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "secret",
            type: "bytes"
          }
        ],
        internalType: "struct HTLC.Redeem[]",
        name: "redeems",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "orderID",
            type: "bytes32"
          }
        ],
        internalType: "struct HTLC.Refund[]",
        name: "refunds",
        type: "tuple[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bool[]",
        name: "results",
        type: "bool[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "orders",
    outputs: [
      {
        internalType: "bool",
        name: "isFulfilled",
        type: "bool"
      },
      {
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "initiatedAt",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "secret",
        type: "bytes"
      }
    ],
    name: "redeem",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      }
    ],
    name: "refund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
class Xa {
  constructor(t, r, n) {
    this.url = new dn("/relayer", r), this.auth = n, this.order = t;
  }
  async init(t) {
    if (!t.account) return N("No account found");
    if (t.account.address.toLowerCase() !== this.order.source_swap.initiator.toLowerCase())
      return N("Account address and order initiator mismatch");
    const { create_order: r, source_swap: n } = this.order;
    if (!n.amount || !n.redeemer || !r.timelock || !r.secret_hash)
      return N("Invalid order");
    const i = fr(r.secret_hash), a = BigInt(r.timelock), f = fr(n.redeemer), u = BigInt(n.amount);
    try {
      const l = await this.auth.getToken();
      if (l.error) return N(l.error);
      const b = Ys({
        address: fr(this.order.source_swap.asset),
        abi: Ja,
        client: t
      }), g = await b.read.token(), m = await Vs(
        Number(u),
        g,
        this.order.source_swap.asset,
        t
      );
      if (m.error) return N(m.error);
      const v = await b.read.eip712Domain(), I = await t.signTypedData({
        account: t.account,
        domain: {
          name: v[1],
          version: v[2],
          chainId: Number(v[3]),
          verifyingContract: v[4]
        },
        types: {
          Initiate: [
            { name: "redeemer", type: "address" },
            { name: "timelock", type: "uint256" },
            { name: "amount", type: "uint256" },
            { name: "secretHash", type: "bytes32" }
          ]
        },
        primaryType: "Initiate",
        message: {
          redeemer: f,
          timelock: a,
          amount: u,
          secretHash: i
        }
      }), B = await _t.post(
        this.url.endpoint("initiate"),
        {
          body: JSON.stringify({
            order_id: r.create_id,
            signature: I,
            perform_on: "Source"
          }),
          headers: {
            Authorization: Pn(l.val),
            "Content-Type": "application/json"
          }
        }
      );
      return B.error ? N(B.error) : B.result ? ue(B.result) : N("Init: No result found");
    } catch (l) {
      return console.log("init error :", l), N(String(l));
    }
  }
  async redeem(t, r) {
    try {
      const n = await this.auth.getToken();
      if (n.error) return N(n.error);
      const i = await _t.post(
        this.url.endpoint("redeem"),
        {
          body: JSON.stringify({
            order_id: t,
            secret: nt(r),
            perform_on: "Destination"
          }),
          headers: {
            Authorization: Pn(n.val),
            "Content-Type": "application/json"
          }
        }
      );
      return i.error ? N(i.error) : i.result ? ue(i.result) : N("Redeem: No result found");
    } catch (n) {
      return N(String(n));
    }
  }
}
const Qa = Buffer.from(
  "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
  "hex"
), Za = Buffer.from(
  "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
  "hex"
), ef = Buffer.concat([Qa, Za]), tf = Buffer.from(
  "0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0",
  "hex"
), Yn = {
  failedToCreateInternalPubkey: "failed to create internal pubkey",
  failedToTweakPubkey: "failed to tweak pubkey"
};
function rf() {
  const e = Js.sha256(Buffer.from("GardenHTLC", "utf-8")), t = st.pointMultiply(
    Buffer.concat([Buffer.from("04", "hex"), ef]),
    e
  );
  if (!t)
    throw new Error(Yn.failedToCreateInternalPubkey);
  const r = st.pointAdd(tf, t);
  if (!r) throw new Error(Yn.failedToCreateInternalPubkey);
  return rn(Buffer.from(r));
}
const me = {
  secretMismatch: "invalid secret",
  secretHashLenMismatch: "secret hash should be 32 bytes",
  pubkeyLenMismatch: "pubkey should be 32 bytes",
  zeroOrNegativeExpiry: "expiry should be greater than 0",
  htlcAddressGenerationFailed: "failed to generate htlc address",
  notFunded: "address not funded",
  noCounterpartySigs: "counterparty signatures are required",
  counterPartySigNotFound: (e) => "counterparty signature not found for utxo " + e,
  invalidCounterpartySigForUTXO: (e) => "invalid counterparty signature for utxo " + e,
  htlcNotExpired: (e) => `HTLC not expired, need more ${e} blocks`,
  controlBlockGenerationFailed: "failed to generate control block",
  invalidLeaf: "invalid leaf"
}, or = 192;
fe.initEccLib(st);
class br {
  /**
   * Note: redeemerAddress and initiatorAddress should be x-only public key without 02 or 03 prefix
   */
  constructor(t, r, n, i, a, f, u, l) {
    this.secretHash = n, this.redeemerPubkey = i, this.initiatorPubkey = a, this.expiry = f, this.signer = t, this.network = u, this.internalPubkey = rf(), this.initiateAmount = r, this.utxoHashes = l;
  }
  /**
   * Creates a GardenHTLC instance
   * @param signer Bitcoin wallet of the initiator or redeemer
   * @param secretHash 32 bytes secret hash
   * @param initiatorPubkey initiator's x-only public key without 02 or 03 prefix
   * @param redeemerPubkey redeemer's x-only public key without 02 or 03 prefix
   * @param expiry block height after which the funds can be refunded
   * @returns GardenHTLC instance
   *
   *
   * Note: When the signer is the initiator, only refund and instant refund can be done
   * When the signer is the redeemer, only redeem can be done
   */
  static async from(t, r, n, i, a, f, u) {
    n = n.startsWith("0x") ? n.slice(2) : n, yt(n.length === 64, me.secretHashLenMismatch), yt(
      i.length === 64 || i.length === 66,
      `initiator ${me.pubkeyLenMismatch}`
    ), yt(
      a.length === 64 || a.length === 66,
      `redeemer ${me.pubkeyLenMismatch}`
    ), yt(f > 0, me.zeroOrNegativeExpiry);
    const l = await t.getNetwork();
    return new br(
      t,
      r,
      n,
      rn(a).toString("hex"),
      rn(i).toString("hex"),
      f,
      l,
      u
    );
  }
  /**
   * Generates a taproot address for receiving the funds
   */
  address() {
    const { address: t } = fe.payments.p2tr({
      internalPubkey: this.internalPubkey,
      network: this.network,
      scriptTree: this.leaves()
    });
    if (!t) throw new Error(me.htlcAddressGenerationFailed);
    return t;
  }
  /**
   * returns the address of the HTLC
   */
  id() {
    return this.address();
  }
  async _buildRawTx(t, r) {
    const n = new fe.Transaction();
    n.version = 2;
    const i = this.address(), a = await this.signer.getProvider();
    let f = [];
    if (this.utxoHashes && this.utxoHashes.length > 0)
      for (const l of this.utxoHashes) {
        const b = await a.getTransaction(l);
        for (let g = 0; g < b.vout.length; g++) {
          const m = b.vout[g];
          m.scriptpubkey_address === i && f.push({
            txid: b.txid,
            vout: g,
            value: m.value,
            status: { confirmed: !1 }
          });
        }
      }
    else
      f = await a.getUTXOs(i);
    const u = f.reduce((l, b) => l + b.value, 0);
    if (u === 0) throw new Error(`${i} ${me.notFunded}`);
    for (let l = 0; l < f.length; l++)
      n.addInput(Buffer.from(f[l].txid, "hex").reverse(), f[l].vout);
    return r ?? (r = await a.suggestFee(i, u, Un.MEDIUM)), n.addOutput(
      fe.address.toOutputScript(t, this.network),
      u - r
    ), { tx: n, usedUtxos: f };
  }
  /**
   * Builds a raw unsigned transaction with utxos from gardenHTLC address
   * and uses signer's address as the output address
   */
  async buildRawTx(t) {
    return await this._buildRawTx(await this.signer.getAddress(), t);
  }
  /**
   * prevout script for the gardenHTLC address
   */
  getOutputScript() {
    return fe.address.toOutputScript(this.address(), this.network);
  }
  async init(t) {
    return t ?? (t = await (await this.signer.getProvider()).suggestFee(
      await this.signer.getAddress(),
      this.initiateAmount,
      Un.MEDIUM
    )), await this.signer.send(this.address(), this.initiateAmount, t);
  }
  /**
   * Instantly refunds the funds to the initiator given the counterparty's signatures and pubkey
   *
   * Note: If there are multiple UTXOs being spend, there should be a signature for each UTXO in counterPartySigs
   */
  async instantRefund(t, r) {
    yt(t.length > 0, me.noCounterpartySigs);
    const { tx: n, usedUtxos: i } = await this.buildRawTx(r);
    for (const m of i)
      if (!t.find((v) => v.utxo === m.txid))
        throw new Error(me.counterPartySigNotFound(m.txid));
    const a = this.getOutputScript(), f = fe.Transaction.SIGHASH_DEFAULT, u = this.leafHash(
      2
      /* INSTANT_REFUND */
    ), l = i.map((m) => m.value), b = Mr(a, i.length);
    for (let m = 0; m < n.ins.length; m++) {
      const v = n.hashForWitnessV1(
        m,
        b,
        l,
        f,
        u
      );
      if (!st.verifySchnorr(
        v,
        Buffer.from(this.redeemerPubkey, "hex"),
        Buffer.from(t[m].sig, "hex")
      ))
        throw new Error(
          me.invalidCounterpartySigForUTXO(t[m].utxo)
        );
      const I = await this.signer.signSchnorr(v), B = Buffer.from(n.ins[m].hash).reverse().toString("hex"), P = t.find((T) => T.utxo === B);
      if (!P)
        throw new Error(me.counterPartySigNotFound(B));
      n.setWitness(m, [
        Buffer.from(P.sig, "hex"),
        I,
        this.instantRefundLeaf(),
        this.generateControlBlockFor(
          2
          /* INSTANT_REFUND */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(n.toHex());
  }
  /**
   * Reveals the secret and redeems the HTLC
   */
  async redeem(t, r, n) {
    yt(
      fe.crypto.sha256(Buffer.from(t, "hex")).toString("hex") === this.secretHash,
      me.secretMismatch
    );
    const { tx: i, usedUtxos: a } = await this._buildRawTx(
      r ?? await this.signer.getAddress(),
      n
    ), f = this.leafHash(
      1
      /* REDEEM */
    ), u = a.map((m) => m.value), l = Mr(this.getOutputScript(), a.length), b = fe.Transaction.SIGHASH_DEFAULT;
    for (let m = 0; m < i.ins.length; m++) {
      const v = i.hashForWitnessV1(
        m,
        l,
        u,
        b,
        f
      ), I = await this.signer.signSchnorr(v);
      i.setWitness(m, [
        I,
        Buffer.from(t, "hex"),
        this.redeemLeaf(),
        this.generateControlBlockFor(
          1
          /* REDEEM */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(i.toHex());
  }
  /**
   * Refunds the funds back to the initiator if the expiry block height + 1 is reached
   */
  async refund(t, r) {
    const { tx: n, usedUtxos: i } = await this._buildRawTx(
      t ?? await this.signer.getAddress(),
      r
    ), [a, f] = await this.canRefund(i);
    if (!a)
      throw new Error(me.htlcNotExpired(f));
    const u = this.leafHash(
      0
      /* REFUND */
    ), l = i.map((v) => v.value), b = Mr(this.getOutputScript(), i.length), g = fe.Transaction.SIGHASH_DEFAULT;
    for (let v = 0; v < n.ins.length; v++) {
      n.ins[v].sequence = this.expiry;
      const I = n.hashForWitnessV1(
        v,
        b,
        l,
        g,
        u
      ), B = await this.signer.signSchnorr(I);
      n.setWitness(v, [
        B,
        this.refundLeaf(),
        this.generateControlBlockFor(
          0
          /* REFUND */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(n.toHex());
  }
  /**
   * Given a list of UTXOs, checks if the HTLC can be refunded
   */
  async canRefund(t) {
    const n = await (await this.signer.getProvider()).getLatestTip();
    for (const i of t) {
      let a = 0;
      if (i.status.confirmed && i.status.block_height + this.expiry > n ? a = i.status.block_height + this.expiry - n + 1 : i.status.confirmed || (a = this.expiry + 1), a > 0)
        return [!1, a];
    }
    return [!0, 0];
  }
  /**
   * Given a leaf, generates the control block necessary for spending the leaf
   */
  generateControlBlockFor(t) {
    let r;
    switch (t) {
      case 1:
        r = this.redeemLeaf();
        break;
      case 0:
        r = this.refundLeaf();
        break;
      case 2:
        r = this.instantRefundLeaf();
        break;
      default:
        throw new Error(me.invalidLeaf);
    }
    const n = fe.payments.p2tr({
      internalPubkey: this.internalPubkey,
      network: this.network,
      scriptTree: this.leaves(),
      redeem: {
        output: r,
        redeemVersion: or
      }
    });
    if (!n.witness)
      throw new Error(me.controlBlockGenerationFailed);
    return n.witness[n.witness.length - 1];
  }
  /**
   * Generates the hash of the leaf script
   * @param leaf Use leaf enum or pass 0 for refund, 1 for redeem, 2 for instant refund
   * @returns hash of the leaf script
   */
  leafHash(t) {
    let r = this.redeemLeaf();
    return t === 0 && (r = this.refundLeaf()), t === 2 && (r = this.instantRefundLeaf()), fe.crypto.taggedHash("TapLeaf", Ha(r));
  }
  refundLeaf() {
    return fe.script.fromASM(
      `
			${fe.script.number.encode(this.expiry).toString("hex")}
			OP_CHECKSEQUENCEVERIFY
			OP_DROP
			${this.initiatorPubkey}	
			OP_CHECKSIG
			`.trim().replace(/\s+/g, " ")
    );
  }
  redeemLeaf() {
    return fe.script.fromASM(
      `
			OP_SHA256
			${this.secretHash}
			OP_EQUALVERIFY
			${this.redeemerPubkey}
			OP_CHECKSIG
			`.trim().replace(/\s+/g, " ")
    );
  }
  instantRefundLeaf() {
    return fe.script.fromASM(
      `
			${this.initiatorPubkey}
			OP_CHECKSIG
			${this.redeemerPubkey}
			OP_CHECKSIGADD
			OP_2
			OP_NUMEQUAL
			`.trim().replace(/\s+/g, " ")
    );
  }
  leaves() {
    return [
      // most probable leaf (redeem)
      {
        version: or,
        output: this.redeemLeaf()
      },
      [
        {
          version: or,
          output: this.refundLeaf()
        },
        {
          version: or,
          output: this.instantRefundLeaf()
        }
      ]
    ];
  }
  /**
   * Generates the merkle proof for the leaf script
   */
  generateMerkleProofFor(t) {
    const r = this.leafHash(
      1
      /* REDEEM */
    ), n = this.leafHash(
      2
      /* INSTANT_REFUND */
    ), i = this.leafHash(
      0
      /* REFUND */
    );
    switch (t) {
      case 1: {
        const a = ja(
          i,
          n
        );
        return [
          fe.crypto.taggedHash(
            "TapBranch",
            Buffer.concat(a)
          )
        ];
      }
      case 0:
        return [n, r];
      case 2:
        return [i, r];
      default:
        throw new Error(me.invalidLeaf);
    }
  }
}
function Mr(e, t) {
  const r = [];
  for (let n = 0; n < t; n++)
    r.push(e);
  return r;
}
class nf {
  constructor() {
    this.cache = {};
  }
  set(t, r, n, i) {
    const a = {
      txHash: n,
      timeStamp: Date.now(),
      btcRedeemUTXO: i
    };
    this.cache[`${r}_${t.create_order.create_id}`] = a;
  }
  get(t, r) {
    return this.cache[`${r}_${t.create_order.create_id}`] || null;
  }
  remove(t, r) {
    delete this.cache[`${r}_${t.create_order.create_id}`];
  }
}
class yl {
  constructor(t) {
    if (this.eventListeners = /* @__PURE__ */ new Map(), this.getOrderThreshold = 20, this.useRelay = !0, this.orderBook = new qs({
      url: t.orderbookURl,
      walletClient: t.wallets.evmWallet,
      auth: t.auth
    }), this.quote = t.quote, this.secretManager = t.secretManager, this.wallets = t.wallets, this.orderbookUrl = t.orderbookURl, this.auth = t.auth, this.orderExecutorCache = new nf(), !t.wallets.evmWallet.account)
      throw new Error("Account not found in evmWallet");
    this.evmAddress = t.wallets.evmWallet.account.address, this.blockNumberFetcher = t.blockNumberFetcher;
  }
  setUseRelay(t) {
    this.useRelay = t;
  }
  async swap(t) {
    const r = await this.validateAndFillParams(t);
    if (r.error) return N(r.error);
    const { sendAddress: n, receiveAddress: i, timelock: a } = r.val, f = await this.orderBook.getOrdersCount(this.evmAddress);
    if (f.error) return N(f.error);
    const u = f.val + 1, l = this.secretManager.generateSecret(u);
    if (l.error) return N(l.error);
    const { strategyId: b, btcAddress: g } = t.additionalData, m = {
      strategy_id: b,
      ...g && {
        bitcoin_optional_recipient: g
      }
    }, v = {
      source_chain: t.fromAsset.chain,
      destination_chain: t.toAsset.chain,
      source_asset: t.fromAsset.atomicSwapAddress,
      destination_asset: t.toAsset.atomicSwapAddress,
      initiator_source_address: n,
      initiator_destination_address: i,
      source_amount: t.sendAmount,
      destination_amount: t.receiveAmount,
      fee: "1",
      nonce: u.toString(),
      timelock: a,
      secret_hash: nt(l.val.secretHash),
      min_destination_confirmations: t.minDestinationConfirmations ?? 0,
      additional_data: m
    }, I = await this.quote.getAttestedQuote(v);
    if (I.error) return N(I.error);
    const B = await this.orderBook.createOrder(I.val);
    if (B.error) return N(B.error);
    const P = await this.pollOrder(B.val);
    return P.error ? N(P.error) : ue(P.val);
  }
  async validateAndFillParams(t) {
    if (t.fromAsset.chain === t.toAsset.chain && t.fromAsset.atomicSwapAddress === t.toAsset.atomicSwapAddress)
      return N("Source and destination assets cannot be the same");
    if (rr(t.fromAsset.chain) && !rr(t.toAsset.chain) || !rr(t.fromAsset.chain) && rr(t.toAsset.chain))
      return N(
        "Both assets should be on the same network (either mainnet or testnet)"
      );
    if (nr(t.fromAsset.chain) || nr(t.toAsset.chain)) {
      if (!this.wallets.btcWallet)
        return N(
          "btcWallet is required for bitcoin chain. Please provide btcWallet in the constructor"
        );
      if (!t.additionalData.btcAddress)
        return N(
          "btcAddress in additionalData is required for bitcoin chain"
        );
    }
    const r = await this.getAddresses(t.fromAsset.chain);
    if (r.error) return N(r.error);
    const n = await this.getAddresses(t.toAsset.chain);
    if (n.error) return N(n.error);
    const i = this.validateAmount(t.sendAmount);
    if (i.error) return N(i.error);
    const a = this.validateAmount(t.receiveAmount);
    if (a.error) return N(a.error);
    if (i < a)
      return N("Send amount should be greater than receive amount");
    const f = this.getTimelock(t.fromAsset.chain);
    return f ? ue({
      sendAddress: r.val,
      receiveAddress: n.val,
      timelock: t.timelock ?? f
    }) : N("Unsupported chain for timelock");
  }
  async getAddresses(t) {
    var n;
    switch (Lt(t)) {
      case ke.EVM:
        return this.wallets.evmWallet.account ? ue(this.wallets.evmWallet.account.address) : N("EVM Wallet not found");
      case ke.Bitcoin: {
        const i = await ((n = this.wallets.btcWallet) == null ? void 0 : n.getPublicKey());
        return !i || !Ga(i) ? N("Invalid btc public key") : ue(Ut(i));
      }
      default:
        return N("Unsupported chain");
    }
  }
  validateAmount(t) {
    if (t == null || t.includes("."))
      return N("Invalid amount ", t);
    const r = new Xs(t);
    return !r.isInteger() || r.isNaN() || r.lt(0) || r.isLessThanOrEqualTo(0) ? N("Invalid amount ", t) : ue(r);
  }
  getTimelock(t) {
    switch (Lt(t)) {
      case ke.EVM:
        return en.evm;
      case ke.Bitcoin:
        return en.btc;
      default:
        return;
    }
  }
  async pollOrder(t) {
    let r = await this.orderBook.getOrder(t, !0), n = 0;
    for (; n < this.getOrderThreshold; ) {
      if (await Ks(1e3), n++, r.error) {
        if (!r.error.includes("result is undefined"))
          return N(r.error);
      } else if (r.val && r.val.create_order.create_id.toLowerCase() === t.toLowerCase())
        return ue(r.val);
      r = await this.orderBook.getOrder(t, !0);
    }
    return N(`Order not found, createOrder id: ${t}`);
  }
  async execute(t = 5e3) {
    return await this.orderBook.subscribeToOrders(
      !0,
      t,
      async (r) => {
        const n = Ya(r.data), i = await this.assignOrderStatus(n);
        this.emit("onPendingOrdersChanged", i);
        for (let a = 0; a < i.length; a++) {
          const f = i[a];
          switch (Qi(f.status)) {
            case le.Redeem: {
              const l = this.secretManager.generateSecret(
                Number(f.create_order.nonce)
              );
              if (l.error) {
                this.emit("error", f, l.error);
                return;
              }
              switch (Lt(f.destination_swap.chain)) {
                case ke.EVM: {
                  await this.evmRedeem(f, l.val.secret);
                  break;
                }
                case ke.Bitcoin: {
                  const b = this.getWallet(
                    f.destination_swap.chain
                  );
                  if (b.error) {
                    this.emit("error", f, b.error);
                    return;
                  }
                  await this.btcRedeem(
                    b.val,
                    f,
                    l.val.secret
                  );
                  break;
                }
                default:
                  this.emit(
                    "error",
                    f,
                    "Unsupported chain: " + f.destination_swap.chain
                  );
              }
              break;
            }
            case le.Refund: {
              switch (Lt(f.source_swap.chain)) {
                case ke.EVM: {
                  this.emit(
                    "error",
                    f,
                    "EVM refund is automatically done by relay service"
                  );
                  break;
                }
                case ke.Bitcoin: {
                  const l = this.getWallet(f.source_swap.chain);
                  if (l.error) {
                    this.emit("error", f, l.error);
                    return;
                  }
                  await this.btcRefund(
                    l.val,
                    f
                  );
                  break;
                }
                default:
                  this.emit(
                    "error",
                    f,
                    "Unsupported chain: " + f.source_swap.chain
                  );
              }
              break;
            }
          }
        }
      },
      {
        per_page: 500
      },
      !0
    );
  }
  async evmRedeem(t, r) {
    if (this.emit("log", t.create_order.create_id, "executing evm redeem"), this.orderExecutorCache.get(t, le.Redeem)) {
      this.emit("log", t.create_order.create_id, "already redeemed");
      return;
    }
    const a = await new Xa(t, this.orderbookUrl, this.auth).redeem(t.create_order.create_id, r);
    if (a.error) {
      this.emit("error", t, a.error), a.error.includes("Order already redeemed") && this.orderExecutorCache.set(
        t,
        le.Redeem,
        t.destination_swap.redeem_tx_hash
      );
      return;
    }
    this.orderExecutorCache.set(t, le.Redeem, a.val), this.emit("success", t, le.Redeem, a.val);
  }
  async btcRedeem(t, r, n) {
    var u, l;
    const i = this.orderExecutorCache.get(r, le.Redeem), a = (u = r.destination_swap.initiate_tx_hash.split(",").at(-1)) == null ? void 0 : u.split(":").at(0);
    if (!a) {
      this.emit("error", r, "Failed to get initiate_tx_hash");
      return;
    }
    let f = !1;
    if (i)
      if (i.btcRedeemUTXO && i.btcRedeemUTXO !== a)
        f = !0, this.emit("log", r.create_order.create_id, "rbf btc redeem");
      else {
        this.emit(
          "log",
          r.create_order.create_id,
          "btcRedeem: already redeemed"
        );
        return;
      }
    else if (r.destination_swap.redeem_tx_hash && !Number(r.destination_swap.redeem_block_number))
      try {
        const b = await (await t.getProvider()).getTransaction(r.destination_swap.redeem_tx_hash);
        let g = !1;
        for (const m of b.vin)
          if (m.txid === a) {
            g = !0;
            break;
          }
        if (g) {
          this.orderExecutorCache.set(
            r,
            le.Redeem,
            r.destination_swap.redeem_tx_hash,
            a
          ), this.emit(
            "log",
            r.create_order.create_id,
            "already a valid redeem"
          );
          return;
        }
        f = !0;
      } catch (b) {
        if (b.message.includes("Transaction not found"))
          f = !0;
        else {
          this.emit("error", r, "Failed to get redeem tx: " + b);
          return;
        }
      }
    this.emit("log", r.create_order.create_id, "executing btc redeem");
    try {
      const g = await (await br.from(
        t,
        Number(r.destination_swap.amount),
        r.create_order.secret_hash,
        Ut(r.destination_swap.initiator),
        Ut(r.destination_swap.redeemer),
        r.destination_swap.timelock,
        f ? [a] : []
      )).redeem(
        nt(n),
        (l = r.create_order.additional_data) == null ? void 0 : l.bitcoin_optional_recipient
      );
      f ? this.emit(
        "log",
        r.create_order.create_id,
        "rbf: btc redeem success"
      ) : this.emit("success", r, le.Redeem, g), this.orderExecutorCache.set(r, le.Redeem, g, a);
    } catch (b) {
      this.emit("error", r, "Failed btc redeem: " + b);
    }
  }
  async btcRefund(t, r) {
    var n;
    if (!this.orderExecutorCache.get(r, le.Refund)) {
      this.emit("log", r.create_order.create_id, "executing btc refund");
      try {
        const a = await (await br.from(
          t,
          Number(r.source_swap.amount),
          r.create_order.secret_hash,
          Ut(r.source_swap.initiator),
          Ut(r.source_swap.redeemer),
          r.source_swap.timelock
        )).refund(
          (n = r.create_order.additional_data) == null ? void 0 : n.bitcoin_optional_recipient
        );
        this.orderExecutorCache.set(r, le.Refund, a), this.emit("success", r, le.Refund, a);
      } catch (i) {
        this.emit("error", r, "Failed btc refund: " + i);
      }
    }
  }
  getWallet(t) {
    switch (Lt(t)) {
      case ke.EVM:
        return ue(this.wallets.evmWallet);
      case ke.Bitcoin:
        return ue(this.wallets.btcWallet);
      default:
        return N("Unsupported chain for wallet");
    }
  }
  emit(t, ...r) {
    (this.eventListeners.get(t) ?? []).forEach((i) => {
      i(...r);
    });
  }
  on(t, r) {
    const n = this.eventListeners.get(t) ?? [];
    n.push(r), this.eventListeners.set(t, n);
  }
  off(t, r) {
    const n = this.eventListeners.get(t) ?? [], i = n.indexOf(r);
    i !== -1 && n.splice(i, 1);
  }
  async fetchCurrentBlockNumbers(t, r) {
    if (!r || !r.source || !r.destination)
      return N("Provide wallets to fetch the current block number");
    const n = nr(t.source_swap.chain) ? await Cn(
      await r.source.getProvider()
    ) : await Ln(r.source);
    if (n.error) return N(n.error);
    const i = nr(t.destination_swap.chain) ? await Cn(
      await r.destination.getProvider()
    ) : await Ln(r.destination);
    return i.error ? N(i.error) : ue({
      source: n.val,
      destination: i.val
    });
  }
  async assignOrderStatus(t) {
    var i;
    const r = await ((i = this.blockNumberFetcher) == null ? void 0 : i.fetchBlockNumbers()), n = [];
    for (let a = 0; a < t.length; a++) {
      const f = t[a], u = f.source_swap.chain, l = f.destination_swap.chain, b = this.getWallet(u), g = this.getWallet(l);
      if (b.error || g.error || !b.val || !g.val) {
        this.emit(
          "error",
          f,
          "Source or Destination Wallet not found while executing order"
        );
        continue;
      }
      let m = r == null ? void 0 : r.val[u], v = r == null ? void 0 : r.val[l];
      if (!m || !v) {
        const B = await this.fetchCurrentBlockNumbers(f, {
          source: b.val,
          destination: g.val
        });
        if (B.error) {
          this.emit(
            "error",
            f,
            "Error while fetching CurrentBlockNumbers: " + B.error
          );
          continue;
        }
        m = B.val.source, v = B.val.destination;
      }
      const I = Xi(
        f,
        m,
        v
      );
      n.push({
        ...f,
        status: I
      });
    }
    return n;
  }
}
class gl {
  constructor(t, r) {
    this.url = new dn("/blocknumber/" + r, t);
  }
  async fetchBlockNumbers() {
    try {
      const t = await _t.get(this.url);
      return ue(t);
    } catch (t) {
      return N("Failed to fetch block numbers", t);
    }
  }
}
var Xe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function of(e) {
  if (e.__esModule) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function n() {
      return this instanceof n ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(n) {
    var i = Object.getOwnPropertyDescriptor(e, n);
    Object.defineProperty(r, n, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[n];
      }
    });
  }), r;
}
var Zi = {}, Et = {}, Bt = {};
Object.defineProperty(Bt, "__esModule", { value: !0 });
Bt.testnet = Bt.bitcoin = void 0;
Bt.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
Bt.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var es = {}, Gt = {
  Array: function(e) {
    return e != null && e.constructor === Array;
  },
  Boolean: function(e) {
    return typeof e == "boolean";
  },
  Function: function(e) {
    return typeof e == "function";
  },
  Nil: function(e) {
    return e == null;
  },
  Number: function(e) {
    return typeof e == "number";
  },
  Object: function(e) {
    return typeof e == "object";
  },
  String: function(e) {
    return typeof e == "string";
  },
  "": function() {
    return !0;
  }
};
Gt.Null = Gt.Nil;
for (var Jn in Gt)
  Gt[Jn].toJSON = (function(e) {
    return e;
  }).bind(null, Jn);
var vn = Gt, it = vn;
function ts(e) {
  return e.name || e.toString().match(/function (.*?)\s*\(/)[1];
}
function En(e) {
  return it.Nil(e) ? "" : ts(e.constructor);
}
function af(e) {
  return it.Function(e) ? "" : it.String(e) ? JSON.stringify(e) : e && it.Object(e) ? "" : e;
}
function Bn(e, t) {
  Error.captureStackTrace && Error.captureStackTrace(e, t);
}
function yr(e) {
  return it.Function(e) ? e.toJSON ? e.toJSON() : ts(e) : it.Array(e) ? "Array" : e && it.Object(e) ? "Object" : e !== void 0 ? e : "";
}
function rs(e, t, r) {
  var n = af(t);
  return "Expected " + yr(e) + ", got" + (r !== "" ? " " + r : "") + (n !== "" ? " " + n : "");
}
function He(e, t, r) {
  r = r || En(t), this.message = rs(e, t, r), Bn(this, He), this.__type = e, this.__value = t, this.__valueTypeName = r;
}
He.prototype = Object.create(Error.prototype);
He.prototype.constructor = He;
function ff(e, t, r, n, i) {
  var a = '" of type ';
  return t === "key" && (a = '" with key type '), rs('property "' + yr(r) + a + yr(e), n, i);
}
function wt(e, t, r, n, i) {
  e ? (i = i || En(n), this.message = ff(e, r, t, n, i)) : this.message = 'Unexpected property "' + t + '"', Bn(this, He), this.__label = r, this.__property = t, this.__type = e, this.__value = n, this.__valueTypeName = i;
}
wt.prototype = Object.create(Error.prototype);
wt.prototype.constructor = He;
function uf(e, t) {
  return new He(e, {}, t);
}
function cf(e, t, r) {
  return e instanceof wt ? (t = t + "." + e.__property, e = new wt(
    e.__type,
    t,
    e.__label,
    e.__value,
    e.__valueTypeName
  )) : e instanceof He && (e = new wt(
    e.__type,
    t,
    r,
    e.__value,
    e.__valueTypeName
  )), Bn(e), e;
}
var ns = {
  TfTypeError: He,
  TfPropertyTypeError: wt,
  tfCustomError: uf,
  tfSubError: cf,
  tfJSON: yr,
  getValueTypeName: En
}, Dr, Xn;
function lf() {
  if (Xn) return Dr;
  Xn = 1;
  var e = vn, t = ns;
  function r(S) {
    return Buffer.isBuffer(S);
  }
  function n(S) {
    return typeof S == "string" && /^([0-9a-f]{2})+$/i.test(S);
  }
  function i(S, z) {
    var M = S.toJSON();
    function $(se) {
      if (!S(se)) return !1;
      if (se.length === z) return !0;
      throw t.tfCustomError(M + "(Length: " + z + ")", M + "(Length: " + se.length + ")");
    }
    return $.toJSON = function() {
      return M;
    }, $;
  }
  var a = i.bind(null, e.Array), f = i.bind(null, r), u = i.bind(null, n), l = i.bind(null, e.String);
  function b(S, z, M) {
    M = M || e.Number;
    function $(se, Te) {
      return M(se, Te) && se > S && se < z;
    }
    return $.toJSON = function() {
      return `${M.toJSON()} between [${S}, ${z}]`;
    }, $;
  }
  var g = Math.pow(2, 53) - 1;
  function m(S) {
    return typeof S == "number" && isFinite(S);
  }
  function v(S) {
    return S << 24 >> 24 === S;
  }
  function I(S) {
    return S << 16 >> 16 === S;
  }
  function B(S) {
    return (S | 0) === S;
  }
  function P(S) {
    return typeof S == "number" && S >= -g && S <= g && Math.floor(S) === S;
  }
  function T(S) {
    return (S & 255) === S;
  }
  function C(S) {
    return (S & 65535) === S;
  }
  function F(S) {
    return S >>> 0 === S;
  }
  function k(S) {
    return typeof S == "number" && S >= 0 && S <= g && Math.floor(S) === S;
  }
  var L = {
    ArrayN: a,
    Buffer: r,
    BufferN: f,
    Finite: m,
    Hex: n,
    HexN: u,
    Int8: v,
    Int16: I,
    Int32: B,
    Int53: P,
    Range: b,
    StringN: l,
    UInt8: T,
    UInt16: C,
    UInt32: F,
    UInt53: k
  };
  for (var O in L)
    L[O].toJSON = (function(S) {
      return S;
    }).bind(null, O);
  return Dr = L, Dr;
}
var Jt = ns, he = vn, De = Jt.tfJSON, is = Jt.TfTypeError, ss = Jt.TfPropertyTypeError, Nt = Jt.tfSubError, hf = Jt.getValueTypeName, $e = {
  arrayOf: function(t, r) {
    t = Oe(t), r = r || {};
    function n(i, a) {
      return !he.Array(i) || he.Nil(i) || r.minLength !== void 0 && i.length < r.minLength || r.maxLength !== void 0 && i.length > r.maxLength || r.length !== void 0 && i.length !== r.length ? !1 : i.every(function(f, u) {
        try {
          return we(t, f, a);
        } catch (l) {
          throw Nt(l, u);
        }
      });
    }
    return n.toJSON = function() {
      var i = "[" + De(t) + "]";
      return r.length !== void 0 ? i += "{" + r.length + "}" : (r.minLength !== void 0 || r.maxLength !== void 0) && (i += "{" + (r.minLength === void 0 ? 0 : r.minLength) + "," + (r.maxLength === void 0 ? 1 / 0 : r.maxLength) + "}"), i;
    }, n;
  },
  maybe: function e(t) {
    t = Oe(t);
    function r(n, i) {
      return he.Nil(n) || t(n, i, e);
    }
    return r.toJSON = function() {
      return "?" + De(t);
    }, r;
  },
  map: function(t, r) {
    t = Oe(t), r && (r = Oe(r));
    function n(i, a) {
      if (!he.Object(i) || he.Nil(i)) return !1;
      for (var f in i) {
        try {
          r && we(r, f, a);
        } catch (l) {
          throw Nt(l, f, "key");
        }
        try {
          var u = i[f];
          we(t, u, a);
        } catch (l) {
          throw Nt(l, f);
        }
      }
      return !0;
    }
    return r ? n.toJSON = function() {
      return "{" + De(r) + ": " + De(t) + "}";
    } : n.toJSON = function() {
      return "{" + De(t) + "}";
    }, n;
  },
  object: function(t) {
    var r = {};
    for (var n in t)
      r[n] = Oe(t[n]);
    function i(a, f) {
      if (!he.Object(a) || he.Nil(a)) return !1;
      var u;
      try {
        for (u in r) {
          var l = r[u], b = a[u];
          we(l, b, f);
        }
      } catch (g) {
        throw Nt(g, u);
      }
      if (f) {
        for (u in a)
          if (!r[u])
            throw new ss(void 0, u);
      }
      return !0;
    }
    return i.toJSON = function() {
      return De(r);
    }, i;
  },
  anyOf: function() {
    var t = [].slice.call(arguments).map(Oe);
    function r(n, i) {
      return t.some(function(a) {
        try {
          return we(a, n, i);
        } catch {
          return !1;
        }
      });
    }
    return r.toJSON = function() {
      return t.map(De).join("|");
    }, r;
  },
  allOf: function() {
    var t = [].slice.call(arguments).map(Oe);
    function r(n, i) {
      return t.every(function(a) {
        try {
          return we(a, n, i);
        } catch {
          return !1;
        }
      });
    }
    return r.toJSON = function() {
      return t.map(De).join(" & ");
    }, r;
  },
  quacksLike: function(t) {
    function r(n) {
      return t === hf(n);
    }
    return r.toJSON = function() {
      return t;
    }, r;
  },
  tuple: function() {
    var t = [].slice.call(arguments).map(Oe);
    function r(n, i) {
      return he.Nil(n) || he.Nil(n.length) || i && n.length !== t.length ? !1 : t.every(function(a, f) {
        try {
          return we(a, n[f], i);
        } catch (u) {
          throw Nt(u, f);
        }
      });
    }
    return r.toJSON = function() {
      return "(" + t.map(De).join(", ") + ")";
    }, r;
  },
  value: function(t) {
    function r(n) {
      return n === t;
    }
    return r.toJSON = function() {
      return t;
    }, r;
  }
};
$e.oneOf = $e.anyOf;
function Oe(e) {
  if (he.String(e))
    return e[0] === "?" ? $e.maybe(e.slice(1)) : he[e] || $e.quacksLike(e);
  if (e && he.Object(e)) {
    if (he.Array(e)) {
      if (e.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return $e.arrayOf(e[0]);
    }
    return $e.object(e);
  } else if (he.Function(e))
    return e;
  return $e.value(e);
}
function we(e, t, r, n) {
  if (he.Function(e)) {
    if (e(t, r)) return !0;
    throw new is(n || e, t);
  }
  return we(Oe(e), t, r);
}
for (var Je in he)
  we[Je] = he[Je];
for (Je in $e)
  we[Je] = $e[Je];
var Qn = lf();
for (Je in Qn)
  we[Je] = Qn[Je];
we.compile = Oe;
we.TfTypeError = is;
we.TfPropertyTypeError = ss;
var df = we;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.maybe = e.Boolean = e.Array = e.Buffer256bit = e.Network = e.typeforce = void 0, e.typeforce = df, e.Network = e.typeforce.compile({
    messagePrefix: e.typeforce.oneOf(
      e.typeforce.Buffer,
      e.typeforce.String
    ),
    bip32: {
      public: e.typeforce.UInt32,
      private: e.typeforce.UInt32
    },
    pubKeyHash: e.typeforce.UInt8,
    scriptHash: e.typeforce.UInt8,
    wif: e.typeforce.UInt8
  }), e.Buffer256bit = e.typeforce.BufferN(32), e.Array = e.typeforce.Array, e.Boolean = e.typeforce.Boolean, e.maybe = e.typeforce.maybe;
})(es);
var nn = { exports: {} }, sn = { exports: {} }, Rt = {}, Er = {};
Er.byteLength = yf;
Er.toByteArray = mf;
Er.fromByteArray = xf;
var Ue = [], Ae = [], pf = typeof Uint8Array < "u" ? Uint8Array : Array, $r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var gt = 0, bf = $r.length; gt < bf; ++gt)
  Ue[gt] = $r[gt], Ae[$r.charCodeAt(gt)] = gt;
Ae[45] = 62;
Ae[95] = 63;
function os(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r = e.indexOf("=");
  r === -1 && (r = t);
  var n = r === t ? 0 : 4 - r % 4;
  return [r, n];
}
function yf(e) {
  var t = os(e), r = t[0], n = t[1];
  return (r + n) * 3 / 4 - n;
}
function gf(e, t, r) {
  return (t + r) * 3 / 4 - r;
}
function mf(e) {
  var t, r = os(e), n = r[0], i = r[1], a = new pf(gf(e, n, i)), f = 0, u = i > 0 ? n - 4 : n, l;
  for (l = 0; l < u; l += 4)
    t = Ae[e.charCodeAt(l)] << 18 | Ae[e.charCodeAt(l + 1)] << 12 | Ae[e.charCodeAt(l + 2)] << 6 | Ae[e.charCodeAt(l + 3)], a[f++] = t >> 16 & 255, a[f++] = t >> 8 & 255, a[f++] = t & 255;
  return i === 2 && (t = Ae[e.charCodeAt(l)] << 2 | Ae[e.charCodeAt(l + 1)] >> 4, a[f++] = t & 255), i === 1 && (t = Ae[e.charCodeAt(l)] << 10 | Ae[e.charCodeAt(l + 1)] << 4 | Ae[e.charCodeAt(l + 2)] >> 2, a[f++] = t >> 8 & 255, a[f++] = t & 255), a;
}
function _f(e) {
  return Ue[e >> 18 & 63] + Ue[e >> 12 & 63] + Ue[e >> 6 & 63] + Ue[e & 63];
}
function wf(e, t, r) {
  for (var n, i = [], a = t; a < r; a += 3)
    n = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), i.push(_f(n));
  return i.join("");
}
function xf(e) {
  for (var t, r = e.length, n = r % 3, i = [], a = 16383, f = 0, u = r - n; f < u; f += a)
    i.push(wf(e, f, f + a > u ? u : f + a));
  return n === 1 ? (t = e[r - 1], i.push(
    Ue[t >> 2] + Ue[t << 4 & 63] + "=="
  )) : n === 2 && (t = (e[r - 2] << 8) + e[r - 1], i.push(
    Ue[t >> 10] + Ue[t >> 4 & 63] + Ue[t << 2 & 63] + "="
  )), i.join("");
}
var Sn = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Sn.read = function(e, t, r, n, i) {
  var a, f, u = i * 8 - n - 1, l = (1 << u) - 1, b = l >> 1, g = -7, m = r ? i - 1 : 0, v = r ? -1 : 1, I = e[t + m];
  for (m += v, a = I & (1 << -g) - 1, I >>= -g, g += u; g > 0; a = a * 256 + e[t + m], m += v, g -= 8)
    ;
  for (f = a & (1 << -g) - 1, a >>= -g, g += n; g > 0; f = f * 256 + e[t + m], m += v, g -= 8)
    ;
  if (a === 0)
    a = 1 - b;
  else {
    if (a === l)
      return f ? NaN : (I ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, n), a = a - b;
  }
  return (I ? -1 : 1) * f * Math.pow(2, a - n);
};
Sn.write = function(e, t, r, n, i, a) {
  var f, u, l, b = a * 8 - i - 1, g = (1 << b) - 1, m = g >> 1, v = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, I = n ? 0 : a - 1, B = n ? 1 : -1, P = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, f = g) : (f = Math.floor(Math.log(t) / Math.LN2), t * (l = Math.pow(2, -f)) < 1 && (f--, l *= 2), f + m >= 1 ? t += v / l : t += v * Math.pow(2, 1 - m), t * l >= 2 && (f++, l /= 2), f + m >= g ? (u = 0, f = g) : f + m >= 1 ? (u = (t * l - 1) * Math.pow(2, i), f = f + m) : (u = t * Math.pow(2, m - 1) * Math.pow(2, i), f = 0)); i >= 8; e[r + I] = u & 255, I += B, u /= 256, i -= 8)
    ;
  for (f = f << i | u, b += i; b > 0; e[r + I] = f & 255, I += B, f /= 256, b -= 8)
    ;
  e[r + I - B] |= P * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Er, r = Sn, n = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = F, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i, u.TYPED_ARRAY_SUPPORT = a(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      const c = new Uint8Array(1), s = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(s, Uint8Array.prototype), Object.setPrototypeOf(c, s), c.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(c) {
    if (c > i)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
    const s = new Uint8Array(c);
    return Object.setPrototypeOf(s, u.prototype), s;
  }
  function u(c, s, o) {
    if (typeof c == "number") {
      if (typeof s == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(c);
    }
    return l(c, s, o);
  }
  u.poolSize = 8192;
  function l(c, s, o) {
    if (typeof c == "string")
      return v(c, s);
    if (ArrayBuffer.isView(c))
      return B(c);
    if (c == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
      );
    if (Se(c, ArrayBuffer) || c && Se(c.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Se(c, SharedArrayBuffer) || c && Se(c.buffer, SharedArrayBuffer)))
      return P(c, s, o);
    if (typeof c == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const h = c.valueOf && c.valueOf();
    if (h != null && h !== c)
      return u.from(h, s, o);
    const y = T(c);
    if (y) return y;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof c[Symbol.toPrimitive] == "function")
      return u.from(c[Symbol.toPrimitive]("string"), s, o);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c
    );
  }
  u.from = function(c, s, o) {
    return l(c, s, o);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function b(c) {
    if (typeof c != "number")
      throw new TypeError('"size" argument must be of type number');
    if (c < 0)
      throw new RangeError('The value "' + c + '" is invalid for option "size"');
  }
  function g(c, s, o) {
    return b(c), c <= 0 ? f(c) : s !== void 0 ? typeof o == "string" ? f(c).fill(s, o) : f(c).fill(s) : f(c);
  }
  u.alloc = function(c, s, o) {
    return g(c, s, o);
  };
  function m(c) {
    return b(c), f(c < 0 ? 0 : C(c) | 0);
  }
  u.allocUnsafe = function(c) {
    return m(c);
  }, u.allocUnsafeSlow = function(c) {
    return m(c);
  };
  function v(c, s) {
    if ((typeof s != "string" || s === "") && (s = "utf8"), !u.isEncoding(s))
      throw new TypeError("Unknown encoding: " + s);
    const o = k(c, s) | 0;
    let h = f(o);
    const y = h.write(c, s);
    return y !== o && (h = h.slice(0, y)), h;
  }
  function I(c) {
    const s = c.length < 0 ? 0 : C(c.length) | 0, o = f(s);
    for (let h = 0; h < s; h += 1)
      o[h] = c[h] & 255;
    return o;
  }
  function B(c) {
    if (Se(c, Uint8Array)) {
      const s = new Uint8Array(c);
      return P(s.buffer, s.byteOffset, s.byteLength);
    }
    return I(c);
  }
  function P(c, s, o) {
    if (s < 0 || c.byteLength < s)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (c.byteLength < s + (o || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let h;
    return s === void 0 && o === void 0 ? h = new Uint8Array(c) : o === void 0 ? h = new Uint8Array(c, s) : h = new Uint8Array(c, s, o), Object.setPrototypeOf(h, u.prototype), h;
  }
  function T(c) {
    if (u.isBuffer(c)) {
      const s = C(c.length) | 0, o = f(s);
      return o.length === 0 || c.copy(o, 0, 0, s), o;
    }
    if (c.length !== void 0)
      return typeof c.length != "number" || tt(c.length) ? f(0) : I(c);
    if (c.type === "Buffer" && Array.isArray(c.data))
      return I(c.data);
  }
  function C(c) {
    if (c >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return c | 0;
  }
  function F(c) {
    return +c != c && (c = 0), u.alloc(+c);
  }
  u.isBuffer = function(s) {
    return s != null && s._isBuffer === !0 && s !== u.prototype;
  }, u.compare = function(s, o) {
    if (Se(s, Uint8Array) && (s = u.from(s, s.offset, s.byteLength)), Se(o, Uint8Array) && (o = u.from(o, o.offset, o.byteLength)), !u.isBuffer(s) || !u.isBuffer(o))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (s === o) return 0;
    let h = s.length, y = o.length;
    for (let x = 0, E = Math.min(h, y); x < E; ++x)
      if (s[x] !== o[x]) {
        h = s[x], y = o[x];
        break;
      }
    return h < y ? -1 : y < h ? 1 : 0;
  }, u.isEncoding = function(s) {
    switch (String(s).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(s, o) {
    if (!Array.isArray(s))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (s.length === 0)
      return u.alloc(0);
    let h;
    if (o === void 0)
      for (o = 0, h = 0; h < s.length; ++h)
        o += s[h].length;
    const y = u.allocUnsafe(o);
    let x = 0;
    for (h = 0; h < s.length; ++h) {
      let E = s[h];
      if (Se(E, Uint8Array))
        x + E.length > y.length ? (u.isBuffer(E) || (E = u.from(E)), E.copy(y, x)) : Uint8Array.prototype.set.call(
          y,
          E,
          x
        );
      else if (u.isBuffer(E))
        E.copy(y, x);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      x += E.length;
    }
    return y;
  };
  function k(c, s) {
    if (u.isBuffer(c))
      return c.length;
    if (ArrayBuffer.isView(c) || Se(c, ArrayBuffer))
      return c.byteLength;
    if (typeof c != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof c
      );
    const o = c.length, h = arguments.length > 2 && arguments[2] === !0;
    if (!h && o === 0) return 0;
    let y = !1;
    for (; ; )
      switch (s) {
        case "ascii":
        case "latin1":
        case "binary":
          return o;
        case "utf8":
        case "utf-8":
          return V(c).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return o * 2;
        case "hex":
          return o >>> 1;
        case "base64":
          return Pt(c).length;
        default:
          if (y)
            return h ? -1 : V(c).length;
          s = ("" + s).toLowerCase(), y = !0;
      }
  }
  u.byteLength = k;
  function L(c, s, o) {
    let h = !1;
    if ((s === void 0 || s < 0) && (s = 0), s > this.length || ((o === void 0 || o > this.length) && (o = this.length), o <= 0) || (o >>>= 0, s >>>= 0, o <= s))
      return "";
    for (c || (c = "utf8"); ; )
      switch (c) {
        case "hex":
          return Ce(this, s, o);
        case "utf8":
        case "utf-8":
          return xe(this, s, o);
        case "ascii":
          return Pe(this, s, o);
        case "latin1":
        case "binary":
          return Ge(this, s, o);
        case "base64":
          return ae(this, s, o);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return We(this, s, o);
        default:
          if (h) throw new TypeError("Unknown encoding: " + c);
          c = (c + "").toLowerCase(), h = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function O(c, s, o) {
    const h = c[s];
    c[s] = c[o], c[o] = h;
  }
  u.prototype.swap16 = function() {
    const s = this.length;
    if (s % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let o = 0; o < s; o += 2)
      O(this, o, o + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const s = this.length;
    if (s % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let o = 0; o < s; o += 4)
      O(this, o, o + 3), O(this, o + 1, o + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const s = this.length;
    if (s % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let o = 0; o < s; o += 8)
      O(this, o, o + 7), O(this, o + 1, o + 6), O(this, o + 2, o + 5), O(this, o + 3, o + 4);
    return this;
  }, u.prototype.toString = function() {
    const s = this.length;
    return s === 0 ? "" : arguments.length === 0 ? xe(this, 0, s) : L.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(s) {
    if (!u.isBuffer(s)) throw new TypeError("Argument must be a Buffer");
    return this === s ? !0 : u.compare(this, s) === 0;
  }, u.prototype.inspect = function() {
    let s = "";
    const o = e.INSPECT_MAX_BYTES;
    return s = this.toString("hex", 0, o).replace(/(.{2})/g, "$1 ").trim(), this.length > o && (s += " ... "), "<Buffer " + s + ">";
  }, n && (u.prototype[n] = u.prototype.inspect), u.prototype.compare = function(s, o, h, y, x) {
    if (Se(s, Uint8Array) && (s = u.from(s, s.offset, s.byteLength)), !u.isBuffer(s))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof s
      );
    if (o === void 0 && (o = 0), h === void 0 && (h = s ? s.length : 0), y === void 0 && (y = 0), x === void 0 && (x = this.length), o < 0 || h > s.length || y < 0 || x > this.length)
      throw new RangeError("out of range index");
    if (y >= x && o >= h)
      return 0;
    if (y >= x)
      return -1;
    if (o >= h)
      return 1;
    if (o >>>= 0, h >>>= 0, y >>>= 0, x >>>= 0, this === s) return 0;
    let E = x - y, q = h - o;
    const ne = Math.min(E, q), ee = this.slice(y, x), ie = s.slice(o, h);
    for (let Y = 0; Y < ne; ++Y)
      if (ee[Y] !== ie[Y]) {
        E = ee[Y], q = ie[Y];
        break;
      }
    return E < q ? -1 : q < E ? 1 : 0;
  };
  function S(c, s, o, h, y) {
    if (c.length === 0) return -1;
    if (typeof o == "string" ? (h = o, o = 0) : o > 2147483647 ? o = 2147483647 : o < -2147483648 && (o = -2147483648), o = +o, tt(o) && (o = y ? 0 : c.length - 1), o < 0 && (o = c.length + o), o >= c.length) {
      if (y) return -1;
      o = c.length - 1;
    } else if (o < 0)
      if (y) o = 0;
      else return -1;
    if (typeof s == "string" && (s = u.from(s, h)), u.isBuffer(s))
      return s.length === 0 ? -1 : z(c, s, o, h, y);
    if (typeof s == "number")
      return s = s & 255, typeof Uint8Array.prototype.indexOf == "function" ? y ? Uint8Array.prototype.indexOf.call(c, s, o) : Uint8Array.prototype.lastIndexOf.call(c, s, o) : z(c, [s], o, h, y);
    throw new TypeError("val must be string, number or Buffer");
  }
  function z(c, s, o, h, y) {
    let x = 1, E = c.length, q = s.length;
    if (h !== void 0 && (h = String(h).toLowerCase(), h === "ucs2" || h === "ucs-2" || h === "utf16le" || h === "utf-16le")) {
      if (c.length < 2 || s.length < 2)
        return -1;
      x = 2, E /= 2, q /= 2, o /= 2;
    }
    function ne(ie, Y) {
      return x === 1 ? ie[Y] : ie.readUInt16BE(Y * x);
    }
    let ee;
    if (y) {
      let ie = -1;
      for (ee = o; ee < E; ee++)
        if (ne(c, ee) === ne(s, ie === -1 ? 0 : ee - ie)) {
          if (ie === -1 && (ie = ee), ee - ie + 1 === q) return ie * x;
        } else
          ie !== -1 && (ee -= ee - ie), ie = -1;
    } else
      for (o + q > E && (o = E - q), ee = o; ee >= 0; ee--) {
        let ie = !0;
        for (let Y = 0; Y < q; Y++)
          if (ne(c, ee + Y) !== ne(s, Y)) {
            ie = !1;
            break;
          }
        if (ie) return ee;
      }
    return -1;
  }
  u.prototype.includes = function(s, o, h) {
    return this.indexOf(s, o, h) !== -1;
  }, u.prototype.indexOf = function(s, o, h) {
    return S(this, s, o, h, !0);
  }, u.prototype.lastIndexOf = function(s, o, h) {
    return S(this, s, o, h, !1);
  };
  function M(c, s, o, h) {
    o = Number(o) || 0;
    const y = c.length - o;
    h ? (h = Number(h), h > y && (h = y)) : h = y;
    const x = s.length;
    h > x / 2 && (h = x / 2);
    let E;
    for (E = 0; E < h; ++E) {
      const q = parseInt(s.substr(E * 2, 2), 16);
      if (tt(q)) return E;
      c[o + E] = q;
    }
    return E;
  }
  function $(c, s, o, h) {
    return pt(V(s, c.length - o), c, o, h);
  }
  function se(c, s, o, h) {
    return pt(Ve(s), c, o, h);
  }
  function Te(c, s, o, h) {
    return pt(Pt(s), c, o, h);
  }
  function je(c, s, o, h) {
    return pt(dt(s, c.length - o), c, o, h);
  }
  u.prototype.write = function(s, o, h, y) {
    if (o === void 0)
      y = "utf8", h = this.length, o = 0;
    else if (h === void 0 && typeof o == "string")
      y = o, h = this.length, o = 0;
    else if (isFinite(o))
      o = o >>> 0, isFinite(h) ? (h = h >>> 0, y === void 0 && (y = "utf8")) : (y = h, h = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const x = this.length - o;
    if ((h === void 0 || h > x) && (h = x), s.length > 0 && (h < 0 || o < 0) || o > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    y || (y = "utf8");
    let E = !1;
    for (; ; )
      switch (y) {
        case "hex":
          return M(this, s, o, h);
        case "utf8":
        case "utf-8":
          return $(this, s, o, h);
        case "ascii":
        case "latin1":
        case "binary":
          return se(this, s, o, h);
        case "base64":
          return Te(this, s, o, h);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, s, o, h);
        default:
          if (E) throw new TypeError("Unknown encoding: " + y);
          y = ("" + y).toLowerCase(), E = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ae(c, s, o) {
    return s === 0 && o === c.length ? t.fromByteArray(c) : t.fromByteArray(c.slice(s, o));
  }
  function xe(c, s, o) {
    o = Math.min(c.length, o);
    const h = [];
    let y = s;
    for (; y < o; ) {
      const x = c[y];
      let E = null, q = x > 239 ? 4 : x > 223 ? 3 : x > 191 ? 2 : 1;
      if (y + q <= o) {
        let ne, ee, ie, Y;
        switch (q) {
          case 1:
            x < 128 && (E = x);
            break;
          case 2:
            ne = c[y + 1], (ne & 192) === 128 && (Y = (x & 31) << 6 | ne & 63, Y > 127 && (E = Y));
            break;
          case 3:
            ne = c[y + 1], ee = c[y + 2], (ne & 192) === 128 && (ee & 192) === 128 && (Y = (x & 15) << 12 | (ne & 63) << 6 | ee & 63, Y > 2047 && (Y < 55296 || Y > 57343) && (E = Y));
            break;
          case 4:
            ne = c[y + 1], ee = c[y + 2], ie = c[y + 3], (ne & 192) === 128 && (ee & 192) === 128 && (ie & 192) === 128 && (Y = (x & 15) << 18 | (ne & 63) << 12 | (ee & 63) << 6 | ie & 63, Y > 65535 && Y < 1114112 && (E = Y));
        }
      }
      E === null ? (E = 65533, q = 1) : E > 65535 && (E -= 65536, h.push(E >>> 10 & 1023 | 55296), E = 56320 | E & 1023), h.push(E), y += q;
    }
    return et(h);
  }
  const ve = 4096;
  function et(c) {
    const s = c.length;
    if (s <= ve)
      return String.fromCharCode.apply(String, c);
    let o = "", h = 0;
    for (; h < s; )
      o += String.fromCharCode.apply(
        String,
        c.slice(h, h += ve)
      );
    return o;
  }
  function Pe(c, s, o) {
    let h = "";
    o = Math.min(c.length, o);
    for (let y = s; y < o; ++y)
      h += String.fromCharCode(c[y] & 127);
    return h;
  }
  function Ge(c, s, o) {
    let h = "";
    o = Math.min(c.length, o);
    for (let y = s; y < o; ++y)
      h += String.fromCharCode(c[y]);
    return h;
  }
  function Ce(c, s, o) {
    const h = c.length;
    (!s || s < 0) && (s = 0), (!o || o < 0 || o > h) && (o = h);
    let y = "";
    for (let x = s; x < o; ++x)
      y += Ct[c[x]];
    return y;
  }
  function We(c, s, o) {
    const h = c.slice(s, o);
    let y = "";
    for (let x = 0; x < h.length - 1; x += 2)
      y += String.fromCharCode(h[x] + h[x + 1] * 256);
    return y;
  }
  u.prototype.slice = function(s, o) {
    const h = this.length;
    s = ~~s, o = o === void 0 ? h : ~~o, s < 0 ? (s += h, s < 0 && (s = 0)) : s > h && (s = h), o < 0 ? (o += h, o < 0 && (o = 0)) : o > h && (o = h), o < s && (o = s);
    const y = this.subarray(s, o);
    return Object.setPrototypeOf(y, u.prototype), y;
  };
  function Q(c, s, o) {
    if (c % 1 !== 0 || c < 0) throw new RangeError("offset is not uint");
    if (c + s > o) throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(s, o, h) {
    s = s >>> 0, o = o >>> 0, h || Q(s, o, this.length);
    let y = this[s], x = 1, E = 0;
    for (; ++E < o && (x *= 256); )
      y += this[s + E] * x;
    return y;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(s, o, h) {
    s = s >>> 0, o = o >>> 0, h || Q(s, o, this.length);
    let y = this[s + --o], x = 1;
    for (; o > 0 && (x *= 256); )
      y += this[s + --o] * x;
    return y;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(s, o) {
    return s = s >>> 0, o || Q(s, 1, this.length), this[s];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(s, o) {
    return s = s >>> 0, o || Q(s, 2, this.length), this[s] | this[s + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(s, o) {
    return s = s >>> 0, o || Q(s, 2, this.length), this[s] << 8 | this[s + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), (this[s] | this[s + 1] << 8 | this[s + 2] << 16) + this[s + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), this[s] * 16777216 + (this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3]);
  }, u.prototype.readBigUInt64LE = Ie(function(s) {
    s = s >>> 0, A(s, "offset");
    const o = this[s], h = this[s + 7];
    (o === void 0 || h === void 0) && U(s, this.length - 8);
    const y = o + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24, x = this[++s] + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + h * 2 ** 24;
    return BigInt(y) + (BigInt(x) << BigInt(32));
  }), u.prototype.readBigUInt64BE = Ie(function(s) {
    s = s >>> 0, A(s, "offset");
    const o = this[s], h = this[s + 7];
    (o === void 0 || h === void 0) && U(s, this.length - 8);
    const y = o * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s], x = this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + h;
    return (BigInt(y) << BigInt(32)) + BigInt(x);
  }), u.prototype.readIntLE = function(s, o, h) {
    s = s >>> 0, o = o >>> 0, h || Q(s, o, this.length);
    let y = this[s], x = 1, E = 0;
    for (; ++E < o && (x *= 256); )
      y += this[s + E] * x;
    return x *= 128, y >= x && (y -= Math.pow(2, 8 * o)), y;
  }, u.prototype.readIntBE = function(s, o, h) {
    s = s >>> 0, o = o >>> 0, h || Q(s, o, this.length);
    let y = o, x = 1, E = this[s + --y];
    for (; y > 0 && (x *= 256); )
      E += this[s + --y] * x;
    return x *= 128, E >= x && (E -= Math.pow(2, 8 * o)), E;
  }, u.prototype.readInt8 = function(s, o) {
    return s = s >>> 0, o || Q(s, 1, this.length), this[s] & 128 ? (255 - this[s] + 1) * -1 : this[s];
  }, u.prototype.readInt16LE = function(s, o) {
    s = s >>> 0, o || Q(s, 2, this.length);
    const h = this[s] | this[s + 1] << 8;
    return h & 32768 ? h | 4294901760 : h;
  }, u.prototype.readInt16BE = function(s, o) {
    s = s >>> 0, o || Q(s, 2, this.length);
    const h = this[s + 1] | this[s] << 8;
    return h & 32768 ? h | 4294901760 : h;
  }, u.prototype.readInt32LE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), this[s] | this[s + 1] << 8 | this[s + 2] << 16 | this[s + 3] << 24;
  }, u.prototype.readInt32BE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), this[s] << 24 | this[s + 1] << 16 | this[s + 2] << 8 | this[s + 3];
  }, u.prototype.readBigInt64LE = Ie(function(s) {
    s = s >>> 0, A(s, "offset");
    const o = this[s], h = this[s + 7];
    (o === void 0 || h === void 0) && U(s, this.length - 8);
    const y = this[s + 4] + this[s + 5] * 2 ** 8 + this[s + 6] * 2 ** 16 + (h << 24);
    return (BigInt(y) << BigInt(32)) + BigInt(o + this[++s] * 2 ** 8 + this[++s] * 2 ** 16 + this[++s] * 2 ** 24);
  }), u.prototype.readBigInt64BE = Ie(function(s) {
    s = s >>> 0, A(s, "offset");
    const o = this[s], h = this[s + 7];
    (o === void 0 || h === void 0) && U(s, this.length - 8);
    const y = (o << 24) + // Overflow
    this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + this[++s];
    return (BigInt(y) << BigInt(32)) + BigInt(this[++s] * 2 ** 24 + this[++s] * 2 ** 16 + this[++s] * 2 ** 8 + h);
  }), u.prototype.readFloatLE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), r.read(this, s, !0, 23, 4);
  }, u.prototype.readFloatBE = function(s, o) {
    return s = s >>> 0, o || Q(s, 4, this.length), r.read(this, s, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(s, o) {
    return s = s >>> 0, o || Q(s, 8, this.length), r.read(this, s, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(s, o) {
    return s = s >>> 0, o || Q(s, 8, this.length), r.read(this, s, !1, 52, 8);
  };
  function oe(c, s, o, h, y, x) {
    if (!u.isBuffer(c)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (s > y || s < x) throw new RangeError('"value" argument is out of bounds');
    if (o + h > c.length) throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(s, o, h, y) {
    if (s = +s, o = o >>> 0, h = h >>> 0, !y) {
      const q = Math.pow(2, 8 * h) - 1;
      oe(this, s, o, h, q, 0);
    }
    let x = 1, E = 0;
    for (this[o] = s & 255; ++E < h && (x *= 256); )
      this[o + E] = s / x & 255;
    return o + h;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(s, o, h, y) {
    if (s = +s, o = o >>> 0, h = h >>> 0, !y) {
      const q = Math.pow(2, 8 * h) - 1;
      oe(this, s, o, h, q, 0);
    }
    let x = h - 1, E = 1;
    for (this[o + x] = s & 255; --x >= 0 && (E *= 256); )
      this[o + x] = s / E & 255;
    return o + h;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 1, 255, 0), this[o] = s & 255, o + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 2, 65535, 0), this[o] = s & 255, this[o + 1] = s >>> 8, o + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 2, 65535, 0), this[o] = s >>> 8, this[o + 1] = s & 255, o + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 4, 4294967295, 0), this[o + 3] = s >>> 24, this[o + 2] = s >>> 16, this[o + 1] = s >>> 8, this[o] = s & 255, o + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 4, 4294967295, 0), this[o] = s >>> 24, this[o + 1] = s >>> 16, this[o + 2] = s >>> 8, this[o + 3] = s & 255, o + 4;
  };
  function Be(c, s, o, h, y) {
    p(s, h, y, c, o, 7);
    let x = Number(s & BigInt(4294967295));
    c[o++] = x, x = x >> 8, c[o++] = x, x = x >> 8, c[o++] = x, x = x >> 8, c[o++] = x;
    let E = Number(s >> BigInt(32) & BigInt(4294967295));
    return c[o++] = E, E = E >> 8, c[o++] = E, E = E >> 8, c[o++] = E, E = E >> 8, c[o++] = E, o;
  }
  function qe(c, s, o, h, y) {
    p(s, h, y, c, o, 7);
    let x = Number(s & BigInt(4294967295));
    c[o + 7] = x, x = x >> 8, c[o + 6] = x, x = x >> 8, c[o + 5] = x, x = x >> 8, c[o + 4] = x;
    let E = Number(s >> BigInt(32) & BigInt(4294967295));
    return c[o + 3] = E, E = E >> 8, c[o + 2] = E, E = E >> 8, c[o + 1] = E, E = E >> 8, c[o] = E, o + 8;
  }
  u.prototype.writeBigUInt64LE = Ie(function(s, o = 0) {
    return Be(this, s, o, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = Ie(function(s, o = 0) {
    return qe(this, s, o, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(s, o, h, y) {
    if (s = +s, o = o >>> 0, !y) {
      const ne = Math.pow(2, 8 * h - 1);
      oe(this, s, o, h, ne - 1, -ne);
    }
    let x = 0, E = 1, q = 0;
    for (this[o] = s & 255; ++x < h && (E *= 256); )
      s < 0 && q === 0 && this[o + x - 1] !== 0 && (q = 1), this[o + x] = (s / E >> 0) - q & 255;
    return o + h;
  }, u.prototype.writeIntBE = function(s, o, h, y) {
    if (s = +s, o = o >>> 0, !y) {
      const ne = Math.pow(2, 8 * h - 1);
      oe(this, s, o, h, ne - 1, -ne);
    }
    let x = h - 1, E = 1, q = 0;
    for (this[o + x] = s & 255; --x >= 0 && (E *= 256); )
      s < 0 && q === 0 && this[o + x + 1] !== 0 && (q = 1), this[o + x] = (s / E >> 0) - q & 255;
    return o + h;
  }, u.prototype.writeInt8 = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 1, 127, -128), s < 0 && (s = 255 + s + 1), this[o] = s & 255, o + 1;
  }, u.prototype.writeInt16LE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 2, 32767, -32768), this[o] = s & 255, this[o + 1] = s >>> 8, o + 2;
  }, u.prototype.writeInt16BE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 2, 32767, -32768), this[o] = s >>> 8, this[o + 1] = s & 255, o + 2;
  }, u.prototype.writeInt32LE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 4, 2147483647, -2147483648), this[o] = s & 255, this[o + 1] = s >>> 8, this[o + 2] = s >>> 16, this[o + 3] = s >>> 24, o + 4;
  }, u.prototype.writeInt32BE = function(s, o, h) {
    return s = +s, o = o >>> 0, h || oe(this, s, o, 4, 2147483647, -2147483648), s < 0 && (s = 4294967295 + s + 1), this[o] = s >>> 24, this[o + 1] = s >>> 16, this[o + 2] = s >>> 8, this[o + 3] = s & 255, o + 4;
  }, u.prototype.writeBigInt64LE = Ie(function(s, o = 0) {
    return Be(this, s, o, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = Ie(function(s, o = 0) {
    return qe(this, s, o, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ne(c, s, o, h, y, x) {
    if (o + h > c.length) throw new RangeError("Index out of range");
    if (o < 0) throw new RangeError("Index out of range");
  }
  function w(c, s, o, h, y) {
    return s = +s, o = o >>> 0, y || Ne(c, s, o, 4), r.write(c, s, o, h, 23, 4), o + 4;
  }
  u.prototype.writeFloatLE = function(s, o, h) {
    return w(this, s, o, !0, h);
  }, u.prototype.writeFloatBE = function(s, o, h) {
    return w(this, s, o, !1, h);
  };
  function _(c, s, o, h, y) {
    return s = +s, o = o >>> 0, y || Ne(c, s, o, 8), r.write(c, s, o, h, 52, 8), o + 8;
  }
  u.prototype.writeDoubleLE = function(s, o, h) {
    return _(this, s, o, !0, h);
  }, u.prototype.writeDoubleBE = function(s, o, h) {
    return _(this, s, o, !1, h);
  }, u.prototype.copy = function(s, o, h, y) {
    if (!u.isBuffer(s)) throw new TypeError("argument should be a Buffer");
    if (h || (h = 0), !y && y !== 0 && (y = this.length), o >= s.length && (o = s.length), o || (o = 0), y > 0 && y < h && (y = h), y === h || s.length === 0 || this.length === 0) return 0;
    if (o < 0)
      throw new RangeError("targetStart out of bounds");
    if (h < 0 || h >= this.length) throw new RangeError("Index out of range");
    if (y < 0) throw new RangeError("sourceEnd out of bounds");
    y > this.length && (y = this.length), s.length - o < y - h && (y = s.length - o + h);
    const x = y - h;
    return this === s && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(o, h, y) : Uint8Array.prototype.set.call(
      s,
      this.subarray(h, y),
      o
    ), x;
  }, u.prototype.fill = function(s, o, h, y) {
    if (typeof s == "string") {
      if (typeof o == "string" ? (y = o, o = 0, h = this.length) : typeof h == "string" && (y = h, h = this.length), y !== void 0 && typeof y != "string")
        throw new TypeError("encoding must be a string");
      if (typeof y == "string" && !u.isEncoding(y))
        throw new TypeError("Unknown encoding: " + y);
      if (s.length === 1) {
        const E = s.charCodeAt(0);
        (y === "utf8" && E < 128 || y === "latin1") && (s = E);
      }
    } else typeof s == "number" ? s = s & 255 : typeof s == "boolean" && (s = Number(s));
    if (o < 0 || this.length < o || this.length < h)
      throw new RangeError("Out of range index");
    if (h <= o)
      return this;
    o = o >>> 0, h = h === void 0 ? this.length : h >>> 0, s || (s = 0);
    let x;
    if (typeof s == "number")
      for (x = o; x < h; ++x)
        this[x] = s;
    else {
      const E = u.isBuffer(s) ? s : u.from(s, y), q = E.length;
      if (q === 0)
        throw new TypeError('The value "' + s + '" is invalid for argument "value"');
      for (x = 0; x < h - o; ++x)
        this[x + o] = E[x % q];
    }
    return this;
  };
  const R = {};
  function D(c, s, o) {
    R[c] = class extends o {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: s.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${c}]`, this.stack, delete this.name;
      }
      get code() {
        return c;
      }
      set code(y) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: y,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${c}]: ${this.message}`;
      }
    };
  }
  D(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(c) {
      return c ? `${c} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), D(
    "ERR_INVALID_ARG_TYPE",
    function(c, s) {
      return `The "${c}" argument must be of type number. Received type ${typeof s}`;
    },
    TypeError
  ), D(
    "ERR_OUT_OF_RANGE",
    function(c, s, o) {
      let h = `The value of "${c}" is out of range.`, y = o;
      return Number.isInteger(o) && Math.abs(o) > 2 ** 32 ? y = j(String(o)) : typeof o == "bigint" && (y = String(o), (o > BigInt(2) ** BigInt(32) || o < -(BigInt(2) ** BigInt(32))) && (y = j(y)), y += "n"), h += ` It must be ${s}. Received ${y}`, h;
    },
    RangeError
  );
  function j(c) {
    let s = "", o = c.length;
    const h = c[0] === "-" ? 1 : 0;
    for (; o >= h + 4; o -= 3)
      s = `_${c.slice(o - 3, o)}${s}`;
    return `${c.slice(0, o)}${s}`;
  }
  function d(c, s, o) {
    A(s, "offset"), (c[s] === void 0 || c[s + o] === void 0) && U(s, c.length - (o + 1));
  }
  function p(c, s, o, h, y, x) {
    if (c > o || c < s) {
      const E = typeof s == "bigint" ? "n" : "";
      let q;
      throw s === 0 || s === BigInt(0) ? q = `>= 0${E} and < 2${E} ** ${(x + 1) * 8}${E}` : q = `>= -(2${E} ** ${(x + 1) * 8 - 1}${E}) and < 2 ** ${(x + 1) * 8 - 1}${E}`, new R.ERR_OUT_OF_RANGE("value", q, c);
    }
    d(h, y, x);
  }
  function A(c, s) {
    if (typeof c != "number")
      throw new R.ERR_INVALID_ARG_TYPE(s, "number", c);
  }
  function U(c, s, o) {
    throw Math.floor(c) !== c ? (A(c, o), new R.ERR_OUT_OF_RANGE("offset", "an integer", c)) : s < 0 ? new R.ERR_BUFFER_OUT_OF_BOUNDS() : new R.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${s}`,
      c
    );
  }
  const Z = /[^+/0-9A-Za-z-_]/g;
  function G(c) {
    if (c = c.split("=")[0], c = c.trim().replace(Z, ""), c.length < 2) return "";
    for (; c.length % 4 !== 0; )
      c = c + "=";
    return c;
  }
  function V(c, s) {
    s = s || 1 / 0;
    let o;
    const h = c.length;
    let y = null;
    const x = [];
    for (let E = 0; E < h; ++E) {
      if (o = c.charCodeAt(E), o > 55295 && o < 57344) {
        if (!y) {
          if (o > 56319) {
            (s -= 3) > -1 && x.push(239, 191, 189);
            continue;
          } else if (E + 1 === h) {
            (s -= 3) > -1 && x.push(239, 191, 189);
            continue;
          }
          y = o;
          continue;
        }
        if (o < 56320) {
          (s -= 3) > -1 && x.push(239, 191, 189), y = o;
          continue;
        }
        o = (y - 55296 << 10 | o - 56320) + 65536;
      } else y && (s -= 3) > -1 && x.push(239, 191, 189);
      if (y = null, o < 128) {
        if ((s -= 1) < 0) break;
        x.push(o);
      } else if (o < 2048) {
        if ((s -= 2) < 0) break;
        x.push(
          o >> 6 | 192,
          o & 63 | 128
        );
      } else if (o < 65536) {
        if ((s -= 3) < 0) break;
        x.push(
          o >> 12 | 224,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else if (o < 1114112) {
        if ((s -= 4) < 0) break;
        x.push(
          o >> 18 | 240,
          o >> 12 & 63 | 128,
          o >> 6 & 63 | 128,
          o & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return x;
  }
  function Ve(c) {
    const s = [];
    for (let o = 0; o < c.length; ++o)
      s.push(c.charCodeAt(o) & 255);
    return s;
  }
  function dt(c, s) {
    let o, h, y;
    const x = [];
    for (let E = 0; E < c.length && !((s -= 2) < 0); ++E)
      o = c.charCodeAt(E), h = o >> 8, y = o % 256, x.push(y), x.push(h);
    return x;
  }
  function Pt(c) {
    return t.toByteArray(G(c));
  }
  function pt(c, s, o, h) {
    let y;
    for (y = 0; y < h && !(y + o >= s.length || y >= c.length); ++y)
      s[y + o] = c[y];
    return y;
  }
  function Se(c, s) {
    return c instanceof s || c != null && c.constructor != null && c.constructor.name != null && c.constructor.name === s.name;
  }
  function tt(c) {
    return c !== c;
  }
  const Ct = function() {
    const c = "0123456789abcdef", s = new Array(256);
    for (let o = 0; o < 16; ++o) {
      const h = o * 16;
      for (let y = 0; y < 16; ++y)
        s[h + y] = c[o] + c[y];
    }
    return s;
  }();
  function Ie(c) {
    return typeof BigInt > "u" ? rt : c;
  }
  function rt() {
    throw new Error("BigInt not supported");
  }
})(Rt);
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var r = Rt, n = r.Buffer;
  function i(f, u) {
    for (var l in f)
      u[l] = f[l];
  }
  n.from && n.alloc && n.allocUnsafe && n.allocUnsafeSlow ? e.exports = r : (i(r, t), t.Buffer = a);
  function a(f, u, l) {
    return n(f, u, l);
  }
  a.prototype = Object.create(n.prototype), i(n, a), a.from = function(f, u, l) {
    if (typeof f == "number")
      throw new TypeError("Argument must not be a number");
    return n(f, u, l);
  }, a.alloc = function(f, u, l) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    var b = n(f);
    return u !== void 0 ? typeof l == "string" ? b.fill(u, l) : b.fill(u) : b.fill(0), b;
  }, a.allocUnsafe = function(f) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    return n(f);
  }, a.allocUnsafeSlow = function(f) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    return r.SlowBuffer(f);
  };
})(sn, sn.exports);
var Ee = sn.exports, Hr = 65536, vf = 4294967295;
function Ef() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Bf = Ee.Buffer, gr = Xe.crypto || Xe.msCrypto;
gr && gr.getRandomValues ? nn.exports = Sf : nn.exports = Ef;
function Sf(e, t) {
  if (e > vf) throw new RangeError("requested too many random bytes");
  var r = Bf.allocUnsafe(e);
  if (e > 0)
    if (e > Hr)
      for (var n = 0; n < e; n += Hr)
        gr.getRandomValues(r.slice(n, n + Hr));
    else
      gr.getRandomValues(r);
  return typeof t == "function" ? process.nextTick(function() {
    t(null, r);
  }) : r;
}
var If = nn.exports, on = { exports: {} };
typeof Object.create == "function" ? on.exports = function(t, r) {
  r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
    constructor: {
      value: t,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : on.exports = function(t, r) {
  if (r) {
    t.super_ = r;
    var n = function() {
    };
    n.prototype = r.prototype, t.prototype = new n(), t.prototype.constructor = t;
  }
};
var ge = on.exports, an = { exports: {} }, In = { exports: {} }, xt = typeof Reflect == "object" ? Reflect : null, Zn = xt && typeof xt.apply == "function" ? xt.apply : function(t, r, n) {
  return Function.prototype.apply.call(t, r, n);
}, ur;
xt && typeof xt.ownKeys == "function" ? ur = xt.ownKeys : Object.getOwnPropertySymbols ? ur = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ur = function(t) {
  return Object.getOwnPropertyNames(t);
};
function Af(e) {
  console && console.warn && console.warn(e);
}
var as = Number.isNaN || function(t) {
  return t !== t;
};
function K() {
  K.init.call(this);
}
In.exports = K;
In.exports.once = Cf;
K.EventEmitter = K;
K.prototype._events = void 0;
K.prototype._eventsCount = 0;
K.prototype._maxListeners = void 0;
var ei = 10;
function Br(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(K, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return ei;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || as(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    ei = e;
  }
});
K.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
K.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || as(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function fs(e) {
  return e._maxListeners === void 0 ? K.defaultMaxListeners : e._maxListeners;
}
K.prototype.getMaxListeners = function() {
  return fs(this);
};
K.prototype.emit = function(t) {
  for (var r = [], n = 1; n < arguments.length; n++) r.push(arguments[n]);
  var i = t === "error", a = this._events;
  if (a !== void 0)
    i = i && a.error === void 0;
  else if (!i)
    return !1;
  if (i) {
    var f;
    if (r.length > 0 && (f = r[0]), f instanceof Error)
      throw f;
    var u = new Error("Unhandled error." + (f ? " (" + f.message + ")" : ""));
    throw u.context = f, u;
  }
  var l = a[t];
  if (l === void 0)
    return !1;
  if (typeof l == "function")
    Zn(l, this, r);
  else
    for (var b = l.length, g = ds(l, b), n = 0; n < b; ++n)
      Zn(g[n], this, r);
  return !0;
};
function us(e, t, r, n) {
  var i, a, f;
  if (Br(r), a = e._events, a === void 0 ? (a = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (a.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    r.listener ? r.listener : r
  ), a = e._events), f = a[t]), f === void 0)
    f = a[t] = r, ++e._eventsCount;
  else if (typeof f == "function" ? f = a[t] = n ? [r, f] : [f, r] : n ? f.unshift(r) : f.push(r), i = fs(e), i > 0 && f.length > i && !f.warned) {
    f.warned = !0;
    var u = new Error("Possible EventEmitter memory leak detected. " + f.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = f.length, Af(u);
  }
  return e;
}
K.prototype.addListener = function(t, r) {
  return us(this, t, r, !1);
};
K.prototype.on = K.prototype.addListener;
K.prototype.prependListener = function(t, r) {
  return us(this, t, r, !0);
};
function Rf() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function cs(e, t, r) {
  var n = { fired: !1, wrapFn: void 0, target: e, type: t, listener: r }, i = Rf.bind(n);
  return i.listener = r, n.wrapFn = i, i;
}
K.prototype.once = function(t, r) {
  return Br(r), this.on(t, cs(this, t, r)), this;
};
K.prototype.prependOnceListener = function(t, r) {
  return Br(r), this.prependListener(t, cs(this, t, r)), this;
};
K.prototype.removeListener = function(t, r) {
  var n, i, a, f, u;
  if (Br(r), i = this._events, i === void 0)
    return this;
  if (n = i[t], n === void 0)
    return this;
  if (n === r || n.listener === r)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, n.listener || r));
  else if (typeof n != "function") {
    for (a = -1, f = n.length - 1; f >= 0; f--)
      if (n[f] === r || n[f].listener === r) {
        u = n[f].listener, a = f;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? n.shift() : Tf(n, a), n.length === 1 && (i[t] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", t, u || r);
  }
  return this;
};
K.prototype.off = K.prototype.removeListener;
K.prototype.removeAllListeners = function(t) {
  var r, n, i;
  if (n = this._events, n === void 0)
    return this;
  if (n.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[t]), this;
  if (arguments.length === 0) {
    var a = Object.keys(n), f;
    for (i = 0; i < a.length; ++i)
      f = a[i], f !== "removeListener" && this.removeAllListeners(f);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r = n[t], typeof r == "function")
    this.removeListener(t, r);
  else if (r !== void 0)
    for (i = r.length - 1; i >= 0; i--)
      this.removeListener(t, r[i]);
  return this;
};
function ls(e, t, r) {
  var n = e._events;
  if (n === void 0)
    return [];
  var i = n[t];
  return i === void 0 ? [] : typeof i == "function" ? r ? [i.listener || i] : [i] : r ? Pf(i) : ds(i, i.length);
}
K.prototype.listeners = function(t) {
  return ls(this, t, !0);
};
K.prototype.rawListeners = function(t) {
  return ls(this, t, !1);
};
K.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : hs.call(e, t);
};
K.prototype.listenerCount = hs;
function hs(e) {
  var t = this._events;
  if (t !== void 0) {
    var r = t[e];
    if (typeof r == "function")
      return 1;
    if (r !== void 0)
      return r.length;
  }
  return 0;
}
K.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ur(this._events) : [];
};
function ds(e, t) {
  for (var r = new Array(t), n = 0; n < t; ++n)
    r[n] = e[n];
  return r;
}
function Tf(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Pf(e) {
  for (var t = new Array(e.length), r = 0; r < t.length; ++r)
    t[r] = e[r].listener || e[r];
  return t;
}
function Cf(e, t) {
  return new Promise(function(r, n) {
    function i(f) {
      e.removeListener(t, a), n(f);
    }
    function a() {
      typeof e.removeListener == "function" && e.removeListener("error", i), r([].slice.call(arguments));
    }
    ps(e, t, a, { once: !0 }), t !== "error" && Lf(e, i, { once: !0 });
  });
}
function Lf(e, t, r) {
  typeof e.on == "function" && ps(e, "error", t, r);
}
function ps(e, t, r, n) {
  if (typeof e.on == "function")
    n.once ? e.once(t, r) : e.on(t, r);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function i(a) {
      n.once && e.removeEventListener(t, i), r(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var bs = In.exports, ys = bs.EventEmitter;
const kf = {}, Ff = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kf
}, Symbol.toStringTag, { value: "Module" })), An = /* @__PURE__ */ of(Ff);
var zr, ti;
function Of() {
  if (ti) return zr;
  ti = 1;
  function e(B, P) {
    var T = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var C = Object.getOwnPropertySymbols(B);
      P && (C = C.filter(function(F) {
        return Object.getOwnPropertyDescriptor(B, F).enumerable;
      })), T.push.apply(T, C);
    }
    return T;
  }
  function t(B) {
    for (var P = 1; P < arguments.length; P++) {
      var T = arguments[P] != null ? arguments[P] : {};
      P % 2 ? e(Object(T), !0).forEach(function(C) {
        r(B, C, T[C]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(T)) : e(Object(T)).forEach(function(C) {
        Object.defineProperty(B, C, Object.getOwnPropertyDescriptor(T, C));
      });
    }
    return B;
  }
  function r(B, P, T) {
    return P = f(P), P in B ? Object.defineProperty(B, P, { value: T, enumerable: !0, configurable: !0, writable: !0 }) : B[P] = T, B;
  }
  function n(B, P) {
    if (!(B instanceof P))
      throw new TypeError("Cannot call a class as a function");
  }
  function i(B, P) {
    for (var T = 0; T < P.length; T++) {
      var C = P[T];
      C.enumerable = C.enumerable || !1, C.configurable = !0, "value" in C && (C.writable = !0), Object.defineProperty(B, f(C.key), C);
    }
  }
  function a(B, P, T) {
    return P && i(B.prototype, P), Object.defineProperty(B, "prototype", { writable: !1 }), B;
  }
  function f(B) {
    var P = u(B, "string");
    return typeof P == "symbol" ? P : String(P);
  }
  function u(B, P) {
    if (typeof B != "object" || B === null) return B;
    var T = B[Symbol.toPrimitive];
    if (T !== void 0) {
      var C = T.call(B, P || "default");
      if (typeof C != "object") return C;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (P === "string" ? String : Number)(B);
  }
  var l = Rt, b = l.Buffer, g = An, m = g.inspect, v = m && m.custom || "inspect";
  function I(B, P, T) {
    b.prototype.copy.call(B, P, T);
  }
  return zr = /* @__PURE__ */ function() {
    function B() {
      n(this, B), this.head = null, this.tail = null, this.length = 0;
    }
    return a(B, [{
      key: "push",
      value: function(T) {
        var C = {
          data: T,
          next: null
        };
        this.length > 0 ? this.tail.next = C : this.head = C, this.tail = C, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(T) {
        var C = {
          data: T,
          next: this.head
        };
        this.length === 0 && (this.tail = C), this.head = C, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var T = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, T;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(T) {
        if (this.length === 0) return "";
        for (var C = this.head, F = "" + C.data; C = C.next; ) F += T + C.data;
        return F;
      }
    }, {
      key: "concat",
      value: function(T) {
        if (this.length === 0) return b.alloc(0);
        for (var C = b.allocUnsafe(T >>> 0), F = this.head, k = 0; F; )
          I(F.data, C, k), k += F.data.length, F = F.next;
        return C;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(T, C) {
        var F;
        return T < this.head.data.length ? (F = this.head.data.slice(0, T), this.head.data = this.head.data.slice(T)) : T === this.head.data.length ? F = this.shift() : F = C ? this._getString(T) : this._getBuffer(T), F;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(T) {
        var C = this.head, F = 1, k = C.data;
        for (T -= k.length; C = C.next; ) {
          var L = C.data, O = T > L.length ? L.length : T;
          if (O === L.length ? k += L : k += L.slice(0, T), T -= O, T === 0) {
            O === L.length ? (++F, C.next ? this.head = C.next : this.head = this.tail = null) : (this.head = C, C.data = L.slice(O));
            break;
          }
          ++F;
        }
        return this.length -= F, k;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(T) {
        var C = b.allocUnsafe(T), F = this.head, k = 1;
        for (F.data.copy(C), T -= F.data.length; F = F.next; ) {
          var L = F.data, O = T > L.length ? L.length : T;
          if (L.copy(C, C.length - T, 0, O), T -= O, T === 0) {
            O === L.length ? (++k, F.next ? this.head = F.next : this.head = this.tail = null) : (this.head = F, F.data = L.slice(O));
            break;
          }
          ++k;
        }
        return this.length -= k, C;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: v,
      value: function(T, C) {
        return m(this, t(t({}, C), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), B;
  }(), zr;
}
function Uf(e, t) {
  var r = this, n = this._readableState && this._readableState.destroyed, i = this._writableState && this._writableState.destroyed;
  return n || i ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(fn, this, e)) : process.nextTick(fn, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
    !t && a ? r._writableState ? r._writableState.errorEmitted ? process.nextTick(cr, r) : (r._writableState.errorEmitted = !0, process.nextTick(ri, r, a)) : process.nextTick(ri, r, a) : t ? (process.nextTick(cr, r), t(a)) : process.nextTick(cr, r);
  }), this);
}
function ri(e, t) {
  fn(e, t), cr(e);
}
function cr(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Nf() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function fn(e, t) {
  e.emit("error", t);
}
function Mf(e, t) {
  var r = e._readableState, n = e._writableState;
  r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var gs = {
  destroy: Uf,
  undestroy: Nf,
  errorOrDestroy: Mf
}, lt = {};
function Df(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var ms = {};
function Re(e, t, r) {
  r || (r = Error);
  function n(a, f, u) {
    return typeof t == "string" ? t : t(a, f, u);
  }
  var i = /* @__PURE__ */ function(a) {
    Df(f, a);
    function f(u, l, b) {
      return a.call(this, n(u, l, b)) || this;
    }
    return f;
  }(r);
  i.prototype.name = r.name, i.prototype.code = e, ms[e] = i;
}
function ni(e, t) {
  if (Array.isArray(e)) {
    var r = e.length;
    return e = e.map(function(n) {
      return String(n);
    }), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : r === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function $f(e, t, r) {
  return e.substr(0, t.length) === t;
}
function Hf(e, t, r) {
  return (r === void 0 || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t;
}
function zf(e, t, r) {
  return typeof r != "number" && (r = 0), r + t.length > e.length ? !1 : e.indexOf(t, r) !== -1;
}
Re("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Re("ERR_INVALID_ARG_TYPE", function(e, t, r) {
  var n;
  typeof t == "string" && $f(t, "not ") ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
  var i;
  if (Hf(e, " argument"))
    i = "The ".concat(e, " ").concat(n, " ").concat(ni(t, "type"));
  else {
    var a = zf(e, ".") ? "property" : "argument";
    i = 'The "'.concat(e, '" ').concat(a, " ").concat(n, " ").concat(ni(t, "type"));
  }
  return i += ". Received type ".concat(typeof r), i;
}, TypeError);
Re("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Re("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Re("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Re("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Re("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Re("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Re("ERR_STREAM_WRITE_AFTER_END", "write after end");
Re("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Re("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Re("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
lt.codes = ms;
var jf = lt.codes.ERR_INVALID_OPT_VALUE;
function Gf(e, t, r) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[r] : null;
}
function Wf(e, t, r, n) {
  var i = Gf(t, n, r);
  if (i != null) {
    if (!(isFinite(i) && Math.floor(i) === i) || i < 0) {
      var a = n ? r : "highWaterMark";
      throw new jf(a, i);
    }
    return Math.floor(i);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var _s = {
  getHighWaterMark: Wf
}, qf = Vf;
function Vf(e, t) {
  if (jr("noDeprecation"))
    return e;
  var r = !1;
  function n() {
    if (!r) {
      if (jr("throwDeprecation"))
        throw new Error(t);
      jr("traceDeprecation") ? console.trace(t) : console.warn(t), r = !0;
    }
    return e.apply(this, arguments);
  }
  return n;
}
function jr(e) {
  try {
    if (!Xe.localStorage) return !1;
  } catch {
    return !1;
  }
  var t = Xe.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var Gr, ii;
function ws() {
  if (ii) return Gr;
  ii = 1, Gr = M;
  function e(w) {
    var _ = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ne(_, w);
    };
  }
  var t;
  M.WritableState = S;
  var r = {
    deprecate: qf
  }, n = ys, i = Rt.Buffer, a = (typeof Xe < "u" ? Xe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(w) {
    return i.from(w);
  }
  function u(w) {
    return i.isBuffer(w) || w instanceof a;
  }
  var l = gs, b = _s, g = b.getHighWaterMark, m = lt.codes, v = m.ERR_INVALID_ARG_TYPE, I = m.ERR_METHOD_NOT_IMPLEMENTED, B = m.ERR_MULTIPLE_CALLBACK, P = m.ERR_STREAM_CANNOT_PIPE, T = m.ERR_STREAM_DESTROYED, C = m.ERR_STREAM_NULL_VALUES, F = m.ERR_STREAM_WRITE_AFTER_END, k = m.ERR_UNKNOWN_ENCODING, L = l.errorOrDestroy;
  ge(M, n);
  function O() {
  }
  function S(w, _, R) {
    t = t || St(), w = w || {}, typeof R != "boolean" && (R = _ instanceof t), this.objectMode = !!w.objectMode, R && (this.objectMode = this.objectMode || !!w.writableObjectMode), this.highWaterMark = g(this, w, "writableHighWaterMark", R), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var D = w.decodeStrings === !1;
    this.decodeStrings = !D, this.defaultEncoding = w.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(j) {
      et(_, j);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = w.emitClose !== !1, this.autoDestroy = !!w.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  S.prototype.getBuffer = function() {
    for (var _ = this.bufferedRequest, R = []; _; )
      R.push(_), _ = _.next;
    return R;
  }, function() {
    try {
      Object.defineProperty(S.prototype, "buffer", {
        get: r.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var z;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (z = Function.prototype[Symbol.hasInstance], Object.defineProperty(M, Symbol.hasInstance, {
    value: function(_) {
      return z.call(this, _) ? !0 : this !== M ? !1 : _ && _._writableState instanceof S;
    }
  })) : z = function(_) {
    return _ instanceof this;
  };
  function M(w) {
    t = t || St();
    var _ = this instanceof t;
    if (!_ && !z.call(M, this)) return new M(w);
    this._writableState = new S(w, this, _), this.writable = !0, w && (typeof w.write == "function" && (this._write = w.write), typeof w.writev == "function" && (this._writev = w.writev), typeof w.destroy == "function" && (this._destroy = w.destroy), typeof w.final == "function" && (this._final = w.final)), n.call(this);
  }
  M.prototype.pipe = function() {
    L(this, new P());
  };
  function $(w, _) {
    var R = new F();
    L(w, R), process.nextTick(_, R);
  }
  function se(w, _, R, D) {
    var j;
    return R === null ? j = new C() : typeof R != "string" && !_.objectMode && (j = new v("chunk", ["string", "Buffer"], R)), j ? (L(w, j), process.nextTick(D, j), !1) : !0;
  }
  M.prototype.write = function(w, _, R) {
    var D = this._writableState, j = !1, d = !D.objectMode && u(w);
    return d && !i.isBuffer(w) && (w = f(w)), typeof _ == "function" && (R = _, _ = null), d ? _ = "buffer" : _ || (_ = D.defaultEncoding), typeof R != "function" && (R = O), D.ending ? $(this, R) : (d || se(this, D, w, R)) && (D.pendingcb++, j = je(this, D, d, w, _, R)), j;
  }, M.prototype.cork = function() {
    this._writableState.corked++;
  }, M.prototype.uncork = function() {
    var w = this._writableState;
    w.corked && (w.corked--, !w.writing && !w.corked && !w.bufferProcessing && w.bufferedRequest && Ce(this, w));
  }, M.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = _.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((_ + "").toLowerCase()) > -1)) throw new k(_);
    return this._writableState.defaultEncoding = _, this;
  }, Object.defineProperty(M.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Te(w, _, R) {
    return !w.objectMode && w.decodeStrings !== !1 && typeof _ == "string" && (_ = i.from(_, R)), _;
  }
  Object.defineProperty(M.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function je(w, _, R, D, j, d) {
    if (!R) {
      var p = Te(_, D, j);
      D !== p && (R = !0, j = "buffer", D = p);
    }
    var A = _.objectMode ? 1 : D.length;
    _.length += A;
    var U = _.length < _.highWaterMark;
    if (U || (_.needDrain = !0), _.writing || _.corked) {
      var Z = _.lastBufferedRequest;
      _.lastBufferedRequest = {
        chunk: D,
        encoding: j,
        isBuf: R,
        callback: d,
        next: null
      }, Z ? Z.next = _.lastBufferedRequest : _.bufferedRequest = _.lastBufferedRequest, _.bufferedRequestCount += 1;
    } else
      ae(w, _, !1, A, D, j, d);
    return U;
  }
  function ae(w, _, R, D, j, d, p) {
    _.writelen = D, _.writecb = p, _.writing = !0, _.sync = !0, _.destroyed ? _.onwrite(new T("write")) : R ? w._writev(j, _.onwrite) : w._write(j, d, _.onwrite), _.sync = !1;
  }
  function xe(w, _, R, D, j) {
    --_.pendingcb, R ? (process.nextTick(j, D), process.nextTick(Be, w, _), w._writableState.errorEmitted = !0, L(w, D)) : (j(D), w._writableState.errorEmitted = !0, L(w, D), Be(w, _));
  }
  function ve(w) {
    w.writing = !1, w.writecb = null, w.length -= w.writelen, w.writelen = 0;
  }
  function et(w, _) {
    var R = w._writableState, D = R.sync, j = R.writecb;
    if (typeof j != "function") throw new B();
    if (ve(R), _) xe(w, R, D, _, j);
    else {
      var d = We(R) || w.destroyed;
      !d && !R.corked && !R.bufferProcessing && R.bufferedRequest && Ce(w, R), D ? process.nextTick(Pe, w, R, d, j) : Pe(w, R, d, j);
    }
  }
  function Pe(w, _, R, D) {
    R || Ge(w, _), _.pendingcb--, D(), Be(w, _);
  }
  function Ge(w, _) {
    _.length === 0 && _.needDrain && (_.needDrain = !1, w.emit("drain"));
  }
  function Ce(w, _) {
    _.bufferProcessing = !0;
    var R = _.bufferedRequest;
    if (w._writev && R && R.next) {
      var D = _.bufferedRequestCount, j = new Array(D), d = _.corkedRequestsFree;
      d.entry = R;
      for (var p = 0, A = !0; R; )
        j[p] = R, R.isBuf || (A = !1), R = R.next, p += 1;
      j.allBuffers = A, ae(w, _, !0, _.length, j, "", d.finish), _.pendingcb++, _.lastBufferedRequest = null, d.next ? (_.corkedRequestsFree = d.next, d.next = null) : _.corkedRequestsFree = new e(_), _.bufferedRequestCount = 0;
    } else {
      for (; R; ) {
        var U = R.chunk, Z = R.encoding, G = R.callback, V = _.objectMode ? 1 : U.length;
        if (ae(w, _, !1, V, U, Z, G), R = R.next, _.bufferedRequestCount--, _.writing)
          break;
      }
      R === null && (_.lastBufferedRequest = null);
    }
    _.bufferedRequest = R, _.bufferProcessing = !1;
  }
  M.prototype._write = function(w, _, R) {
    R(new I("_write()"));
  }, M.prototype._writev = null, M.prototype.end = function(w, _, R) {
    var D = this._writableState;
    return typeof w == "function" ? (R = w, w = null, _ = null) : typeof _ == "function" && (R = _, _ = null), w != null && this.write(w, _), D.corked && (D.corked = 1, this.uncork()), D.ending || qe(this, D, R), this;
  }, Object.defineProperty(M.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function We(w) {
    return w.ending && w.length === 0 && w.bufferedRequest === null && !w.finished && !w.writing;
  }
  function Q(w, _) {
    w._final(function(R) {
      _.pendingcb--, R && L(w, R), _.prefinished = !0, w.emit("prefinish"), Be(w, _);
    });
  }
  function oe(w, _) {
    !_.prefinished && !_.finalCalled && (typeof w._final == "function" && !_.destroyed ? (_.pendingcb++, _.finalCalled = !0, process.nextTick(Q, w, _)) : (_.prefinished = !0, w.emit("prefinish")));
  }
  function Be(w, _) {
    var R = We(_);
    if (R && (oe(w, _), _.pendingcb === 0 && (_.finished = !0, w.emit("finish"), _.autoDestroy))) {
      var D = w._readableState;
      (!D || D.autoDestroy && D.endEmitted) && w.destroy();
    }
    return R;
  }
  function qe(w, _, R) {
    _.ending = !0, Be(w, _), R && (_.finished ? process.nextTick(R) : w.once("finish", R)), _.ended = !0, w.writable = !1;
  }
  function Ne(w, _, R) {
    var D = w.entry;
    for (w.entry = null; D; ) {
      var j = D.callback;
      _.pendingcb--, j(R), D = D.next;
    }
    _.corkedRequestsFree.next = w;
  }
  return Object.defineProperty(M.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(_) {
      this._writableState && (this._writableState.destroyed = _);
    }
  }), M.prototype.destroy = l.destroy, M.prototype._undestroy = l.undestroy, M.prototype._destroy = function(w, _) {
    _(w);
  }, Gr;
}
var Wr, si;
function St() {
  if (si) return Wr;
  si = 1;
  var e = Object.keys || function(b) {
    var g = [];
    for (var m in b) g.push(m);
    return g;
  };
  Wr = f;
  var t = vs(), r = ws();
  ge(f, t);
  for (var n = e(r.prototype), i = 0; i < n.length; i++) {
    var a = n[i];
    f.prototype[a] || (f.prototype[a] = r.prototype[a]);
  }
  function f(b) {
    if (!(this instanceof f)) return new f(b);
    t.call(this, b), r.call(this, b), this.allowHalfOpen = !0, b && (b.readable === !1 && (this.readable = !1), b.writable === !1 && (this.writable = !1), b.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function u() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(b) {
    b.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), Wr;
}
var mr = {}, Rn = Ee.Buffer, oi = Rn.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function Kf(e) {
  if (!e) return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t) return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function Yf(e) {
  var t = Kf(e);
  if (typeof t != "string" && (Rn.isEncoding === oi || !oi(e))) throw new Error("Unknown encoding: " + e);
  return t || e;
}
mr.StringDecoder = Xt;
function Xt(e) {
  this.encoding = Yf(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = tu, this.end = ru, t = 4;
      break;
    case "utf8":
      this.fillLast = Qf, t = 4;
      break;
    case "base64":
      this.text = nu, this.end = iu, t = 3;
      break;
    default:
      this.write = su, this.end = ou;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Rn.allocUnsafe(t);
}
Xt.prototype.write = function(e) {
  if (e.length === 0) return "";
  var t, r;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0) return "";
    r = this.lastNeed, this.lastNeed = 0;
  } else
    r = 0;
  return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || "";
};
Xt.prototype.end = eu;
Xt.prototype.text = Zf;
Xt.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function qr(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function Jf(e, t, r) {
  var n = t.length - 1;
  if (n < r) return 0;
  var i = qr(t[n]);
  return i >= 0 ? (i > 0 && (e.lastNeed = i - 1), i) : --n < r || i === -2 ? 0 : (i = qr(t[n]), i >= 0 ? (i > 0 && (e.lastNeed = i - 2), i) : --n < r || i === -2 ? 0 : (i = qr(t[n]), i >= 0 ? (i > 0 && (i === 2 ? i = 0 : e.lastNeed = i - 3), i) : 0));
}
function Xf(e, t, r) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "";
  }
}
function Qf(e) {
  var t = this.lastTotal - this.lastNeed, r = Xf(this, e);
  if (r !== void 0) return r;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function Zf(e, t) {
  var r = Jf(this, e, t);
  if (!this.lastNeed) return e.toString("utf8", t);
  this.lastTotal = r;
  var n = e.length - (r - this.lastNeed);
  return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n);
}
function eu(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "" : t;
}
function tu(e, t) {
  if ((e.length - t) % 2 === 0) {
    var r = e.toString("utf16le", t);
    if (r) {
      var n = r.charCodeAt(r.length - 1);
      if (n >= 55296 && n <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1);
    }
    return r;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function ru(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var r = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, r);
  }
  return t;
}
function nu(e, t) {
  var r = (e.length - t) % 3;
  return r === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, r === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r));
}
function iu(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function su(e) {
  return e.toString(this.encoding);
}
function ou(e) {
  return e && e.length ? this.write(e) : "";
}
var ai = lt.codes.ERR_STREAM_PREMATURE_CLOSE;
function au(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      e.apply(this, n);
    }
  };
}
function fu() {
}
function uu(e) {
  return e.setHeader && typeof e.abort == "function";
}
function xs(e, t, r) {
  if (typeof t == "function") return xs(e, null, t);
  t || (t = {}), r = au(r || fu);
  var n = t.readable || t.readable !== !1 && e.readable, i = t.writable || t.writable !== !1 && e.writable, a = function() {
    e.writable || u();
  }, f = e._writableState && e._writableState.finished, u = function() {
    i = !1, f = !0, n || r.call(e);
  }, l = e._readableState && e._readableState.endEmitted, b = function() {
    n = !1, l = !0, i || r.call(e);
  }, g = function(B) {
    r.call(e, B);
  }, m = function() {
    var B;
    if (n && !l)
      return (!e._readableState || !e._readableState.ended) && (B = new ai()), r.call(e, B);
    if (i && !f)
      return (!e._writableState || !e._writableState.ended) && (B = new ai()), r.call(e, B);
  }, v = function() {
    e.req.on("finish", u);
  };
  return uu(e) ? (e.on("complete", u), e.on("abort", m), e.req ? v() : e.on("request", v)) : i && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", b), e.on("finish", u), t.error !== !1 && e.on("error", g), e.on("close", m), function() {
    e.removeListener("complete", u), e.removeListener("abort", m), e.removeListener("request", v), e.req && e.req.removeListener("finish", u), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", u), e.removeListener("end", b), e.removeListener("error", g), e.removeListener("close", m);
  };
}
var Tn = xs, Vr, fi;
function cu() {
  if (fi) return Vr;
  fi = 1;
  var e;
  function t(k, L, O) {
    return L = r(L), L in k ? Object.defineProperty(k, L, { value: O, enumerable: !0, configurable: !0, writable: !0 }) : k[L] = O, k;
  }
  function r(k) {
    var L = n(k, "string");
    return typeof L == "symbol" ? L : String(L);
  }
  function n(k, L) {
    if (typeof k != "object" || k === null) return k;
    var O = k[Symbol.toPrimitive];
    if (O !== void 0) {
      var S = O.call(k, L || "default");
      if (typeof S != "object") return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (L === "string" ? String : Number)(k);
  }
  var i = Tn, a = Symbol("lastResolve"), f = Symbol("lastReject"), u = Symbol("error"), l = Symbol("ended"), b = Symbol("lastPromise"), g = Symbol("handlePromise"), m = Symbol("stream");
  function v(k, L) {
    return {
      value: k,
      done: L
    };
  }
  function I(k) {
    var L = k[a];
    if (L !== null) {
      var O = k[m].read();
      O !== null && (k[b] = null, k[a] = null, k[f] = null, L(v(O, !1)));
    }
  }
  function B(k) {
    process.nextTick(I, k);
  }
  function P(k, L) {
    return function(O, S) {
      k.then(function() {
        if (L[l]) {
          O(v(void 0, !0));
          return;
        }
        L[g](O, S);
      }, S);
    };
  }
  var T = Object.getPrototypeOf(function() {
  }), C = Object.setPrototypeOf((e = {
    get stream() {
      return this[m];
    },
    next: function() {
      var L = this, O = this[u];
      if (O !== null)
        return Promise.reject(O);
      if (this[l])
        return Promise.resolve(v(void 0, !0));
      if (this[m].destroyed)
        return new Promise(function($, se) {
          process.nextTick(function() {
            L[u] ? se(L[u]) : $(v(void 0, !0));
          });
        });
      var S = this[b], z;
      if (S)
        z = new Promise(P(S, this));
      else {
        var M = this[m].read();
        if (M !== null)
          return Promise.resolve(v(M, !1));
        z = new Promise(this[g]);
      }
      return this[b] = z, z;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var L = this;
    return new Promise(function(O, S) {
      L[m].destroy(null, function(z) {
        if (z) {
          S(z);
          return;
        }
        O(v(void 0, !0));
      });
    });
  }), e), T), F = function(L) {
    var O, S = Object.create(C, (O = {}, t(O, m, {
      value: L,
      writable: !0
    }), t(O, a, {
      value: null,
      writable: !0
    }), t(O, f, {
      value: null,
      writable: !0
    }), t(O, u, {
      value: null,
      writable: !0
    }), t(O, l, {
      value: L._readableState.endEmitted,
      writable: !0
    }), t(O, g, {
      value: function(M, $) {
        var se = S[m].read();
        se ? (S[b] = null, S[a] = null, S[f] = null, M(v(se, !1))) : (S[a] = M, S[f] = $);
      },
      writable: !0
    }), O));
    return S[b] = null, i(L, function(z) {
      if (z && z.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var M = S[f];
        M !== null && (S[b] = null, S[a] = null, S[f] = null, M(z)), S[u] = z;
        return;
      }
      var $ = S[a];
      $ !== null && (S[b] = null, S[a] = null, S[f] = null, $(v(void 0, !0))), S[l] = !0;
    }), L.on("readable", B.bind(null, S)), S;
  };
  return Vr = F, Vr;
}
var Kr, ui;
function lu() {
  return ui || (ui = 1, Kr = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Kr;
}
var Yr, ci;
function vs() {
  if (ci) return Yr;
  ci = 1, Yr = $;
  var e;
  $.ReadableState = M, bs.EventEmitter;
  var t = function(p, A) {
    return p.listeners(A).length;
  }, r = ys, n = Rt.Buffer, i = (typeof Xe < "u" ? Xe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(d) {
    return n.from(d);
  }
  function f(d) {
    return n.isBuffer(d) || d instanceof i;
  }
  var u = An, l;
  u && u.debuglog ? l = u.debuglog("stream") : l = function() {
  };
  var b = Of(), g = gs, m = _s, v = m.getHighWaterMark, I = lt.codes, B = I.ERR_INVALID_ARG_TYPE, P = I.ERR_STREAM_PUSH_AFTER_EOF, T = I.ERR_METHOD_NOT_IMPLEMENTED, C = I.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, F, k, L;
  ge($, r);
  var O = g.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
  function z(d, p, A) {
    if (typeof d.prependListener == "function") return d.prependListener(p, A);
    !d._events || !d._events[p] ? d.on(p, A) : Array.isArray(d._events[p]) ? d._events[p].unshift(A) : d._events[p] = [A, d._events[p]];
  }
  function M(d, p, A) {
    e = e || St(), d = d || {}, typeof A != "boolean" && (A = p instanceof e), this.objectMode = !!d.objectMode, A && (this.objectMode = this.objectMode || !!d.readableObjectMode), this.highWaterMark = v(this, d, "readableHighWaterMark", A), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = d.emitClose !== !1, this.autoDestroy = !!d.autoDestroy, this.destroyed = !1, this.defaultEncoding = d.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, d.encoding && (F || (F = mr.StringDecoder), this.decoder = new F(d.encoding), this.encoding = d.encoding);
  }
  function $(d) {
    if (e = e || St(), !(this instanceof $)) return new $(d);
    var p = this instanceof e;
    this._readableState = new M(d, this, p), this.readable = !0, d && (typeof d.read == "function" && (this._read = d.read), typeof d.destroy == "function" && (this._destroy = d.destroy)), r.call(this);
  }
  Object.defineProperty($.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(p) {
      this._readableState && (this._readableState.destroyed = p);
    }
  }), $.prototype.destroy = g.destroy, $.prototype._undestroy = g.undestroy, $.prototype._destroy = function(d, p) {
    p(d);
  }, $.prototype.push = function(d, p) {
    var A = this._readableState, U;
    return A.objectMode ? U = !0 : typeof d == "string" && (p = p || A.defaultEncoding, p !== A.encoding && (d = n.from(d, p), p = ""), U = !0), se(this, d, p, !1, U);
  }, $.prototype.unshift = function(d) {
    return se(this, d, null, !0, !1);
  };
  function se(d, p, A, U, Z) {
    l("readableAddChunk", p);
    var G = d._readableState;
    if (p === null)
      G.reading = !1, et(d, G);
    else {
      var V;
      if (Z || (V = je(G, p)), V)
        O(d, V);
      else if (G.objectMode || p && p.length > 0)
        if (typeof p != "string" && !G.objectMode && Object.getPrototypeOf(p) !== n.prototype && (p = a(p)), U)
          G.endEmitted ? O(d, new C()) : Te(d, G, p, !0);
        else if (G.ended)
          O(d, new P());
        else {
          if (G.destroyed)
            return !1;
          G.reading = !1, G.decoder && !A ? (p = G.decoder.write(p), G.objectMode || p.length !== 0 ? Te(d, G, p, !1) : Ce(d, G)) : Te(d, G, p, !1);
        }
      else U || (G.reading = !1, Ce(d, G));
    }
    return !G.ended && (G.length < G.highWaterMark || G.length === 0);
  }
  function Te(d, p, A, U) {
    p.flowing && p.length === 0 && !p.sync ? (p.awaitDrain = 0, d.emit("data", A)) : (p.length += p.objectMode ? 1 : A.length, U ? p.buffer.unshift(A) : p.buffer.push(A), p.needReadable && Pe(d)), Ce(d, p);
  }
  function je(d, p) {
    var A;
    return !f(p) && typeof p != "string" && p !== void 0 && !d.objectMode && (A = new B("chunk", ["string", "Buffer", "Uint8Array"], p)), A;
  }
  $.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, $.prototype.setEncoding = function(d) {
    F || (F = mr.StringDecoder);
    var p = new F(d);
    this._readableState.decoder = p, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var A = this._readableState.buffer.head, U = ""; A !== null; )
      U += p.write(A.data), A = A.next;
    return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this;
  };
  var ae = 1073741824;
  function xe(d) {
    return d >= ae ? d = ae : (d--, d |= d >>> 1, d |= d >>> 2, d |= d >>> 4, d |= d >>> 8, d |= d >>> 16, d++), d;
  }
  function ve(d, p) {
    return d <= 0 || p.length === 0 && p.ended ? 0 : p.objectMode ? 1 : d !== d ? p.flowing && p.length ? p.buffer.head.data.length : p.length : (d > p.highWaterMark && (p.highWaterMark = xe(d)), d <= p.length ? d : p.ended ? p.length : (p.needReadable = !0, 0));
  }
  $.prototype.read = function(d) {
    l("read", d), d = parseInt(d, 10);
    var p = this._readableState, A = d;
    if (d !== 0 && (p.emittedReadable = !1), d === 0 && p.needReadable && ((p.highWaterMark !== 0 ? p.length >= p.highWaterMark : p.length > 0) || p.ended))
      return l("read: emitReadable", p.length, p.ended), p.length === 0 && p.ended ? R(this) : Pe(this), null;
    if (d = ve(d, p), d === 0 && p.ended)
      return p.length === 0 && R(this), null;
    var U = p.needReadable;
    l("need readable", U), (p.length === 0 || p.length - d < p.highWaterMark) && (U = !0, l("length less than watermark", U)), p.ended || p.reading ? (U = !1, l("reading or ended", U)) : U && (l("do read"), p.reading = !0, p.sync = !0, p.length === 0 && (p.needReadable = !0), this._read(p.highWaterMark), p.sync = !1, p.reading || (d = ve(A, p)));
    var Z;
    return d > 0 ? Z = _(d, p) : Z = null, Z === null ? (p.needReadable = p.length <= p.highWaterMark, d = 0) : (p.length -= d, p.awaitDrain = 0), p.length === 0 && (p.ended || (p.needReadable = !0), A !== d && p.ended && R(this)), Z !== null && this.emit("data", Z), Z;
  };
  function et(d, p) {
    if (l("onEofChunk"), !p.ended) {
      if (p.decoder) {
        var A = p.decoder.end();
        A && A.length && (p.buffer.push(A), p.length += p.objectMode ? 1 : A.length);
      }
      p.ended = !0, p.sync ? Pe(d) : (p.needReadable = !1, p.emittedReadable || (p.emittedReadable = !0, Ge(d)));
    }
  }
  function Pe(d) {
    var p = d._readableState;
    l("emitReadable", p.needReadable, p.emittedReadable), p.needReadable = !1, p.emittedReadable || (l("emitReadable", p.flowing), p.emittedReadable = !0, process.nextTick(Ge, d));
  }
  function Ge(d) {
    var p = d._readableState;
    l("emitReadable_", p.destroyed, p.length, p.ended), !p.destroyed && (p.length || p.ended) && (d.emit("readable"), p.emittedReadable = !1), p.needReadable = !p.flowing && !p.ended && p.length <= p.highWaterMark, w(d);
  }
  function Ce(d, p) {
    p.readingMore || (p.readingMore = !0, process.nextTick(We, d, p));
  }
  function We(d, p) {
    for (; !p.reading && !p.ended && (p.length < p.highWaterMark || p.flowing && p.length === 0); ) {
      var A = p.length;
      if (l("maybeReadMore read 0"), d.read(0), A === p.length)
        break;
    }
    p.readingMore = !1;
  }
  $.prototype._read = function(d) {
    O(this, new T("_read()"));
  }, $.prototype.pipe = function(d, p) {
    var A = this, U = this._readableState;
    switch (U.pipesCount) {
      case 0:
        U.pipes = d;
        break;
      case 1:
        U.pipes = [U.pipes, d];
        break;
      default:
        U.pipes.push(d);
        break;
    }
    U.pipesCount += 1, l("pipe count=%d opts=%j", U.pipesCount, p);
    var Z = (!p || p.end !== !1) && d !== process.stdout && d !== process.stderr, G = Z ? Ve : rt;
    U.endEmitted ? process.nextTick(G) : A.once("end", G), d.on("unpipe", V);
    function V(c, s) {
      l("onunpipe"), c === A && s && s.hasUnpiped === !1 && (s.hasUnpiped = !0, pt());
    }
    function Ve() {
      l("onend"), d.end();
    }
    var dt = Q(A);
    d.on("drain", dt);
    var Pt = !1;
    function pt() {
      l("cleanup"), d.removeListener("close", Ct), d.removeListener("finish", Ie), d.removeListener("drain", dt), d.removeListener("error", tt), d.removeListener("unpipe", V), A.removeListener("end", Ve), A.removeListener("end", rt), A.removeListener("data", Se), Pt = !0, U.awaitDrain && (!d._writableState || d._writableState.needDrain) && dt();
    }
    A.on("data", Se);
    function Se(c) {
      l("ondata");
      var s = d.write(c);
      l("dest.write", s), s === !1 && ((U.pipesCount === 1 && U.pipes === d || U.pipesCount > 1 && j(U.pipes, d) !== -1) && !Pt && (l("false write response, pause", U.awaitDrain), U.awaitDrain++), A.pause());
    }
    function tt(c) {
      l("onerror", c), rt(), d.removeListener("error", tt), t(d, "error") === 0 && O(d, c);
    }
    z(d, "error", tt);
    function Ct() {
      d.removeListener("finish", Ie), rt();
    }
    d.once("close", Ct);
    function Ie() {
      l("onfinish"), d.removeListener("close", Ct), rt();
    }
    d.once("finish", Ie);
    function rt() {
      l("unpipe"), A.unpipe(d);
    }
    return d.emit("pipe", A), U.flowing || (l("pipe resume"), A.resume()), d;
  };
  function Q(d) {
    return function() {
      var A = d._readableState;
      l("pipeOnDrain", A.awaitDrain), A.awaitDrain && A.awaitDrain--, A.awaitDrain === 0 && t(d, "data") && (A.flowing = !0, w(d));
    };
  }
  $.prototype.unpipe = function(d) {
    var p = this._readableState, A = {
      hasUnpiped: !1
    };
    if (p.pipesCount === 0) return this;
    if (p.pipesCount === 1)
      return d && d !== p.pipes ? this : (d || (d = p.pipes), p.pipes = null, p.pipesCount = 0, p.flowing = !1, d && d.emit("unpipe", this, A), this);
    if (!d) {
      var U = p.pipes, Z = p.pipesCount;
      p.pipes = null, p.pipesCount = 0, p.flowing = !1;
      for (var G = 0; G < Z; G++) U[G].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var V = j(p.pipes, d);
    return V === -1 ? this : (p.pipes.splice(V, 1), p.pipesCount -= 1, p.pipesCount === 1 && (p.pipes = p.pipes[0]), d.emit("unpipe", this, A), this);
  }, $.prototype.on = function(d, p) {
    var A = r.prototype.on.call(this, d, p), U = this._readableState;
    return d === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== !1 && this.resume()) : d === "readable" && !U.endEmitted && !U.readableListening && (U.readableListening = U.needReadable = !0, U.flowing = !1, U.emittedReadable = !1, l("on readable", U.length, U.reading), U.length ? Pe(this) : U.reading || process.nextTick(Be, this)), A;
  }, $.prototype.addListener = $.prototype.on, $.prototype.removeListener = function(d, p) {
    var A = r.prototype.removeListener.call(this, d, p);
    return d === "readable" && process.nextTick(oe, this), A;
  }, $.prototype.removeAllListeners = function(d) {
    var p = r.prototype.removeAllListeners.apply(this, arguments);
    return (d === "readable" || d === void 0) && process.nextTick(oe, this), p;
  };
  function oe(d) {
    var p = d._readableState;
    p.readableListening = d.listenerCount("readable") > 0, p.resumeScheduled && !p.paused ? p.flowing = !0 : d.listenerCount("data") > 0 && d.resume();
  }
  function Be(d) {
    l("readable nexttick read 0"), d.read(0);
  }
  $.prototype.resume = function() {
    var d = this._readableState;
    return d.flowing || (l("resume"), d.flowing = !d.readableListening, qe(this, d)), d.paused = !1, this;
  };
  function qe(d, p) {
    p.resumeScheduled || (p.resumeScheduled = !0, process.nextTick(Ne, d, p));
  }
  function Ne(d, p) {
    l("resume", p.reading), p.reading || d.read(0), p.resumeScheduled = !1, d.emit("resume"), w(d), p.flowing && !p.reading && d.read(0);
  }
  $.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (l("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function w(d) {
    var p = d._readableState;
    for (l("flow", p.flowing); p.flowing && d.read() !== null; ) ;
  }
  $.prototype.wrap = function(d) {
    var p = this, A = this._readableState, U = !1;
    d.on("end", function() {
      if (l("wrapped end"), A.decoder && !A.ended) {
        var V = A.decoder.end();
        V && V.length && p.push(V);
      }
      p.push(null);
    }), d.on("data", function(V) {
      if (l("wrapped data"), A.decoder && (V = A.decoder.write(V)), !(A.objectMode && V == null) && !(!A.objectMode && (!V || !V.length))) {
        var Ve = p.push(V);
        Ve || (U = !0, d.pause());
      }
    });
    for (var Z in d)
      this[Z] === void 0 && typeof d[Z] == "function" && (this[Z] = /* @__PURE__ */ function(Ve) {
        return function() {
          return d[Ve].apply(d, arguments);
        };
      }(Z));
    for (var G = 0; G < S.length; G++)
      d.on(S[G], this.emit.bind(this, S[G]));
    return this._read = function(V) {
      l("wrapped _read", V), U && (U = !1, d.resume());
    }, this;
  }, typeof Symbol == "function" && ($.prototype[Symbol.asyncIterator] = function() {
    return k === void 0 && (k = cu()), k(this);
  }), Object.defineProperty($.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty($.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty($.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(p) {
      this._readableState && (this._readableState.flowing = p);
    }
  }), $._fromList = _, Object.defineProperty($.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function _(d, p) {
    if (p.length === 0) return null;
    var A;
    return p.objectMode ? A = p.buffer.shift() : !d || d >= p.length ? (p.decoder ? A = p.buffer.join("") : p.buffer.length === 1 ? A = p.buffer.first() : A = p.buffer.concat(p.length), p.buffer.clear()) : A = p.buffer.consume(d, p.decoder), A;
  }
  function R(d) {
    var p = d._readableState;
    l("endReadable", p.endEmitted), p.endEmitted || (p.ended = !0, process.nextTick(D, p, d));
  }
  function D(d, p) {
    if (l("endReadableNT", d.endEmitted, d.length), !d.endEmitted && d.length === 0 && (d.endEmitted = !0, p.readable = !1, p.emit("end"), d.autoDestroy)) {
      var A = p._writableState;
      (!A || A.autoDestroy && A.finished) && p.destroy();
    }
  }
  typeof Symbol == "function" && ($.from = function(d, p) {
    return L === void 0 && (L = lu()), L($, d, p);
  });
  function j(d, p) {
    for (var A = 0, U = d.length; A < U; A++)
      if (d[A] === p) return A;
    return -1;
  }
  return Yr;
}
var Es = ze, Sr = lt.codes, hu = Sr.ERR_METHOD_NOT_IMPLEMENTED, du = Sr.ERR_MULTIPLE_CALLBACK, pu = Sr.ERR_TRANSFORM_ALREADY_TRANSFORMING, bu = Sr.ERR_TRANSFORM_WITH_LENGTH_0, Ir = St();
ge(ze, Ir);
function yu(e, t) {
  var r = this._transformState;
  r.transforming = !1;
  var n = r.writecb;
  if (n === null)
    return this.emit("error", new du());
  r.writechunk = null, r.writecb = null, t != null && this.push(t), n(e);
  var i = this._readableState;
  i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
}
function ze(e) {
  if (!(this instanceof ze)) return new ze(e);
  Ir.call(this, e), this._transformState = {
    afterTransform: yu.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", gu);
}
function gu() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, r) {
    li(e, t, r);
  }) : li(this, null, null);
}
ze.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Ir.prototype.push.call(this, e, t);
};
ze.prototype._transform = function(e, t, r) {
  r(new hu("_transform()"));
};
ze.prototype._write = function(e, t, r) {
  var n = this._transformState;
  if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
    var i = this._readableState;
    (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark);
  }
};
ze.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
ze.prototype._destroy = function(e, t) {
  Ir.prototype._destroy.call(this, e, function(r) {
    t(r);
  });
};
function li(e, t, r) {
  if (t) return e.emit("error", t);
  if (r != null && e.push(r), e._writableState.length) throw new bu();
  if (e._transformState.transforming) throw new pu();
  return e.push(null);
}
var mu = Wt, Bs = Es;
ge(Wt, Bs);
function Wt(e) {
  if (!(this instanceof Wt)) return new Wt(e);
  Bs.call(this, e);
}
Wt.prototype._transform = function(e, t, r) {
  r(null, e);
};
var Jr;
function _u(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var Ss = lt.codes, wu = Ss.ERR_MISSING_ARGS, xu = Ss.ERR_STREAM_DESTROYED;
function hi(e) {
  if (e) throw e;
}
function vu(e) {
  return e.setHeader && typeof e.abort == "function";
}
function Eu(e, t, r, n) {
  n = _u(n);
  var i = !1;
  e.on("close", function() {
    i = !0;
  }), Jr === void 0 && (Jr = Tn), Jr(e, {
    readable: t,
    writable: r
  }, function(f) {
    if (f) return n(f);
    i = !0, n();
  });
  var a = !1;
  return function(f) {
    if (!i && !a) {
      if (a = !0, vu(e)) return e.abort();
      if (typeof e.destroy == "function") return e.destroy();
      n(f || new xu("pipe"));
    }
  };
}
function di(e) {
  e();
}
function Bu(e, t) {
  return e.pipe(t);
}
function Su(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? hi : e.pop();
}
function Iu() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = Su(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new wu("streams");
  var i, a = t.map(function(f, u) {
    var l = u < t.length - 1, b = u > 0;
    return Eu(f, l, b, function(g) {
      i || (i = g), g && a.forEach(di), !l && (a.forEach(di), n(i));
    });
  });
  return t.reduce(Bu);
}
var Au = Iu;
(function(e, t) {
  t = e.exports = vs(), t.Stream = t, t.Readable = t, t.Writable = ws(), t.Duplex = St(), t.Transform = Es, t.PassThrough = mu, t.finished = Tn, t.pipeline = Au;
})(an, an.exports);
var Ru = an.exports, _r = Ee.Buffer, Is = Ru.Transform, Tu = ge;
function Pu(e, t) {
  if (!_r.isBuffer(e) && typeof e != "string")
    throw new TypeError(t + " must be a string or a buffer");
}
function Ze(e) {
  Is.call(this), this._block = _r.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
Tu(Ze, Is);
Ze.prototype._transform = function(e, t, r) {
  var n = null;
  try {
    this.update(e, t);
  } catch (i) {
    n = i;
  }
  r(n);
};
Ze.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (r) {
    t = r;
  }
  e(t);
};
Ze.prototype.update = function(e, t) {
  if (Pu(e, "Data"), this._finalized) throw new Error("Digest already called");
  _r.isBuffer(e) || (e = _r.from(e, t));
  for (var r = this._block, n = 0; this._blockOffset + e.length - n >= this._blockSize; ) {
    for (var i = this._blockOffset; i < this._blockSize; ) r[i++] = e[n++];
    this._update(), this._blockOffset = 0;
  }
  for (; n < e.length; ) r[this._blockOffset++] = e[n++];
  for (var a = 0, f = e.length * 8; f > 0; ++a)
    this._length[a] += f, f = this._length[a] / 4294967296 | 0, f > 0 && (this._length[a] -= 4294967296 * f);
  return this;
};
Ze.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Ze.prototype.digest = function(e) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var r = 0; r < 4; ++r) this._length[r] = 0;
  return t;
};
Ze.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var As = Ze, Cu = ge, Rs = As, Lu = Ee.Buffer, ku = new Array(16);
function Ar() {
  Rs.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
Cu(Ar, Rs);
Ar.prototype._update = function() {
  for (var e = ku, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
  var r = this._a, n = this._b, i = this._c, a = this._d;
  r = de(r, n, i, a, e[0], 3614090360, 7), a = de(a, r, n, i, e[1], 3905402710, 12), i = de(i, a, r, n, e[2], 606105819, 17), n = de(n, i, a, r, e[3], 3250441966, 22), r = de(r, n, i, a, e[4], 4118548399, 7), a = de(a, r, n, i, e[5], 1200080426, 12), i = de(i, a, r, n, e[6], 2821735955, 17), n = de(n, i, a, r, e[7], 4249261313, 22), r = de(r, n, i, a, e[8], 1770035416, 7), a = de(a, r, n, i, e[9], 2336552879, 12), i = de(i, a, r, n, e[10], 4294925233, 17), n = de(n, i, a, r, e[11], 2304563134, 22), r = de(r, n, i, a, e[12], 1804603682, 7), a = de(a, r, n, i, e[13], 4254626195, 12), i = de(i, a, r, n, e[14], 2792965006, 17), n = de(n, i, a, r, e[15], 1236535329, 22), r = pe(r, n, i, a, e[1], 4129170786, 5), a = pe(a, r, n, i, e[6], 3225465664, 9), i = pe(i, a, r, n, e[11], 643717713, 14), n = pe(n, i, a, r, e[0], 3921069994, 20), r = pe(r, n, i, a, e[5], 3593408605, 5), a = pe(a, r, n, i, e[10], 38016083, 9), i = pe(i, a, r, n, e[15], 3634488961, 14), n = pe(n, i, a, r, e[4], 3889429448, 20), r = pe(r, n, i, a, e[9], 568446438, 5), a = pe(a, r, n, i, e[14], 3275163606, 9), i = pe(i, a, r, n, e[3], 4107603335, 14), n = pe(n, i, a, r, e[8], 1163531501, 20), r = pe(r, n, i, a, e[13], 2850285829, 5), a = pe(a, r, n, i, e[2], 4243563512, 9), i = pe(i, a, r, n, e[7], 1735328473, 14), n = pe(n, i, a, r, e[12], 2368359562, 20), r = be(r, n, i, a, e[5], 4294588738, 4), a = be(a, r, n, i, e[8], 2272392833, 11), i = be(i, a, r, n, e[11], 1839030562, 16), n = be(n, i, a, r, e[14], 4259657740, 23), r = be(r, n, i, a, e[1], 2763975236, 4), a = be(a, r, n, i, e[4], 1272893353, 11), i = be(i, a, r, n, e[7], 4139469664, 16), n = be(n, i, a, r, e[10], 3200236656, 23), r = be(r, n, i, a, e[13], 681279174, 4), a = be(a, r, n, i, e[0], 3936430074, 11), i = be(i, a, r, n, e[3], 3572445317, 16), n = be(n, i, a, r, e[6], 76029189, 23), r = be(r, n, i, a, e[9], 3654602809, 4), a = be(a, r, n, i, e[12], 3873151461, 11), i = be(i, a, r, n, e[15], 530742520, 16), n = be(n, i, a, r, e[2], 3299628645, 23), r = ye(r, n, i, a, e[0], 4096336452, 6), a = ye(a, r, n, i, e[7], 1126891415, 10), i = ye(i, a, r, n, e[14], 2878612391, 15), n = ye(n, i, a, r, e[5], 4237533241, 21), r = ye(r, n, i, a, e[12], 1700485571, 6), a = ye(a, r, n, i, e[3], 2399980690, 10), i = ye(i, a, r, n, e[10], 4293915773, 15), n = ye(n, i, a, r, e[1], 2240044497, 21), r = ye(r, n, i, a, e[8], 1873313359, 6), a = ye(a, r, n, i, e[15], 4264355552, 10), i = ye(i, a, r, n, e[6], 2734768916, 15), n = ye(n, i, a, r, e[13], 1309151649, 21), r = ye(r, n, i, a, e[4], 4149444226, 6), a = ye(a, r, n, i, e[11], 3174756917, 10), i = ye(i, a, r, n, e[2], 718787259, 15), n = ye(n, i, a, r, e[9], 3951481745, 21), this._a = this._a + r | 0, this._b = this._b + n | 0, this._c = this._c + i | 0, this._d = this._d + a | 0;
};
Ar.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Lu.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function Rr(e, t) {
  return e << t | e >>> 32 - t;
}
function de(e, t, r, n, i, a, f) {
  return Rr(e + (t & r | ~t & n) + i + a | 0, f) + t | 0;
}
function pe(e, t, r, n, i, a, f) {
  return Rr(e + (t & n | r & ~n) + i + a | 0, f) + t | 0;
}
function be(e, t, r, n, i, a, f) {
  return Rr(e + (t ^ r ^ n) + i + a | 0, f) + t | 0;
}
function ye(e, t, r, n, i, a, f) {
  return Rr(e + (r ^ (t | ~n)) + i + a | 0, f) + t | 0;
}
var Fu = Ar, Xr = Rt.Buffer, Ou = ge, Ts = As, Uu = new Array(16), Mt = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], Dt = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], $t = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], Ht = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], zt = [0, 1518500249, 1859775393, 2400959708, 2840853838], jt = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function Tr() {
  Ts.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
Ou(Tr, Ts);
Tr.prototype._update = function() {
  for (var e = Uu, t = 0; t < 16; ++t) e[t] = this._block.readInt32LE(t * 4);
  for (var r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, f = this._e | 0, u = this._a | 0, l = this._b | 0, b = this._c | 0, g = this._d | 0, m = this._e | 0, v = 0; v < 80; v += 1) {
    var I, B;
    v < 16 ? (I = pi(r, n, i, a, f, e[Mt[v]], zt[0], $t[v]), B = mi(u, l, b, g, m, e[Dt[v]], jt[0], Ht[v])) : v < 32 ? (I = bi(r, n, i, a, f, e[Mt[v]], zt[1], $t[v]), B = gi(u, l, b, g, m, e[Dt[v]], jt[1], Ht[v])) : v < 48 ? (I = yi(r, n, i, a, f, e[Mt[v]], zt[2], $t[v]), B = yi(u, l, b, g, m, e[Dt[v]], jt[2], Ht[v])) : v < 64 ? (I = gi(r, n, i, a, f, e[Mt[v]], zt[3], $t[v]), B = bi(u, l, b, g, m, e[Dt[v]], jt[3], Ht[v])) : (I = mi(r, n, i, a, f, e[Mt[v]], zt[4], $t[v]), B = pi(u, l, b, g, m, e[Dt[v]], jt[4], Ht[v])), r = f, f = a, a = ct(i, 10), i = n, n = I, u = m, m = g, g = ct(b, 10), b = l, l = B;
  }
  var P = this._b + i + g | 0;
  this._b = this._c + a + m | 0, this._c = this._d + f + u | 0, this._d = this._e + r + l | 0, this._e = this._a + n + b | 0, this._a = P;
};
Tr.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = Xr.alloc ? Xr.alloc(20) : new Xr(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
function ct(e, t) {
  return e << t | e >>> 32 - t;
}
function pi(e, t, r, n, i, a, f, u) {
  return ct(e + (t ^ r ^ n) + a + f | 0, u) + i | 0;
}
function bi(e, t, r, n, i, a, f, u) {
  return ct(e + (t & r | ~t & n) + a + f | 0, u) + i | 0;
}
function yi(e, t, r, n, i, a, f, u) {
  return ct(e + ((t | ~r) ^ n) + a + f | 0, u) + i | 0;
}
function gi(e, t, r, n, i, a, f, u) {
  return ct(e + (t & n | r & ~n) + a + f | 0, u) + i | 0;
}
function mi(e, t, r, n, i, a, f, u) {
  return ct(e + (t ^ (r | ~n)) + a + f | 0, u) + i | 0;
}
var Nu = Tr, Ps = { exports: {} }, Cs = Ee.Buffer;
function Pr(e, t) {
  this._block = Cs.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
Pr.prototype.update = function(e, t) {
  typeof e == "string" && (t = t || "utf8", e = Cs.from(e, t));
  for (var r = this._block, n = this._blockSize, i = e.length, a = this._len, f = 0; f < i; ) {
    for (var u = a % n, l = Math.min(i - f, n - u), b = 0; b < l; b++)
      r[u + b] = e[f + b];
    a += l, f += l, a % n === 0 && this._update(r);
  }
  return this._len += i, this;
};
Pr.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r = this._len * 8;
  if (r <= 4294967295)
    this._block.writeUInt32BE(r, this._blockSize - 4);
  else {
    var n = (r & 4294967295) >>> 0, i = (r - n) / 4294967296;
    this._block.writeUInt32BE(i, this._blockSize - 8), this._block.writeUInt32BE(n, this._blockSize - 4);
  }
  this._update(this._block);
  var a = this._hash();
  return e ? a.toString(e) : a;
};
Pr.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Tt = Pr, Mu = ge, Ls = Tt, Du = Ee.Buffer, $u = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Hu = new Array(80);
function Qt() {
  this.init(), this._w = Hu, Ls.call(this, 64, 56);
}
Mu(Qt, Ls);
Qt.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function zu(e) {
  return e << 5 | e >>> 27;
}
function ju(e) {
  return e << 30 | e >>> 2;
}
function Gu(e, t, r, n) {
  return e === 0 ? t & r | ~t & n : e === 2 ? t & r | t & n | r & n : t ^ r ^ n;
}
Qt.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, f = this._e | 0, u = 0; u < 16; ++u) t[u] = e.readInt32BE(u * 4);
  for (; u < 80; ++u) t[u] = t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16];
  for (var l = 0; l < 80; ++l) {
    var b = ~~(l / 20), g = zu(r) + Gu(b, n, i, a) + f + t[l] + $u[b] | 0;
    f = a, a = i, i = ju(n), n = r, r = g;
  }
  this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = f + this._e | 0;
};
Qt.prototype._hash = function() {
  var e = Du.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var Wu = Qt, qu = ge, ks = Tt, Vu = Ee.Buffer, Ku = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Yu = new Array(80);
function Zt() {
  this.init(), this._w = Yu, ks.call(this, 64, 56);
}
qu(Zt, ks);
Zt.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Ju(e) {
  return e << 1 | e >>> 31;
}
function Xu(e) {
  return e << 5 | e >>> 27;
}
function Qu(e) {
  return e << 30 | e >>> 2;
}
function Zu(e, t, r, n) {
  return e === 0 ? t & r | ~t & n : e === 2 ? t & r | t & n | r & n : t ^ r ^ n;
}
Zt.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, f = this._e | 0, u = 0; u < 16; ++u) t[u] = e.readInt32BE(u * 4);
  for (; u < 80; ++u) t[u] = Ju(t[u - 3] ^ t[u - 8] ^ t[u - 14] ^ t[u - 16]);
  for (var l = 0; l < 80; ++l) {
    var b = ~~(l / 20), g = Xu(r) + Zu(b, n, i, a) + f + t[l] + Ku[b] | 0;
    f = a, a = i, i = Qu(n), n = r, r = g;
  }
  this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = f + this._e | 0;
};
Zt.prototype._hash = function() {
  var e = Vu.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var ec = Zt, tc = ge, Fs = Tt, rc = Ee.Buffer, nc = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], ic = new Array(64);
function er() {
  this.init(), this._w = ic, Fs.call(this, 64, 56);
}
tc(er, Fs);
er.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function sc(e, t, r) {
  return r ^ e & (t ^ r);
}
function oc(e, t, r) {
  return e & t | r & (e | t);
}
function ac(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function fc(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function uc(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function cc(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
er.prototype._update = function(e) {
  for (var t = this._w, r = this._a | 0, n = this._b | 0, i = this._c | 0, a = this._d | 0, f = this._e | 0, u = this._f | 0, l = this._g | 0, b = this._h | 0, g = 0; g < 16; ++g) t[g] = e.readInt32BE(g * 4);
  for (; g < 64; ++g) t[g] = cc(t[g - 2]) + t[g - 7] + uc(t[g - 15]) + t[g - 16] | 0;
  for (var m = 0; m < 64; ++m) {
    var v = b + fc(f) + sc(f, u, l) + nc[m] + t[m] | 0, I = ac(r) + oc(r, n, i) | 0;
    b = l, l = u, u = f, f = a + v | 0, a = i, i = n, n = r, r = v + I | 0;
  }
  this._a = r + this._a | 0, this._b = n + this._b | 0, this._c = i + this._c | 0, this._d = a + this._d | 0, this._e = f + this._e | 0, this._f = u + this._f | 0, this._g = l + this._g | 0, this._h = b + this._h | 0;
};
er.prototype._hash = function() {
  var e = rc.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var Os = er, lc = ge, hc = Os, dc = Tt, pc = Ee.Buffer, bc = new Array(64);
function Cr() {
  this.init(), this._w = bc, dc.call(this, 64, 56);
}
lc(Cr, hc);
Cr.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Cr.prototype._hash = function() {
  var e = pc.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var yc = Cr, gc = ge, Us = Tt, mc = Ee.Buffer, _i = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], _c = new Array(160);
function tr() {
  this.init(), this._w = _c, Us.call(this, 128, 112);
}
gc(tr, Us);
tr.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function wi(e, t, r) {
  return r ^ e & (t ^ r);
}
function xi(e, t, r) {
  return e & t | r & (e | t);
}
function vi(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function Ei(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function wc(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function xc(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function vc(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function Ec(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function ce(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
tr.prototype._update = function(e) {
  for (var t = this._w, r = this._ah | 0, n = this._bh | 0, i = this._ch | 0, a = this._dh | 0, f = this._eh | 0, u = this._fh | 0, l = this._gh | 0, b = this._hh | 0, g = this._al | 0, m = this._bl | 0, v = this._cl | 0, I = this._dl | 0, B = this._el | 0, P = this._fl | 0, T = this._gl | 0, C = this._hl | 0, F = 0; F < 32; F += 2)
    t[F] = e.readInt32BE(F * 4), t[F + 1] = e.readInt32BE(F * 4 + 4);
  for (; F < 160; F += 2) {
    var k = t[F - 30], L = t[F - 15 * 2 + 1], O = wc(k, L), S = xc(L, k);
    k = t[F - 2 * 2], L = t[F - 2 * 2 + 1];
    var z = vc(k, L), M = Ec(L, k), $ = t[F - 7 * 2], se = t[F - 7 * 2 + 1], Te = t[F - 16 * 2], je = t[F - 16 * 2 + 1], ae = S + se | 0, xe = O + $ + ce(ae, S) | 0;
    ae = ae + M | 0, xe = xe + z + ce(ae, M) | 0, ae = ae + je | 0, xe = xe + Te + ce(ae, je) | 0, t[F] = xe, t[F + 1] = ae;
  }
  for (var ve = 0; ve < 160; ve += 2) {
    xe = t[ve], ae = t[ve + 1];
    var et = xi(r, n, i), Pe = xi(g, m, v), Ge = vi(r, g), Ce = vi(g, r), We = Ei(f, B), Q = Ei(B, f), oe = _i[ve], Be = _i[ve + 1], qe = wi(f, u, l), Ne = wi(B, P, T), w = C + Q | 0, _ = b + We + ce(w, C) | 0;
    w = w + Ne | 0, _ = _ + qe + ce(w, Ne) | 0, w = w + Be | 0, _ = _ + oe + ce(w, Be) | 0, w = w + ae | 0, _ = _ + xe + ce(w, ae) | 0;
    var R = Ce + Pe | 0, D = Ge + et + ce(R, Ce) | 0;
    b = l, C = T, l = u, T = P, u = f, P = B, B = I + w | 0, f = a + _ + ce(B, I) | 0, a = i, I = v, i = n, v = m, n = r, m = g, g = w + R | 0, r = _ + D + ce(g, w) | 0;
  }
  this._al = this._al + g | 0, this._bl = this._bl + m | 0, this._cl = this._cl + v | 0, this._dl = this._dl + I | 0, this._el = this._el + B | 0, this._fl = this._fl + P | 0, this._gl = this._gl + T | 0, this._hl = this._hl + C | 0, this._ah = this._ah + r + ce(this._al, g) | 0, this._bh = this._bh + n + ce(this._bl, m) | 0, this._ch = this._ch + i + ce(this._cl, v) | 0, this._dh = this._dh + a + ce(this._dl, I) | 0, this._eh = this._eh + f + ce(this._el, B) | 0, this._fh = this._fh + u + ce(this._fl, P) | 0, this._gh = this._gh + l + ce(this._gl, T) | 0, this._hh = this._hh + b + ce(this._hl, C) | 0;
};
tr.prototype._hash = function() {
  var e = mc.allocUnsafe(64);
  function t(r, n, i) {
    e.writeInt32BE(r, i), e.writeInt32BE(n, i + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var Ns = tr, Bc = ge, Sc = Ns, Ic = Tt, Ac = Ee.Buffer, Rc = new Array(160);
function Lr() {
  this.init(), this._w = Rc, Ic.call(this, 128, 112);
}
Bc(Lr, Sc);
Lr.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Lr.prototype._hash = function() {
  var e = Ac.allocUnsafe(48);
  function t(r, n, i) {
    e.writeInt32BE(r, i), e.writeInt32BE(n, i + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var Tc = Lr, ht = Ps.exports = function(t) {
  t = t.toLowerCase();
  var r = ht[t];
  if (!r) throw new Error(t + " is not supported (we accept pull requests)");
  return new r();
};
ht.sha = Wu;
ht.sha1 = ec;
ht.sha224 = yc;
ht.sha256 = Os;
ht.sha384 = Tc;
ht.sha512 = Ns;
var Pc = Ps.exports, Ms = Ee.Buffer, Ds = An.Transform, Cc = mr.StringDecoder, Lc = ge;
function Le(e) {
  Ds.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
Lc(Le, Ds);
Le.prototype.update = function(e, t, r) {
  typeof e == "string" && (e = Ms.from(e, t));
  var n = this._update(e);
  return this.hashMode ? this : (r && (n = this._toString(n, r)), n);
};
Le.prototype.setAutoPadding = function() {
};
Le.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
Le.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
Le.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
Le.prototype._transform = function(e, t, r) {
  var n;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (i) {
    n = i;
  } finally {
    r(n);
  }
};
Le.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (r) {
    t = r;
  }
  e(t);
};
Le.prototype._finalOrDigest = function(e) {
  var t = this.__final() || Ms.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
Le.prototype._toString = function(e, t, r) {
  if (this._decoder || (this._decoder = new Cc(t), this._encoding = t), this._encoding !== t) throw new Error("can't switch encodings");
  var n = this._decoder.write(e);
  return r && (n += this._decoder.end()), n;
};
var kc = Le, Fc = ge, Oc = Fu, Uc = Nu, Nc = Pc, $s = kc;
function kr(e) {
  $s.call(this, "digest"), this._hash = e;
}
Fc(kr, $s);
kr.prototype._update = function(e) {
  this._hash.update(e);
};
kr.prototype._final = function() {
  return this._hash.digest();
};
var Mc = function(t) {
  return t = t.toLowerCase(), t === "md5" ? new Oc() : t === "rmd160" || t === "ripemd160" ? new Uc() : new kr(Nc(t));
}, ar = Ee.Buffer;
function Dc(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var n = 0; n < e.length; n++) {
    var i = e.charAt(n), a = i.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[a] = n;
  }
  var f = e.length, u = e.charAt(0), l = Math.log(f) / Math.log(256), b = Math.log(256) / Math.log(f);
  function g(I) {
    if ((Array.isArray(I) || I instanceof Uint8Array) && (I = ar.from(I)), !ar.isBuffer(I))
      throw new TypeError("Expected Buffer");
    if (I.length === 0)
      return "";
    for (var B = 0, P = 0, T = 0, C = I.length; T !== C && I[T] === 0; )
      T++, B++;
    for (var F = (C - T) * b + 1 >>> 0, k = new Uint8Array(F); T !== C; ) {
      for (var L = I[T], O = 0, S = F - 1; (L !== 0 || O < P) && S !== -1; S--, O++)
        L += 256 * k[S] >>> 0, k[S] = L % f >>> 0, L = L / f >>> 0;
      if (L !== 0)
        throw new Error("Non-zero carry");
      P = O, T++;
    }
    for (var z = F - P; z !== F && k[z] === 0; )
      z++;
    for (var M = u.repeat(B); z < F; ++z)
      M += e.charAt(k[z]);
    return M;
  }
  function m(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return ar.alloc(0);
    for (var B = 0, P = 0, T = 0; I[B] === u; )
      P++, B++;
    for (var C = (I.length - B) * l + 1 >>> 0, F = new Uint8Array(C); B < I.length; ) {
      var k = t[I.charCodeAt(B)];
      if (k === 255)
        return;
      for (var L = 0, O = C - 1; (k !== 0 || L < T) && O !== -1; O--, L++)
        k += f * F[O] >>> 0, F[O] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      T = L, B++;
    }
    for (var S = C - T; S !== C && F[S] === 0; )
      S++;
    var z = ar.allocUnsafe(P + (C - S));
    z.fill(0, 0, P);
    for (var M = P; S !== C; )
      z[M++] = F[S++];
    return z;
  }
  function v(I) {
    var B = m(I);
    if (B)
      return B;
    throw new Error("Non-base" + f + " character");
  }
  return {
    encode: g,
    decodeUnsafe: m,
    decode: v
  };
}
var $c = Dc, Hc = $c, zc = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", jc = Hc(zc), Qr = jc, Gc = Ee.Buffer, Wc = function(e) {
  function t(a) {
    var f = e(a);
    return Qr.encode(Gc.concat([
      a,
      f
    ], a.length + 4));
  }
  function r(a) {
    var f = a.slice(0, -4), u = a.slice(-4), l = e(f);
    if (!(u[0] ^ l[0] | u[1] ^ l[1] | u[2] ^ l[2] | u[3] ^ l[3]))
      return f;
  }
  function n(a) {
    var f = Qr.decodeUnsafe(a);
    if (f)
      return r(f);
  }
  function i(a) {
    var f = Qr.decode(a), u = r(f);
    if (!u) throw new Error("Invalid checksum");
    return u;
  }
  return {
    encode: t,
    decode: i,
    decodeUnsafe: n
  };
}, Bi = Mc, qc = Wc;
function Vc(e) {
  var t = Bi("sha256").update(e).digest();
  return Bi("sha256").update(t).digest();
}
var Kc = qc(Vc), un = Kc;
function Hs(e, t) {
  if (t !== void 0 && e[0] !== t) throw new Error("Invalid network version");
  if (e.length === 33)
    return {
      version: e[0],
      privateKey: e.slice(1, 33),
      compressed: !1
    };
  if (e.length !== 34) throw new Error("Invalid WIF length");
  if (e[33] !== 1) throw new Error("Invalid compression flag");
  return {
    version: e[0],
    privateKey: e.slice(1, 33),
    compressed: !0
  };
}
function cn(e, t, r) {
  var n = new Buffer(r ? 34 : 33);
  return n.writeUInt8(e, 0), t.copy(n, 1), r && (n[33] = 1), n;
}
function Yc(e, t) {
  return Hs(un.decode(e), t);
}
function Jc(e, t, r) {
  return typeof e == "number" ? un.encode(cn(e, t, r)) : un.encode(
    cn(
      e.version,
      e.privateKey,
      e.compressed
    )
  );
}
var Xc = {
  decode: Yc,
  decodeRaw: Hs,
  encode: Jc,
  encodeRaw: cn
}, Fr = {};
Object.defineProperty(Fr, "__esModule", { value: !0 });
Fr.testEcc = void 0;
const H = (e) => Buffer.from(e, "hex");
function Qc(e) {
  J(
    e.isPoint(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    !e.isPoint(
      H("030000000000000000000000000000000000000000000000000000000000000005")
    )
  ), J(
    e.isPrivate(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    e.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), J(
    !e.isPrivate(
      H("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), J(
    !e.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
    )
  ), J(
    !e.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
    )
  ), J(
    Buffer.from(
      e.privateAdd(
        H("0000000000000000000000000000000000000000000000000000000000000001"),
        H("0000000000000000000000000000000000000000000000000000000000000000")
      )
    ).equals(
      H("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), J(
    e.privateAdd(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      H("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null
  ), J(
    Buffer.from(
      e.privateAdd(
        H("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
        H("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
      )
    ).equals(
      H("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    )
  ), J(
    Buffer.from(
      e.privateNegate(
        H("0000000000000000000000000000000000000000000000000000000000000001")
      )
    ).equals(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), J(
    Buffer.from(
      e.privateNegate(
        H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      )
    ).equals(
      H("0000000000000000000000000000000000000000000000000000000000000003")
    )
  ), J(
    Buffer.from(
      e.privateNegate(
        H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      H("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    )
  ), J(
    Buffer.from(
      e.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !0
      )
    ).equals(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    Buffer.from(
      e.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        !1
      )
    ).equals(
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), J(
    Buffer.from(
      e.pointCompress(
        H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !0
      )
    ).equals(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    Buffer.from(
      e.pointCompress(
        H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        !1
      )
    ).equals(
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), J(
    Buffer.from(
      e.pointFromScalar(
        H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      H("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    )
  ), J(
    e.xOnlyPointAddTweak(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null
  );
  let t = e.xOnlyPointAddTweak(
    H("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    H("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  J(
    Buffer.from(t.xOnlyPubkey).equals(
      H("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && t.parity === 1
  ), t = e.xOnlyPointAddTweak(
    H("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    H("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), J(
    Buffer.from(t.xOnlyPubkey).equals(
      H("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && t.parity === 0
  ), J(
    Buffer.from(
      e.sign(
        H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ).equals(
      H(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), J(
    e.verify(
      H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      H("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      H(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), e.signSchnorr && J(
    Buffer.from(
      e.signSchnorr(
        H("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        H("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
        H("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
      )
    ).equals(
      H(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  ), e.verifySchnorr && J(
    e.verifySchnorr(
      H("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      H("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
      H(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  );
}
Fr.testEcc = Qc;
function J(e) {
  if (!e) throw new Error("ecc library invalid");
}
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.ECPairFactory = Et.networks = void 0;
const ln = Bt;
Et.networks = ln;
const _e = es, Zc = If, Si = Xc, el = Fr, Zr = _e.typeforce.maybe(
  _e.typeforce.compile({
    compressed: _e.maybe(_e.Boolean),
    network: _e.maybe(_e.Network)
  })
), tl = (e) => e.length === 32 ? e : e.slice(1, 33);
function rl(e) {
  (0, el.testEcc)(e);
  function t(u) {
    return e.isPoint(u);
  }
  function r(u, l) {
    if (_e.typeforce(_e.Buffer256bit, u), !e.isPrivate(u))
      throw new TypeError("Private key not in range [1, n)");
    return _e.typeforce(Zr, l), new f(u, void 0, l);
  }
  function n(u, l) {
    return _e.typeforce(e.isPoint, u), _e.typeforce(Zr, l), new f(void 0, u, l);
  }
  function i(u, l) {
    const b = Si.decode(u), g = b.version;
    if (_e.Array(l)) {
      if (l = l.filter((m) => g === m.wif).pop(), !l) throw new Error("Unknown network version");
    } else if (l = l || ln.bitcoin, g !== l.wif) throw new Error("Invalid network version");
    return r(b.privateKey, {
      compressed: b.compressed,
      network: l
    });
  }
  function a(u) {
    _e.typeforce(Zr, u), u === void 0 && (u = {});
    const l = u.rng || Zc;
    let b;
    do
      b = l(32), _e.typeforce(_e.Buffer256bit, b);
    while (!e.isPrivate(b));
    return r(b, u);
  }
  class f {
    constructor(l, b, g) {
      bt(this, "__D");
      bt(this, "__Q");
      bt(this, "compressed");
      bt(this, "network");
      bt(this, "lowR");
      this.__D = l, this.__Q = b, this.lowR = !1, g === void 0 && (g = {}), this.compressed = g.compressed === void 0 ? !0 : g.compressed, this.network = g.network || ln.bitcoin, b !== void 0 && (this.__Q = Buffer.from(e.pointCompress(b, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const l = e.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer.from(l);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error("Missing private key");
      return Si.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(l) {
      return this.privateKey ? this.tweakFromPrivateKey(l) : this.tweakFromPublicKey(l);
    }
    sign(l, b) {
      if (!this.__D) throw new Error("Missing private key");
      if (b === void 0 && (b = this.lowR), b === !1)
        return Buffer.from(e.sign(l, this.__D));
      {
        let g = e.sign(l, this.__D);
        const m = Buffer.alloc(32, 0);
        let v = 0;
        for (; g[0] > 127; )
          v++, m.writeUIntLE(v, 0, 6), g = e.sign(l, this.__D, m);
        return Buffer.from(g);
      }
    }
    signSchnorr(l) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!e.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer.from(e.signSchnorr(l, this.privateKey));
    }
    verify(l, b) {
      return e.verify(l, this.publicKey, b);
    }
    verifySchnorr(l, b) {
      if (!e.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e.verifySchnorr(l, this.publicKey.subarray(1, 33), b);
    }
    tweakFromPublicKey(l) {
      const b = tl(this.publicKey), g = e.xOnlyPointAddTweak(b, l);
      if (!g || g.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const m = Buffer.from([
        g.parity === 0 ? 2 : 3
      ]);
      return n(
        Buffer.concat([m, g.xOnlyPubkey]),
        { network: this.network, compressed: this.compressed }
      );
    }
    tweakFromPrivateKey(l) {
      const g = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1 ? e.privateNegate(this.privateKey) : this.privateKey, m = e.privateAdd(g, l);
      if (!m) throw new Error("Invalid tweaked private key!");
      return r(Buffer.from(m), {
        network: this.network,
        compressed: this.compressed
      });
    }
  }
  return {
    isPoint: t,
    fromPrivateKey: r,
    fromPublicKey: n,
    fromWIF: i,
    makeRandom: a
  };
}
Et.ECPairFactory = rl;
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.networks = e.ECPairFactory = e.default = void 0;
  var t = Et;
  Object.defineProperty(e, "default", {
    enumerable: !0,
    get: function() {
      return t.ECPairFactory;
    }
  }), Object.defineProperty(e, "ECPairFactory", {
    enumerable: !0,
    get: function() {
      return t.ECPairFactory;
    }
  }), Object.defineProperty(e, "networks", {
    enumerable: !0,
    get: function() {
      return t.networks;
    }
  });
})(Zi);
const nl = /* @__PURE__ */ sf(Zi);
class hn {
  constructor(t) {
    this.privKey = t;
  }
  static fromPrivKey(t) {
    return new hn(nt(t));
  }
  static async fromWalletClient(t) {
    if (!t.account) return N("No account found");
    try {
      const r = await t.signTypedData({
        account: t.account,
        types: {
          EIP712Domain: [
            { name: "name", type: "string" },
            { name: "version", type: "string" }
          ],
          Data: [
            { name: "Message", type: "string" },
            { name: "Version", type: "string" },
            { name: "Nonce", type: "uint256" }
          ]
        },
        domain: {
          name: "WBTC GARDEN",
          version: "1"
        },
        primaryType: "Data",
        message: {
          Message: "Initialize your account",
          Version: "1.0.2",
          Nonce: 1n
        }
      });
      return ue(new hn(nt(ir(r))));
    } catch (r) {
      return N("Failed to initialize: " + r);
    }
  }
  getMasterPrivKey() {
    return this.privKey;
  }
  generateSecret(t) {
    const r = this.signMessage(t), n = ir(fr(r)), i = ir(n);
    return ue({ secret: n, secretHash: i });
  }
  signMessage(t) {
    const r = nl(st), n = "Garden.fi" + t.toString(), i = Buffer.from(n, "utf8"), a = ir(i), f = Buffer.from(nt(this.privKey), "hex");
    if (f.length !== 32)
      throw new Error("Invalid private key length. Expected 32 bytes.");
    return r.fromPrivateKey(f).sign(Buffer.from(nt(a), "hex")).toString("hex");
  }
}
class _l {
  constructor(t) {
    this.quoteUrl = new dn("/quote", t);
  }
  async getQuote(t, r, n = !1) {
    try {
      const i = this.quoteUrl.addSearchParams({
        order_pair: t,
        amount: r.toString(),
        exact_out: n.toString()
      }), a = await _t.get(i);
      return a.error ? N(a.error) : a.result ? ue(a.result) : N("GetQuote: Unexpected error, result is undefined");
    } catch (i) {
      return N("GetQuote:", String(i));
    }
  }
  async getAttestedQuote(t) {
    try {
      const r = await _t.post(this.quoteUrl.endpoint("/attested").toString(), {
        body: JSON.stringify(t),
        headers: {
          "Content-Type": "application/json"
        }
      });
      return r.error ? N(r.error) : r.result ? ue(r.result) : N("GetAttestedQuote: Unexpected error, result is undefined");
    } catch (r) {
      return console.log("error :", r), N("GetAttestedQuote:", String(r));
    }
  }
  async getStrategies() {
    try {
      const t = await _t.get(
        this.quoteUrl.endpoint("/strategies")
      );
      if (t.error) return N(t.error);
      if (!t.result)
        return N("GetStrategies: Unexpected error, result is undefined");
      const r = {};
      for (const n of Object.values(t.result)) {
        const i = Ka(
          n.source_chain,
          n.source_asset.asset,
          n.dest_chain,
          n.dest_asset.asset
        );
        r[i] = {
          id: n.id,
          minAmount: n.min_amount,
          maxAmount: n.max_amount
        };
      }
      return ue(r);
    } catch (t) {
      return N("GetStrategies:", String(t));
    }
  }
}
export {
  gl as BlockNumberFetcher,
  Xa as EvmRelay,
  yl as Garden,
  le as OrderActions,
  te as OrderStatus,
  Xi as ParseOrderStatus,
  Kn as ParseSwapStatus,
  _l as Quote,
  hn as SecretManager,
  re as SwapStatus,
  en as TimeLocks,
  Ka as constructOrderPair,
  qa as evmToViemChainMap,
  Ya as filterDeadlineExpiredOrders,
  pr as isExpired,
  bl as parseAction,
  Qi as parseActionFromStatus,
  dl as switchOrAddNetwork,
  pl as validateBTCAddress
};
