var y = (t, e, r) => {
  if (!e.has(t))
    throw TypeError("Cannot " + r);
};
var u = (t, e, r) => (y(t, e, "read from private field"), r ? r.call(t) : e.get(t)), h = (t, e, r) => {
  if (e.has(t))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(t) : e.set(t, r);
}, l = (t, e, r, s) => (y(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r);
const d = (t) => new Promise((e) => setTimeout(e, t));
class x {
  /**
   * @param {number} maxRetries - The maximum number of retries, if less < 0 then it is set to 0
   * @param {number} delay - The delay between retries
   */
  constructor(e, r) {
    this.maxRetries = Math.max(e, 0), this.delay = r;
  }
  /**
   * Retries a function until it succeeds or the max number of retries is reached
   *
   * @param {() => Promise<T>} fn - The function to retry
   * @return {Promise<T>} a Promise that resolves to the result of the function
   */
  async retry(e) {
    let r = 0, s;
    for (; r < this.maxRetries + 1; )
      try {
        return await e();
      } catch (n) {
        r++, s = n, await d(this.delay * r);
      }
    throw s;
  }
}
const p = (t) => {
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
};
class k {
  static async _postWithFallback(e, r) {
    let s = "";
    for (const n of e)
      try {
        const a = await fetch(n, {
          method: "POST",
          ...r
        });
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback logic.
   *
   * @param {string[]} input - array of URLs to send the POST request to
   * @param {RequestInit} [init] - optional request initialization options
   * @return {Promise<T>} a Promise that resolves to the parsed response data
   */
  static async postWithFallback(e, r) {
    return await f(r).retry(
      () => this._postWithFallback(e, r)
    );
  }
  static async _getWithFallback(e, r) {
    let s = "";
    for (const n of e)
      try {
        const a = await fetch(n, r);
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback mechanism.
   *
   * @param {string[]} input - An array of URLs to retrieve data from.
   * @param {RequestInit} [init] - Optional request options.
   * @return {Promise<T>} A promise that resolves to the retrieved data.
   */
  static async getWithFallback(e, r) {
    return await f(r).retry(
      () => this._getWithFallback(e, r)
    );
  }
  static async _get(e, r) {
    return await this.parse(await fetch(e, r));
  }
  /**
   * Asynchronously retrieves data of type T from the specified URL or RequestInfo, with optional initialization options.
   *
   * @param {RequestInfo | URL} input - The URL or RequestInfo to fetch data from
   * @param {RequestInit} init - Optional initialization options for the fetch request
   * @return {Promise<T>} The retrieved data of type T
   */
  static async get(e, r) {
    return await f(r).retry(() => this._get(e, r));
  }
  static async _post(e, r) {
    return await this.parse(
      await fetch(e, {
        method: "POST",
        ...r
      })
    );
  }
  /**
   * Asynchronously sends a POST request to the specified URL or RequestInfo, with optional initialization options.
   */
  static async post(e, r) {
    return await f(r).retry(() => this._post(e, r));
  }
  /**
   * Parses the response and returns the result as the specified type.
   *
   * @param {Response} res - the response object to be parsed
   * @return {Promise<T>} the parsed result of type T
   */
  static async parse(e) {
    const r = await e.text();
    if (e.status >= 200 && e.status < 300)
      return p(r);
    throw new Error(r);
  }
}
function g(t) {
  return (t == null ? void 0 : t.message) || (t == null ? void 0 : t.toString()) || "unknown error";
}
const f = (t) => new x((t == null ? void 0 : t.retryCount) ?? 2, (t == null ? void 0 : t.retryDelay) ?? 1e3);
class S {
  constructor(e) {
    this.url = e;
  }
  /**
   * Sends a request and returns a response.
   *
   * @param {RpcRequest} request - The request to send.
   * @return {Promise<RpcResponse<T>>} - A promise that resolves to the response.
   */
  async sendRequest(e) {
    try {
      return await k.post(this.url, {
        body: JSON.stringify(e)
      });
    } catch (r) {
      return p(r.message);
    }
  }
}
const _ = (t, e) => {
  if (!t)
    throw new Error(e);
  return t;
}, E = (t) => t.startsWith("0x") ? t : `0x${t}`, R = (t) => t.startsWith("0x") ? t.slice(2) : t;
var c, i, o;
class w {
  constructor(e, r, s = void 0) {
    h(this, c, void 0);
    h(this, i, void 0);
    h(this, o, void 0);
    l(this, c, e), l(this, o, s), l(this, i, r);
  }
  get ok() {
    return u(this, c);
  }
  get error() {
    return u(this, o);
  }
  get val() {
    return u(this, i);
  }
}
c = new WeakMap(), i = new WeakMap(), o = new WeakMap();
const W = (t) => new w(!0, t), O = void 0, b = (t, ...e) => {
  if (typeof t == "string" && e && e.length > 0) {
    let r = [t, ...e].map((s) => {
      if (s) {
        if (s instanceof Error)
          return s.message;
        if (typeof s == "string")
          return s;
        if (typeof s == "object")
          return JSON.stringify(s);
        if (s != null && s.toString)
          return s.toString();
      }
    });
    return new w(
      !1,
      null,
      r.filter((s) => s !== void 0).join(" ")
    );
  }
  return new w(!1, null, t);
};
async function P(t, e = "Failed to execute") {
  try {
    const r = await t();
    return r instanceof w ? r : W(r);
  } catch (r) {
    return b(e + ": ", r);
  }
}
export {
  b as Err,
  k as Fetcher,
  S as JsonRpc,
  W as Ok,
  w as Result,
  x as Retry,
  O as Void,
  _ as ensureVal,
  P as executeWithTryCatch,
  p as safeParseJson,
  d as sleep,
  R as trim0x,
  E as with0x
};
