import { bytes as f } from "./index51.js";
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const s = (t) => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), y = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, r = (t) => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;
function p(t) {
  for (let e = 0; e < t.length; e++)
    t[e] = r(t[e]);
}
function c(t) {
  if (typeof t != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof t}`);
  return new Uint8Array(new TextEncoder().encode(t));
}
function u(t) {
  return typeof t == "string" && (t = c(t)), f(t), t;
}
class b {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function x(t) {
  const e = (o) => t().update(u(o)).digest(), n = t();
  return e.outputLen = n.outputLen, e.blockLen = n.blockLen, e.create = () => t(), e;
}
export {
  b as Hash,
  r as byteSwap,
  p as byteSwap32,
  y as isLE,
  u as toBytes,
  s as u32,
  c as utf8ToBytes,
  x as wrapConstructor
};
