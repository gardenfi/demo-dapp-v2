const o = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map();
let y = 0;
function M(t, i, w) {
  const l = ++y, e = () => o.get(t) || [], C = () => {
    const n = e();
    o.set(t, n.filter((c) => c.id !== l));
  }, f = () => {
    const n = h.get(t);
    e().length === 1 && n && n(), C();
  }, s = e();
  if (o.set(t, [
    ...s,
    { id: l, fns: i }
  ]), s && s.length > 0)
    return f;
  const u = {};
  for (const n in i)
    u[n] = (...c) => {
      var p, g;
      const r = e();
      if (r.length !== 0)
        for (const k of r)
          (g = (p = k.fns)[n]) == null || g.call(p, ...c);
    };
  const a = w(u);
  return typeof a == "function" && h.set(t, a), f;
}
export {
  h as cleanupCache,
  o as listenersCache,
  M as observe
};
