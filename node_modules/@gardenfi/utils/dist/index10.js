import { BlockNotFoundError as j } from "./index15.js";
import { WaitForTransactionReceiptTimeoutError as x, TransactionNotFoundError as A, TransactionReceiptNotFoundError as M } from "./index21.js";
import { getAction as p } from "./index27.js";
import { observe as O } from "./index28.js";
import { withRetry as R } from "./index31.js";
import { stringify as P } from "./index30.js";
import { getBlock as W } from "./index14.js";
import { getTransaction as q } from "./index20.js";
import { getTransactionReceipt as v } from "./index23.js";
import { watchBlockNumber as z } from "./index25.js";
async function Y(o, {
  confirmations: n = 1,
  hash: b,
  onReplaced: y,
  pollingInterval: B = o.pollingInterval,
  retryCount: T = 6,
  retryDelay: N = ({ count: m }) => ~~(1 << m) * 200,
  // exponential backoff
  timeout: w = 18e4
}) {
  const m = P(["waitForTransactionReceipt", o.uid, b]);
  let a, c, r, i = !1;
  return new Promise((F, g) => {
    w && setTimeout(() => g(new x({ hash: b })), w);
    const h = O(m, { onReplaced: y, resolve: F, reject: g }, (e) => {
      const E = p(o, z, "watchBlockNumber")({
        emitMissed: !0,
        emitOnBegin: !0,
        poll: !0,
        pollingInterval: B,
        async onBlockNumber(_) {
          const l = (f) => {
            E(), f(), h();
          };
          let u = _;
          if (!i)
            try {
              if (r) {
                if (n > 1 && (!r.blockNumber || u - r.blockNumber + 1n < n))
                  return;
                l(() => e.resolve(r));
                return;
              }
              if (a || (i = !0, await R(async () => {
                a = await p(o, q, "getTransaction")({ hash: b }), a.blockNumber && (u = a.blockNumber);
              }, {
                delay: N,
                retryCount: T
              }), i = !1), r = await p(o, v, "getTransactionReceipt")({ hash: b }), n > 1 && (!r.blockNumber || u - r.blockNumber + 1n < n))
                return;
              l(() => e.resolve(r));
            } catch (f) {
              if (f instanceof A || f instanceof M) {
                if (!a) {
                  i = !1;
                  return;
                }
                try {
                  c = a, i = !0;
                  const d = await R(() => p(o, W, "getBlock")({
                    blockNumber: u,
                    includeTransactions: !0
                  }), {
                    delay: N,
                    retryCount: T,
                    shouldRetry: ({ error: s }) => s instanceof j
                  });
                  i = !1;
                  const t = d.transactions.find(({ from: s, nonce: I }) => s === c.from && I === c.nonce);
                  if (!t || (r = await p(o, v, "getTransactionReceipt")({
                    hash: t.hash
                  }), n > 1 && (!r.blockNumber || u - r.blockNumber + 1n < n)))
                    return;
                  let k = "replaced";
                  t.to === c.to && t.value === c.value ? k = "repriced" : t.from === t.to && t.value === 0n && (k = "cancelled"), l(() => {
                    var s;
                    (s = e.onReplaced) == null || s.call(e, {
                      reason: k,
                      replacedTransaction: c,
                      transaction: t,
                      transactionReceipt: r
                    }), e.resolve(r);
                  });
                } catch (d) {
                  l(() => e.reject(d));
                }
              } else
                l(() => e.reject(f));
            }
        }
      });
    });
  });
}
export {
  Y as waitForTransactionReceipt
};
