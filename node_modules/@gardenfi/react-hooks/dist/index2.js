import S, { createContext as T, useState as b, useMemo as m, useEffect as R } from "react";
import { useWalletClient as V } from "wagmi";
import { useSecretManager as j } from "./index4.js";
import { useOrderbook as D } from "./index3.js";
import { Quote as H, BlockNumberFetcher as J, Garden as F, switchOrAddNetwork as G, EvmRelay as N } from "@gardenfi/core";
import { Err as i, Ok as p } from "@catalogfi/utils";
import { isBitcoin as x } from "@gardenfi/orderbook";
import { BitcoinNetwork as W, BitcoinProvider as L, BitcoinWallet as E } from "@catalogfi/wallets";
import { Siwe as X, Url as Y } from "@gardenfi/utils";
import { constructOrderpair as Z } from "./index5.js";
const g = T({
  isExecuting: !1
}), ce = ({
  children: v,
  config: r
}) => {
  const [l, z] = b(), [s, B] = b(), [n, A] = b(), [f, P] = b(), K = m(
    () => !!(l && s && n && f),
    [l, s, n, f]
  ), u = m(() => new H(r.quoteUrl), [r.quoteUrl]), U = m(() => {
    const e = r.network === W.Mainnet ? "mainnet" : r.network === W.Testnet ? "testnet" : void 0;
    return r.blockNumberFetcherUrl && e ? new J(
      r.blockNumberFetcherUrl,
      e
    ) : void 0;
  }, [r.blockNumberFetcherUrl, r.network]), y = m(
    () => new L(r.network, r.bitcoinRPCUrl),
    [r.network, r.bitcoinRPCUrl]
  ), { data: a } = V(), { initializeSecretManager: O } = j(z), { orderbook: h } = D(
    r.orderBookUrl,
    n,
    P,
    U
  ), M = async () => {
    if (!a || !n)
      return i("WalletClient or auth not initialized");
    const e = await O();
    if (e.error) return i(e.error);
    const o = E.fromPrivateKey(
      e.val.getMasterPrivKey(),
      y
    ), t = new F({
      orderbookURl: r.orderBookUrl,
      secretManager: e.val,
      quote: u,
      auth: n,
      wallets: {
        evmWallet: a,
        btcWallet: o
      },
      blockNumberFetcher: U
    });
    return B(t), p(t);
  }, q = async (e) => {
    if (!h || !a || !n)
      return i("Orderbook or walletClient or auth not initialized");
    let o = s;
    if (!l || !o) {
      const C = await M();
      if (C.error) return i(C.error);
      o = C.val;
    }
    const t = await o.swap(e);
    if (t.error) return i(t.error);
    if (x(t.val.source_swap.chain)) return p(t.val);
    const c = await G(
      e.fromAsset.chain,
      a
    );
    if (c.error)
      return i("Failed to switch network: " + c.error);
    const _ = c.val.walletClient, d = await new N(t.val, r.orderBookUrl, n).init(_);
    if (d.error) return i(d.error);
    const w = {
      ...t.val,
      source_swap: {
        ...t.val.source_swap,
        initiate_tx_hash: d.val
      }
    };
    return p(w);
  }, Q = async (e) => {
    if (!a || !n)
      return i("Orderbook or walletClient or auth not initialized");
    if (x(e.source_swap.chain))
      return i("Not an EVM order: sourceSwap.chain is Bitcoin");
    let o = s;
    if (!l || !o) {
      const w = await M();
      if (w.error) return i(w.error);
      o = w.val;
    }
    const t = await G(
      e.source_swap.chain,
      a
    );
    if (t.error)
      return i("Failed to switch network: " + t.error);
    const c = t.val.walletClient, k = await new N(e, r.orderBookUrl, n).init(c);
    if (k.error) return i(k.error);
    const d = {
      ...e,
      source_swap: {
        ...e.source_swap,
        initiate_tx_hash: k.val
      }
    };
    return p(d);
  }, I = m(
    () => async ({ fromAsset: e, toAsset: o, amount: t, isExactOut: c = !1 }) => await u.getQuote(
      Z(e, o),
      t,
      c
    ),
    [u]
  );
  return R(() => {
    if (!a) return;
    const e = new X(new Y(r.orderBookUrl), a, {
      store: r.store
    });
    A(e);
  }, [a]), R(() => {
    if (!l || !a || !h || !n) return;
    const e = E.fromPrivateKey(
      l.getMasterPrivKey(),
      y
    ), o = new F({
      orderbookURl: r.orderBookUrl,
      secretManager: l,
      quote: u,
      auth: n,
      wallets: {
        evmWallet: a,
        btcWallet: e
      },
      blockNumberFetcher: U
    });
    B(o);
  }, [l, a, h, n]), R(() => {
    if (!s) return;
    const e = s.execute(), o = (t) => P(t);
    return s.on("onPendingOrdersChanged", o), () => {
      (async () => (await e)())(), s.off("onPendingOrdersChanged", o);
    };
  }, [s]), /* @__PURE__ */ S.createElement(
    g.Provider,
    {
      value: {
        orderBookUrl: r.orderBookUrl,
        initializeSecretManager: O,
        orderBook: h,
        swapAndInitiate: q,
        pendingOrders: f,
        getQuote: I,
        secretManager: l,
        garden: s,
        isExecuting: K,
        evmInitiate: Q,
        quote: u
      }
    },
    v
  );
}, ue = () => {
  const v = S.useContext(g);
  if (!v)
    throw new Error("useGarden must be used within a GardenProvider");
  return v;
};
export {
  g as GardenContext,
  ce as GardenProvider,
  ue as useGarden
};
