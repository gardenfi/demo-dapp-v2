import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  C,
  N,
  i,
  o,
  o2,
  r,
  r2,
  x
} from "./chunk-7UECOOSC.js";
import {
  createWalletClient,
  custom,
  getContract
} from "./chunk-EPBOGNF7.js";
import {
  sha256
} from "./chunk-XBLCQEYA.js";
import {
  require_src,
  require_varuint_bitcoin,
  s
} from "./chunk-IAEW6RMH.js";
import {
  isPoint,
  lib_exports,
  pointAdd,
  pointMultiply,
  verifySchnorr
} from "./chunk-6BCIRRQU.js";
import {
  R,
  W,
  b,
  k
} from "./chunk-64BDWLZ5.js";
import {
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-HKR3LW4X.js";

// node_modules/@gardenfi/core/dist/index.js
var import_dist25 = __toESM(require_dist());
var import_dist26 = __toESM(require_dist2());
var import_dist27 = __toESM(require_dist3());

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index.js
var import_dist19 = __toESM(require_dist());
var import_dist20 = __toESM(require_dist2());
var import_dist21 = __toESM(require_dist3());

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index2.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index6.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var n = "https://api.garden.finance";

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index4.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index7.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var i2 = (o4, e2, t3) => {
  const r4 = o4.endpoint(e2);
  return t3 && Object.entries(t3).forEach(([c2, n4]) => {
    n4 !== void 0 && r4.searchParams.append(c2, n4.toString());
  }), r4;
};

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index4.js
var w = class {
  constructor(t3) {
    this.url = new r2("/orders", t3);
  }
  async getOrder(t3, o4) {
    const e2 = o4 ? `/id/matched/${t3}` : `/id/unmatched/${t3}`, n4 = this.url.endpoint(e2);
    try {
      const r4 = await k.get(n4);
      return r4.error ? b(r4.error) : r4.result ? W(r4.result) : b("GetOrder: Unexpected error, result is undefined");
    } catch (r4) {
      return b("GetOrder:", String(r4));
    }
  }
  async getMatchedOrders(t3, o4, e2) {
    const n4 = i2(this.url, `/user/matched/${t3}`, {
      ...e2,
      pending: o4
    });
    try {
      const r4 = await k.get(
        n4
      );
      return r4.error ? b(r4.error) : r4.result ? W(r4.result) : b("GetMatchedOrders: Unexpected error, result is undefined");
    } catch (r4) {
      return b("GetMatchedOrders:", String(r4));
    }
  }
  async getUnMatchedOrders(t3, o4) {
    const e2 = i2(
      this.url,
      `/user/unmatched/${t3}`,
      o4
    );
    try {
      const n4 = await k.get(
        e2
      );
      return n4.error ? b(n4.error) : n4.result ? W(n4.result) : b("GetUnMatchedOrders: Unexpected error, result is undefined");
    } catch (n4) {
      return b("GetUnMatchedOrders:", String(n4));
    }
  }
  async getOrders(t3, o4) {
    const e2 = t3 ? "/matched" : "/unmatched", n4 = i2(this.url, e2, o4);
    try {
      const r4 = await k.get(n4);
      return r4.error ? b(r4.error) : r4.result ? W(r4.result) : b("GetAllOrders: Unexpected error, result is undefined");
    } catch (r4) {
      return b("GetAllOrders:", String(r4));
    }
  }
  async subscribeOrders(t3, o4, e2, n4, r4 = false, l) {
    let a2 = false;
    const h = async () => {
      if (!a2) {
        a2 = true;
        try {
          const c2 = o4 ? await this.getMatchedOrders(t3, r4, l) : await this.getUnMatchedOrders(t3, l);
          c2.ok ? await n4(
            c2.val
          ) : console.error("Error fetching orders:", c2.error);
        } catch (c2) {
          console.error("Error fetching orders:", c2);
        } finally {
          a2 = false;
        }
      }
    };
    await h();
    const O = setInterval(h, e2);
    return () => {
      clearInterval(O);
    };
  }
  async getOrdersCount(t3) {
    const o4 = this.url.endpoint(`/user/count/${t3}`);
    try {
      const e2 = await k.get(o4);
      return e2.error ? b(e2.error) : e2.status === o.Ok && e2.result !== void 0 ? W(e2.result) : b("GetOrdersCount: Unexpected error, result is undefined");
    } catch (e2) {
      return b("GetOrdersCount:", String(e2));
    }
  }
};

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index2.js
var c = class _c2 extends w {
  /**
   * Creates an instance of Orderbook. Does not login to the orderbook.
   * @constructor
   * @param {OrderbookConfig} orderbookConfig - The configuration object for the orderbook.
   */
  constructor(r4) {
    const e2 = new r2(
      "/relayer",
      r4.url ?? n
    );
    super(e2), this.Url = e2, this.walletClient = r4.walletClient, this.auth = r4.auth;
  }
  /**
   * Initializes the orderbook as well as logs in the orderbook (fetches the auth token).
   * @param {OrderbookConfig} orderbookConfig - The configuration object for the orderbook.
   */
  static async init(r4) {
    return await r4.auth.getToken(), new _c2(r4);
  }
  /**
   * Creates an order
   * @param {CreateOrderConfig} createOrderConfig - The configuration for the creating the order.
   * @returns {string} The create order ID.
   */
  async createOrder(r4) {
    const e2 = await this.auth.getToken();
    if (e2.error) return b(e2.error);
    try {
      const t3 = await k.post(
        this.Url.endpoint("create-order"),
        {
          body: JSON.stringify(r4),
          headers: {
            Authorization: r(e2.val),
            "Content-Type": "application/json"
          }
        }
      );
      return t3.error ? b(t3.error) : t3.result ? W(t3.result) : b("CreateOrder: Unexpected error, result is undefined");
    } catch (t3) {
      return b("CreateOrder:", String(t3));
    }
  }
  async fetchOrders(r4, e2 = false, t3) {
    var n4;
    const a2 = (n4 = this.walletClient.account) == null ? void 0 : n4.address;
    return a2 ? r4 ? await super.getMatchedOrders(
      a2,
      e2,
      t3
    ) : await super.getUnMatchedOrders(
      a2,
      t3
    ) : b("Wallet client does not have an account");
  }
  /**
   * Wrapper for the subscribeOrders method in the OrdersProvider class to abstract the address parameter.
   * @param matched - Whether to get matched or unmatched orders
   * @param interval - The interval to poll for updates
   * @param cb - The callback to be called when the orders are updated
   * @param paginationConfig - The configuration for the pagination
   * @returns {() => void} A function to unsubscribe from the order updates
   */
  async subscribeToOrders(r4, e2, t3, a2, n4) {
    var u2;
    const i5 = (u2 = this.walletClient.account) == null ? void 0 : u2.address;
    return i5 ? await super.subscribeOrders(
      i5,
      r4,
      e2,
      t3,
      n4,
      a2
    ) : () => {
    };
  }
  async getUserOrdersCount() {
    var e2;
    const r4 = (e2 = this.walletClient.account) == null ? void 0 : e2.address;
    return r4 ? super.getOrdersCount(r4) : b("Wallet client does not have an account");
  }
};

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index3.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
var r3 = ((e2) => (e2.Bitcoin = "Bitcoin", e2.EVM = "EVM", e2))(r3 || {});
var i3 = ((e2) => (e2.mainnet = "mainnet", e2.testnet = "testnet", e2.localnet = "localnet", e2))(i3 || {});
var t = {
  bitcoin: "bitcoin",
  bitcoin_testnet: "bitcoin_testnet",
  bitcoin_regtest: "bitcoin_regtest",
  ethereum: "ethereum",
  ethereum_arbitrum: "ethereum_arbitrum",
  ethereum_sepolia: "ethereum_sepolia",
  arbitrum_localnet: "arbitrum_localnet",
  arbitrum_sepolia: "arbitrum_sepolia",
  ethereum_localnet: "ethereum_localnet",
  base_sepolia: "base_sepolia"
};
var s2 = (e2) => !(e2 === t.ethereum_sepolia || e2 === t.bitcoin_testnet || e2 === t.bitcoin_regtest || e2 === t.arbitrum_localnet || e2 === t.ethereum_localnet || e2 === t.arbitrum_sepolia || e2 === t.base_sepolia);
var o3 = (e2) => e2 === t.bitcoin || e2 === t.bitcoin_testnet || e2 === t.bitcoin_regtest;
var n2 = (e2) => e2 === t.ethereum || e2 === t.ethereum_arbitrum || e2 === t.ethereum_sepolia || e2 === t.ethereum_localnet || e2 === t.arbitrum_localnet || e2 === t.arbitrum_sepolia || e2 === t.base_sepolia;
var u = (e2) => {
  if (o3(e2)) return "Bitcoin";
  if (n2(e2)) return "EVM";
  throw new Error("Invalid or unsupported chain");
};

// node_modules/@gardenfi/core/node_modules/@gardenfi/orderbook/dist/index5.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var s3 = {
  id: 31338,
  name: "Arbitrum Localnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://localhost:8546/"]
    }
  },
  testnet: true
};
var i4 = {
  id: 31337,
  name: "Ethereum Localnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://localhost:8545/"]
    }
  },
  testnet: true
};
var n3 = {
  name: "Bitcoin Regtest",
  decimals: 8,
  symbol: "BTC",
  chain: t.bitcoin_regtest,
  atomicSwapAddress: "primary",
  tokenAddress: "primary"
};
var a = {
  name: "WBTC Arbitrum Localnet",
  decimals: 8,
  symbol: "WBTC",
  chain: t.arbitrum_localnet,
  atomicSwapAddress: "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
  tokenAddress: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512"
};
var t2 = {
  name: "WBTC Ethereum Localnet",
  decimals: 8,
  symbol: "WBTC",
  chain: t.ethereum_localnet,
  atomicSwapAddress: "0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512",
  tokenAddress: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
};
var d = {
  localnet: {
    [`${t.arbitrum_localnet}_0xdc64a140aa3e981100a9beca4e685f962f0cf6c9`]: a,
    [`${t.ethereum_localnet}_0xe7f1725e7734ce288f8367e1bb143e90bb3f0512`]: t2
  },
  testnet: {
    [`${t.bitcoin_testnet}_primary`]: {
      name: "BTC",
      decimals: 8,
      symbol: "BTC",
      chain: t.bitcoin_testnet,
      tokenAddress: "primary",
      atomicSwapAddress: "primary"
    },
    [`${t.ethereum_sepolia}_0x3c6a17b8cd92976d1d91e491c93c98cd81998265`]: {
      name: "Wrapped Bitcoin",
      decimals: 8,
      symbol: "WBTC",
      chain: t.ethereum_sepolia,
      logo: "https://garden-finance.imgix.net/token-images/wbtc.svg",
      tokenAddress: "0x4D68da063577F98C55166c7AF6955cF58a97b20A",
      atomicSwapAddress: "0x3C6a17b8cD92976D1D91E491c93c98cd81998265"
    },
    [`${t.arbitrum_sepolia}_0x1cd0bbd55fd66b4c5f7dfe434efd009c09e628d1`]: {
      name: "Wrapped Bitcoin",
      decimals: 8,
      symbol: "WBTC",
      logo: "https://garden-finance.imgix.net/token-images/wbtc.svg",
      chain: t.arbitrum_sepolia,
      tokenAddress: "0x00ab86f54F436CfE15253845F139955ae0C00bAf",
      atomicSwapAddress: "0x1cd0bBd55fD66B4C5F7dfE434eFD009C09e628d1"
    },
    [`${t.arbitrum_sepolia}_0xd5fedb4cecb0f1d32788a190d9eb47d94d23ee4e`]: {
      name: "Seed",
      decimals: 18,
      symbol: "SEED",
      chain: t.arbitrum_sepolia,
      logo: "https://garden-finance.imgix.net/token-images/seed.svg",
      tokenAddress: "0x13DCec0762EcC5E666c207ab44Dc768e5e33070F",
      atomicSwapAddress: "0xD5FeDb4ceCB0F1D32788a190d9EB47D94D23eE4e"
    },
    [`${t.base_sepolia}_0x00ab86f54f436cfe15253845f139955ae0c00baf`]: {
      name: "Wrapped Bitcoin",
      decimals: 8,
      symbol: "WBTC",
      chain: t.base_sepolia,
      logo: "https://garden-finance.imgix.net/token-images/wbtc.svg",
      tokenAddress: "0x13DCec0762EcC5E666c207ab44Dc768e5e33070F",
      atomicSwapAddress: "0x00ab86f54F436CfE15253845F139955ae0C00bAf"
    }
  },
  mainnet: {}
};

// node_modules/@gardenfi/core/dist/index.js
var On = __toESM(require_varuint_bitcoin());
var fe = __toESM(require_src());
var import_bitcoinjs_lib = __toESM(require_src());

// node_modules/bignumber.js/bignumber.mjs
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
  function BigNumber2(v, b2) {
    var alphabet, c2, caseChanged, e2, i5, isNum, len, str, x2 = this;
    if (!(x2 instanceof BigNumber2)) return new BigNumber2(v, b2);
    if (b2 == null) {
      if (v && v._isBigNumber === true) {
        x2.s = v.s;
        if (!v.c || v.e > MAX_EXP) {
          x2.c = x2.e = null;
        } else if (v.e < MIN_EXP) {
          x2.c = [x2.e = 0];
        } else {
          x2.e = v.e;
          x2.c = v.c.slice();
        }
        return;
      }
      if ((isNum = typeof v == "number") && v * 0 == 0) {
        x2.s = 1 / v < 0 ? (v = -v, -1) : 1;
        if (v === ~~v) {
          for (e2 = 0, i5 = v; i5 >= 10; i5 /= 10, e2++) ;
          if (e2 > MAX_EXP) {
            x2.c = x2.e = null;
          } else {
            x2.e = e2;
            x2.c = [v];
          }
          return;
        }
        str = String(v);
      } else {
        if (!isNumeric.test(str = String(v))) return parseNumeric(x2, str, isNum);
        x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      if ((i5 = str.search(/e/i)) > 0) {
        if (e2 < 0) e2 = i5;
        e2 += +str.slice(i5 + 1);
        str = str.substring(0, i5);
      } else if (e2 < 0) {
        e2 = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET.length, "Base");
      if (b2 == 10 && alphabetHasNormalDecimalDigits) {
        x2 = new BigNumber2(v);
        return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
      }
      str = String(v);
      if (isNum = typeof v == "number") {
        if (v * 0 != 0) return parseNumeric(x2, str, isNum, b2);
        x2.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v);
        }
      } else {
        x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b2);
      e2 = i5 = 0;
      for (len = str.length; i5 < len; i5++) {
        if (alphabet.indexOf(c2 = str.charAt(i5)) < 0) {
          if (c2 == ".") {
            if (i5 > e2) {
              e2 = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i5 = -1;
              e2 = 0;
              continue;
            }
          }
          return parseNumeric(x2, String(v), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x2.s);
      if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
      else e2 = str.length;
    }
    for (i5 = 0; str.charCodeAt(i5) === 48; i5++) ;
    for (len = str.length; str.charCodeAt(--len) === 48; ) ;
    if (str = str.slice(i5, ++len)) {
      len -= i5;
      if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
        throw Error(tooManyDigits + x2.s * v);
      }
      if ((e2 = e2 - i5 - 1) > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (e2 < MIN_EXP) {
        x2.c = [x2.e = 0];
      } else {
        x2.e = e2;
        x2.c = [];
        i5 = (e2 + 1) % LOG_BASE;
        if (e2 < 0) i5 += LOG_BASE;
        if (i5 < len) {
          if (i5) x2.c.push(+str.slice(0, i5));
          for (len -= LOG_BASE; i5 < len; ) {
            x2.c.push(+str.slice(i5, i5 += LOG_BASE));
          }
          i5 = LOG_BASE - (str = str.slice(i5)).length;
        } else {
          i5 -= len;
        }
        for (; i5--; str += "0") ;
        x2.c.push(+str);
      }
    } else {
      x2.c = [x2.e = 0];
    }
  }
  BigNumber2.clone = clone;
  BigNumber2.ROUND_UP = 0;
  BigNumber2.ROUND_DOWN = 1;
  BigNumber2.ROUND_CEIL = 2;
  BigNumber2.ROUND_FLOOR = 3;
  BigNumber2.ROUND_HALF_UP = 4;
  BigNumber2.ROUND_HALF_DOWN = 5;
  BigNumber2.ROUND_HALF_EVEN = 6;
  BigNumber2.ROUND_HALF_CEIL = 7;
  BigNumber2.ROUND_HALF_FLOOR = 8;
  BigNumber2.EUCLID = 9;
  BigNumber2.config = BigNumber2.set = function(obj) {
    var p, v;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          DECIMAL_PLACES = v;
        }
        if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
          v = obj[p];
          intCheck(v, 0, 8, p);
          ROUNDING_MODE = v;
        }
        if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, 0, p);
            intCheck(v[1], 0, MAX, p);
            TO_EXP_NEG = v[0];
            TO_EXP_POS = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
          }
        }
        if (obj.hasOwnProperty(p = "RANGE")) {
          v = obj[p];
          if (v && v.pop) {
            intCheck(v[0], -MAX, -1, p);
            intCheck(v[1], 1, MAX, p);
            MIN_EXP = v[0];
            MAX_EXP = v[1];
          } else {
            intCheck(v, -MAX, MAX, p);
            if (v) {
              MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
            } else {
              throw Error(bignumberError + p + " cannot be zero: " + v);
            }
          }
        }
        if (obj.hasOwnProperty(p = "CRYPTO")) {
          v = obj[p];
          if (v === !!v) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v;
              } else {
                CRYPTO = !v;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v;
            }
          } else {
            throw Error(bignumberError + p + " not true or false: " + v);
          }
        }
        if (obj.hasOwnProperty(p = "MODULO_MODE")) {
          v = obj[p];
          intCheck(v, 0, 9, p);
          MODULO_MODE = v;
        }
        if (obj.hasOwnProperty(p = "POW_PRECISION")) {
          v = obj[p];
          intCheck(v, 0, MAX, p);
          POW_PRECISION = v;
        }
        if (obj.hasOwnProperty(p = "FORMAT")) {
          v = obj[p];
          if (typeof v == "object") FORMAT = v;
          else throw Error(bignumberError + p + " not an object: " + v);
        }
        if (obj.hasOwnProperty(p = "ALPHABET")) {
          v = obj[p];
          if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
            alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
            ALPHABET = v;
          } else {
            throw Error(bignumberError + p + " invalid: " + v);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber2.isBigNumber = function(v) {
    if (!v || v._isBigNumber !== true) return false;
    if (!BigNumber2.DEBUG) return true;
    var i5, n4, c2 = v.c, e2 = v.e, s4 = v.s;
    out: if ({}.toString.call(c2) == "[object Array]") {
      if ((s4 === 1 || s4 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
        if (c2[0] === 0) {
          if (e2 === 0 && c2.length === 1) return true;
          break out;
        }
        i5 = (e2 + 1) % LOG_BASE;
        if (i5 < 1) i5 += LOG_BASE;
        if (String(c2[0]).length == i5) {
          for (i5 = 0; i5 < c2.length; i5++) {
            n4 = c2[i5];
            if (n4 < 0 || n4 >= BASE || n4 !== mathfloor(n4)) break out;
          }
          if (n4 !== 0) return true;
        }
      }
    } else if (c2 === null && e2 === null && (s4 === null || s4 === 1 || s4 === -1)) {
      return true;
    }
    throw Error(bignumberError + "Invalid BigNumber: " + v);
  };
  BigNumber2.maximum = BigNumber2.max = function() {
    return maxOrMin(arguments, -1);
  };
  BigNumber2.minimum = BigNumber2.min = function() {
    return maxOrMin(arguments, 1);
  };
  BigNumber2.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a2, b2, e2, k2, v, i5 = 0, c2 = [], rand = new BigNumber2(ONE);
      if (dp == null) dp = DECIMAL_PLACES;
      else intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i5 < k2; ) {
            v = a2[i5] * 131072 + (a2[i5 + 1] >>> 11);
            if (v >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a2[i5] = b2[0];
              a2[i5 + 1] = b2[1];
            } else {
              c2.push(v % 1e14);
              i5 += 2;
            }
          }
          i5 = k2 / 2;
        } else if (crypto.randomBytes) {
          a2 = crypto.randomBytes(k2 *= 7);
          for (; i5 < k2; ) {
            v = (a2[i5] & 31) * 281474976710656 + a2[i5 + 1] * 1099511627776 + a2[i5 + 2] * 4294967296 + a2[i5 + 3] * 16777216 + (a2[i5 + 4] << 16) + (a2[i5 + 5] << 8) + a2[i5 + 6];
            if (v >= 9e15) {
              crypto.randomBytes(7).copy(a2, i5);
            } else {
              c2.push(v % 1e14);
              i5 += 7;
            }
          }
          i5 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i5 < k2; ) {
          v = random53bitInt();
          if (v < 9e15) c2[i5++] = v % 1e14;
        }
      }
      k2 = c2[--i5];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v = POWS_TEN[LOG_BASE - dp];
        c2[i5] = mathfloor(k2 / v) * v;
      }
      for (; c2[i5] === 0; c2.pop(), i5--) ;
      if (i5 < 0) {
        c2 = [e2 = 0];
      } else {
        for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
        for (i5 = 1, v = c2[0]; v >= 10; v /= 10, i5++) ;
        if (i5 < LOG_BASE) e2 -= LOG_BASE - i5;
      }
      rand.e = e2;
      rand.c = c2;
      return rand;
    };
  }();
  BigNumber2.sum = function() {
    var i5 = 1, args = arguments, sum = new BigNumber2(args[0]);
    for (; i5 < args.length; ) sum = sum.plus(args[i5++]);
    return sum;
  };
  convertBase = /* @__PURE__ */ function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j, arr = [0], arrL, i5 = 0, len = str.length;
      for (; i5 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
        arr[0] += alphabet.indexOf(str.charAt(i5++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] == null) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d2, e2, k2, r4, x2, xc2, y, i5 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i5 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y = new BigNumber2(baseIn);
        x2 = y.pow(str.length - i5);
        POW_PRECISION = k2;
        y.c = toBaseOut(
          toFixedPoint(coeffToString(x2.c), x2.e, "0"),
          10,
          baseOut,
          decimal
        );
        y.e = y.c.length;
      }
      xc2 = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e2 = k2 = xc2.length;
      for (; xc2[--k2] == 0; xc2.pop()) ;
      if (!xc2[0]) return alphabet.charAt(0);
      if (i5 < 0) {
        --e2;
      } else {
        x2.c = xc2;
        x2.e = e2;
        x2.s = sign;
        x2 = div(x2, y, dp, rm, baseOut);
        xc2 = x2.c;
        r4 = x2.r;
        e2 = x2.e;
      }
      d2 = e2 + dp + 1;
      i5 = xc2[d2];
      k2 = baseOut / 2;
      r4 = r4 || d2 < 0 || xc2[d2 + 1] != null;
      r4 = rm < 4 ? (i5 != null || r4) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i5 > k2 || i5 == k2 && (rm == 4 || r4 || rm == 6 && xc2[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
      if (d2 < 1 || !xc2[0]) {
        str = r4 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc2.length = d2;
        if (r4) {
          for (--baseOut; ++xc2[--d2] > baseOut; ) {
            xc2[d2] = 0;
            if (!d2) {
              ++e2;
              xc2 = [1].concat(xc2);
            }
          }
        }
        for (k2 = xc2.length; !xc2[--k2]; ) ;
        for (i5 = 0, str = ""; i5 <= k2; str += alphabet.charAt(xc2[i5++])) ;
        str = toFixedPoint(str, e2, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = /* @__PURE__ */ function() {
    function multiply(x2, k2, base) {
      var m, temp, xlo, xhi, carry = 0, i5 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x2 = x2.slice(); i5--; ) {
        xlo = x2[i5] % SQRT_BASE;
        xhi = x2[i5] / SQRT_BASE | 0;
        m = khi * xlo + xhi * klo;
        temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
        x2[i5] = temp % base;
      }
      if (carry) x2 = [carry].concat(x2);
      return x2;
    }
    function compare2(a2, b2, aL, bL) {
      var i5, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i5 = cmp = 0; i5 < aL; i5++) {
          if (a2[i5] != b2[i5]) {
            cmp = a2[i5] > b2[i5] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a2, b2, aL, base) {
      var i5 = 0;
      for (; aL--; ) {
        a2[aL] -= i5;
        i5 = a2[aL] < b2[aL] ? 1 : 0;
        a2[aL] = i5 * base + a2[aL] - b2[aL];
      }
      for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
    }
    return function(x2, y, dp, rm, base) {
      var cmp, e2, i5, more, n4, prod, prodL, q, qc2, rem, remL, rem0, xi2, xL, yc0, yL, yz, s4 = x2.s == y.s ? 1 : -1, xc2 = x2.c, yc2 = y.c;
      if (!xc2 || !xc2[0] || !yc2 || !yc2[0]) {
        return new BigNumber2(
          // Return NaN if either NaN, or both Infinity or 0.
          !x2.s || !y.s || (xc2 ? yc2 && xc2[0] == yc2[0] : !yc2) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            xc2 && xc2[0] == 0 || !yc2 ? s4 * 0 : s4 / 0
          )
        );
      }
      q = new BigNumber2(s4);
      qc2 = q.c = [];
      e2 = x2.e - y.e;
      s4 = dp + e2 + 1;
      if (!base) {
        base = BASE;
        e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
        s4 = s4 / LOG_BASE | 0;
      }
      for (i5 = 0; yc2[i5] == (xc2[i5] || 0); i5++) ;
      if (yc2[i5] > (xc2[i5] || 0)) e2--;
      if (s4 < 0) {
        qc2.push(1);
        more = true;
      } else {
        xL = xc2.length;
        yL = yc2.length;
        i5 = 0;
        s4 += 2;
        n4 = mathfloor(base / (yc2[0] + 1));
        if (n4 > 1) {
          yc2 = multiply(yc2, n4, base);
          xc2 = multiply(xc2, n4, base);
          yL = yc2.length;
          xL = xc2.length;
        }
        xi2 = yL;
        rem = xc2.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0) ;
        yz = yc2.slice();
        yz = [0].concat(yz);
        yc0 = yc2[0];
        if (yc2[1] >= base / 2) yc0++;
        do {
          n4 = 0;
          cmp = compare2(yc2, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
            n4 = mathfloor(rem0 / yc0);
            if (n4 > 1) {
              if (n4 >= base) n4 = base - 1;
              prod = multiply(yc2, n4, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n4--;
                subtract(prod, yL < prodL ? yz : yc2, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n4 == 0) {
                cmp = n4 = 1;
              }
              prod = yc2.slice();
              prodL = prod.length;
            }
            if (prodL < remL) prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc2, rem, yL, remL) < 1) {
                n4++;
                subtract(rem, yL < remL ? yz : yc2, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n4++;
            rem = [0];
          }
          qc2[i5++] = n4;
          if (rem[0]) {
            rem[remL++] = xc2[xi2] || 0;
          } else {
            rem = [xc2[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s4--);
        more = rem[0] != null;
        if (!qc2[0]) qc2.splice(0, 1);
      }
      if (base == BASE) {
        for (i5 = 1, s4 = qc2[0]; s4 >= 10; s4 /= 10, i5++) ;
        round(q, dp + (q.e = i5 + e2 * LOG_BASE - 1) + 1, rm, more);
      } else {
        q.e = e2;
        q.r = +more;
      }
      return q;
    };
  }();
  function format(n4, i5, rm, id) {
    var c0, e2, ne, len, str;
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    if (!n4.c) return n4.toString();
    c0 = n4.c[0];
    ne = n4.e;
    if (i5 == null) {
      str = coeffToString(n4.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n4 = round(new BigNumber2(n4), i5, rm);
      e2 = n4.e;
      str = coeffToString(n4.c);
      len = str.length;
      if (id == 1 || id == 2 && (i5 <= e2 || e2 <= TO_EXP_NEG)) {
        for (; len < i5; str += "0", len++) ;
        str = toExponential(str, e2);
      } else {
        i5 -= ne;
        str = toFixedPoint(str, e2, "0");
        if (e2 + 1 > len) {
          if (--i5 > 0) for (str += "."; i5--; str += "0") ;
        } else {
          i5 += e2 - len;
          if (i5 > 0) {
            if (e2 + 1 == len) str += ".";
            for (; i5--; str += "0") ;
          }
        }
      }
    }
    return n4.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, n4) {
    var k2, y, i5 = 1, x2 = new BigNumber2(args[0]);
    for (; i5 < args.length; i5++) {
      y = new BigNumber2(args[i5]);
      if (!y.s || (k2 = compare(x2, y)) === n4 || k2 === 0 && x2.s === n4) {
        x2 = y;
      }
    }
    return x2;
  }
  function normalise(n4, c2, e2) {
    var i5 = 1, j = c2.length;
    for (; !c2[--j]; c2.pop()) ;
    for (j = c2[0]; j >= 10; j /= 10, i5++) ;
    if ((e2 = i5 + e2 * LOG_BASE - 1) > MAX_EXP) {
      n4.c = n4.e = null;
    } else if (e2 < MIN_EXP) {
      n4.c = [n4.e = 0];
    } else {
      n4.e = e2;
      n4.c = c2;
    }
    return n4;
  }
  parseNumeric = /* @__PURE__ */ function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x2, str, isNum, b2) {
      var base, s4 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s4)) {
        x2.s = isNaN(s4) ? null : s4 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s4 = s4.replace(basePrefix, function(m, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base ? p1 : m;
          });
          if (b2) {
            base = b2;
            s4 = s4.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s4) return new BigNumber2(s4, base);
        }
        if (BigNumber2.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x2.s = null;
      }
      x2.c = x2.e = null;
    };
  }();
  function round(x2, sd, rm, r4) {
    var d2, i5, j, k2, n4, ni2, rd, xc2 = x2.c, pows10 = POWS_TEN;
    if (xc2) {
      out: {
        for (d2 = 1, k2 = xc2[0]; k2 >= 10; k2 /= 10, d2++) ;
        i5 = sd - d2;
        if (i5 < 0) {
          i5 += LOG_BASE;
          j = sd;
          n4 = xc2[ni2 = 0];
          rd = mathfloor(n4 / pows10[d2 - j - 1] % 10);
        } else {
          ni2 = mathceil((i5 + 1) / LOG_BASE);
          if (ni2 >= xc2.length) {
            if (r4) {
              for (; xc2.length <= ni2; xc2.push(0)) ;
              n4 = rd = 0;
              d2 = 1;
              i5 %= LOG_BASE;
              j = i5 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n4 = k2 = xc2[ni2];
            for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
            i5 %= LOG_BASE;
            j = i5 - LOG_BASE + d2;
            rd = j < 0 ? 0 : mathfloor(n4 / pows10[d2 - j - 1] % 10);
          }
        }
        r4 = r4 || sd < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        xc2[ni2 + 1] != null || (j < 0 ? n4 : n4 % pows10[d2 - j - 1]);
        r4 = rm < 4 ? (rd || r4) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r4 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i5 > 0 ? j > 0 ? n4 / pows10[d2 - j] : 0 : xc2[ni2 - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
        if (sd < 1 || !xc2[0]) {
          xc2.length = 0;
          if (r4) {
            sd -= x2.e + 1;
            xc2[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x2.e = -sd || 0;
          } else {
            xc2[0] = x2.e = 0;
          }
          return x2;
        }
        if (i5 == 0) {
          xc2.length = ni2;
          k2 = 1;
          ni2--;
        } else {
          xc2.length = ni2 + 1;
          k2 = pows10[LOG_BASE - i5];
          xc2[ni2] = j > 0 ? mathfloor(n4 / pows10[d2 - j] % pows10[j]) * k2 : 0;
        }
        if (r4) {
          for (; ; ) {
            if (ni2 == 0) {
              for (i5 = 1, j = xc2[0]; j >= 10; j /= 10, i5++) ;
              j = xc2[0] += k2;
              for (k2 = 1; j >= 10; j /= 10, k2++) ;
              if (i5 != k2) {
                x2.e++;
                if (xc2[0] == BASE) xc2[0] = 1;
              }
              break;
            } else {
              xc2[ni2] += k2;
              if (xc2[ni2] != BASE) break;
              xc2[ni2--] = 0;
              k2 = 1;
            }
          }
        }
        for (i5 = xc2.length; xc2[--i5] === 0; xc2.pop()) ;
      }
      if (x2.e > MAX_EXP) {
        x2.c = x2.e = null;
      } else if (x2.e < MIN_EXP) {
        x2.c = [x2.e = 0];
      }
    }
    return x2;
  }
  function valueOf(n4) {
    var str, e2 = n4.e;
    if (e2 === null) return n4.toString();
    str = coeffToString(n4.c);
    str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
    return n4.s < 0 ? "-" + str : str;
  }
  P.absoluteValue = P.abs = function() {
    var x2 = new BigNumber2(this);
    if (x2.s < 0) x2.s = 1;
    return x2;
  };
  P.comparedTo = function(y, b2) {
    return compare(this, new BigNumber2(y, b2));
  };
  P.decimalPlaces = P.dp = function(dp, rm) {
    var c2, n4, v, x2 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), dp + x2.e + 1, rm);
    }
    if (!(c2 = x2.c)) return null;
    n4 = ((v = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v = c2[v]) for (; v % 10 == 0; v /= 10, n4--) ;
    if (n4 < 0) n4 = 0;
    return n4;
  };
  P.dividedBy = P.div = function(y, b2) {
    return div(this, new BigNumber2(y, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P.dividedToIntegerBy = P.idiv = function(y, b2) {
    return div(this, new BigNumber2(y, b2), 0, 1);
  };
  P.exponentiatedBy = P.pow = function(n4, m) {
    var half, isModExp, i5, k2, more, nIsBig, nIsNeg, nIsOdd, y, x2 = this;
    n4 = new BigNumber2(n4);
    if (n4.c && !n4.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n4));
    }
    if (m != null) m = new BigNumber2(m);
    nIsBig = n4.e > 14;
    if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n4.c || !n4.c[0]) {
      y = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n4.s * (2 - isOdd(n4)) : +valueOf(n4)));
      return m ? y.mod(m) : y;
    }
    nIsNeg = n4.s < 0;
    if (m) {
      if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
      isModExp = !nIsNeg && x2.isInteger() && m.isInteger();
      if (isModExp) x2 = x2.mod(m);
    } else if (n4.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
      k2 = x2.s < 0 && isOdd(n4) ? -0 : 0;
      if (x2.e > -1) k2 = 1 / k2;
      return new BigNumber2(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber2(0.5);
      if (nIsNeg) n4.s = 1;
      nIsOdd = isOdd(n4);
    } else {
      i5 = Math.abs(+valueOf(n4));
      nIsOdd = i5 % 2;
    }
    y = new BigNumber2(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y = y.times(x2);
        if (!y.c) break;
        if (k2) {
          if (y.c.length > k2) y.c.length = k2;
        } else if (isModExp) {
          y = y.mod(m);
        }
      }
      if (i5) {
        i5 = mathfloor(i5 / 2);
        if (i5 === 0) break;
        nIsOdd = i5 % 2;
      } else {
        n4 = n4.times(half);
        round(n4, n4.e + 1, 1);
        if (n4.e > 14) {
          nIsOdd = isOdd(n4);
        } else {
          i5 = +valueOf(n4);
          if (i5 === 0) break;
          nIsOdd = i5 % 2;
        }
      }
      x2 = x2.times(x2);
      if (k2) {
        if (x2.c && x2.c.length > k2) x2.c.length = k2;
      } else if (isModExp) {
        x2 = x2.mod(m);
      }
    }
    if (isModExp) return y;
    if (nIsNeg) y = ONE.div(y);
    return m ? y.mod(m) : k2 ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
  };
  P.integerValue = function(rm) {
    var n4 = new BigNumber2(this);
    if (rm == null) rm = ROUNDING_MODE;
    else intCheck(rm, 0, 8);
    return round(n4, n4.e + 1, rm);
  };
  P.isEqualTo = P.eq = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) === 0;
  };
  P.isFinite = function() {
    return !!this.c;
  };
  P.isGreaterThan = P.gt = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) > 0;
  };
  P.isGreaterThanOrEqualTo = P.gte = function(y, b2) {
    return (b2 = compare(this, new BigNumber2(y, b2))) === 1 || b2 === 0;
  };
  P.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P.isLessThan = P.lt = function(y, b2) {
    return compare(this, new BigNumber2(y, b2)) < 0;
  };
  P.isLessThanOrEqualTo = P.lte = function(y, b2) {
    return (b2 = compare(this, new BigNumber2(y, b2))) === -1 || b2 === 0;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = function() {
    return this.s < 0;
  };
  P.isPositive = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P.minus = function(y, b2) {
    var i5, j, t3, xLTy, x2 = this, a2 = x2.s;
    y = new BigNumber2(y, b2);
    b2 = y.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y.s = -b2;
      return x2.plus(y);
    }
    var xe = x2.e / LOG_BASE, ye2 = y.e / LOG_BASE, xc2 = x2.c, yc2 = y.c;
    if (!xe || !ye2) {
      if (!xc2 || !yc2) return xc2 ? (y.s = -b2, y) : new BigNumber2(yc2 ? x2 : NaN);
      if (!xc2[0] || !yc2[0]) {
        return yc2[0] ? (y.s = -b2, y) : new BigNumber2(xc2[0] ? x2 : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          ROUNDING_MODE == 3 ? -0 : 0
        ));
      }
    }
    xe = bitFloor(xe);
    ye2 = bitFloor(ye2);
    xc2 = xc2.slice();
    if (a2 = xe - ye2) {
      if (xLTy = a2 < 0) {
        a2 = -a2;
        t3 = xc2;
      } else {
        ye2 = xe;
        t3 = yc2;
      }
      t3.reverse();
      for (b2 = a2; b2--; t3.push(0)) ;
      t3.reverse();
    } else {
      j = (xLTy = (a2 = xc2.length) < (b2 = yc2.length)) ? a2 : b2;
      for (a2 = b2 = 0; b2 < j; b2++) {
        if (xc2[b2] != yc2[b2]) {
          xLTy = xc2[b2] < yc2[b2];
          break;
        }
      }
    }
    if (xLTy) {
      t3 = xc2;
      xc2 = yc2;
      yc2 = t3;
      y.s = -y.s;
    }
    b2 = (j = yc2.length) - (i5 = xc2.length);
    if (b2 > 0) for (; b2--; xc2[i5++] = 0) ;
    b2 = BASE - 1;
    for (; j > a2; ) {
      if (xc2[--j] < yc2[j]) {
        for (i5 = j; i5 && !xc2[--i5]; xc2[i5] = b2) ;
        --xc2[i5];
        xc2[j] += BASE;
      }
      xc2[j] -= yc2[j];
    }
    for (; xc2[0] == 0; xc2.splice(0, 1), --ye2) ;
    if (!xc2[0]) {
      y.s = ROUNDING_MODE == 3 ? -1 : 1;
      y.c = [y.e = 0];
      return y;
    }
    return normalise(y, xc2, ye2);
  };
  P.modulo = P.mod = function(y, b2) {
    var q, s4, x2 = this;
    y = new BigNumber2(y, b2);
    if (!x2.c || !y.s || y.c && !y.c[0]) {
      return new BigNumber2(NaN);
    } else if (!y.c || x2.c && !x2.c[0]) {
      return new BigNumber2(x2);
    }
    if (MODULO_MODE == 9) {
      s4 = y.s;
      y.s = 1;
      q = div(x2, y, 0, 3);
      y.s = s4;
      q.s *= s4;
    } else {
      q = div(x2, y, 0, MODULO_MODE);
    }
    y = x2.minus(q.times(y));
    if (!y.c[0] && MODULO_MODE == 1) y.s = x2.s;
    return y;
  };
  P.multipliedBy = P.times = function(y, b2) {
    var c2, e2, i5, j, k2, m, xcL, xlo, xhi, ycL, ylo, yhi, zc2, base, sqrtBase, x2 = this, xc2 = x2.c, yc2 = (y = new BigNumber2(y, b2)).c;
    if (!xc2 || !yc2 || !xc2[0] || !yc2[0]) {
      if (!x2.s || !y.s || xc2 && !xc2[0] && !yc2 || yc2 && !yc2[0] && !xc2) {
        y.c = y.e = y.s = null;
      } else {
        y.s *= x2.s;
        if (!xc2 || !yc2) {
          y.c = y.e = null;
        } else {
          y.c = [0];
          y.e = 0;
        }
      }
      return y;
    }
    e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
    y.s *= x2.s;
    xcL = xc2.length;
    ycL = yc2.length;
    if (xcL < ycL) {
      zc2 = xc2;
      xc2 = yc2;
      yc2 = zc2;
      i5 = xcL;
      xcL = ycL;
      ycL = i5;
    }
    for (i5 = xcL + ycL, zc2 = []; i5--; zc2.push(0)) ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i5 = ycL; --i5 >= 0; ) {
      c2 = 0;
      ylo = yc2[i5] % sqrtBase;
      yhi = yc2[i5] / sqrtBase | 0;
      for (k2 = xcL, j = i5 + k2; j > i5; ) {
        xlo = xc2[--k2] % sqrtBase;
        xhi = xc2[k2] / sqrtBase | 0;
        m = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc2[j] + c2;
        c2 = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
        zc2[j--] = xlo % base;
      }
      zc2[j] = c2;
    }
    if (c2) {
      ++e2;
    } else {
      zc2.splice(0, 1);
    }
    return normalise(y, zc2, e2);
  };
  P.negated = function() {
    var x2 = new BigNumber2(this);
    x2.s = -x2.s || null;
    return x2;
  };
  P.plus = function(y, b2) {
    var t3, x2 = this, a2 = x2.s;
    y = new BigNumber2(y, b2);
    b2 = y.s;
    if (!a2 || !b2) return new BigNumber2(NaN);
    if (a2 != b2) {
      y.s = -b2;
      return x2.minus(y);
    }
    var xe = x2.e / LOG_BASE, ye2 = y.e / LOG_BASE, xc2 = x2.c, yc2 = y.c;
    if (!xe || !ye2) {
      if (!xc2 || !yc2) return new BigNumber2(a2 / 0);
      if (!xc2[0] || !yc2[0]) return yc2[0] ? y : new BigNumber2(xc2[0] ? x2 : a2 * 0);
    }
    xe = bitFloor(xe);
    ye2 = bitFloor(ye2);
    xc2 = xc2.slice();
    if (a2 = xe - ye2) {
      if (a2 > 0) {
        ye2 = xe;
        t3 = yc2;
      } else {
        a2 = -a2;
        t3 = xc2;
      }
      t3.reverse();
      for (; a2--; t3.push(0)) ;
      t3.reverse();
    }
    a2 = xc2.length;
    b2 = yc2.length;
    if (a2 - b2 < 0) {
      t3 = yc2;
      yc2 = xc2;
      xc2 = t3;
      b2 = a2;
    }
    for (a2 = 0; b2; ) {
      a2 = (xc2[--b2] = xc2[b2] + yc2[b2] + a2) / BASE | 0;
      xc2[b2] = BASE === xc2[b2] ? 0 : xc2[b2] % BASE;
    }
    if (a2) {
      xc2 = [a2].concat(xc2);
      ++ye2;
    }
    return normalise(y, xc2, ye2);
  };
  P.precision = P.sd = function(sd, rm) {
    var c2, n4, v, x2 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null) rm = ROUNDING_MODE;
      else intCheck(rm, 0, 8);
      return round(new BigNumber2(x2), sd, rm);
    }
    if (!(c2 = x2.c)) return null;
    v = c2.length - 1;
    n4 = v * LOG_BASE + 1;
    if (v = c2[v]) {
      for (; v % 10 == 0; v /= 10, n4--) ;
      for (v = c2[0]; v >= 10; v /= 10, n4++) ;
    }
    if (sd && x2.e + 1 > n4) n4 = x2.e + 1;
    return n4;
  };
  P.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n4, r4, rep, t3, x2 = this, c2 = x2.c, s4 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
    if (s4 !== 1 || !c2 || !c2[0]) {
      return new BigNumber2(!s4 || s4 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
    }
    s4 = Math.sqrt(+valueOf(x2));
    if (s4 == 0 || s4 == 1 / 0) {
      n4 = coeffToString(c2);
      if ((n4.length + e2) % 2 == 0) n4 += "0";
      s4 = Math.sqrt(+n4);
      e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
      if (s4 == 1 / 0) {
        n4 = "5e" + e2;
      } else {
        n4 = s4.toExponential();
        n4 = n4.slice(0, n4.indexOf("e") + 1) + e2;
      }
      r4 = new BigNumber2(n4);
    } else {
      r4 = new BigNumber2(s4 + "");
    }
    if (r4.c[0]) {
      e2 = r4.e;
      s4 = e2 + dp;
      if (s4 < 3) s4 = 0;
      for (; ; ) {
        t3 = r4;
        r4 = half.times(t3.plus(div(x2, t3, dp, 1)));
        if (coeffToString(t3.c).slice(0, s4) === (n4 = coeffToString(r4.c)).slice(0, s4)) {
          if (r4.e < e2) --s4;
          n4 = n4.slice(s4 - 3, s4 + 1);
          if (n4 == "9999" || !rep && n4 == "4999") {
            if (!rep) {
              round(t3, t3.e + DECIMAL_PLACES + 2, 0);
              if (t3.times(t3).eq(x2)) {
                r4 = t3;
                break;
              }
            }
            dp += 4;
            s4 += 4;
            rep = 1;
          } else {
            if (!+n4 || !+n4.slice(1) && n4.charAt(0) == "5") {
              round(r4, r4.e + DECIMAL_PLACES + 2, 1);
              m = !r4.times(r4).eq(x2);
            }
            break;
          }
        }
      }
    }
    return round(r4, r4.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
  };
  P.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P.toFormat = function(dp, rm, format2) {
    var str, x2 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x2.toFixed(dp, rm);
    if (x2.c) {
      var i5, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2) {
        i5 = g1;
        g1 = g2;
        g2 = i5;
        len -= i5;
      }
      if (g1 > 0 && len > 0) {
        i5 = len % g1 || g1;
        intPart = intDigits.substr(0, i5);
        for (; i5 < len; i5 += g1) intPart += groupSeparator + intDigits.substr(i5, g1);
        if (g2 > 0) intPart += groupSeparator + intDigits.slice(i5);
        if (isNeg) intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
        new RegExp("\\d{" + g2 + "}\\B", "g"),
        "$&" + (format2.fractionGroupSeparator || "")
      ) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P.toFraction = function(md) {
    var d2, d0, d1, d22, e2, exp, n4, n0, n1, q, r4, s4, x2 = this, xc2 = x2.c;
    if (md != null) {
      n4 = new BigNumber2(md);
      if (!n4.isInteger() && (n4.c || n4.s !== 1) || n4.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n4.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n4));
      }
    }
    if (!xc2) return new BigNumber2(x2);
    d2 = new BigNumber2(ONE);
    n1 = d0 = new BigNumber2(ONE);
    d1 = n0 = new BigNumber2(ONE);
    s4 = coeffToString(xc2);
    e2 = d2.e = s4.length - x2.e - 1;
    d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n4.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n4;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n4 = new BigNumber2(s4);
    n0.c[0] = 0;
    for (; ; ) {
      q = div(n4, d2, 0, 1);
      d22 = d0.plus(q.times(d1));
      if (d22.comparedTo(md) == 1) break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q.times(d22 = n1));
      n0 = d22;
      d2 = n4.minus(q.times(d22 = d2));
      n4 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x2.s;
    e2 = e2 * 2;
    r4 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
      div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
    ) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r4;
  };
  P.toNumber = function() {
    return +valueOf(this);
  };
  P.toPrecision = function(sd, rm) {
    if (sd != null) intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P.toString = function(b2) {
    var str, n4 = this, s4 = n4.s, e2 = n4.e;
    if (e2 === null) {
      if (s4) {
        str = "Infinity";
        if (s4 < 0) str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n4.c), e2) : toFixedPoint(coeffToString(n4.c), e2, "0");
      } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
        n4 = round(new BigNumber2(n4), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n4.c), n4.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n4.c), e2, "0"), 10, b2, s4, true);
      }
      if (s4 < 0 && n4.c[0]) str = "-" + str;
    }
    return str;
  };
  P.valueOf = P.toJSON = function() {
    return valueOf(this);
  };
  P._isBigNumber = true;
  P[Symbol.toStringTag] = "BigNumber";
  P[Symbol.for("nodejs.util.inspect.custom")] = P.valueOf;
  if (configObject != null) BigNumber2.set(configObject);
  return BigNumber2;
}
function bitFloor(n4) {
  var i5 = n4 | 0;
  return n4 > 0 || n4 === i5 ? i5 : i5 - 1;
}
function coeffToString(a2) {
  var s4, z, i5 = 1, j = a2.length, r4 = a2[0] + "";
  for (; i5 < j; ) {
    s4 = a2[i5++] + "";
    z = LOG_BASE - s4.length;
    for (; z--; s4 = "0" + s4) ;
    r4 += s4;
  }
  for (j = r4.length; r4.charCodeAt(--j) === 48; ) ;
  return r4.slice(0, j + 1 || 1);
}
function compare(x2, y) {
  var a2, b2, xc2 = x2.c, yc2 = y.c, i5 = x2.s, j = y.s, k2 = x2.e, l = y.e;
  if (!i5 || !j) return null;
  a2 = xc2 && !xc2[0];
  b2 = yc2 && !yc2[0];
  if (a2 || b2) return a2 ? b2 ? 0 : -j : i5;
  if (i5 != j) return i5;
  a2 = i5 < 0;
  b2 = k2 == l;
  if (!xc2 || !yc2) return b2 ? 0 : !xc2 ^ a2 ? 1 : -1;
  if (!b2) return k2 > l ^ a2 ? 1 : -1;
  j = (k2 = xc2.length) < (l = yc2.length) ? k2 : l;
  for (i5 = 0; i5 < j; i5++) if (xc2[i5] != yc2[i5]) return xc2[i5] > yc2[i5] ^ a2 ? 1 : -1;
  return k2 == l ? 0 : k2 > l ^ a2 ? 1 : -1;
}
function intCheck(n4, min, max, name) {
  if (n4 < min || n4 > max || n4 !== mathfloor(n4)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n4 == "number" ? n4 < min || n4 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n4));
  }
}
function isOdd(n4) {
  var k2 = n4.c.length - 1;
  return bitFloor(n4.e / LOG_BASE) == k2 && n4.c[k2] % 2 != 0;
}
function toExponential(str, e2) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
}
function toFixedPoint(str, e2, z) {
  var len, zs2;
  if (e2 < 0) {
    for (zs2 = z + "."; ++e2; zs2 += z) ;
    str = zs2 + str;
  } else {
    len = str.length;
    if (++e2 > len) {
      for (zs2 = z, e2 -= len; --e2; zs2 += z) ;
      str += zs2;
    } else if (e2 < len) {
      str = str.slice(0, e2) + "." + str.slice(e2);
    }
  }
  return str;
}
var BigNumber = clone();
var bignumber_default = BigNumber;

// node_modules/@gardenfi/core/dist/index.js
var zs = Object.defineProperty;
var js = (e2, t3, r4) => t3 in e2 ? zs(e2, t3, { enumerable: true, configurable: true, writable: true, value: r4 }) : e2[t3] = r4;
var bt = (e2, t3, r4) => js(e2, typeof t3 != "symbol" ? t3 + "" : t3, r4);
var en = ((e2) => (e2[e2.evm = 14400] = "evm", e2[e2.btc = 288] = "btc", e2))(en || {});
var le = ((e2) => (e2.Idle = "Idle", e2.Initiate = "Initiate", e2.Redeem = "Redeem", e2.Refund = "Refund", e2))(le || {});
function qt(e2) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e2
  };
}
var Ii = "2.21.30";
var kt = {
  getDocsUrl: ({ docsBaseUrl: e2, docsPath: t3 = "", docsSlug: r4 }) => t3 ? `${e2 ?? "https://viem.sh"}${t3}${r4 ? `#${r4}` : ""}` : void 0,
  version: `viem@${Ii}`
};
var X = class _X extends Error {
  constructor(t3, r4 = {}) {
    var u2;
    const n4 = (() => {
      var l;
      return r4.cause instanceof _X ? r4.cause.details : (l = r4.cause) != null && l.message ? r4.cause.message : r4.details;
    })(), i5 = r4.cause instanceof _X && r4.cause.docsPath || r4.docsPath, a2 = (u2 = kt.getDocsUrl) == null ? void 0 : u2.call(kt, { ...r4, docsPath: i5 }), f = [
      t3 || "An error occurred.",
      "",
      ...r4.metaMessages ? [...r4.metaMessages, ""] : [],
      ...a2 ? [`Docs: ${a2}`] : [],
      ...n4 ? [`Details: ${n4}`] : [],
      ...kt.version ? [`Version: ${kt.version}`] : []
    ].join(`
`);
    super(f, r4.cause ? { cause: r4.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    }), this.details = n4, this.docsPath = i5, this.metaMessages = r4.metaMessages, this.name = r4.name ?? this.name, this.shortMessage = t3, this.version = Ii;
  }
  walk(t3) {
    return Ai(this, t3);
  }
};
function Ai(e2, t3) {
  return t3 != null && t3(e2) ? e2 : e2 && typeof e2 == "object" && "cause" in e2 ? Ai(e2.cause, t3) : t3 ? null : e2;
}
var Qs = class extends X {
  constructor({ max: t3, min: r4, signed: n4, size: i5, value: a2 }) {
    super(`Number "${a2}" is not in safe ${i5 ? `${i5 * 8}-bit ${n4 ? "signed" : "unsigned"} ` : ""}integer range ${t3 ? `(${r4} to ${t3})` : `(above ${r4})`}`, { name: "IntegerOutOfRangeError" });
  }
};
var Zs = class extends X {
  constructor({ givenSize: t3, maxSize: r4 }) {
    super(`Size cannot exceed ${r4} bytes. Given size: ${t3} bytes.`, { name: "SizeOverflowError" });
  }
};
function Vt(e2, { strict: t3 = true } = {}) {
  return !e2 || typeof e2 != "string" ? false : t3 ? /^0x[0-9a-fA-F]*$/.test(e2) : e2.startsWith("0x");
}
function vt(e2) {
  return Vt(e2, { strict: false }) ? Math.ceil((e2.length - 2) / 2) : e2.length;
}
function lr(e2, { dir: t3 = "left" } = {}) {
  let r4 = typeof e2 == "string" ? e2.replace("0x", "") : e2, n4 = 0;
  for (let i5 = 0; i5 < r4.length - 1 && r4[t3 === "left" ? i5 : r4.length - i5 - 1].toString() === "0"; i5++)
    n4++;
  return r4 = t3 === "left" ? r4.slice(n4) : r4.slice(0, r4.length - n4), typeof e2 == "string" ? (r4.length === 1 && t3 === "right" && (r4 = `${r4}0`), `0x${r4.length % 2 === 1 ? `0${r4}` : r4}`) : r4;
}
var eo = class extends X {
  constructor({ offset: t3, position: r4, size: n4 }) {
    super(`Slice ${r4 === "start" ? "starting" : "ending"} at offset "${t3}" is out-of-bounds (size: ${n4}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
};
var Ri = class extends X {
  constructor({ size: t3, targetSize: r4, type: n4 }) {
    super(`${n4.charAt(0).toUpperCase()}${n4.slice(1).toLowerCase()} size (${t3}) exceeds padding size (${r4}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
function It(e2, { dir: t3, size: r4 = 32 } = {}) {
  return typeof e2 == "string" ? to(e2, { dir: t3, size: r4 }) : ro(e2, { dir: t3, size: r4 });
}
function to(e2, { dir: t3, size: r4 = 32 } = {}) {
  if (r4 === null)
    return e2;
  const n4 = e2.replace("0x", "");
  if (n4.length > r4 * 2)
    throw new Ri({
      size: Math.ceil(n4.length / 2),
      targetSize: r4,
      type: "hex"
    });
  return `0x${n4[t3 === "right" ? "padEnd" : "padStart"](r4 * 2, "0")}`;
}
function ro(e2, { dir: t3, size: r4 = 32 } = {}) {
  if (r4 === null)
    return e2;
  if (e2.length > r4)
    throw new Ri({
      size: e2.length,
      targetSize: r4,
      type: "bytes"
    });
  const n4 = new Uint8Array(r4);
  for (let i5 = 0; i5 < r4; i5++) {
    const a2 = t3 === "right";
    n4[a2 ? i5 : r4 - i5 - 1] = e2[a2 ? i5 : e2.length - i5 - 1];
  }
  return n4;
}
var no = Array.from({ length: 256 }, (e2, t3) => t3.toString(16).padStart(2, "0"));
function W2(e2, t3 = {}) {
  return typeof e2 == "number" || typeof e2 == "bigint" ? Ti(e2, t3) : typeof e2 == "string" ? oo(e2, t3) : typeof e2 == "boolean" ? io(e2, t3) : Qe(e2, t3);
}
function io(e2, t3 = {}) {
  const r4 = `0x${Number(e2)}`;
  return typeof t3.size == "number" ? (At(r4, { size: t3.size }), It(r4, { size: t3.size })) : r4;
}
function Qe(e2, t3 = {}) {
  let r4 = "";
  for (let i5 = 0; i5 < e2.length; i5++)
    r4 += no[e2[i5]];
  const n4 = `0x${r4}`;
  return typeof t3.size == "number" ? (At(n4, { size: t3.size }), It(n4, { dir: "right", size: t3.size })) : n4;
}
function Ti(e2, t3 = {}) {
  const { signed: r4, size: n4 } = t3, i5 = BigInt(e2);
  let a2;
  n4 ? r4 ? a2 = (1n << BigInt(n4) * 8n - 1n) - 1n : a2 = 2n ** (BigInt(n4) * 8n) - 1n : typeof e2 == "number" && (a2 = BigInt(Number.MAX_SAFE_INTEGER));
  const f = typeof a2 == "bigint" && r4 ? -a2 - 1n : 0;
  if (a2 && i5 > a2 || i5 < f) {
    const l = typeof e2 == "bigint" ? "n" : "";
    throw new Qs({
      max: a2 ? `${a2}${l}` : void 0,
      min: `${f}${l}`,
      signed: r4,
      size: n4,
      value: `${e2}${l}`
    });
  }
  const u2 = `0x${(r4 && i5 < 0 ? (1n << BigInt(n4 * 8)) + BigInt(i5) : i5).toString(16)}`;
  return n4 ? It(u2, { size: n4 }) : u2;
}
var so = new TextEncoder();
function oo(e2, t3 = {}) {
  const r4 = so.encode(e2);
  return Qe(r4, t3);
}
var ao = new TextEncoder();
function Pi(e2, t3 = {}) {
  return typeof e2 == "number" || typeof e2 == "bigint" ? uo(e2, t3) : typeof e2 == "boolean" ? fo(e2, t3) : Vt(e2) ? ot(e2, t3) : Ci(e2, t3);
}
function fo(e2, t3 = {}) {
  const r4 = new Uint8Array(1);
  return r4[0] = Number(e2), typeof t3.size == "number" ? (At(r4, { size: t3.size }), It(r4, { size: t3.size })) : r4;
}
var Me = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function Nn(e2) {
  if (e2 >= Me.zero && e2 <= Me.nine)
    return e2 - Me.zero;
  if (e2 >= Me.A && e2 <= Me.F)
    return e2 - (Me.A - 10);
  if (e2 >= Me.a && e2 <= Me.f)
    return e2 - (Me.a - 10);
}
function ot(e2, t3 = {}) {
  let r4 = e2;
  t3.size && (At(r4, { size: t3.size }), r4 = It(r4, { dir: "right", size: t3.size }));
  let n4 = r4.slice(2);
  n4.length % 2 && (n4 = `0${n4}`);
  const i5 = n4.length / 2, a2 = new Uint8Array(i5);
  for (let f = 0, u2 = 0; f < i5; f++) {
    const l = Nn(n4.charCodeAt(u2++)), b2 = Nn(n4.charCodeAt(u2++));
    if (l === void 0 || b2 === void 0)
      throw new X(`Invalid byte sequence ("${n4[u2 - 2]}${n4[u2 - 1]}" in "${n4}").`);
    a2[f] = l * 16 + b2;
  }
  return a2;
}
function uo(e2, t3) {
  const r4 = Ti(e2, t3);
  return ot(r4);
}
function Ci(e2, t3 = {}) {
  const r4 = ao.encode(e2);
  return typeof t3.size == "number" ? (At(r4, { size: t3.size }), It(r4, { dir: "right", size: t3.size })) : r4;
}
function At(e2, { size: t3 }) {
  if (vt(e2) > t3)
    throw new Zs({
      givenSize: vt(e2),
      maxSize: t3
    });
}
function mt(e2, t3 = {}) {
  const { signed: r4 } = t3;
  t3.size && At(e2, { size: t3.size });
  const n4 = BigInt(e2);
  if (!r4)
    return n4;
  const i5 = (e2.length - 2) / 2, a2 = (1n << BigInt(i5) * 8n - 1n) - 1n;
  return n4 <= a2 ? n4 : n4 - BigInt(`0x${"f".padStart(i5 * 2, "f")}`) - 1n;
}
function hr(e2, t3 = {}) {
  return Number(mt(e2, t3));
}
function pn(e2, t3) {
  return ({ exclude: r4, format: n4 }) => ({
    exclude: r4,
    format: (i5) => {
      const a2 = t3(i5);
      if (r4)
        for (const f of r4)
          delete a2[f];
      return {
        ...a2,
        ...n4(i5)
      };
    },
    type: e2
  });
}
var Li = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function bn(e2) {
  const t3 = {
    ...e2,
    blockHash: e2.blockHash ? e2.blockHash : null,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    chainId: e2.chainId ? hr(e2.chainId) : void 0,
    gas: e2.gas ? BigInt(e2.gas) : void 0,
    gasPrice: e2.gasPrice ? BigInt(e2.gasPrice) : void 0,
    maxFeePerBlobGas: e2.maxFeePerBlobGas ? BigInt(e2.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e2.maxFeePerGas ? BigInt(e2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e2.maxPriorityFeePerGas ? BigInt(e2.maxPriorityFeePerGas) : void 0,
    nonce: e2.nonce ? hr(e2.nonce) : void 0,
    to: e2.to ? e2.to : null,
    transactionIndex: e2.transactionIndex ? Number(e2.transactionIndex) : null,
    type: e2.type ? Li[e2.type] : void 0,
    typeHex: e2.type ? e2.type : void 0,
    value: e2.value ? BigInt(e2.value) : void 0,
    v: e2.v ? BigInt(e2.v) : void 0
  };
  return e2.authorizationList && (t3.authorizationList = lo(e2.authorizationList)), t3.yParity = (() => {
    if (e2.yParity)
      return Number(e2.yParity);
    if (typeof t3.v == "bigint") {
      if (t3.v === 0n || t3.v === 27n)
        return 0;
      if (t3.v === 1n || t3.v === 28n)
        return 1;
      if (t3.v >= 35n)
        return t3.v % 2n === 0n ? 1 : 0;
    }
  })(), t3.type === "legacy" && (delete t3.accessList, delete t3.maxFeePerBlobGas, delete t3.maxFeePerGas, delete t3.maxPriorityFeePerGas, delete t3.yParity), t3.type === "eip2930" && (delete t3.maxFeePerBlobGas, delete t3.maxFeePerGas, delete t3.maxPriorityFeePerGas), t3.type === "eip1559" && delete t3.maxFeePerBlobGas, t3;
}
var co = pn("transaction", bn);
function lo(e2) {
  return e2.map((t3) => ({
    contractAddress: t3.address,
    chainId: Number(t3.chainId),
    nonce: Number(t3.nonce),
    r: t3.r,
    s: t3.s,
    yParity: Number(t3.yParity)
  }));
}
function ho(e2) {
  var r4;
  const t3 = (r4 = e2.transactions) == null ? void 0 : r4.map((n4) => typeof n4 == "string" ? n4 : bn(n4));
  return {
    ...e2,
    baseFeePerGas: e2.baseFeePerGas ? BigInt(e2.baseFeePerGas) : null,
    blobGasUsed: e2.blobGasUsed ? BigInt(e2.blobGasUsed) : void 0,
    difficulty: e2.difficulty ? BigInt(e2.difficulty) : void 0,
    excessBlobGas: e2.excessBlobGas ? BigInt(e2.excessBlobGas) : void 0,
    gasLimit: e2.gasLimit ? BigInt(e2.gasLimit) : void 0,
    gasUsed: e2.gasUsed ? BigInt(e2.gasUsed) : void 0,
    hash: e2.hash ? e2.hash : null,
    logsBloom: e2.logsBloom ? e2.logsBloom : null,
    nonce: e2.nonce ? e2.nonce : null,
    number: e2.number ? BigInt(e2.number) : null,
    size: e2.size ? BigInt(e2.size) : void 0,
    timestamp: e2.timestamp ? BigInt(e2.timestamp) : void 0,
    transactions: t3,
    totalDifficulty: e2.totalDifficulty ? BigInt(e2.totalDifficulty) : null
  };
}
var po = pn("block", ho);
function bo(e2, { args: t3, eventName: r4 } = {}) {
  return {
    ...e2,
    blockHash: e2.blockHash ? e2.blockHash : null,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    logIndex: e2.logIndex ? Number(e2.logIndex) : null,
    transactionHash: e2.transactionHash ? e2.transactionHash : null,
    transactionIndex: e2.transactionIndex ? Number(e2.transactionIndex) : null,
    ...r4 ? { args: t3, eventName: r4 } : {}
  };
}
var yo = {
  "0x0": "reverted",
  "0x1": "success"
};
function go(e2) {
  const t3 = {
    ...e2,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    contractAddress: e2.contractAddress ? e2.contractAddress : null,
    cumulativeGasUsed: e2.cumulativeGasUsed ? BigInt(e2.cumulativeGasUsed) : null,
    effectiveGasPrice: e2.effectiveGasPrice ? BigInt(e2.effectiveGasPrice) : null,
    gasUsed: e2.gasUsed ? BigInt(e2.gasUsed) : null,
    logs: e2.logs ? e2.logs.map((r4) => bo(r4)) : null,
    to: e2.to ? e2.to : null,
    transactionIndex: e2.transactionIndex ? hr(e2.transactionIndex) : null,
    status: e2.status ? yo[e2.status] : null,
    type: e2.type ? Li[e2.type] || e2.type : null
  };
  return e2.blobGasPrice && (t3.blobGasPrice = BigInt(e2.blobGasPrice)), e2.blobGasUsed && (t3.blobGasUsed = BigInt(e2.blobGasUsed)), t3;
}
var mo = pn("transactionReceipt", go);
var yn = 2n ** 256n - 1n;
function Kt(e2) {
  return `0x${e2.reduce((t3, r4) => t3 + r4.replace("0x", ""), "")}`;
}
var Mn = class extends X {
  constructor({ offset: t3 }) {
    super(`Offset \`${t3}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
};
var _o = class extends X {
  constructor({ length: t3, position: r4 }) {
    super(`Position \`${r4}\` is out of bounds (\`0 < position < ${t3}\`).`, { name: "PositionOutOfBoundsError" });
  }
};
var wo = class extends X {
  constructor({ count: t3, limit: r4 }) {
    super(`Recursive read limit of \`${r4}\` exceeded (recursive read count: \`${t3}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
};
var xo = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new wo({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e2) {
    if (e2 < 0 || e2 > this.bytes.length - 1)
      throw new _o({
        length: this.bytes.length,
        position: e2
      });
  },
  decrementPosition(e2) {
    if (e2 < 0)
      throw new Mn({ offset: e2 });
    const t3 = this.position - e2;
    this.assertPosition(t3), this.position = t3;
  },
  getReadCount(e2) {
    return this.positionReadCount.get(e2 || this.position) || 0;
  },
  incrementPosition(e2) {
    if (e2 < 0)
      throw new Mn({ offset: e2 });
    const t3 = this.position + e2;
    this.assertPosition(t3), this.position = t3;
  },
  inspectByte(e2) {
    const t3 = e2 ?? this.position;
    return this.assertPosition(t3), this.bytes[t3];
  },
  inspectBytes(e2, t3) {
    const r4 = t3 ?? this.position;
    return this.assertPosition(r4 + e2 - 1), this.bytes.subarray(r4, r4 + e2);
  },
  inspectUint8(e2) {
    const t3 = e2 ?? this.position;
    return this.assertPosition(t3), this.bytes[t3];
  },
  inspectUint16(e2) {
    const t3 = e2 ?? this.position;
    return this.assertPosition(t3 + 1), this.dataView.getUint16(t3);
  },
  inspectUint24(e2) {
    const t3 = e2 ?? this.position;
    return this.assertPosition(t3 + 2), (this.dataView.getUint16(t3) << 8) + this.dataView.getUint8(t3 + 2);
  },
  inspectUint32(e2) {
    const t3 = e2 ?? this.position;
    return this.assertPosition(t3 + 3), this.dataView.getUint32(t3);
  },
  pushByte(e2) {
    this.assertPosition(this.position), this.bytes[this.position] = e2, this.position++;
  },
  pushBytes(e2) {
    this.assertPosition(this.position + e2.length - 1), this.bytes.set(e2, this.position), this.position += e2.length;
  },
  pushUint8(e2) {
    this.assertPosition(this.position), this.bytes[this.position] = e2, this.position++;
  },
  pushUint16(e2) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e2), this.position += 2;
  },
  pushUint24(e2) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e2 >> 8), this.dataView.setUint8(this.position + 2, e2 & 255), this.position += 3;
  },
  pushUint32(e2) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e2), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectByte();
    return this.position++, e2;
  },
  readBytes(e2, t3) {
    this.assertReadLimit(), this._touch();
    const r4 = this.inspectBytes(e2);
    return this.position += t3 ?? e2, r4;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint8();
    return this.position += 1, e2;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint16();
    return this.position += 2, e2;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint24();
    return this.position += 3, e2;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint32();
    return this.position += 4, e2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e2) {
    const t3 = this.position;
    return this.assertPosition(e2), this.position = e2, () => this.position = t3;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e2 = this.getReadCount();
    this.positionReadCount.set(this.position, e2 + 1), e2 > 0 && this.recursiveReadCount++;
  }
};
function ki(e2, { recursiveReadLimit: t3 = 8192 } = {}) {
  const r4 = Object.create(xo);
  return r4.bytes = e2, r4.dataView = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), r4.positionReadCount = /* @__PURE__ */ new Map(), r4.recursiveReadLimit = t3, r4;
}
function at(e2, t3 = "hex") {
  const r4 = Fi(e2), n4 = ki(new Uint8Array(r4.length));
  return r4.encode(n4), t3 === "hex" ? Qe(n4.bytes) : n4.bytes;
}
function Fi(e2) {
  return Array.isArray(e2) ? vo(e2.map((t3) => Fi(t3))) : Eo(e2);
}
function vo(e2) {
  const t3 = e2.reduce((i5, a2) => i5 + a2.length, 0), r4 = Oi(t3);
  return {
    length: t3 <= 55 ? 1 + t3 : 1 + r4 + t3,
    encode(i5) {
      t3 <= 55 ? i5.pushByte(192 + t3) : (i5.pushByte(247 + r4), r4 === 1 ? i5.pushUint8(t3) : r4 === 2 ? i5.pushUint16(t3) : r4 === 3 ? i5.pushUint24(t3) : i5.pushUint32(t3));
      for (const { encode: a2 } of e2)
        a2(i5);
    }
  };
}
function Eo(e2) {
  const t3 = typeof e2 == "string" ? ot(e2) : e2, r4 = Oi(t3.length);
  return {
    length: t3.length === 1 && t3[0] < 128 ? 1 : t3.length <= 55 ? 1 + t3.length : 1 + r4 + t3.length,
    encode(i5) {
      t3.length === 1 && t3[0] < 128 ? i5.pushBytes(t3) : t3.length <= 55 ? (i5.pushByte(128 + t3.length), i5.pushBytes(t3)) : (i5.pushByte(183 + r4), r4 === 1 ? i5.pushUint8(t3.length) : r4 === 2 ? i5.pushUint16(t3.length) : r4 === 3 ? i5.pushUint24(t3.length) : i5.pushUint32(t3.length), i5.pushBytes(t3));
    }
  };
}
function Oi(e2) {
  if (e2 < 2 ** 8)
    return 1;
  if (e2 < 2 ** 16)
    return 2;
  if (e2 < 2 ** 24)
    return 3;
  if (e2 < 2 ** 32)
    return 4;
  throw new X("Length is too large.");
}
var Bo = {
  ether: -9,
  wei: 9
};
function So(e2, t3) {
  let r4 = e2.toString();
  const n4 = r4.startsWith("-");
  n4 && (r4 = r4.slice(1)), r4 = r4.padStart(t3, "0");
  let [i5, a2] = [
    r4.slice(0, r4.length - t3),
    r4.slice(r4.length - t3)
  ];
  return a2 = a2.replace(/(0+)$/, ""), `${n4 ? "-" : ""}${i5 || "0"}${a2 ? `.${a2}` : ""}`;
}
function tn(e2, t3 = "wei") {
  return So(e2, Bo[t3]);
}
function Io(e2) {
  const t3 = Object.entries(e2).map(([n4, i5]) => i5 === void 0 || i5 === false ? null : [n4, i5]).filter(Boolean), r4 = t3.reduce((n4, [i5]) => Math.max(n4, i5.length), 0);
  return t3.map(([n4, i5]) => `  ${`${n4}:`.padEnd(r4 + 1)}  ${i5}`).join(`
`);
}
var Ao = class extends X {
  constructor({ v: t3 }) {
    super(`Invalid \`v\` value "${t3}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
};
var Ro = class extends X {
  constructor({ transaction: t3 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Io(t3),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
};
var To = class extends X {
  constructor({ storageKey: t3 }) {
    super(`Size for storage key "${t3}" is invalid. Expected 32 bytes. Got ${Math.floor((t3.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
};
function Ui(e2) {
  const { kzg: t3 } = e2, r4 = e2.to ?? (typeof e2.blobs[0] == "string" ? "hex" : "bytes"), n4 = typeof e2.blobs[0] == "string" ? e2.blobs.map((a2) => ot(a2)) : e2.blobs, i5 = [];
  for (const a2 of n4)
    i5.push(Uint8Array.from(t3.blobToKzgCommitment(a2)));
  return r4 === "bytes" ? i5 : i5.map((a2) => Qe(a2));
}
function Ni(e2) {
  const { kzg: t3 } = e2, r4 = e2.to ?? (typeof e2.blobs[0] == "string" ? "hex" : "bytes"), n4 = typeof e2.blobs[0] == "string" ? e2.blobs.map((f) => ot(f)) : e2.blobs, i5 = typeof e2.commitments[0] == "string" ? e2.commitments.map((f) => ot(f)) : e2.commitments, a2 = [];
  for (let f = 0; f < n4.length; f++) {
    const u2 = n4[f], l = i5[f];
    a2.push(Uint8Array.from(t3.computeBlobKzgProof(u2, l)));
  }
  return r4 === "bytes" ? a2 : a2.map((f) => Qe(f));
}
function Dn(e2) {
  if (!Number.isSafeInteger(e2) || e2 < 0)
    throw new Error(`positive integer expected, not ${e2}`);
}
function Po(e2) {
  return e2 instanceof Uint8Array || e2 != null && typeof e2 == "object" && e2.constructor.name === "Uint8Array";
}
function gn(e2, ...t3) {
  if (!Po(e2))
    throw new Error("Uint8Array expected");
  if (t3.length > 0 && !t3.includes(e2.length))
    throw new Error(`Uint8Array expected of length ${t3}, not of length=${e2.length}`);
}
function dr(e2, t3 = true) {
  if (e2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t3 && e2.finished)
    throw new Error("Hash#digest() has already been called");
}
function Mi(e2, t3) {
  gn(e2);
  const r4 = t3.outputLen;
  if (e2.length < r4)
    throw new Error(`digestInto() expects output buffer of length at least ${r4}`);
}
var Co = (e2) => new Uint32Array(e2.buffer, e2.byteOffset, Math.floor(e2.byteLength / 4));
var Or = (e2) => new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
var Fe = (e2, t3) => e2 << 32 - t3 | e2 >>> t3;
var $n = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var Lo = (e2) => e2 << 24 & 4278190080 | e2 << 8 & 16711680 | e2 >>> 8 & 65280 | e2 >>> 24 & 255;
function Hn(e2) {
  for (let t3 = 0; t3 < e2.length; t3++)
    e2[t3] = Lo(e2[t3]);
}
function ko(e2) {
  if (typeof e2 != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e2}`);
  return new Uint8Array(new TextEncoder().encode(e2));
}
function mn(e2) {
  return typeof e2 == "string" && (e2 = ko(e2)), gn(e2), e2;
}
var Di = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function $i(e2) {
  const t3 = (n4) => e2().update(mn(n4)).digest(), r4 = e2();
  return t3.outputLen = r4.outputLen, t3.blockLen = r4.blockLen, t3.create = () => e2(), t3;
}
function Fo(e2, t3, r4, n4) {
  if (typeof e2.setBigUint64 == "function")
    return e2.setBigUint64(t3, r4, n4);
  const i5 = BigInt(32), a2 = BigInt(4294967295), f = Number(r4 >> i5 & a2), u2 = Number(r4 & a2), l = n4 ? 4 : 0, b2 = n4 ? 0 : 4;
  e2.setUint32(t3 + l, f, n4), e2.setUint32(t3 + b2, u2, n4);
}
var Oo = (e2, t3, r4) => e2 & t3 ^ ~e2 & r4;
var Uo = (e2, t3, r4) => e2 & t3 ^ e2 & r4 ^ t3 & r4;
var No = class extends Di {
  constructor(t3, r4, n4, i5) {
    super(), this.blockLen = t3, this.outputLen = r4, this.padOffset = n4, this.isLE = i5, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t3), this.view = Or(this.buffer);
  }
  update(t3) {
    dr(this);
    const { view: r4, buffer: n4, blockLen: i5 } = this;
    t3 = mn(t3);
    const a2 = t3.length;
    for (let f = 0; f < a2; ) {
      const u2 = Math.min(i5 - this.pos, a2 - f);
      if (u2 === i5) {
        const l = Or(t3);
        for (; i5 <= a2 - f; f += i5)
          this.process(l, f);
        continue;
      }
      n4.set(t3.subarray(f, f + u2), this.pos), this.pos += u2, f += u2, this.pos === i5 && (this.process(r4, 0), this.pos = 0);
    }
    return this.length += t3.length, this.roundClean(), this;
  }
  digestInto(t3) {
    dr(this), Mi(t3, this), this.finished = true;
    const { buffer: r4, view: n4, blockLen: i5, isLE: a2 } = this;
    let { pos: f } = this;
    r4[f++] = 128, this.buffer.subarray(f).fill(0), this.padOffset > i5 - f && (this.process(n4, 0), f = 0);
    for (let m = f; m < i5; m++)
      r4[m] = 0;
    Fo(n4, i5 - 8, BigInt(this.length * 8), a2), this.process(n4, 0);
    const u2 = Or(t3), l = this.outputLen;
    if (l % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const b2 = l / 4, g = this.get();
    if (b2 > g.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let m = 0; m < b2; m++)
      u2.setUint32(4 * m, g[m], a2);
  }
  digest() {
    const { buffer: t3, outputLen: r4 } = this;
    this.digestInto(t3);
    const n4 = t3.slice(0, r4);
    return this.destroy(), n4;
  }
  _cloneInto(t3) {
    t3 || (t3 = new this.constructor()), t3.set(...this.get());
    const { blockLen: r4, buffer: n4, length: i5, finished: a2, destroyed: f, pos: u2 } = this;
    return t3.length = i5, t3.pos = u2, t3.finished = a2, t3.destroyed = f, i5 % r4 && t3.buffer.set(n4), t3;
  }
};
var Mo = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Ke = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Ye = new Uint32Array(64);
var Do = class extends No {
  constructor() {
    super(64, 32, 8, false), this.A = Ke[0] | 0, this.B = Ke[1] | 0, this.C = Ke[2] | 0, this.D = Ke[3] | 0, this.E = Ke[4] | 0, this.F = Ke[5] | 0, this.G = Ke[6] | 0, this.H = Ke[7] | 0;
  }
  get() {
    const { A: t3, B: r4, C: n4, D: i5, E: a2, F: f, G: u2, H: l } = this;
    return [t3, r4, n4, i5, a2, f, u2, l];
  }
  // prettier-ignore
  set(t3, r4, n4, i5, a2, f, u2, l) {
    this.A = t3 | 0, this.B = r4 | 0, this.C = n4 | 0, this.D = i5 | 0, this.E = a2 | 0, this.F = f | 0, this.G = u2 | 0, this.H = l | 0;
  }
  process(t3, r4) {
    for (let m = 0; m < 16; m++, r4 += 4)
      Ye[m] = t3.getUint32(r4, false);
    for (let m = 16; m < 64; m++) {
      const v = Ye[m - 15], I = Ye[m - 2], B = Fe(v, 7) ^ Fe(v, 18) ^ v >>> 3, P = Fe(I, 17) ^ Fe(I, 19) ^ I >>> 10;
      Ye[m] = P + Ye[m - 7] + B + Ye[m - 16] | 0;
    }
    let { A: n4, B: i5, C: a2, D: f, E: u2, F: l, G: b2, H: g } = this;
    for (let m = 0; m < 64; m++) {
      const v = Fe(u2, 6) ^ Fe(u2, 11) ^ Fe(u2, 25), I = g + v + Oo(u2, l, b2) + Mo[m] + Ye[m] | 0, P = (Fe(n4, 2) ^ Fe(n4, 13) ^ Fe(n4, 22)) + Uo(n4, i5, a2) | 0;
      g = b2, b2 = l, l = u2, u2 = f + I | 0, f = a2, a2 = i5, i5 = n4, n4 = I + P | 0;
    }
    n4 = n4 + this.A | 0, i5 = i5 + this.B | 0, a2 = a2 + this.C | 0, f = f + this.D | 0, u2 = u2 + this.E | 0, l = l + this.F | 0, b2 = b2 + this.G | 0, g = g + this.H | 0, this.set(n4, i5, a2, f, u2, l, b2, g);
  }
  roundClean() {
    Ye.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var $o = $i(() => new Do());
function Ho(e2, t3) {
  return $o(Vt(e2, { strict: false }) ? Pi(e2) : e2);
}
function zo(e2) {
  const { commitment: t3, version: r4 = 1 } = e2, n4 = e2.to ?? (typeof t3 == "string" ? "hex" : "bytes"), i5 = Ho(t3);
  return i5.set([r4], 0), n4 === "bytes" ? i5 : Qe(i5);
}
function jo(e2) {
  const { commitments: t3, version: r4 } = e2, n4 = e2.to ?? (typeof t3[0] == "string" ? "hex" : "bytes"), i5 = [];
  for (const a2 of t3)
    i5.push(zo({
      commitment: a2,
      to: n4,
      version: r4
    }));
  return i5;
}
var zn = 6;
var Hi = 32;
var _n = 4096;
var zi = Hi * _n;
var jn = zi * zn - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * _n * zn;
var ji = 1;
var Go = class extends X {
  constructor({ maxSize: t3, size: r4 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t3} bytes`, `Given: ${r4} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var Gi = class extends X {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var Wo = class extends X {
  constructor({ hash: t3, size: r4 }) {
    super(`Versioned hash "${t3}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${r4}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var qo = class extends X {
  constructor({ hash: t3, version: r4 }) {
    super(`Versioned hash "${t3}" version is invalid.`, {
      metaMessages: [
        `Expected: ${ji}`,
        `Received: ${r4}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
};
function Vo(e2) {
  const t3 = e2.to ?? (typeof e2.data == "string" ? "hex" : "bytes"), r4 = typeof e2.data == "string" ? ot(e2.data) : e2.data, n4 = vt(r4);
  if (!n4)
    throw new Gi();
  if (n4 > jn)
    throw new Go({
      maxSize: jn,
      size: n4
    });
  const i5 = [];
  let a2 = true, f = 0;
  for (; a2; ) {
    const u2 = ki(new Uint8Array(zi));
    let l = 0;
    for (; l < _n; ) {
      const b2 = r4.slice(f, f + (Hi - 1));
      if (u2.pushByte(0), u2.pushBytes(b2), b2.length < 31) {
        u2.pushByte(128), a2 = false;
        break;
      }
      l++, f += 31;
    }
    i5.push(u2);
  }
  return t3 === "bytes" ? i5.map((u2) => u2.bytes) : i5.map((u2) => Qe(u2.bytes));
}
function Ko(e2) {
  const { data: t3, kzg: r4, to: n4 } = e2, i5 = e2.blobs ?? Vo({ data: t3, to: n4 }), a2 = e2.commitments ?? Ui({ blobs: i5, kzg: r4, to: n4 }), f = e2.proofs ?? Ni({ blobs: i5, commitments: a2, kzg: r4, to: n4 }), u2 = [];
  for (let l = 0; l < i5.length; l++)
    u2.push({
      blob: i5[l],
      commitment: a2[l],
      proof: f[l]
    });
  return u2;
}
function Yo(e2) {
  if (!e2 || e2.length === 0)
    return [];
  const t3 = [];
  for (const r4 of e2) {
    const { contractAddress: n4, chainId: i5, nonce: a2, ...f } = r4;
    t3.push([
      W2(i5),
      n4,
      a2 ? W2(a2) : "0x",
      ...Yt({}, f)
    ]);
  }
  return t3;
}
var ft = class extends X {
  constructor({ address: t3 }) {
    super(`Address "${t3}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
};
var wr = class extends X {
  constructor({ chainId: t3 }) {
    super(typeof t3 == "number" ? `Chain ID "${t3}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
};
var xr = class extends X {
  constructor({ cause: t3, maxFeePerGas: r4 } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r4 ? ` = ${tn(r4)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t3,
      name: "FeeCapTooHighError"
    });
  }
};
Object.defineProperty(xr, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
var Wi = class extends X {
  constructor({ cause: t3, maxPriorityFeePerGas: r4, maxFeePerGas: n4 } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r4 ? ` = ${tn(r4)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n4 ? ` = ${tn(n4)} gwei` : ""}).`
    ].join(`
`), {
      cause: t3,
      name: "TipAboveFeeCapError"
    });
  }
};
Object.defineProperty(Wi, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
var qi = class extends Map {
  constructor(t3) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), this.maxSize = t3;
  }
  get(t3) {
    const r4 = super.get(t3);
    return super.has(t3) && r4 !== void 0 && (this.delete(t3), super.set(t3, r4)), r4;
  }
  set(t3, r4) {
    if (super.set(t3, r4), this.maxSize && this.size > this.maxSize) {
      const n4 = this.keys().next().value;
      n4 && this.delete(n4);
    }
    return this;
  }
};
var sr = BigInt(2 ** 32 - 1);
var Gn = BigInt(32);
function Jo(e2, t3 = false) {
  return t3 ? { h: Number(e2 & sr), l: Number(e2 >> Gn & sr) } : { h: Number(e2 >> Gn & sr) | 0, l: Number(e2 & sr) | 0 };
}
function Xo(e2, t3 = false) {
  let r4 = new Uint32Array(e2.length), n4 = new Uint32Array(e2.length);
  for (let i5 = 0; i5 < e2.length; i5++) {
    const { h: a2, l: f } = Jo(e2[i5], t3);
    [r4[i5], n4[i5]] = [a2, f];
  }
  return [r4, n4];
}
var Qo = (e2, t3, r4) => e2 << r4 | t3 >>> 32 - r4;
var Zo = (e2, t3, r4) => t3 << r4 | e2 >>> 32 - r4;
var ea = (e2, t3, r4) => t3 << r4 - 32 | e2 >>> 64 - r4;
var ta = (e2, t3, r4) => e2 << r4 - 32 | t3 >>> 64 - r4;
var Vi = [];
var Ki = [];
var Yi = [];
var ra = BigInt(0);
var Ft = BigInt(1);
var na = BigInt(2);
var ia = BigInt(7);
var sa = BigInt(256);
var oa = BigInt(113);
for (let e2 = 0, t3 = Ft, r4 = 1, n4 = 0; e2 < 24; e2++) {
  [r4, n4] = [n4, (2 * r4 + 3 * n4) % 5], Vi.push(2 * (5 * n4 + r4)), Ki.push((e2 + 1) * (e2 + 2) / 2 % 64);
  let i5 = ra;
  for (let a2 = 0; a2 < 7; a2++)
    t3 = (t3 << Ft ^ (t3 >> ia) * oa) % sa, t3 & na && (i5 ^= Ft << (Ft << BigInt(a2)) - Ft);
  Yi.push(i5);
}
var [aa, fa] = Xo(Yi, true);
var Wn = (e2, t3, r4) => r4 > 32 ? ea(e2, t3, r4) : Qo(e2, t3, r4);
var qn = (e2, t3, r4) => r4 > 32 ? ta(e2, t3, r4) : Zo(e2, t3, r4);
function ua(e2, t3 = 24) {
  const r4 = new Uint32Array(10);
  for (let n4 = 24 - t3; n4 < 24; n4++) {
    for (let f = 0; f < 10; f++)
      r4[f] = e2[f] ^ e2[f + 10] ^ e2[f + 20] ^ e2[f + 30] ^ e2[f + 40];
    for (let f = 0; f < 10; f += 2) {
      const u2 = (f + 8) % 10, l = (f + 2) % 10, b2 = r4[l], g = r4[l + 1], m = Wn(b2, g, 1) ^ r4[u2], v = qn(b2, g, 1) ^ r4[u2 + 1];
      for (let I = 0; I < 50; I += 10)
        e2[f + I] ^= m, e2[f + I + 1] ^= v;
    }
    let i5 = e2[2], a2 = e2[3];
    for (let f = 0; f < 24; f++) {
      const u2 = Ki[f], l = Wn(i5, a2, u2), b2 = qn(i5, a2, u2), g = Vi[f];
      i5 = e2[g], a2 = e2[g + 1], e2[g] = l, e2[g + 1] = b2;
    }
    for (let f = 0; f < 50; f += 10) {
      for (let u2 = 0; u2 < 10; u2++)
        r4[u2] = e2[f + u2];
      for (let u2 = 0; u2 < 10; u2++)
        e2[f + u2] ^= ~r4[(u2 + 2) % 10] & r4[(u2 + 4) % 10];
    }
    e2[0] ^= aa[n4], e2[1] ^= fa[n4];
  }
  r4.fill(0);
}
var wn = class _wn extends Di {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t3, r4, n4, i5 = false, a2 = 24) {
    if (super(), this.blockLen = t3, this.suffix = r4, this.outputLen = n4, this.enableXOF = i5, this.rounds = a2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, Dn(n4), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = Co(this.state);
  }
  keccak() {
    $n || Hn(this.state32), ua(this.state32, this.rounds), $n || Hn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t3) {
    dr(this);
    const { blockLen: r4, state: n4 } = this;
    t3 = mn(t3);
    const i5 = t3.length;
    for (let a2 = 0; a2 < i5; ) {
      const f = Math.min(r4 - this.pos, i5 - a2);
      for (let u2 = 0; u2 < f; u2++)
        n4[this.pos++] ^= t3[a2++];
      this.pos === r4 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: t3, suffix: r4, pos: n4, blockLen: i5 } = this;
    t3[n4] ^= r4, r4 & 128 && n4 === i5 - 1 && this.keccak(), t3[i5 - 1] ^= 128, this.keccak();
  }
  writeInto(t3) {
    dr(this, false), gn(t3), this.finish();
    const r4 = this.state, { blockLen: n4 } = this;
    for (let i5 = 0, a2 = t3.length; i5 < a2; ) {
      this.posOut >= n4 && this.keccak();
      const f = Math.min(n4 - this.posOut, a2 - i5);
      t3.set(r4.subarray(this.posOut, this.posOut + f), i5), this.posOut += f, i5 += f;
    }
    return t3;
  }
  xofInto(t3) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t3);
  }
  xof(t3) {
    return Dn(t3), this.xofInto(new Uint8Array(t3));
  }
  digestInto(t3) {
    if (Mi(t3, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t3), this.destroy(), t3;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t3) {
    const { blockLen: r4, suffix: n4, outputLen: i5, rounds: a2, enableXOF: f } = this;
    return t3 || (t3 = new _wn(r4, n4, i5, f, a2)), t3.state32.set(this.state32), t3.pos = this.pos, t3.posOut = this.posOut, t3.finished = this.finished, t3.rounds = a2, t3.suffix = n4, t3.outputLen = i5, t3.enableXOF = f, t3.destroyed = this.destroyed, t3;
  }
};
var ca = (e2, t3, r4) => $i(() => new wn(t3, e2, r4));
var la = ca(1, 136, 256 / 8);
function ha(e2, t3) {
  return la(Vt(e2, { strict: false }) ? Pi(e2) : e2);
}
var Ur = new qi(8192);
function da(e2, t3) {
  if (Ur.has(`${e2}.${t3}`))
    return Ur.get(`${e2}.${t3}`);
  const r4 = e2.substring(2).toLowerCase(), n4 = ha(Ci(r4)), i5 = r4.split("");
  for (let f = 0; f < 40; f += 2)
    n4[f >> 1] >> 4 >= 8 && i5[f] && (i5[f] = i5[f].toUpperCase()), (n4[f >> 1] & 15) >= 8 && i5[f + 1] && (i5[f + 1] = i5[f + 1].toUpperCase());
  const a2 = `0x${i5.join("")}`;
  return Ur.set(`${e2}.${t3}`, a2), a2;
}
var pa = /^0x[a-fA-F0-9]{40}$/;
var Nr = new qi(8192);
function ut(e2, t3) {
  const { strict: r4 = true } = t3 ?? {}, n4 = `${e2}.${r4}`;
  if (Nr.has(n4))
    return Nr.get(n4);
  const i5 = pa.test(e2) ? e2.toLowerCase() === e2 ? true : r4 ? da(e2) === e2 : true : false;
  return Nr.set(n4, i5), i5;
}
function ba(e2, t3, r4, { strict: n4 } = {}) {
  return Vt(e2, { strict: false }) ? ga(e2, t3, r4, {
    strict: n4
  }) : ya(e2, t3, r4, {
    strict: n4
  });
}
function Ji(e2, t3, r4) {
  if (vt(e2) !== r4 - t3)
    throw new eo({
      offset: r4,
      position: "end",
      size: vt(e2)
    });
}
function ya(e2, t3, r4, { strict: n4 } = {}) {
  const i5 = e2.slice(t3, r4);
  return n4 && Ji(i5, t3, r4), i5;
}
function ga(e2, t3, r4, { strict: n4 } = {}) {
  const i5 = `0x${e2.replace("0x", "").slice(t3 * 2, r4 * 2)}`;
  return n4 && Ji(i5, t3, r4), i5;
}
function ma(e2) {
  const { authorizationList: t3 } = e2;
  if (t3)
    for (const r4 of t3) {
      const { contractAddress: n4, chainId: i5 } = r4;
      if (!ut(n4))
        throw new ft({ address: n4 });
      if (i5 <= 0)
        throw new wr({ chainId: i5 });
    }
  xn(e2);
}
function _a(e2) {
  const { blobVersionedHashes: t3 } = e2;
  if (t3) {
    if (t3.length === 0)
      throw new Gi();
    for (const r4 of t3) {
      const n4 = vt(r4), i5 = hr(ba(r4, 0, 1));
      if (n4 !== 32)
        throw new Wo({ hash: r4, size: n4 });
      if (i5 !== ji)
        throw new qo({
          hash: r4,
          version: i5
        });
    }
  }
  xn(e2);
}
function xn(e2) {
  const { chainId: t3, maxPriorityFeePerGas: r4, maxFeePerGas: n4, to: i5 } = e2;
  if (t3 <= 0)
    throw new wr({ chainId: t3 });
  if (i5 && !ut(i5))
    throw new ft({ address: i5 });
  if (n4 && n4 > yn)
    throw new xr({ maxFeePerGas: n4 });
  if (r4 && n4 && r4 > n4)
    throw new Wi({ maxFeePerGas: n4, maxPriorityFeePerGas: r4 });
}
function wa(e2) {
  const { chainId: t3, maxPriorityFeePerGas: r4, gasPrice: n4, maxFeePerGas: i5, to: a2 } = e2;
  if (t3 <= 0)
    throw new wr({ chainId: t3 });
  if (a2 && !ut(a2))
    throw new ft({ address: a2 });
  if (r4 || i5)
    throw new X("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (n4 && n4 > yn)
    throw new xr({ maxFeePerGas: n4 });
}
function xa(e2) {
  const { chainId: t3, maxPriorityFeePerGas: r4, gasPrice: n4, maxFeePerGas: i5, to: a2 } = e2;
  if (a2 && !ut(a2))
    throw new ft({ address: a2 });
  if (typeof t3 < "u" && t3 <= 0)
    throw new wr({ chainId: t3 });
  if (r4 || i5)
    throw new X("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (n4 && n4 > yn)
    throw new xr({ maxFeePerGas: n4 });
}
function va(e2) {
  if (e2.type)
    return e2.type;
  if (typeof e2.authorizationList < "u")
    return "eip7702";
  if (typeof e2.blobs < "u" || typeof e2.blobVersionedHashes < "u" || typeof e2.maxFeePerBlobGas < "u" || typeof e2.sidecars < "u")
    return "eip4844";
  if (typeof e2.maxFeePerGas < "u" || typeof e2.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e2.gasPrice < "u")
    return typeof e2.accessList < "u" ? "eip2930" : "legacy";
  throw new Ro({ transaction: e2 });
}
function vr(e2) {
  if (!e2 || e2.length === 0)
    return [];
  const t3 = [];
  for (let r4 = 0; r4 < e2.length; r4++) {
    const { address: n4, storageKeys: i5 } = e2[r4];
    for (let a2 = 0; a2 < i5.length; a2++)
      if (i5[a2].length - 2 !== 64)
        throw new To({ storageKey: i5[a2] });
    if (!ut(n4, { strict: false }))
      throw new ft({ address: n4 });
    t3.push([n4, i5]);
  }
  return t3;
}
function Ea(e2, t3) {
  const r4 = va(e2);
  return r4 === "eip1559" ? Ia(e2, t3) : r4 === "eip2930" ? Aa(e2, t3) : r4 === "eip4844" ? Sa(e2, t3) : r4 === "eip7702" ? Ba(e2, t3) : Ra(e2, t3);
}
function Ba(e2, t3) {
  const { authorizationList: r4, chainId: n4, gas: i5, nonce: a2, to: f, value: u2, maxFeePerGas: l, maxPriorityFeePerGas: b2, accessList: g, data: m } = e2;
  ma(e2);
  const v = vr(g), I = Yo(r4);
  return Kt([
    "0x04",
    at([
      W2(n4),
      a2 ? W2(a2) : "0x",
      b2 ? W2(b2) : "0x",
      l ? W2(l) : "0x",
      i5 ? W2(i5) : "0x",
      f ?? "0x",
      u2 ? W2(u2) : "0x",
      m ?? "0x",
      v,
      I,
      ...Yt(e2, t3)
    ])
  ]);
}
function Sa(e2, t3) {
  const { chainId: r4, gas: n4, nonce: i5, to: a2, value: f, maxFeePerBlobGas: u2, maxFeePerGas: l, maxPriorityFeePerGas: b2, accessList: g, data: m } = e2;
  _a(e2);
  let v = e2.blobVersionedHashes, I = e2.sidecars;
  if (e2.blobs && (typeof v > "u" || typeof I > "u")) {
    const k2 = typeof e2.blobs[0] == "string" ? e2.blobs : e2.blobs.map((S) => Qe(S)), L = e2.kzg, O = Ui({
      blobs: k2,
      kzg: L
    });
    if (typeof v > "u" && (v = jo({
      commitments: O
    })), typeof I > "u") {
      const S = Ni({ blobs: k2, commitments: O, kzg: L });
      I = Ko({ blobs: k2, commitments: O, proofs: S });
    }
  }
  const B = vr(g), P = [
    W2(r4),
    i5 ? W2(i5) : "0x",
    b2 ? W2(b2) : "0x",
    l ? W2(l) : "0x",
    n4 ? W2(n4) : "0x",
    a2 ?? "0x",
    f ? W2(f) : "0x",
    m ?? "0x",
    B,
    u2 ? W2(u2) : "0x",
    v ?? [],
    ...Yt(e2, t3)
  ], T = [], C2 = [], F = [];
  if (I)
    for (let k2 = 0; k2 < I.length; k2++) {
      const { blob: L, commitment: O, proof: S } = I[k2];
      T.push(L), C2.push(O), F.push(S);
    }
  return Kt([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    at(I ? [P, T, C2, F] : P)
  ]);
}
function Ia(e2, t3) {
  const { chainId: r4, gas: n4, nonce: i5, to: a2, value: f, maxFeePerGas: u2, maxPriorityFeePerGas: l, accessList: b2, data: g } = e2;
  xn(e2);
  const m = vr(b2), v = [
    W2(r4),
    i5 ? W2(i5) : "0x",
    l ? W2(l) : "0x",
    u2 ? W2(u2) : "0x",
    n4 ? W2(n4) : "0x",
    a2 ?? "0x",
    f ? W2(f) : "0x",
    g ?? "0x",
    m,
    ...Yt(e2, t3)
  ];
  return Kt([
    "0x02",
    at(v)
  ]);
}
function Aa(e2, t3) {
  const { chainId: r4, gas: n4, data: i5, nonce: a2, to: f, value: u2, accessList: l, gasPrice: b2 } = e2;
  wa(e2);
  const g = vr(l), m = [
    W2(r4),
    a2 ? W2(a2) : "0x",
    b2 ? W2(b2) : "0x",
    n4 ? W2(n4) : "0x",
    f ?? "0x",
    u2 ? W2(u2) : "0x",
    i5 ?? "0x",
    g,
    ...Yt(e2, t3)
  ];
  return Kt([
    "0x01",
    at(m)
  ]);
}
function Ra(e2, t3) {
  const { chainId: r4 = 0, gas: n4, data: i5, nonce: a2, to: f, value: u2, gasPrice: l } = e2;
  xa(e2);
  let b2 = [
    a2 ? W2(a2) : "0x",
    l ? W2(l) : "0x",
    n4 ? W2(n4) : "0x",
    f ?? "0x",
    u2 ? W2(u2) : "0x",
    i5 ?? "0x"
  ];
  if (t3) {
    const g = (() => {
      if (t3.v >= 35n)
        return (t3.v - 35n) / 2n > 0 ? t3.v : 27n + (t3.v === 35n ? 0n : 1n);
      if (r4 > 0)
        return BigInt(r4 * 2) + BigInt(35n + t3.v - 27n);
      const I = 27n + (t3.v === 27n ? 0n : 1n);
      if (t3.v !== I)
        throw new Ao({ v: t3.v });
      return I;
    })(), m = lr(t3.r), v = lr(t3.s);
    b2 = [
      ...b2,
      W2(g),
      m === "0x00" ? "0x" : m,
      v === "0x00" ? "0x" : v
    ];
  } else r4 > 0 && (b2 = [
    ...b2,
    W2(r4),
    "0x",
    "0x"
  ]);
  return at(b2);
}
function Yt(e2, t3) {
  const r4 = t3 ?? e2, { v: n4, yParity: i5 } = r4;
  if (typeof r4.r > "u")
    return [];
  if (typeof r4.s > "u")
    return [];
  if (typeof n4 > "u" && typeof i5 > "u")
    return [];
  const a2 = lr(r4.r), f = lr(r4.s);
  return [typeof i5 == "number" ? i5 ? W2(1) : "0x" : n4 === 0n ? "0x" : n4 === 1n ? W2(1) : n4 === 27n ? "0x" : W2(1), a2 === "0x00" ? "0x" : a2, f === "0x00" ? "0x" : f];
}
var Ta = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};
var Pa = {
  block: po({
    format(e2) {
      var r4;
      return {
        transactions: (r4 = e2.transactions) == null ? void 0 : r4.map((n4) => {
          if (typeof n4 == "string")
            return n4;
          const i5 = bn(n4);
          return i5.typeHex === "0x7e" && (i5.isSystemTx = n4.isSystemTx, i5.mint = n4.mint ? mt(n4.mint) : void 0, i5.sourceHash = n4.sourceHash, i5.type = "deposit"), i5;
        }),
        stateRoot: e2.stateRoot
      };
    }
  }),
  transaction: co({
    format(e2) {
      const t3 = {};
      return e2.type === "0x7e" && (t3.isSystemTx = e2.isSystemTx, t3.mint = e2.mint ? mt(e2.mint) : void 0, t3.sourceHash = e2.sourceHash, t3.type = "deposit"), t3;
    }
  }),
  transactionReceipt: mo({
    format(e2) {
      return {
        l1GasPrice: e2.l1GasPrice ? mt(e2.l1GasPrice) : null,
        l1GasUsed: e2.l1GasUsed ? mt(e2.l1GasUsed) : null,
        l1Fee: e2.l1Fee ? mt(e2.l1Fee) : null,
        l1FeeScalar: e2.l1FeeScalar ? Number(e2.l1FeeScalar) : null
      };
    }
  })
};
function Ca(e2, t3) {
  return Fa(e2) ? ka(e2) : Ea(e2, t3);
}
var La = {
  transaction: Ca
};
function ka(e2) {
  Oa(e2);
  const { sourceHash: t3, data: r4, from: n4, gas: i5, isSystemTx: a2, mint: f, to: u2, value: l } = e2, b2 = [
    t3,
    n4,
    u2 ?? "0x",
    f ? W2(f) : "0x",
    l ? W2(l) : "0x",
    i5 ? W2(i5) : "0x",
    a2 ? "0x1" : "0x",
    r4 ?? "0x"
  ];
  return Kt([
    "0x7e",
    at(b2)
  ]);
}
function Fa(e2) {
  return e2.type === "deposit" || typeof e2.sourceHash < "u";
}
function Oa(e2) {
  const { from: t3, to: r4 } = e2;
  if (t3 && !ut(t3))
    throw new ft({ address: t3 });
  if (r4 && !ut(r4))
    throw new ft({ address: r4 });
}
var Vn = {
  contracts: Ta,
  formatters: Pa,
  serializers: La
};
var Ua = qt({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
var Na = qt({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});
var Ot = 11155111;
var Ma = qt({
  ...Vn,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...Vn.contracts,
    disputeGameFactory: {
      [Ot]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [Ot]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [Ot]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [Ot]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: Ot
});
var Da = qt({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
var $a = qt({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc2.sepolia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});
function rn(e2) {
  return typeof e2 == "string" && (e2 = Buffer.from(e2, "hex")), e2.length === 32 ? e2 : e2.subarray(1, 33);
}
function yt(e2, t3) {
  if (!e2) throw new Error(t3);
}
function Ha(e2) {
  return Buffer.concat([
    Uint8Array.from([192]),
    za(e2)
  ]);
}
function za(e2) {
  const t3 = On.encodingLength(e2.length), r4 = Buffer.allocUnsafe(t3);
  return On.encode(e2.length, r4), Buffer.concat([r4, e2]);
}
function ja(e2, t3) {
  if (e2.compare(t3) > 0) {
    const r4 = e2;
    e2 = t3, t3 = r4;
  }
  return [e2, t3];
}
var Ut = (e2) => e2.length === 64 ? e2 : e2.slice(2);
var Ga = (e2) => {
  if (!e2) return false;
  try {
    const t3 = Buffer.from(e2, "hex");
    return isPoint(t3);
  } catch {
    return false;
  }
};
var Wa = {
  ...$a,
  rpcUrls: {
    default: {
      http: ["https://ethereum-sepolia-rpc.publicnode.com"]
    }
  }
};
var qa = {
  ethereum: Da,
  ethereum_arbitrum: Ua,
  ethereum_sepolia: Wa,
  arbitrum_sepolia: Na,
  ethereum_localnet: i4,
  arbitrum_localnet: s3,
  base_sepolia: Ma
};
var dl = async (e2, t3) => {
  var n4;
  const r4 = qa[e2];
  if (r4)
    try {
      if (r4.id === ((n4 = t3.chain) == null ? void 0 : n4.id))
        return W({ message: "Already on the network", walletClient: t3 });
      await t3.switchChain({ id: r4.id });
      const i5 = createWalletClient({
        account: t3.account,
        chain: r4,
        transport: custom(window.ethereum)
      });
      return W({
        message: "Switched chain",
        walletClient: i5
      });
    } catch (i5) {
      if (Va(i5))
        try {
          await t3.addChain({ chain: r4 });
          const a2 = createWalletClient({
            account: t3.account,
            chain: r4,
            transport: custom(window.ethereum)
          });
          return W({
            message: "Added network",
            walletClient: a2
          });
        } catch {
          return b("Failed to add network");
        }
      else
        return b("Failed to switch network");
    }
  else
    return b("Chain not supported");
};
var Va = (e2) => typeof e2 == "object" && e2 !== null && "code" in e2 && e2.code === 4902;
var Ka = (e2, t3, r4, n4) => e2 + ":" + t3.toLowerCase() + "::" + r4 + ":" + n4.toLowerCase();
function pl(e2, t3) {
  if (!e2) return false;
  const r4 = t3 === "mainnet" ? fe.networks.bitcoin : fe.networks.testnet;
  fe.initEccLib(lib_exports);
  try {
    return fe.address.toOutputScript(e2, r4), true;
  } catch {
    return false;
  }
}
var te = ((e2) => (e2.Created = "Created", e2.Matched = "Matched", e2.InitiateDetected = "InitiateDetected", e2.Initiated = "Initiated", e2.CounterPartyInitiateDetected = "CounterPartyInitiateDetected", e2.CounterPartyInitiated = "CounterPartyInitiated", e2.RedeemDetected = "RedeemDetected", e2.Redeemed = "Redeemed", e2.CounterPartyRedeemDetected = "CounterPartyRedeemDetected", e2.CounterPartyRedeemed = "CounterPartyRedeemed", e2.Completed = "Completed", e2.CounterPartySwapExpired = "CounterPartySwapExpired", e2.Expired = "Expired", e2.RefundDetected = "RefundDetected", e2.Refunded = "Refunded", e2.CounterPartyRefundDetected = "CounterPartyRefundDetected", e2.CounterPartyRefunded = "CounterPartyRefunded", e2.Cancelled = "Cancelled", e2.DeadLineExceeded = "DeadLineExceeded", e2))(te || {});
var re = ((e2) => (e2.Idle = "Idle", e2.InitiateDetected = "InitiateDetected", e2.Initiated = "Initiated", e2.RedeemDetected = "RedeemDetected", e2.Redeemed = "Redeemed", e2.RefundDetected = "RefundDetected", e2.Refunded = "Refunded", e2.Expired = "Expired", e2))(re || {});
var Xi = (e2, t3, r4) => {
  const n4 = Kn(
    e2.source_swap,
    t3
  ), i5 = Kn(
    e2.destination_swap,
    r4
  );
  if (i5 === re.RedeemDetected)
    return te.RedeemDetected;
  if (n4 === re.Redeemed)
    return te.CounterPartyRedeemed;
  if (n4 === re.RedeemDetected)
    return te.CounterPartyRedeemDetected;
  if (i5 === re.Redeemed) return te.Redeemed;
  if (n4 === re.Refunded) return te.Refunded;
  if (n4 === re.RefundDetected)
    return te.RefundDetected;
  if (i5 === re.Expired)
    return te.CounterPartySwapExpired;
  if (n4 === re.Expired) return te.Expired;
  if (i5 === re.Refunded)
    return te.CounterPartyRefunded;
  if (i5 === re.RefundDetected)
    return te.CounterPartyRefundDetected;
  const a2 = Number(
    e2.create_order.additional_data.deadline
  );
  return i5 === re.Initiated ? te.CounterPartyInitiated : i5 === re.InitiateDetected ? te.CounterPartyInitiateDetected : pr(a2, 12) ? te.DeadLineExceeded : n4 === re.Initiated ? te.Initiated : pr(a2, 1) ? te.DeadLineExceeded : n4 === re.InitiateDetected ? te.InitiateDetected : te.Matched;
};
var Kn = (e2, t3) => {
  if (e2.redeem_tx_hash)
    return Number(e2.redeem_block_number) ? re.Redeemed : re.RedeemDetected;
  if (e2.refund_tx_hash)
    return Number(e2.refund_block_number) ? re.Refunded : re.RefundDetected;
  if (Number(e2.initiate_block_number)) {
    const r4 = Number(e2.initiate_block_number) + e2.timelock;
    if (t3 > r4) return re.Expired;
  }
  return e2.initiate_tx_hash ? Number(e2.initiate_block_number) ? re.Initiated : re.InitiateDetected : re.Idle;
};
var bl = (e2, t3, r4) => {
  const n4 = Xi(
    e2,
    t3,
    r4
  );
  return Qi(n4);
};
var Qi = (e2) => {
  switch (e2) {
    case te.Matched:
      return le.Initiate;
    case te.CounterPartyInitiated:
    case te.CounterPartyInitiateDetected:
    case te.RedeemDetected:
      return le.Redeem;
    case te.Expired:
      return le.Refund;
    default:
      return le.Idle;
  }
};
var pr = (e2, t3 = 0) => {
  const r4 = Date.now(), n4 = e2 * 1e3 + t3 * 36e5;
  return r4 >= n4;
};
var Ya = (e2) => e2.filter((t3) => {
  const { source_swap: r4, create_order: n4 } = t3, { initiate_tx_hash: i5, initiate_block_number: a2 } = r4, { deadline: f } = n4.additional_data;
  return i5 && Number(a2) ? true : i5 && !Number(a2) ? !pr(Number(f), 12) : i5 ? true : !pr(Number(f), 1);
});
var Ja = [
  {
    inputs: [
      {
        internalType: "address",
        name: "token_",
        type: "address"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "InvalidShortString",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "str",
        type: "string"
      }
    ],
    name: "StringTooLong",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [],
    name: "EIP712DomainChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Initiated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "secret",
        type: "bytes"
      }
    ],
    name: "Redeemed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      }
    ],
    name: "Refunded",
    type: "event"
  },
  {
    inputs: [],
    name: "eip712Domain",
    outputs: [
      {
        internalType: "bytes1",
        name: "fields",
        type: "bytes1"
      },
      {
        internalType: "string",
        name: "name",
        type: "string"
      },
      {
        internalType: "string",
        name: "version",
        type: "string"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "verifyingContract",
        type: "address"
      },
      {
        internalType: "bytes32",
        name: "salt",
        type: "bytes32"
      },
      {
        internalType: "uint256[]",
        name: "extensions",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      }
    ],
    name: "initiate",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes32",
        name: "secretHash",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "initiateWithSignature",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "signature",
        type: "bytes"
      }
    ],
    name: "instantRefund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          {
            internalType: "address",
            name: "redeemer",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "expiry",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes32",
            name: "secretHash",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "signature",
            type: "bytes"
          }
        ],
        internalType: "struct HTLC.InitWithSig[]",
        name: "inits",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "orderID",
            type: "bytes32"
          },
          {
            internalType: "bytes",
            name: "secret",
            type: "bytes"
          }
        ],
        internalType: "struct HTLC.Redeem[]",
        name: "redeems",
        type: "tuple[]"
      },
      {
        components: [
          {
            internalType: "bytes32",
            name: "orderID",
            type: "bytes32"
          }
        ],
        internalType: "struct HTLC.Refund[]",
        name: "refunds",
        type: "tuple[]"
      }
    ],
    name: "multicall",
    outputs: [
      {
        internalType: "bool[]",
        name: "results",
        type: "bool[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "orders",
    outputs: [
      {
        internalType: "bool",
        name: "isFulfilled",
        type: "bool"
      },
      {
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        internalType: "address",
        name: "redeemer",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "initiatedAt",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "timelock",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      },
      {
        internalType: "bytes",
        name: "secret",
        type: "bytes"
      }
    ],
    name: "redeem",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "orderID",
        type: "bytes32"
      }
    ],
    name: "refund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "contract IERC20",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];
var Xa = class {
  constructor(t3, r4, n4) {
    this.url = new r2("/relayer", r4), this.auth = n4, this.order = t3;
  }
  async init(t3) {
    if (!t3.account) return b("No account found");
    if (t3.account.address.toLowerCase() !== this.order.source_swap.initiator.toLowerCase())
      return b("Account address and order initiator mismatch");
    const { create_order: r4, source_swap: n4 } = this.order;
    if (!n4.amount || !n4.redeemer || !r4.timelock || !r4.secret_hash)
      return b("Invalid order");
    const i5 = o2(r4.secret_hash), a2 = BigInt(r4.timelock), f = o2(n4.redeemer), u2 = BigInt(n4.amount);
    try {
      const l = await this.auth.getToken();
      if (l.error) return b(l.error);
      const b2 = getContract({
        address: o2(this.order.source_swap.asset),
        abi: Ja,
        client: t3
      }), g = await b2.read.token(), m = await x(
        Number(u2),
        g,
        this.order.source_swap.asset,
        t3
      );
      if (m.error) return b(m.error);
      const v = await b2.read.eip712Domain(), I = await t3.signTypedData({
        account: t3.account,
        domain: {
          name: v[1],
          version: v[2],
          chainId: Number(v[3]),
          verifyingContract: v[4]
        },
        types: {
          Initiate: [
            { name: "redeemer", type: "address" },
            { name: "timelock", type: "uint256" },
            { name: "amount", type: "uint256" },
            { name: "secretHash", type: "bytes32" }
          ]
        },
        primaryType: "Initiate",
        message: {
          redeemer: f,
          timelock: a2,
          amount: u2,
          secretHash: i5
        }
      }), B = await k.post(
        this.url.endpoint("initiate"),
        {
          body: JSON.stringify({
            order_id: r4.create_id,
            signature: I,
            perform_on: "Source"
          }),
          headers: {
            Authorization: r(l.val),
            "Content-Type": "application/json"
          }
        }
      );
      return B.error ? b(B.error) : B.result ? W(B.result) : b("Init: No result found");
    } catch (l) {
      return console.log("init error :", l), b(String(l));
    }
  }
  async redeem(t3, r4) {
    try {
      const n4 = await this.auth.getToken();
      if (n4.error) return b(n4.error);
      const i5 = await k.post(
        this.url.endpoint("redeem"),
        {
          body: JSON.stringify({
            order_id: t3,
            secret: R(r4),
            perform_on: "Destination"
          }),
          headers: {
            Authorization: r(n4.val),
            "Content-Type": "application/json"
          }
        }
      );
      return i5.error ? b(i5.error) : i5.result ? W(i5.result) : b("Redeem: No result found");
    } catch (n4) {
      return b(String(n4));
    }
  }
};
var Qa = Buffer.from(
  "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
  "hex"
);
var Za = Buffer.from(
  "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
  "hex"
);
var ef = Buffer.concat([Qa, Za]);
var tf = Buffer.from(
  "0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0",
  "hex"
);
var Yn = {
  failedToCreateInternalPubkey: "failed to create internal pubkey",
  failedToTweakPubkey: "failed to tweak pubkey"
};
function rf() {
  const e2 = import_bitcoinjs_lib.crypto.sha256(Buffer.from("GardenHTLC", "utf-8")), t3 = pointMultiply(
    Buffer.concat([Buffer.from("04", "hex"), ef]),
    e2
  );
  if (!t3)
    throw new Error(Yn.failedToCreateInternalPubkey);
  const r4 = pointAdd(tf, t3);
  if (!r4) throw new Error(Yn.failedToCreateInternalPubkey);
  return rn(Buffer.from(r4));
}
var me = {
  secretMismatch: "invalid secret",
  secretHashLenMismatch: "secret hash should be 32 bytes",
  pubkeyLenMismatch: "pubkey should be 32 bytes",
  zeroOrNegativeExpiry: "expiry should be greater than 0",
  htlcAddressGenerationFailed: "failed to generate htlc address",
  notFunded: "address not funded",
  noCounterpartySigs: "counterparty signatures are required",
  counterPartySigNotFound: (e2) => "counterparty signature not found for utxo " + e2,
  invalidCounterpartySigForUTXO: (e2) => "invalid counterparty signature for utxo " + e2,
  htlcNotExpired: (e2) => `HTLC not expired, need more ${e2} blocks`,
  controlBlockGenerationFailed: "failed to generate control block",
  invalidLeaf: "invalid leaf"
};
var or = 192;
fe.initEccLib(lib_exports);
var br = class _br {
  /**
   * Note: redeemerAddress and initiatorAddress should be x-only public key without 02 or 03 prefix
   */
  constructor(t3, r4, n4, i5, a2, f, u2, l) {
    this.secretHash = n4, this.redeemerPubkey = i5, this.initiatorPubkey = a2, this.expiry = f, this.signer = t3, this.network = u2, this.internalPubkey = rf(), this.initiateAmount = r4, this.utxoHashes = l;
  }
  /**
   * Creates a GardenHTLC instance
   * @param signer Bitcoin wallet of the initiator or redeemer
   * @param secretHash 32 bytes secret hash
   * @param initiatorPubkey initiator's x-only public key without 02 or 03 prefix
   * @param redeemerPubkey redeemer's x-only public key without 02 or 03 prefix
   * @param expiry block height after which the funds can be refunded
   * @returns GardenHTLC instance
   *
   *
   * Note: When the signer is the initiator, only refund and instant refund can be done
   * When the signer is the redeemer, only redeem can be done
   */
  static async from(t3, r4, n4, i5, a2, f, u2) {
    n4 = n4.startsWith("0x") ? n4.slice(2) : n4, yt(n4.length === 64, me.secretHashLenMismatch), yt(
      i5.length === 64 || i5.length === 66,
      `initiator ${me.pubkeyLenMismatch}`
    ), yt(
      a2.length === 64 || a2.length === 66,
      `redeemer ${me.pubkeyLenMismatch}`
    ), yt(f > 0, me.zeroOrNegativeExpiry);
    const l = await t3.getNetwork();
    return new _br(
      t3,
      r4,
      n4,
      rn(a2).toString("hex"),
      rn(i5).toString("hex"),
      f,
      l,
      u2
    );
  }
  /**
   * Generates a taproot address for receiving the funds
   */
  address() {
    const { address: t3 } = fe.payments.p2tr({
      internalPubkey: this.internalPubkey,
      network: this.network,
      scriptTree: this.leaves()
    });
    if (!t3) throw new Error(me.htlcAddressGenerationFailed);
    return t3;
  }
  /**
   * returns the address of the HTLC
   */
  id() {
    return this.address();
  }
  async _buildRawTx(t3, r4) {
    const n4 = new fe.Transaction();
    n4.version = 2;
    const i5 = this.address(), a2 = await this.signer.getProvider();
    let f = [];
    if (this.utxoHashes && this.utxoHashes.length > 0)
      for (const l of this.utxoHashes) {
        const b2 = await a2.getTransaction(l);
        for (let g = 0; g < b2.vout.length; g++) {
          const m = b2.vout[g];
          m.scriptpubkey_address === i5 && f.push({
            txid: b2.txid,
            vout: g,
            value: m.value,
            status: { confirmed: false }
          });
        }
      }
    else
      f = await a2.getUTXOs(i5);
    const u2 = f.reduce((l, b2) => l + b2.value, 0);
    if (u2 === 0) throw new Error(`${i5} ${me.notFunded}`);
    for (let l = 0; l < f.length; l++)
      n4.addInput(Buffer.from(f[l].txid, "hex").reverse(), f[l].vout);
    return r4 ?? (r4 = await a2.suggestFee(i5, u2, s.MEDIUM)), n4.addOutput(
      fe.address.toOutputScript(t3, this.network),
      u2 - r4
    ), { tx: n4, usedUtxos: f };
  }
  /**
   * Builds a raw unsigned transaction with utxos from gardenHTLC address
   * and uses signer's address as the output address
   */
  async buildRawTx(t3) {
    return await this._buildRawTx(await this.signer.getAddress(), t3);
  }
  /**
   * prevout script for the gardenHTLC address
   */
  getOutputScript() {
    return fe.address.toOutputScript(this.address(), this.network);
  }
  async init(t3) {
    return t3 ?? (t3 = await (await this.signer.getProvider()).suggestFee(
      await this.signer.getAddress(),
      this.initiateAmount,
      s.MEDIUM
    )), await this.signer.send(this.address(), this.initiateAmount, t3);
  }
  /**
   * Instantly refunds the funds to the initiator given the counterparty's signatures and pubkey
   *
   * Note: If there are multiple UTXOs being spend, there should be a signature for each UTXO in counterPartySigs
   */
  async instantRefund(t3, r4) {
    yt(t3.length > 0, me.noCounterpartySigs);
    const { tx: n4, usedUtxos: i5 } = await this.buildRawTx(r4);
    for (const m of i5)
      if (!t3.find((v) => v.utxo === m.txid))
        throw new Error(me.counterPartySigNotFound(m.txid));
    const a2 = this.getOutputScript(), f = fe.Transaction.SIGHASH_DEFAULT, u2 = this.leafHash(
      2
      /* INSTANT_REFUND */
    ), l = i5.map((m) => m.value), b2 = Mr(a2, i5.length);
    for (let m = 0; m < n4.ins.length; m++) {
      const v = n4.hashForWitnessV1(
        m,
        b2,
        l,
        f,
        u2
      );
      if (!verifySchnorr(
        v,
        Buffer.from(this.redeemerPubkey, "hex"),
        Buffer.from(t3[m].sig, "hex")
      ))
        throw new Error(
          me.invalidCounterpartySigForUTXO(t3[m].utxo)
        );
      const I = await this.signer.signSchnorr(v), B = Buffer.from(n4.ins[m].hash).reverse().toString("hex"), P = t3.find((T) => T.utxo === B);
      if (!P)
        throw new Error(me.counterPartySigNotFound(B));
      n4.setWitness(m, [
        Buffer.from(P.sig, "hex"),
        I,
        this.instantRefundLeaf(),
        this.generateControlBlockFor(
          2
          /* INSTANT_REFUND */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(n4.toHex());
  }
  /**
   * Reveals the secret and redeems the HTLC
   */
  async redeem(t3, r4, n4) {
    yt(
      fe.crypto.sha256(Buffer.from(t3, "hex")).toString("hex") === this.secretHash,
      me.secretMismatch
    );
    const { tx: i5, usedUtxos: a2 } = await this._buildRawTx(
      r4 ?? await this.signer.getAddress(),
      n4
    ), f = this.leafHash(
      1
      /* REDEEM */
    ), u2 = a2.map((m) => m.value), l = Mr(this.getOutputScript(), a2.length), b2 = fe.Transaction.SIGHASH_DEFAULT;
    for (let m = 0; m < i5.ins.length; m++) {
      const v = i5.hashForWitnessV1(
        m,
        l,
        u2,
        b2,
        f
      ), I = await this.signer.signSchnorr(v);
      i5.setWitness(m, [
        I,
        Buffer.from(t3, "hex"),
        this.redeemLeaf(),
        this.generateControlBlockFor(
          1
          /* REDEEM */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(i5.toHex());
  }
  /**
   * Refunds the funds back to the initiator if the expiry block height + 1 is reached
   */
  async refund(t3, r4) {
    const { tx: n4, usedUtxos: i5 } = await this._buildRawTx(
      t3 ?? await this.signer.getAddress(),
      r4
    ), [a2, f] = await this.canRefund(i5);
    if (!a2)
      throw new Error(me.htlcNotExpired(f));
    const u2 = this.leafHash(
      0
      /* REFUND */
    ), l = i5.map((v) => v.value), b2 = Mr(this.getOutputScript(), i5.length), g = fe.Transaction.SIGHASH_DEFAULT;
    for (let v = 0; v < n4.ins.length; v++) {
      n4.ins[v].sequence = this.expiry;
      const I = n4.hashForWitnessV1(
        v,
        b2,
        l,
        g,
        u2
      ), B = await this.signer.signSchnorr(I);
      n4.setWitness(v, [
        B,
        this.refundLeaf(),
        this.generateControlBlockFor(
          0
          /* REFUND */
        )
      ]);
    }
    return await (await this.signer.getProvider()).broadcast(n4.toHex());
  }
  /**
   * Given a list of UTXOs, checks if the HTLC can be refunded
   */
  async canRefund(t3) {
    const n4 = await (await this.signer.getProvider()).getLatestTip();
    for (const i5 of t3) {
      let a2 = 0;
      if (i5.status.confirmed && i5.status.block_height + this.expiry > n4 ? a2 = i5.status.block_height + this.expiry - n4 + 1 : i5.status.confirmed || (a2 = this.expiry + 1), a2 > 0)
        return [false, a2];
    }
    return [true, 0];
  }
  /**
   * Given a leaf, generates the control block necessary for spending the leaf
   */
  generateControlBlockFor(t3) {
    let r4;
    switch (t3) {
      case 1:
        r4 = this.redeemLeaf();
        break;
      case 0:
        r4 = this.refundLeaf();
        break;
      case 2:
        r4 = this.instantRefundLeaf();
        break;
      default:
        throw new Error(me.invalidLeaf);
    }
    const n4 = fe.payments.p2tr({
      internalPubkey: this.internalPubkey,
      network: this.network,
      scriptTree: this.leaves(),
      redeem: {
        output: r4,
        redeemVersion: or
      }
    });
    if (!n4.witness)
      throw new Error(me.controlBlockGenerationFailed);
    return n4.witness[n4.witness.length - 1];
  }
  /**
   * Generates the hash of the leaf script
   * @param leaf Use leaf enum or pass 0 for refund, 1 for redeem, 2 for instant refund
   * @returns hash of the leaf script
   */
  leafHash(t3) {
    let r4 = this.redeemLeaf();
    return t3 === 0 && (r4 = this.refundLeaf()), t3 === 2 && (r4 = this.instantRefundLeaf()), fe.crypto.taggedHash("TapLeaf", Ha(r4));
  }
  refundLeaf() {
    return fe.script.fromASM(
      `
			${fe.script.number.encode(this.expiry).toString("hex")}
			OP_CHECKSEQUENCEVERIFY
			OP_DROP
			${this.initiatorPubkey}	
			OP_CHECKSIG
			`.trim().replace(/\s+/g, " ")
    );
  }
  redeemLeaf() {
    return fe.script.fromASM(
      `
			OP_SHA256
			${this.secretHash}
			OP_EQUALVERIFY
			${this.redeemerPubkey}
			OP_CHECKSIG
			`.trim().replace(/\s+/g, " ")
    );
  }
  instantRefundLeaf() {
    return fe.script.fromASM(
      `
			${this.initiatorPubkey}
			OP_CHECKSIG
			${this.redeemerPubkey}
			OP_CHECKSIGADD
			OP_2
			OP_NUMEQUAL
			`.trim().replace(/\s+/g, " ")
    );
  }
  leaves() {
    return [
      // most probable leaf (redeem)
      {
        version: or,
        output: this.redeemLeaf()
      },
      [
        {
          version: or,
          output: this.refundLeaf()
        },
        {
          version: or,
          output: this.instantRefundLeaf()
        }
      ]
    ];
  }
  /**
   * Generates the merkle proof for the leaf script
   */
  generateMerkleProofFor(t3) {
    const r4 = this.leafHash(
      1
      /* REDEEM */
    ), n4 = this.leafHash(
      2
      /* INSTANT_REFUND */
    ), i5 = this.leafHash(
      0
      /* REFUND */
    );
    switch (t3) {
      case 1: {
        const a2 = ja(
          i5,
          n4
        );
        return [
          fe.crypto.taggedHash(
            "TapBranch",
            Buffer.concat(a2)
          )
        ];
      }
      case 0:
        return [n4, r4];
      case 2:
        return [i5, r4];
      default:
        throw new Error(me.invalidLeaf);
    }
  }
};
function Mr(e2, t3) {
  const r4 = [];
  for (let n4 = 0; n4 < t3; n4++)
    r4.push(e2);
  return r4;
}
var nf = class {
  constructor() {
    this.cache = {};
  }
  set(t3, r4, n4, i5) {
    const a2 = {
      txHash: n4,
      timeStamp: Date.now(),
      btcRedeemUTXO: i5
    };
    this.cache[`${r4}_${t3.create_order.create_id}`] = a2;
  }
  get(t3, r4) {
    return this.cache[`${r4}_${t3.create_order.create_id}`] || null;
  }
  remove(t3, r4) {
    delete this.cache[`${r4}_${t3.create_order.create_id}`];
  }
};
var yl = class {
  constructor(t3) {
    if (this.eventListeners = /* @__PURE__ */ new Map(), this.getOrderThreshold = 20, this.useRelay = true, this.orderBook = new c({
      url: t3.orderbookURl,
      walletClient: t3.wallets.evmWallet,
      auth: t3.auth
    }), this.quote = t3.quote, this.secretManager = t3.secretManager, this.wallets = t3.wallets, this.orderbookUrl = t3.orderbookURl, this.auth = t3.auth, this.orderExecutorCache = new nf(), !t3.wallets.evmWallet.account)
      throw new Error("Account not found in evmWallet");
    this.evmAddress = t3.wallets.evmWallet.account.address, this.blockNumberFetcher = t3.blockNumberFetcher;
  }
  setUseRelay(t3) {
    this.useRelay = t3;
  }
  async swap(t3) {
    const r4 = await this.validateAndFillParams(t3);
    if (r4.error) return b(r4.error);
    const { sendAddress: n4, receiveAddress: i5, timelock: a2 } = r4.val, f = await this.orderBook.getOrdersCount(this.evmAddress);
    if (f.error) return b(f.error);
    const u2 = f.val + 1, l = this.secretManager.generateSecret(u2);
    if (l.error) return b(l.error);
    const { strategyId: b2, btcAddress: g } = t3.additionalData, m = {
      strategy_id: b2,
      ...g && {
        bitcoin_optional_recipient: g
      }
    }, v = {
      source_chain: t3.fromAsset.chain,
      destination_chain: t3.toAsset.chain,
      source_asset: t3.fromAsset.atomicSwapAddress,
      destination_asset: t3.toAsset.atomicSwapAddress,
      initiator_source_address: n4,
      initiator_destination_address: i5,
      source_amount: t3.sendAmount,
      destination_amount: t3.receiveAmount,
      fee: "1",
      nonce: u2.toString(),
      timelock: a2,
      secret_hash: R(l.val.secretHash),
      min_destination_confirmations: t3.minDestinationConfirmations ?? 0,
      additional_data: m
    }, I = await this.quote.getAttestedQuote(v);
    if (I.error) return b(I.error);
    const B = await this.orderBook.createOrder(I.val);
    if (B.error) return b(B.error);
    const P = await this.pollOrder(B.val);
    return P.error ? b(P.error) : W(P.val);
  }
  async validateAndFillParams(t3) {
    if (t3.fromAsset.chain === t3.toAsset.chain && t3.fromAsset.atomicSwapAddress === t3.toAsset.atomicSwapAddress)
      return b("Source and destination assets cannot be the same");
    if (s2(t3.fromAsset.chain) && !s2(t3.toAsset.chain) || !s2(t3.fromAsset.chain) && s2(t3.toAsset.chain))
      return b(
        "Both assets should be on the same network (either mainnet or testnet)"
      );
    if (o3(t3.fromAsset.chain) || o3(t3.toAsset.chain)) {
      if (!this.wallets.btcWallet)
        return b(
          "btcWallet is required for bitcoin chain. Please provide btcWallet in the constructor"
        );
      if (!t3.additionalData.btcAddress)
        return b(
          "btcAddress in additionalData is required for bitcoin chain"
        );
    }
    const r4 = await this.getAddresses(t3.fromAsset.chain);
    if (r4.error) return b(r4.error);
    const n4 = await this.getAddresses(t3.toAsset.chain);
    if (n4.error) return b(n4.error);
    const i5 = this.validateAmount(t3.sendAmount);
    if (i5.error) return b(i5.error);
    const a2 = this.validateAmount(t3.receiveAmount);
    if (a2.error) return b(a2.error);
    if (i5 < a2)
      return b("Send amount should be greater than receive amount");
    const f = this.getTimelock(t3.fromAsset.chain);
    return f ? W({
      sendAddress: r4.val,
      receiveAddress: n4.val,
      timelock: t3.timelock ?? f
    }) : b("Unsupported chain for timelock");
  }
  async getAddresses(t3) {
    var n4;
    switch (u(t3)) {
      case r3.EVM:
        return this.wallets.evmWallet.account ? W(this.wallets.evmWallet.account.address) : b("EVM Wallet not found");
      case r3.Bitcoin: {
        const i5 = await ((n4 = this.wallets.btcWallet) == null ? void 0 : n4.getPublicKey());
        return !i5 || !Ga(i5) ? b("Invalid btc public key") : W(Ut(i5));
      }
      default:
        return b("Unsupported chain");
    }
  }
  validateAmount(t3) {
    if (t3 == null || t3.includes("."))
      return b("Invalid amount ", t3);
    const r4 = new bignumber_default(t3);
    return !r4.isInteger() || r4.isNaN() || r4.lt(0) || r4.isLessThanOrEqualTo(0) ? b("Invalid amount ", t3) : W(r4);
  }
  getTimelock(t3) {
    switch (u(t3)) {
      case r3.EVM:
        return en.evm;
      case r3.Bitcoin:
        return en.btc;
      default:
        return;
    }
  }
  async pollOrder(t3) {
    let r4 = await this.orderBook.getOrder(t3, true), n4 = 0;
    for (; n4 < this.getOrderThreshold; ) {
      if (await i(1e3), n4++, r4.error) {
        if (!r4.error.includes("result is undefined"))
          return b(r4.error);
      } else if (r4.val && r4.val.create_order.create_id.toLowerCase() === t3.toLowerCase())
        return W(r4.val);
      r4 = await this.orderBook.getOrder(t3, true);
    }
    return b(`Order not found, createOrder id: ${t3}`);
  }
  async execute(t3 = 5e3) {
    return await this.orderBook.subscribeToOrders(
      true,
      t3,
      async (r4) => {
        const n4 = Ya(r4.data), i5 = await this.assignOrderStatus(n4);
        this.emit("onPendingOrdersChanged", i5);
        for (let a2 = 0; a2 < i5.length; a2++) {
          const f = i5[a2];
          switch (Qi(f.status)) {
            case le.Redeem: {
              const l = this.secretManager.generateSecret(
                Number(f.create_order.nonce)
              );
              if (l.error) {
                this.emit("error", f, l.error);
                return;
              }
              switch (u(f.destination_swap.chain)) {
                case r3.EVM: {
                  await this.evmRedeem(f, l.val.secret);
                  break;
                }
                case r3.Bitcoin: {
                  const b2 = this.getWallet(
                    f.destination_swap.chain
                  );
                  if (b2.error) {
                    this.emit("error", f, b2.error);
                    return;
                  }
                  await this.btcRedeem(
                    b2.val,
                    f,
                    l.val.secret
                  );
                  break;
                }
                default:
                  this.emit(
                    "error",
                    f,
                    "Unsupported chain: " + f.destination_swap.chain
                  );
              }
              break;
            }
            case le.Refund: {
              switch (u(f.source_swap.chain)) {
                case r3.EVM: {
                  this.emit(
                    "error",
                    f,
                    "EVM refund is automatically done by relay service"
                  );
                  break;
                }
                case r3.Bitcoin: {
                  const l = this.getWallet(f.source_swap.chain);
                  if (l.error) {
                    this.emit("error", f, l.error);
                    return;
                  }
                  await this.btcRefund(
                    l.val,
                    f
                  );
                  break;
                }
                default:
                  this.emit(
                    "error",
                    f,
                    "Unsupported chain: " + f.source_swap.chain
                  );
              }
              break;
            }
          }
        }
      },
      {
        per_page: 500
      },
      true
    );
  }
  async evmRedeem(t3, r4) {
    if (this.emit("log", t3.create_order.create_id, "executing evm redeem"), this.orderExecutorCache.get(t3, le.Redeem)) {
      this.emit("log", t3.create_order.create_id, "already redeemed");
      return;
    }
    const a2 = await new Xa(t3, this.orderbookUrl, this.auth).redeem(t3.create_order.create_id, r4);
    if (a2.error) {
      this.emit("error", t3, a2.error), a2.error.includes("Order already redeemed") && this.orderExecutorCache.set(
        t3,
        le.Redeem,
        t3.destination_swap.redeem_tx_hash
      );
      return;
    }
    this.orderExecutorCache.set(t3, le.Redeem, a2.val), this.emit("success", t3, le.Redeem, a2.val);
  }
  async btcRedeem(t3, r4, n4) {
    var u2, l;
    const i5 = this.orderExecutorCache.get(r4, le.Redeem), a2 = (u2 = r4.destination_swap.initiate_tx_hash.split(",").at(-1)) == null ? void 0 : u2.split(":").at(0);
    if (!a2) {
      this.emit("error", r4, "Failed to get initiate_tx_hash");
      return;
    }
    let f = false;
    if (i5)
      if (i5.btcRedeemUTXO && i5.btcRedeemUTXO !== a2)
        f = true, this.emit("log", r4.create_order.create_id, "rbf btc redeem");
      else {
        this.emit(
          "log",
          r4.create_order.create_id,
          "btcRedeem: already redeemed"
        );
        return;
      }
    else if (r4.destination_swap.redeem_tx_hash && !Number(r4.destination_swap.redeem_block_number))
      try {
        const b2 = await (await t3.getProvider()).getTransaction(r4.destination_swap.redeem_tx_hash);
        let g = false;
        for (const m of b2.vin)
          if (m.txid === a2) {
            g = true;
            break;
          }
        if (g) {
          this.orderExecutorCache.set(
            r4,
            le.Redeem,
            r4.destination_swap.redeem_tx_hash,
            a2
          ), this.emit(
            "log",
            r4.create_order.create_id,
            "already a valid redeem"
          );
          return;
        }
        f = true;
      } catch (b2) {
        if (b2.message.includes("Transaction not found"))
          f = true;
        else {
          this.emit("error", r4, "Failed to get redeem tx: " + b2);
          return;
        }
      }
    this.emit("log", r4.create_order.create_id, "executing btc redeem");
    try {
      const g = await (await br.from(
        t3,
        Number(r4.destination_swap.amount),
        r4.create_order.secret_hash,
        Ut(r4.destination_swap.initiator),
        Ut(r4.destination_swap.redeemer),
        r4.destination_swap.timelock,
        f ? [a2] : []
      )).redeem(
        R(n4),
        (l = r4.create_order.additional_data) == null ? void 0 : l.bitcoin_optional_recipient
      );
      f ? this.emit(
        "log",
        r4.create_order.create_id,
        "rbf: btc redeem success"
      ) : this.emit("success", r4, le.Redeem, g), this.orderExecutorCache.set(r4, le.Redeem, g, a2);
    } catch (b2) {
      this.emit("error", r4, "Failed btc redeem: " + b2);
    }
  }
  async btcRefund(t3, r4) {
    var n4;
    if (!this.orderExecutorCache.get(r4, le.Refund)) {
      this.emit("log", r4.create_order.create_id, "executing btc refund");
      try {
        const a2 = await (await br.from(
          t3,
          Number(r4.source_swap.amount),
          r4.create_order.secret_hash,
          Ut(r4.source_swap.initiator),
          Ut(r4.source_swap.redeemer),
          r4.source_swap.timelock
        )).refund(
          (n4 = r4.create_order.additional_data) == null ? void 0 : n4.bitcoin_optional_recipient
        );
        this.orderExecutorCache.set(r4, le.Refund, a2), this.emit("success", r4, le.Refund, a2);
      } catch (i5) {
        this.emit("error", r4, "Failed btc refund: " + i5);
      }
    }
  }
  getWallet(t3) {
    switch (u(t3)) {
      case r3.EVM:
        return W(this.wallets.evmWallet);
      case r3.Bitcoin:
        return W(this.wallets.btcWallet);
      default:
        return b("Unsupported chain for wallet");
    }
  }
  emit(t3, ...r4) {
    (this.eventListeners.get(t3) ?? []).forEach((i5) => {
      i5(...r4);
    });
  }
  on(t3, r4) {
    const n4 = this.eventListeners.get(t3) ?? [];
    n4.push(r4), this.eventListeners.set(t3, n4);
  }
  off(t3, r4) {
    const n4 = this.eventListeners.get(t3) ?? [], i5 = n4.indexOf(r4);
    i5 !== -1 && n4.splice(i5, 1);
  }
  async fetchCurrentBlockNumbers(t3, r4) {
    if (!r4 || !r4.source || !r4.destination)
      return b("Provide wallets to fetch the current block number");
    const n4 = o3(t3.source_swap.chain) ? await C(
      await r4.source.getProvider()
    ) : await N(r4.source);
    if (n4.error) return b(n4.error);
    const i5 = o3(t3.destination_swap.chain) ? await C(
      await r4.destination.getProvider()
    ) : await N(r4.destination);
    return i5.error ? b(i5.error) : W({
      source: n4.val,
      destination: i5.val
    });
  }
  async assignOrderStatus(t3) {
    var i5;
    const r4 = await ((i5 = this.blockNumberFetcher) == null ? void 0 : i5.fetchBlockNumbers()), n4 = [];
    for (let a2 = 0; a2 < t3.length; a2++) {
      const f = t3[a2], u2 = f.source_swap.chain, l = f.destination_swap.chain, b2 = this.getWallet(u2), g = this.getWallet(l);
      if (b2.error || g.error || !b2.val || !g.val) {
        this.emit(
          "error",
          f,
          "Source or Destination Wallet not found while executing order"
        );
        continue;
      }
      let m = r4 == null ? void 0 : r4.val[u2], v = r4 == null ? void 0 : r4.val[l];
      if (!m || !v) {
        const B = await this.fetchCurrentBlockNumbers(f, {
          source: b2.val,
          destination: g.val
        });
        if (B.error) {
          this.emit(
            "error",
            f,
            "Error while fetching CurrentBlockNumbers: " + B.error
          );
          continue;
        }
        m = B.val.source, v = B.val.destination;
      }
      const I = Xi(
        f,
        m,
        v
      );
      n4.push({
        ...f,
        status: I
      });
    }
    return n4;
  }
};
var gl = class {
  constructor(t3, r4) {
    this.url = new r2("/blocknumber/" + r4, t3);
  }
  async fetchBlockNumbers() {
    try {
      const t3 = await k.get(this.url);
      return W(t3);
    } catch (t3) {
      return b("Failed to fetch block numbers", t3);
    }
  }
};
var Xe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sf(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function of(e2) {
  if (e2.__esModule) return e2;
  var t3 = e2.default;
  if (typeof t3 == "function") {
    var r4 = function n4() {
      return this instanceof n4 ? Reflect.construct(t3, arguments, this.constructor) : t3.apply(this, arguments);
    };
    r4.prototype = t3.prototype;
  } else r4 = {};
  return Object.defineProperty(r4, "__esModule", { value: true }), Object.keys(e2).forEach(function(n4) {
    var i5 = Object.getOwnPropertyDescriptor(e2, n4);
    Object.defineProperty(r4, n4, i5.get ? i5 : {
      enumerable: true,
      get: function() {
        return e2[n4];
      }
    });
  }), r4;
}
var Zi = {};
var Et = {};
var Bt = {};
Object.defineProperty(Bt, "__esModule", { value: true });
Bt.testnet = Bt.bitcoin = void 0;
Bt.bitcoin = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "bc",
  bip32: {
    public: 76067358,
    private: 76066276
  },
  pubKeyHash: 0,
  scriptHash: 5,
  wif: 128
};
Bt.testnet = {
  messagePrefix: `Bitcoin Signed Message:
`,
  bech32: "tb",
  bip32: {
    public: 70617039,
    private: 70615956
  },
  pubKeyHash: 111,
  scriptHash: 196,
  wif: 239
};
var es = {};
var Gt = {
  Array: function(e2) {
    return e2 != null && e2.constructor === Array;
  },
  Boolean: function(e2) {
    return typeof e2 == "boolean";
  },
  Function: function(e2) {
    return typeof e2 == "function";
  },
  Nil: function(e2) {
    return e2 == null;
  },
  Number: function(e2) {
    return typeof e2 == "number";
  },
  Object: function(e2) {
    return typeof e2 == "object";
  },
  String: function(e2) {
    return typeof e2 == "string";
  },
  "": function() {
    return true;
  }
};
Gt.Null = Gt.Nil;
for (Jn in Gt)
  Gt[Jn].toJSON = function(e2) {
    return e2;
  }.bind(null, Jn);
var Jn;
var vn = Gt;
var it = vn;
function ts(e2) {
  return e2.name || e2.toString().match(/function (.*?)\s*\(/)[1];
}
function En(e2) {
  return it.Nil(e2) ? "" : ts(e2.constructor);
}
function af(e2) {
  return it.Function(e2) ? "" : it.String(e2) ? JSON.stringify(e2) : e2 && it.Object(e2) ? "" : e2;
}
function Bn(e2, t3) {
  Error.captureStackTrace && Error.captureStackTrace(e2, t3);
}
function yr(e2) {
  return it.Function(e2) ? e2.toJSON ? e2.toJSON() : ts(e2) : it.Array(e2) ? "Array" : e2 && it.Object(e2) ? "Object" : e2 !== void 0 ? e2 : "";
}
function rs(e2, t3, r4) {
  var n4 = af(t3);
  return "Expected " + yr(e2) + ", got" + (r4 !== "" ? " " + r4 : "") + (n4 !== "" ? " " + n4 : "");
}
function He(e2, t3, r4) {
  r4 = r4 || En(t3), this.message = rs(e2, t3, r4), Bn(this, He), this.__type = e2, this.__value = t3, this.__valueTypeName = r4;
}
He.prototype = Object.create(Error.prototype);
He.prototype.constructor = He;
function ff(e2, t3, r4, n4, i5) {
  var a2 = '" of type ';
  return t3 === "key" && (a2 = '" with key type '), rs('property "' + yr(r4) + a2 + yr(e2), n4, i5);
}
function wt(e2, t3, r4, n4, i5) {
  e2 ? (i5 = i5 || En(n4), this.message = ff(e2, r4, t3, n4, i5)) : this.message = 'Unexpected property "' + t3 + '"', Bn(this, He), this.__label = r4, this.__property = t3, this.__type = e2, this.__value = n4, this.__valueTypeName = i5;
}
wt.prototype = Object.create(Error.prototype);
wt.prototype.constructor = He;
function uf(e2, t3) {
  return new He(e2, {}, t3);
}
function cf(e2, t3, r4) {
  return e2 instanceof wt ? (t3 = t3 + "." + e2.__property, e2 = new wt(
    e2.__type,
    t3,
    e2.__label,
    e2.__value,
    e2.__valueTypeName
  )) : e2 instanceof He && (e2 = new wt(
    e2.__type,
    t3,
    r4,
    e2.__value,
    e2.__valueTypeName
  )), Bn(e2), e2;
}
var ns = {
  TfTypeError: He,
  TfPropertyTypeError: wt,
  tfCustomError: uf,
  tfSubError: cf,
  tfJSON: yr,
  getValueTypeName: En
};
var Dr;
var Xn;
function lf() {
  if (Xn) return Dr;
  Xn = 1;
  var e2 = vn, t3 = ns;
  function r4(S) {
    return Buffer.isBuffer(S);
  }
  function n4(S) {
    return typeof S == "string" && /^([0-9a-f]{2})+$/i.test(S);
  }
  function i5(S, z) {
    var M = S.toJSON();
    function $(se) {
      if (!S(se)) return false;
      if (se.length === z) return true;
      throw t3.tfCustomError(M + "(Length: " + z + ")", M + "(Length: " + se.length + ")");
    }
    return $.toJSON = function() {
      return M;
    }, $;
  }
  var a2 = i5.bind(null, e2.Array), f = i5.bind(null, r4), u2 = i5.bind(null, n4), l = i5.bind(null, e2.String);
  function b2(S, z, M) {
    M = M || e2.Number;
    function $(se, Te) {
      return M(se, Te) && se > S && se < z;
    }
    return $.toJSON = function() {
      return `${M.toJSON()} between [${S}, ${z}]`;
    }, $;
  }
  var g = Math.pow(2, 53) - 1;
  function m(S) {
    return typeof S == "number" && isFinite(S);
  }
  function v(S) {
    return S << 24 >> 24 === S;
  }
  function I(S) {
    return S << 16 >> 16 === S;
  }
  function B(S) {
    return (S | 0) === S;
  }
  function P(S) {
    return typeof S == "number" && S >= -g && S <= g && Math.floor(S) === S;
  }
  function T(S) {
    return (S & 255) === S;
  }
  function C2(S) {
    return (S & 65535) === S;
  }
  function F(S) {
    return S >>> 0 === S;
  }
  function k2(S) {
    return typeof S == "number" && S >= 0 && S <= g && Math.floor(S) === S;
  }
  var L = {
    ArrayN: a2,
    Buffer: r4,
    BufferN: f,
    Finite: m,
    Hex: n4,
    HexN: u2,
    Int8: v,
    Int16: I,
    Int32: B,
    Int53: P,
    Range: b2,
    StringN: l,
    UInt8: T,
    UInt16: C2,
    UInt32: F,
    UInt53: k2
  };
  for (var O in L)
    L[O].toJSON = function(S) {
      return S;
    }.bind(null, O);
  return Dr = L, Dr;
}
var Jt = ns;
var he = vn;
var De = Jt.tfJSON;
var is = Jt.TfTypeError;
var ss = Jt.TfPropertyTypeError;
var Nt = Jt.tfSubError;
var hf = Jt.getValueTypeName;
var $e = {
  arrayOf: function(t3, r4) {
    t3 = Oe(t3), r4 = r4 || {};
    function n4(i5, a2) {
      return !he.Array(i5) || he.Nil(i5) || r4.minLength !== void 0 && i5.length < r4.minLength || r4.maxLength !== void 0 && i5.length > r4.maxLength || r4.length !== void 0 && i5.length !== r4.length ? false : i5.every(function(f, u2) {
        try {
          return we(t3, f, a2);
        } catch (l) {
          throw Nt(l, u2);
        }
      });
    }
    return n4.toJSON = function() {
      var i5 = "[" + De(t3) + "]";
      return r4.length !== void 0 ? i5 += "{" + r4.length + "}" : (r4.minLength !== void 0 || r4.maxLength !== void 0) && (i5 += "{" + (r4.minLength === void 0 ? 0 : r4.minLength) + "," + (r4.maxLength === void 0 ? 1 / 0 : r4.maxLength) + "}"), i5;
    }, n4;
  },
  maybe: function e(t3) {
    t3 = Oe(t3);
    function r4(n4, i5) {
      return he.Nil(n4) || t3(n4, i5, e);
    }
    return r4.toJSON = function() {
      return "?" + De(t3);
    }, r4;
  },
  map: function(t3, r4) {
    t3 = Oe(t3), r4 && (r4 = Oe(r4));
    function n4(i5, a2) {
      if (!he.Object(i5) || he.Nil(i5)) return false;
      for (var f in i5) {
        try {
          r4 && we(r4, f, a2);
        } catch (l) {
          throw Nt(l, f, "key");
        }
        try {
          var u2 = i5[f];
          we(t3, u2, a2);
        } catch (l) {
          throw Nt(l, f);
        }
      }
      return true;
    }
    return r4 ? n4.toJSON = function() {
      return "{" + De(r4) + ": " + De(t3) + "}";
    } : n4.toJSON = function() {
      return "{" + De(t3) + "}";
    }, n4;
  },
  object: function(t3) {
    var r4 = {};
    for (var n4 in t3)
      r4[n4] = Oe(t3[n4]);
    function i5(a2, f) {
      if (!he.Object(a2) || he.Nil(a2)) return false;
      var u2;
      try {
        for (u2 in r4) {
          var l = r4[u2], b2 = a2[u2];
          we(l, b2, f);
        }
      } catch (g) {
        throw Nt(g, u2);
      }
      if (f) {
        for (u2 in a2)
          if (!r4[u2])
            throw new ss(void 0, u2);
      }
      return true;
    }
    return i5.toJSON = function() {
      return De(r4);
    }, i5;
  },
  anyOf: function() {
    var t3 = [].slice.call(arguments).map(Oe);
    function r4(n4, i5) {
      return t3.some(function(a2) {
        try {
          return we(a2, n4, i5);
        } catch {
          return false;
        }
      });
    }
    return r4.toJSON = function() {
      return t3.map(De).join("|");
    }, r4;
  },
  allOf: function() {
    var t3 = [].slice.call(arguments).map(Oe);
    function r4(n4, i5) {
      return t3.every(function(a2) {
        try {
          return we(a2, n4, i5);
        } catch {
          return false;
        }
      });
    }
    return r4.toJSON = function() {
      return t3.map(De).join(" & ");
    }, r4;
  },
  quacksLike: function(t3) {
    function r4(n4) {
      return t3 === hf(n4);
    }
    return r4.toJSON = function() {
      return t3;
    }, r4;
  },
  tuple: function() {
    var t3 = [].slice.call(arguments).map(Oe);
    function r4(n4, i5) {
      return he.Nil(n4) || he.Nil(n4.length) || i5 && n4.length !== t3.length ? false : t3.every(function(a2, f) {
        try {
          return we(a2, n4[f], i5);
        } catch (u2) {
          throw Nt(u2, f);
        }
      });
    }
    return r4.toJSON = function() {
      return "(" + t3.map(De).join(", ") + ")";
    }, r4;
  },
  value: function(t3) {
    function r4(n4) {
      return n4 === t3;
    }
    return r4.toJSON = function() {
      return t3;
    }, r4;
  }
};
$e.oneOf = $e.anyOf;
function Oe(e2) {
  if (he.String(e2))
    return e2[0] === "?" ? $e.maybe(e2.slice(1)) : he[e2] || $e.quacksLike(e2);
  if (e2 && he.Object(e2)) {
    if (he.Array(e2)) {
      if (e2.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
      return $e.arrayOf(e2[0]);
    }
    return $e.object(e2);
  } else if (he.Function(e2))
    return e2;
  return $e.value(e2);
}
function we(e2, t3, r4, n4) {
  if (he.Function(e2)) {
    if (e2(t3, r4)) return true;
    throw new is(n4 || e2, t3);
  }
  return we(Oe(e2), t3, r4);
}
for (Je in he)
  we[Je] = he[Je];
var Je;
for (Je in $e)
  we[Je] = $e[Je];
var Qn = lf();
for (Je in Qn)
  we[Je] = Qn[Je];
we.compile = Oe;
we.TfTypeError = is;
we.TfPropertyTypeError = ss;
var df = we;
(function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.maybe = e2.Boolean = e2.Array = e2.Buffer256bit = e2.Network = e2.typeforce = void 0, e2.typeforce = df, e2.Network = e2.typeforce.compile({
    messagePrefix: e2.typeforce.oneOf(
      e2.typeforce.Buffer,
      e2.typeforce.String
    ),
    bip32: {
      public: e2.typeforce.UInt32,
      private: e2.typeforce.UInt32
    },
    pubKeyHash: e2.typeforce.UInt8,
    scriptHash: e2.typeforce.UInt8,
    wif: e2.typeforce.UInt8
  }), e2.Buffer256bit = e2.typeforce.BufferN(32), e2.Array = e2.typeforce.Array, e2.Boolean = e2.typeforce.Boolean, e2.maybe = e2.typeforce.maybe;
})(es);
var nn = { exports: {} };
var sn = { exports: {} };
var Rt = {};
var Er = {};
Er.byteLength = yf;
Er.toByteArray = mf;
Er.fromByteArray = xf;
var Ue = [];
var Ae = [];
var pf = typeof Uint8Array < "u" ? Uint8Array : Array;
var $r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (gt = 0, bf = $r.length; gt < bf; ++gt)
  Ue[gt] = $r[gt], Ae[$r.charCodeAt(gt)] = gt;
var gt;
var bf;
Ae[45] = 62;
Ae[95] = 63;
function os(e2) {
  var t3 = e2.length;
  if (t3 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var r4 = e2.indexOf("=");
  r4 === -1 && (r4 = t3);
  var n4 = r4 === t3 ? 0 : 4 - r4 % 4;
  return [r4, n4];
}
function yf(e2) {
  var t3 = os(e2), r4 = t3[0], n4 = t3[1];
  return (r4 + n4) * 3 / 4 - n4;
}
function gf(e2, t3, r4) {
  return (t3 + r4) * 3 / 4 - r4;
}
function mf(e2) {
  var t3, r4 = os(e2), n4 = r4[0], i5 = r4[1], a2 = new pf(gf(e2, n4, i5)), f = 0, u2 = i5 > 0 ? n4 - 4 : n4, l;
  for (l = 0; l < u2; l += 4)
    t3 = Ae[e2.charCodeAt(l)] << 18 | Ae[e2.charCodeAt(l + 1)] << 12 | Ae[e2.charCodeAt(l + 2)] << 6 | Ae[e2.charCodeAt(l + 3)], a2[f++] = t3 >> 16 & 255, a2[f++] = t3 >> 8 & 255, a2[f++] = t3 & 255;
  return i5 === 2 && (t3 = Ae[e2.charCodeAt(l)] << 2 | Ae[e2.charCodeAt(l + 1)] >> 4, a2[f++] = t3 & 255), i5 === 1 && (t3 = Ae[e2.charCodeAt(l)] << 10 | Ae[e2.charCodeAt(l + 1)] << 4 | Ae[e2.charCodeAt(l + 2)] >> 2, a2[f++] = t3 >> 8 & 255, a2[f++] = t3 & 255), a2;
}
function _f(e2) {
  return Ue[e2 >> 18 & 63] + Ue[e2 >> 12 & 63] + Ue[e2 >> 6 & 63] + Ue[e2 & 63];
}
function wf(e2, t3, r4) {
  for (var n4, i5 = [], a2 = t3; a2 < r4; a2 += 3)
    n4 = (e2[a2] << 16 & 16711680) + (e2[a2 + 1] << 8 & 65280) + (e2[a2 + 2] & 255), i5.push(_f(n4));
  return i5.join("");
}
function xf(e2) {
  for (var t3, r4 = e2.length, n4 = r4 % 3, i5 = [], a2 = 16383, f = 0, u2 = r4 - n4; f < u2; f += a2)
    i5.push(wf(e2, f, f + a2 > u2 ? u2 : f + a2));
  return n4 === 1 ? (t3 = e2[r4 - 1], i5.push(
    Ue[t3 >> 2] + Ue[t3 << 4 & 63] + "=="
  )) : n4 === 2 && (t3 = (e2[r4 - 2] << 8) + e2[r4 - 1], i5.push(
    Ue[t3 >> 10] + Ue[t3 >> 4 & 63] + Ue[t3 << 2 & 63] + "="
  )), i5.join("");
}
var Sn = {};
Sn.read = function(e2, t3, r4, n4, i5) {
  var a2, f, u2 = i5 * 8 - n4 - 1, l = (1 << u2) - 1, b2 = l >> 1, g = -7, m = r4 ? i5 - 1 : 0, v = r4 ? -1 : 1, I = e2[t3 + m];
  for (m += v, a2 = I & (1 << -g) - 1, I >>= -g, g += u2; g > 0; a2 = a2 * 256 + e2[t3 + m], m += v, g -= 8)
    ;
  for (f = a2 & (1 << -g) - 1, a2 >>= -g, g += n4; g > 0; f = f * 256 + e2[t3 + m], m += v, g -= 8)
    ;
  if (a2 === 0)
    a2 = 1 - b2;
  else {
    if (a2 === l)
      return f ? NaN : (I ? -1 : 1) * (1 / 0);
    f = f + Math.pow(2, n4), a2 = a2 - b2;
  }
  return (I ? -1 : 1) * f * Math.pow(2, a2 - n4);
};
Sn.write = function(e2, t3, r4, n4, i5, a2) {
  var f, u2, l, b2 = a2 * 8 - i5 - 1, g = (1 << b2) - 1, m = g >> 1, v = i5 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, I = n4 ? 0 : a2 - 1, B = n4 ? 1 : -1, P = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
  for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (u2 = isNaN(t3) ? 1 : 0, f = g) : (f = Math.floor(Math.log(t3) / Math.LN2), t3 * (l = Math.pow(2, -f)) < 1 && (f--, l *= 2), f + m >= 1 ? t3 += v / l : t3 += v * Math.pow(2, 1 - m), t3 * l >= 2 && (f++, l /= 2), f + m >= g ? (u2 = 0, f = g) : f + m >= 1 ? (u2 = (t3 * l - 1) * Math.pow(2, i5), f = f + m) : (u2 = t3 * Math.pow(2, m - 1) * Math.pow(2, i5), f = 0)); i5 >= 8; e2[r4 + I] = u2 & 255, I += B, u2 /= 256, i5 -= 8)
    ;
  for (f = f << i5 | u2, b2 += i5; b2 > 0; e2[r4 + I] = f & 255, I += B, f /= 256, b2 -= 8)
    ;
  e2[r4 + I - B] |= P * 128;
};
(function(e2) {
  const t3 = Er, r4 = Sn, n4 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e2.Buffer = u2, e2.SlowBuffer = F, e2.INSPECT_MAX_BYTES = 50;
  const i5 = 2147483647;
  e2.kMaxLength = i5, u2.TYPED_ARRAY_SUPPORT = a2(), !u2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a2() {
    try {
      const c2 = new Uint8Array(1), s4 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(s4, Uint8Array.prototype), Object.setPrototypeOf(c2, s4), c2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(u2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (u2.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (u2.isBuffer(this))
        return this.byteOffset;
    }
  });
  function f(c2) {
    if (c2 > i5)
      throw new RangeError('The value "' + c2 + '" is invalid for option "size"');
    const s4 = new Uint8Array(c2);
    return Object.setPrototypeOf(s4, u2.prototype), s4;
  }
  function u2(c2, s4, o4) {
    if (typeof c2 == "number") {
      if (typeof s4 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return m(c2);
    }
    return l(c2, s4, o4);
  }
  u2.poolSize = 8192;
  function l(c2, s4, o4) {
    if (typeof c2 == "string")
      return v(c2, s4);
    if (ArrayBuffer.isView(c2))
      return B(c2);
    if (c2 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c2
      );
    if (Se(c2, ArrayBuffer) || c2 && Se(c2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Se(c2, SharedArrayBuffer) || c2 && Se(c2.buffer, SharedArrayBuffer)))
      return P(c2, s4, o4);
    if (typeof c2 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const h = c2.valueOf && c2.valueOf();
    if (h != null && h !== c2)
      return u2.from(h, s4, o4);
    const y = T(c2);
    if (y) return y;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof c2[Symbol.toPrimitive] == "function")
      return u2.from(c2[Symbol.toPrimitive]("string"), s4, o4);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof c2
    );
  }
  u2.from = function(c2, s4, o4) {
    return l(c2, s4, o4);
  }, Object.setPrototypeOf(u2.prototype, Uint8Array.prototype), Object.setPrototypeOf(u2, Uint8Array);
  function b2(c2) {
    if (typeof c2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (c2 < 0)
      throw new RangeError('The value "' + c2 + '" is invalid for option "size"');
  }
  function g(c2, s4, o4) {
    return b2(c2), c2 <= 0 ? f(c2) : s4 !== void 0 ? typeof o4 == "string" ? f(c2).fill(s4, o4) : f(c2).fill(s4) : f(c2);
  }
  u2.alloc = function(c2, s4, o4) {
    return g(c2, s4, o4);
  };
  function m(c2) {
    return b2(c2), f(c2 < 0 ? 0 : C2(c2) | 0);
  }
  u2.allocUnsafe = function(c2) {
    return m(c2);
  }, u2.allocUnsafeSlow = function(c2) {
    return m(c2);
  };
  function v(c2, s4) {
    if ((typeof s4 != "string" || s4 === "") && (s4 = "utf8"), !u2.isEncoding(s4))
      throw new TypeError("Unknown encoding: " + s4);
    const o4 = k2(c2, s4) | 0;
    let h = f(o4);
    const y = h.write(c2, s4);
    return y !== o4 && (h = h.slice(0, y)), h;
  }
  function I(c2) {
    const s4 = c2.length < 0 ? 0 : C2(c2.length) | 0, o4 = f(s4);
    for (let h = 0; h < s4; h += 1)
      o4[h] = c2[h] & 255;
    return o4;
  }
  function B(c2) {
    if (Se(c2, Uint8Array)) {
      const s4 = new Uint8Array(c2);
      return P(s4.buffer, s4.byteOffset, s4.byteLength);
    }
    return I(c2);
  }
  function P(c2, s4, o4) {
    if (s4 < 0 || c2.byteLength < s4)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (c2.byteLength < s4 + (o4 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let h;
    return s4 === void 0 && o4 === void 0 ? h = new Uint8Array(c2) : o4 === void 0 ? h = new Uint8Array(c2, s4) : h = new Uint8Array(c2, s4, o4), Object.setPrototypeOf(h, u2.prototype), h;
  }
  function T(c2) {
    if (u2.isBuffer(c2)) {
      const s4 = C2(c2.length) | 0, o4 = f(s4);
      return o4.length === 0 || c2.copy(o4, 0, 0, s4), o4;
    }
    if (c2.length !== void 0)
      return typeof c2.length != "number" || tt(c2.length) ? f(0) : I(c2);
    if (c2.type === "Buffer" && Array.isArray(c2.data))
      return I(c2.data);
  }
  function C2(c2) {
    if (c2 >= i5)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i5.toString(16) + " bytes");
    return c2 | 0;
  }
  function F(c2) {
    return +c2 != c2 && (c2 = 0), u2.alloc(+c2);
  }
  u2.isBuffer = function(s4) {
    return s4 != null && s4._isBuffer === true && s4 !== u2.prototype;
  }, u2.compare = function(s4, o4) {
    if (Se(s4, Uint8Array) && (s4 = u2.from(s4, s4.offset, s4.byteLength)), Se(o4, Uint8Array) && (o4 = u2.from(o4, o4.offset, o4.byteLength)), !u2.isBuffer(s4) || !u2.isBuffer(o4))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (s4 === o4) return 0;
    let h = s4.length, y = o4.length;
    for (let x2 = 0, E = Math.min(h, y); x2 < E; ++x2)
      if (s4[x2] !== o4[x2]) {
        h = s4[x2], y = o4[x2];
        break;
      }
    return h < y ? -1 : y < h ? 1 : 0;
  }, u2.isEncoding = function(s4) {
    switch (String(s4).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, u2.concat = function(s4, o4) {
    if (!Array.isArray(s4))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (s4.length === 0)
      return u2.alloc(0);
    let h;
    if (o4 === void 0)
      for (o4 = 0, h = 0; h < s4.length; ++h)
        o4 += s4[h].length;
    const y = u2.allocUnsafe(o4);
    let x2 = 0;
    for (h = 0; h < s4.length; ++h) {
      let E = s4[h];
      if (Se(E, Uint8Array))
        x2 + E.length > y.length ? (u2.isBuffer(E) || (E = u2.from(E)), E.copy(y, x2)) : Uint8Array.prototype.set.call(
          y,
          E,
          x2
        );
      else if (u2.isBuffer(E))
        E.copy(y, x2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      x2 += E.length;
    }
    return y;
  };
  function k2(c2, s4) {
    if (u2.isBuffer(c2))
      return c2.length;
    if (ArrayBuffer.isView(c2) || Se(c2, ArrayBuffer))
      return c2.byteLength;
    if (typeof c2 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof c2
      );
    const o4 = c2.length, h = arguments.length > 2 && arguments[2] === true;
    if (!h && o4 === 0) return 0;
    let y = false;
    for (; ; )
      switch (s4) {
        case "ascii":
        case "latin1":
        case "binary":
          return o4;
        case "utf8":
        case "utf-8":
          return V(c2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return o4 * 2;
        case "hex":
          return o4 >>> 1;
        case "base64":
          return Pt(c2).length;
        default:
          if (y)
            return h ? -1 : V(c2).length;
          s4 = ("" + s4).toLowerCase(), y = true;
      }
  }
  u2.byteLength = k2;
  function L(c2, s4, o4) {
    let h = false;
    if ((s4 === void 0 || s4 < 0) && (s4 = 0), s4 > this.length || ((o4 === void 0 || o4 > this.length) && (o4 = this.length), o4 <= 0) || (o4 >>>= 0, s4 >>>= 0, o4 <= s4))
      return "";
    for (c2 || (c2 = "utf8"); ; )
      switch (c2) {
        case "hex":
          return Ce(this, s4, o4);
        case "utf8":
        case "utf-8":
          return xe(this, s4, o4);
        case "ascii":
          return Pe(this, s4, o4);
        case "latin1":
        case "binary":
          return Ge(this, s4, o4);
        case "base64":
          return ae(this, s4, o4);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return We(this, s4, o4);
        default:
          if (h) throw new TypeError("Unknown encoding: " + c2);
          c2 = (c2 + "").toLowerCase(), h = true;
      }
  }
  u2.prototype._isBuffer = true;
  function O(c2, s4, o4) {
    const h = c2[s4];
    c2[s4] = c2[o4], c2[o4] = h;
  }
  u2.prototype.swap16 = function() {
    const s4 = this.length;
    if (s4 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let o4 = 0; o4 < s4; o4 += 2)
      O(this, o4, o4 + 1);
    return this;
  }, u2.prototype.swap32 = function() {
    const s4 = this.length;
    if (s4 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let o4 = 0; o4 < s4; o4 += 4)
      O(this, o4, o4 + 3), O(this, o4 + 1, o4 + 2);
    return this;
  }, u2.prototype.swap64 = function() {
    const s4 = this.length;
    if (s4 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let o4 = 0; o4 < s4; o4 += 8)
      O(this, o4, o4 + 7), O(this, o4 + 1, o4 + 6), O(this, o4 + 2, o4 + 5), O(this, o4 + 3, o4 + 4);
    return this;
  }, u2.prototype.toString = function() {
    const s4 = this.length;
    return s4 === 0 ? "" : arguments.length === 0 ? xe(this, 0, s4) : L.apply(this, arguments);
  }, u2.prototype.toLocaleString = u2.prototype.toString, u2.prototype.equals = function(s4) {
    if (!u2.isBuffer(s4)) throw new TypeError("Argument must be a Buffer");
    return this === s4 ? true : u2.compare(this, s4) === 0;
  }, u2.prototype.inspect = function() {
    let s4 = "";
    const o4 = e2.INSPECT_MAX_BYTES;
    return s4 = this.toString("hex", 0, o4).replace(/(.{2})/g, "$1 ").trim(), this.length > o4 && (s4 += " ... "), "<Buffer " + s4 + ">";
  }, n4 && (u2.prototype[n4] = u2.prototype.inspect), u2.prototype.compare = function(s4, o4, h, y, x2) {
    if (Se(s4, Uint8Array) && (s4 = u2.from(s4, s4.offset, s4.byteLength)), !u2.isBuffer(s4))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof s4
      );
    if (o4 === void 0 && (o4 = 0), h === void 0 && (h = s4 ? s4.length : 0), y === void 0 && (y = 0), x2 === void 0 && (x2 = this.length), o4 < 0 || h > s4.length || y < 0 || x2 > this.length)
      throw new RangeError("out of range index");
    if (y >= x2 && o4 >= h)
      return 0;
    if (y >= x2)
      return -1;
    if (o4 >= h)
      return 1;
    if (o4 >>>= 0, h >>>= 0, y >>>= 0, x2 >>>= 0, this === s4) return 0;
    let E = x2 - y, q = h - o4;
    const ne = Math.min(E, q), ee = this.slice(y, x2), ie = s4.slice(o4, h);
    for (let Y = 0; Y < ne; ++Y)
      if (ee[Y] !== ie[Y]) {
        E = ee[Y], q = ie[Y];
        break;
      }
    return E < q ? -1 : q < E ? 1 : 0;
  };
  function S(c2, s4, o4, h, y) {
    if (c2.length === 0) return -1;
    if (typeof o4 == "string" ? (h = o4, o4 = 0) : o4 > 2147483647 ? o4 = 2147483647 : o4 < -2147483648 && (o4 = -2147483648), o4 = +o4, tt(o4) && (o4 = y ? 0 : c2.length - 1), o4 < 0 && (o4 = c2.length + o4), o4 >= c2.length) {
      if (y) return -1;
      o4 = c2.length - 1;
    } else if (o4 < 0)
      if (y) o4 = 0;
      else return -1;
    if (typeof s4 == "string" && (s4 = u2.from(s4, h)), u2.isBuffer(s4))
      return s4.length === 0 ? -1 : z(c2, s4, o4, h, y);
    if (typeof s4 == "number")
      return s4 = s4 & 255, typeof Uint8Array.prototype.indexOf == "function" ? y ? Uint8Array.prototype.indexOf.call(c2, s4, o4) : Uint8Array.prototype.lastIndexOf.call(c2, s4, o4) : z(c2, [s4], o4, h, y);
    throw new TypeError("val must be string, number or Buffer");
  }
  function z(c2, s4, o4, h, y) {
    let x2 = 1, E = c2.length, q = s4.length;
    if (h !== void 0 && (h = String(h).toLowerCase(), h === "ucs2" || h === "ucs-2" || h === "utf16le" || h === "utf-16le")) {
      if (c2.length < 2 || s4.length < 2)
        return -1;
      x2 = 2, E /= 2, q /= 2, o4 /= 2;
    }
    function ne(ie, Y) {
      return x2 === 1 ? ie[Y] : ie.readUInt16BE(Y * x2);
    }
    let ee;
    if (y) {
      let ie = -1;
      for (ee = o4; ee < E; ee++)
        if (ne(c2, ee) === ne(s4, ie === -1 ? 0 : ee - ie)) {
          if (ie === -1 && (ie = ee), ee - ie + 1 === q) return ie * x2;
        } else
          ie !== -1 && (ee -= ee - ie), ie = -1;
    } else
      for (o4 + q > E && (o4 = E - q), ee = o4; ee >= 0; ee--) {
        let ie = true;
        for (let Y = 0; Y < q; Y++)
          if (ne(c2, ee + Y) !== ne(s4, Y)) {
            ie = false;
            break;
          }
        if (ie) return ee;
      }
    return -1;
  }
  u2.prototype.includes = function(s4, o4, h) {
    return this.indexOf(s4, o4, h) !== -1;
  }, u2.prototype.indexOf = function(s4, o4, h) {
    return S(this, s4, o4, h, true);
  }, u2.prototype.lastIndexOf = function(s4, o4, h) {
    return S(this, s4, o4, h, false);
  };
  function M(c2, s4, o4, h) {
    o4 = Number(o4) || 0;
    const y = c2.length - o4;
    h ? (h = Number(h), h > y && (h = y)) : h = y;
    const x2 = s4.length;
    h > x2 / 2 && (h = x2 / 2);
    let E;
    for (E = 0; E < h; ++E) {
      const q = parseInt(s4.substr(E * 2, 2), 16);
      if (tt(q)) return E;
      c2[o4 + E] = q;
    }
    return E;
  }
  function $(c2, s4, o4, h) {
    return pt(V(s4, c2.length - o4), c2, o4, h);
  }
  function se(c2, s4, o4, h) {
    return pt(Ve(s4), c2, o4, h);
  }
  function Te(c2, s4, o4, h) {
    return pt(Pt(s4), c2, o4, h);
  }
  function je(c2, s4, o4, h) {
    return pt(dt(s4, c2.length - o4), c2, o4, h);
  }
  u2.prototype.write = function(s4, o4, h, y) {
    if (o4 === void 0)
      y = "utf8", h = this.length, o4 = 0;
    else if (h === void 0 && typeof o4 == "string")
      y = o4, h = this.length, o4 = 0;
    else if (isFinite(o4))
      o4 = o4 >>> 0, isFinite(h) ? (h = h >>> 0, y === void 0 && (y = "utf8")) : (y = h, h = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const x2 = this.length - o4;
    if ((h === void 0 || h > x2) && (h = x2), s4.length > 0 && (h < 0 || o4 < 0) || o4 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    y || (y = "utf8");
    let E = false;
    for (; ; )
      switch (y) {
        case "hex":
          return M(this, s4, o4, h);
        case "utf8":
        case "utf-8":
          return $(this, s4, o4, h);
        case "ascii":
        case "latin1":
        case "binary":
          return se(this, s4, o4, h);
        case "base64":
          return Te(this, s4, o4, h);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return je(this, s4, o4, h);
        default:
          if (E) throw new TypeError("Unknown encoding: " + y);
          y = ("" + y).toLowerCase(), E = true;
      }
  }, u2.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function ae(c2, s4, o4) {
    return s4 === 0 && o4 === c2.length ? t3.fromByteArray(c2) : t3.fromByteArray(c2.slice(s4, o4));
  }
  function xe(c2, s4, o4) {
    o4 = Math.min(c2.length, o4);
    const h = [];
    let y = s4;
    for (; y < o4; ) {
      const x2 = c2[y];
      let E = null, q = x2 > 239 ? 4 : x2 > 223 ? 3 : x2 > 191 ? 2 : 1;
      if (y + q <= o4) {
        let ne, ee, ie, Y;
        switch (q) {
          case 1:
            x2 < 128 && (E = x2);
            break;
          case 2:
            ne = c2[y + 1], (ne & 192) === 128 && (Y = (x2 & 31) << 6 | ne & 63, Y > 127 && (E = Y));
            break;
          case 3:
            ne = c2[y + 1], ee = c2[y + 2], (ne & 192) === 128 && (ee & 192) === 128 && (Y = (x2 & 15) << 12 | (ne & 63) << 6 | ee & 63, Y > 2047 && (Y < 55296 || Y > 57343) && (E = Y));
            break;
          case 4:
            ne = c2[y + 1], ee = c2[y + 2], ie = c2[y + 3], (ne & 192) === 128 && (ee & 192) === 128 && (ie & 192) === 128 && (Y = (x2 & 15) << 18 | (ne & 63) << 12 | (ee & 63) << 6 | ie & 63, Y > 65535 && Y < 1114112 && (E = Y));
        }
      }
      E === null ? (E = 65533, q = 1) : E > 65535 && (E -= 65536, h.push(E >>> 10 & 1023 | 55296), E = 56320 | E & 1023), h.push(E), y += q;
    }
    return et(h);
  }
  const ve = 4096;
  function et(c2) {
    const s4 = c2.length;
    if (s4 <= ve)
      return String.fromCharCode.apply(String, c2);
    let o4 = "", h = 0;
    for (; h < s4; )
      o4 += String.fromCharCode.apply(
        String,
        c2.slice(h, h += ve)
      );
    return o4;
  }
  function Pe(c2, s4, o4) {
    let h = "";
    o4 = Math.min(c2.length, o4);
    for (let y = s4; y < o4; ++y)
      h += String.fromCharCode(c2[y] & 127);
    return h;
  }
  function Ge(c2, s4, o4) {
    let h = "";
    o4 = Math.min(c2.length, o4);
    for (let y = s4; y < o4; ++y)
      h += String.fromCharCode(c2[y]);
    return h;
  }
  function Ce(c2, s4, o4) {
    const h = c2.length;
    (!s4 || s4 < 0) && (s4 = 0), (!o4 || o4 < 0 || o4 > h) && (o4 = h);
    let y = "";
    for (let x2 = s4; x2 < o4; ++x2)
      y += Ct[c2[x2]];
    return y;
  }
  function We(c2, s4, o4) {
    const h = c2.slice(s4, o4);
    let y = "";
    for (let x2 = 0; x2 < h.length - 1; x2 += 2)
      y += String.fromCharCode(h[x2] + h[x2 + 1] * 256);
    return y;
  }
  u2.prototype.slice = function(s4, o4) {
    const h = this.length;
    s4 = ~~s4, o4 = o4 === void 0 ? h : ~~o4, s4 < 0 ? (s4 += h, s4 < 0 && (s4 = 0)) : s4 > h && (s4 = h), o4 < 0 ? (o4 += h, o4 < 0 && (o4 = 0)) : o4 > h && (o4 = h), o4 < s4 && (o4 = s4);
    const y = this.subarray(s4, o4);
    return Object.setPrototypeOf(y, u2.prototype), y;
  };
  function Q(c2, s4, o4) {
    if (c2 % 1 !== 0 || c2 < 0) throw new RangeError("offset is not uint");
    if (c2 + s4 > o4) throw new RangeError("Trying to access beyond buffer length");
  }
  u2.prototype.readUintLE = u2.prototype.readUIntLE = function(s4, o4, h) {
    s4 = s4 >>> 0, o4 = o4 >>> 0, h || Q(s4, o4, this.length);
    let y = this[s4], x2 = 1, E = 0;
    for (; ++E < o4 && (x2 *= 256); )
      y += this[s4 + E] * x2;
    return y;
  }, u2.prototype.readUintBE = u2.prototype.readUIntBE = function(s4, o4, h) {
    s4 = s4 >>> 0, o4 = o4 >>> 0, h || Q(s4, o4, this.length);
    let y = this[s4 + --o4], x2 = 1;
    for (; o4 > 0 && (x2 *= 256); )
      y += this[s4 + --o4] * x2;
    return y;
  }, u2.prototype.readUint8 = u2.prototype.readUInt8 = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 1, this.length), this[s4];
  }, u2.prototype.readUint16LE = u2.prototype.readUInt16LE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 2, this.length), this[s4] | this[s4 + 1] << 8;
  }, u2.prototype.readUint16BE = u2.prototype.readUInt16BE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 2, this.length), this[s4] << 8 | this[s4 + 1];
  }, u2.prototype.readUint32LE = u2.prototype.readUInt32LE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), (this[s4] | this[s4 + 1] << 8 | this[s4 + 2] << 16) + this[s4 + 3] * 16777216;
  }, u2.prototype.readUint32BE = u2.prototype.readUInt32BE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), this[s4] * 16777216 + (this[s4 + 1] << 16 | this[s4 + 2] << 8 | this[s4 + 3]);
  }, u2.prototype.readBigUInt64LE = Ie(function(s4) {
    s4 = s4 >>> 0, A(s4, "offset");
    const o4 = this[s4], h = this[s4 + 7];
    (o4 === void 0 || h === void 0) && U(s4, this.length - 8);
    const y = o4 + this[++s4] * 2 ** 8 + this[++s4] * 2 ** 16 + this[++s4] * 2 ** 24, x2 = this[++s4] + this[++s4] * 2 ** 8 + this[++s4] * 2 ** 16 + h * 2 ** 24;
    return BigInt(y) + (BigInt(x2) << BigInt(32));
  }), u2.prototype.readBigUInt64BE = Ie(function(s4) {
    s4 = s4 >>> 0, A(s4, "offset");
    const o4 = this[s4], h = this[s4 + 7];
    (o4 === void 0 || h === void 0) && U(s4, this.length - 8);
    const y = o4 * 2 ** 24 + this[++s4] * 2 ** 16 + this[++s4] * 2 ** 8 + this[++s4], x2 = this[++s4] * 2 ** 24 + this[++s4] * 2 ** 16 + this[++s4] * 2 ** 8 + h;
    return (BigInt(y) << BigInt(32)) + BigInt(x2);
  }), u2.prototype.readIntLE = function(s4, o4, h) {
    s4 = s4 >>> 0, o4 = o4 >>> 0, h || Q(s4, o4, this.length);
    let y = this[s4], x2 = 1, E = 0;
    for (; ++E < o4 && (x2 *= 256); )
      y += this[s4 + E] * x2;
    return x2 *= 128, y >= x2 && (y -= Math.pow(2, 8 * o4)), y;
  }, u2.prototype.readIntBE = function(s4, o4, h) {
    s4 = s4 >>> 0, o4 = o4 >>> 0, h || Q(s4, o4, this.length);
    let y = o4, x2 = 1, E = this[s4 + --y];
    for (; y > 0 && (x2 *= 256); )
      E += this[s4 + --y] * x2;
    return x2 *= 128, E >= x2 && (E -= Math.pow(2, 8 * o4)), E;
  }, u2.prototype.readInt8 = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 1, this.length), this[s4] & 128 ? (255 - this[s4] + 1) * -1 : this[s4];
  }, u2.prototype.readInt16LE = function(s4, o4) {
    s4 = s4 >>> 0, o4 || Q(s4, 2, this.length);
    const h = this[s4] | this[s4 + 1] << 8;
    return h & 32768 ? h | 4294901760 : h;
  }, u2.prototype.readInt16BE = function(s4, o4) {
    s4 = s4 >>> 0, o4 || Q(s4, 2, this.length);
    const h = this[s4 + 1] | this[s4] << 8;
    return h & 32768 ? h | 4294901760 : h;
  }, u2.prototype.readInt32LE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), this[s4] | this[s4 + 1] << 8 | this[s4 + 2] << 16 | this[s4 + 3] << 24;
  }, u2.prototype.readInt32BE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), this[s4] << 24 | this[s4 + 1] << 16 | this[s4 + 2] << 8 | this[s4 + 3];
  }, u2.prototype.readBigInt64LE = Ie(function(s4) {
    s4 = s4 >>> 0, A(s4, "offset");
    const o4 = this[s4], h = this[s4 + 7];
    (o4 === void 0 || h === void 0) && U(s4, this.length - 8);
    const y = this[s4 + 4] + this[s4 + 5] * 2 ** 8 + this[s4 + 6] * 2 ** 16 + (h << 24);
    return (BigInt(y) << BigInt(32)) + BigInt(o4 + this[++s4] * 2 ** 8 + this[++s4] * 2 ** 16 + this[++s4] * 2 ** 24);
  }), u2.prototype.readBigInt64BE = Ie(function(s4) {
    s4 = s4 >>> 0, A(s4, "offset");
    const o4 = this[s4], h = this[s4 + 7];
    (o4 === void 0 || h === void 0) && U(s4, this.length - 8);
    const y = (o4 << 24) + // Overflow
    this[++s4] * 2 ** 16 + this[++s4] * 2 ** 8 + this[++s4];
    return (BigInt(y) << BigInt(32)) + BigInt(this[++s4] * 2 ** 24 + this[++s4] * 2 ** 16 + this[++s4] * 2 ** 8 + h);
  }), u2.prototype.readFloatLE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), r4.read(this, s4, true, 23, 4);
  }, u2.prototype.readFloatBE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 4, this.length), r4.read(this, s4, false, 23, 4);
  }, u2.prototype.readDoubleLE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 8, this.length), r4.read(this, s4, true, 52, 8);
  }, u2.prototype.readDoubleBE = function(s4, o4) {
    return s4 = s4 >>> 0, o4 || Q(s4, 8, this.length), r4.read(this, s4, false, 52, 8);
  };
  function oe(c2, s4, o4, h, y, x2) {
    if (!u2.isBuffer(c2)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (s4 > y || s4 < x2) throw new RangeError('"value" argument is out of bounds');
    if (o4 + h > c2.length) throw new RangeError("Index out of range");
  }
  u2.prototype.writeUintLE = u2.prototype.writeUIntLE = function(s4, o4, h, y) {
    if (s4 = +s4, o4 = o4 >>> 0, h = h >>> 0, !y) {
      const q = Math.pow(2, 8 * h) - 1;
      oe(this, s4, o4, h, q, 0);
    }
    let x2 = 1, E = 0;
    for (this[o4] = s4 & 255; ++E < h && (x2 *= 256); )
      this[o4 + E] = s4 / x2 & 255;
    return o4 + h;
  }, u2.prototype.writeUintBE = u2.prototype.writeUIntBE = function(s4, o4, h, y) {
    if (s4 = +s4, o4 = o4 >>> 0, h = h >>> 0, !y) {
      const q = Math.pow(2, 8 * h) - 1;
      oe(this, s4, o4, h, q, 0);
    }
    let x2 = h - 1, E = 1;
    for (this[o4 + x2] = s4 & 255; --x2 >= 0 && (E *= 256); )
      this[o4 + x2] = s4 / E & 255;
    return o4 + h;
  }, u2.prototype.writeUint8 = u2.prototype.writeUInt8 = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 1, 255, 0), this[o4] = s4 & 255, o4 + 1;
  }, u2.prototype.writeUint16LE = u2.prototype.writeUInt16LE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 2, 65535, 0), this[o4] = s4 & 255, this[o4 + 1] = s4 >>> 8, o4 + 2;
  }, u2.prototype.writeUint16BE = u2.prototype.writeUInt16BE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 2, 65535, 0), this[o4] = s4 >>> 8, this[o4 + 1] = s4 & 255, o4 + 2;
  }, u2.prototype.writeUint32LE = u2.prototype.writeUInt32LE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 4, 4294967295, 0), this[o4 + 3] = s4 >>> 24, this[o4 + 2] = s4 >>> 16, this[o4 + 1] = s4 >>> 8, this[o4] = s4 & 255, o4 + 4;
  }, u2.prototype.writeUint32BE = u2.prototype.writeUInt32BE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 4, 4294967295, 0), this[o4] = s4 >>> 24, this[o4 + 1] = s4 >>> 16, this[o4 + 2] = s4 >>> 8, this[o4 + 3] = s4 & 255, o4 + 4;
  };
  function Be(c2, s4, o4, h, y) {
    p(s4, h, y, c2, o4, 7);
    let x2 = Number(s4 & BigInt(4294967295));
    c2[o4++] = x2, x2 = x2 >> 8, c2[o4++] = x2, x2 = x2 >> 8, c2[o4++] = x2, x2 = x2 >> 8, c2[o4++] = x2;
    let E = Number(s4 >> BigInt(32) & BigInt(4294967295));
    return c2[o4++] = E, E = E >> 8, c2[o4++] = E, E = E >> 8, c2[o4++] = E, E = E >> 8, c2[o4++] = E, o4;
  }
  function qe(c2, s4, o4, h, y) {
    p(s4, h, y, c2, o4, 7);
    let x2 = Number(s4 & BigInt(4294967295));
    c2[o4 + 7] = x2, x2 = x2 >> 8, c2[o4 + 6] = x2, x2 = x2 >> 8, c2[o4 + 5] = x2, x2 = x2 >> 8, c2[o4 + 4] = x2;
    let E = Number(s4 >> BigInt(32) & BigInt(4294967295));
    return c2[o4 + 3] = E, E = E >> 8, c2[o4 + 2] = E, E = E >> 8, c2[o4 + 1] = E, E = E >> 8, c2[o4] = E, o4 + 8;
  }
  u2.prototype.writeBigUInt64LE = Ie(function(s4, o4 = 0) {
    return Be(this, s4, o4, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u2.prototype.writeBigUInt64BE = Ie(function(s4, o4 = 0) {
    return qe(this, s4, o4, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u2.prototype.writeIntLE = function(s4, o4, h, y) {
    if (s4 = +s4, o4 = o4 >>> 0, !y) {
      const ne = Math.pow(2, 8 * h - 1);
      oe(this, s4, o4, h, ne - 1, -ne);
    }
    let x2 = 0, E = 1, q = 0;
    for (this[o4] = s4 & 255; ++x2 < h && (E *= 256); )
      s4 < 0 && q === 0 && this[o4 + x2 - 1] !== 0 && (q = 1), this[o4 + x2] = (s4 / E >> 0) - q & 255;
    return o4 + h;
  }, u2.prototype.writeIntBE = function(s4, o4, h, y) {
    if (s4 = +s4, o4 = o4 >>> 0, !y) {
      const ne = Math.pow(2, 8 * h - 1);
      oe(this, s4, o4, h, ne - 1, -ne);
    }
    let x2 = h - 1, E = 1, q = 0;
    for (this[o4 + x2] = s4 & 255; --x2 >= 0 && (E *= 256); )
      s4 < 0 && q === 0 && this[o4 + x2 + 1] !== 0 && (q = 1), this[o4 + x2] = (s4 / E >> 0) - q & 255;
    return o4 + h;
  }, u2.prototype.writeInt8 = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 1, 127, -128), s4 < 0 && (s4 = 255 + s4 + 1), this[o4] = s4 & 255, o4 + 1;
  }, u2.prototype.writeInt16LE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 2, 32767, -32768), this[o4] = s4 & 255, this[o4 + 1] = s4 >>> 8, o4 + 2;
  }, u2.prototype.writeInt16BE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 2, 32767, -32768), this[o4] = s4 >>> 8, this[o4 + 1] = s4 & 255, o4 + 2;
  }, u2.prototype.writeInt32LE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 4, 2147483647, -2147483648), this[o4] = s4 & 255, this[o4 + 1] = s4 >>> 8, this[o4 + 2] = s4 >>> 16, this[o4 + 3] = s4 >>> 24, o4 + 4;
  }, u2.prototype.writeInt32BE = function(s4, o4, h) {
    return s4 = +s4, o4 = o4 >>> 0, h || oe(this, s4, o4, 4, 2147483647, -2147483648), s4 < 0 && (s4 = 4294967295 + s4 + 1), this[o4] = s4 >>> 24, this[o4 + 1] = s4 >>> 16, this[o4 + 2] = s4 >>> 8, this[o4 + 3] = s4 & 255, o4 + 4;
  }, u2.prototype.writeBigInt64LE = Ie(function(s4, o4 = 0) {
    return Be(this, s4, o4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u2.prototype.writeBigInt64BE = Ie(function(s4, o4 = 0) {
    return qe(this, s4, o4, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Ne(c2, s4, o4, h, y, x2) {
    if (o4 + h > c2.length) throw new RangeError("Index out of range");
    if (o4 < 0) throw new RangeError("Index out of range");
  }
  function w2(c2, s4, o4, h, y) {
    return s4 = +s4, o4 = o4 >>> 0, y || Ne(c2, s4, o4, 4), r4.write(c2, s4, o4, h, 23, 4), o4 + 4;
  }
  u2.prototype.writeFloatLE = function(s4, o4, h) {
    return w2(this, s4, o4, true, h);
  }, u2.prototype.writeFloatBE = function(s4, o4, h) {
    return w2(this, s4, o4, false, h);
  };
  function _(c2, s4, o4, h, y) {
    return s4 = +s4, o4 = o4 >>> 0, y || Ne(c2, s4, o4, 8), r4.write(c2, s4, o4, h, 52, 8), o4 + 8;
  }
  u2.prototype.writeDoubleLE = function(s4, o4, h) {
    return _(this, s4, o4, true, h);
  }, u2.prototype.writeDoubleBE = function(s4, o4, h) {
    return _(this, s4, o4, false, h);
  }, u2.prototype.copy = function(s4, o4, h, y) {
    if (!u2.isBuffer(s4)) throw new TypeError("argument should be a Buffer");
    if (h || (h = 0), !y && y !== 0 && (y = this.length), o4 >= s4.length && (o4 = s4.length), o4 || (o4 = 0), y > 0 && y < h && (y = h), y === h || s4.length === 0 || this.length === 0) return 0;
    if (o4 < 0)
      throw new RangeError("targetStart out of bounds");
    if (h < 0 || h >= this.length) throw new RangeError("Index out of range");
    if (y < 0) throw new RangeError("sourceEnd out of bounds");
    y > this.length && (y = this.length), s4.length - o4 < y - h && (y = s4.length - o4 + h);
    const x2 = y - h;
    return this === s4 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(o4, h, y) : Uint8Array.prototype.set.call(
      s4,
      this.subarray(h, y),
      o4
    ), x2;
  }, u2.prototype.fill = function(s4, o4, h, y) {
    if (typeof s4 == "string") {
      if (typeof o4 == "string" ? (y = o4, o4 = 0, h = this.length) : typeof h == "string" && (y = h, h = this.length), y !== void 0 && typeof y != "string")
        throw new TypeError("encoding must be a string");
      if (typeof y == "string" && !u2.isEncoding(y))
        throw new TypeError("Unknown encoding: " + y);
      if (s4.length === 1) {
        const E = s4.charCodeAt(0);
        (y === "utf8" && E < 128 || y === "latin1") && (s4 = E);
      }
    } else typeof s4 == "number" ? s4 = s4 & 255 : typeof s4 == "boolean" && (s4 = Number(s4));
    if (o4 < 0 || this.length < o4 || this.length < h)
      throw new RangeError("Out of range index");
    if (h <= o4)
      return this;
    o4 = o4 >>> 0, h = h === void 0 ? this.length : h >>> 0, s4 || (s4 = 0);
    let x2;
    if (typeof s4 == "number")
      for (x2 = o4; x2 < h; ++x2)
        this[x2] = s4;
    else {
      const E = u2.isBuffer(s4) ? s4 : u2.from(s4, y), q = E.length;
      if (q === 0)
        throw new TypeError('The value "' + s4 + '" is invalid for argument "value"');
      for (x2 = 0; x2 < h - o4; ++x2)
        this[x2 + o4] = E[x2 % q];
    }
    return this;
  };
  const R2 = {};
  function D(c2, s4, o4) {
    R2[c2] = class extends o4 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: s4.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${c2}]`, this.stack, delete this.name;
      }
      get code() {
        return c2;
      }
      set code(y) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: y,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${c2}]: ${this.message}`;
      }
    };
  }
  D(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(c2) {
      return c2 ? `${c2} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), D(
    "ERR_INVALID_ARG_TYPE",
    function(c2, s4) {
      return `The "${c2}" argument must be of type number. Received type ${typeof s4}`;
    },
    TypeError
  ), D(
    "ERR_OUT_OF_RANGE",
    function(c2, s4, o4) {
      let h = `The value of "${c2}" is out of range.`, y = o4;
      return Number.isInteger(o4) && Math.abs(o4) > 2 ** 32 ? y = j(String(o4)) : typeof o4 == "bigint" && (y = String(o4), (o4 > BigInt(2) ** BigInt(32) || o4 < -(BigInt(2) ** BigInt(32))) && (y = j(y)), y += "n"), h += ` It must be ${s4}. Received ${y}`, h;
    },
    RangeError
  );
  function j(c2) {
    let s4 = "", o4 = c2.length;
    const h = c2[0] === "-" ? 1 : 0;
    for (; o4 >= h + 4; o4 -= 3)
      s4 = `_${c2.slice(o4 - 3, o4)}${s4}`;
    return `${c2.slice(0, o4)}${s4}`;
  }
  function d2(c2, s4, o4) {
    A(s4, "offset"), (c2[s4] === void 0 || c2[s4 + o4] === void 0) && U(s4, c2.length - (o4 + 1));
  }
  function p(c2, s4, o4, h, y, x2) {
    if (c2 > o4 || c2 < s4) {
      const E = typeof s4 == "bigint" ? "n" : "";
      let q;
      throw s4 === 0 || s4 === BigInt(0) ? q = `>= 0${E} and < 2${E} ** ${(x2 + 1) * 8}${E}` : q = `>= -(2${E} ** ${(x2 + 1) * 8 - 1}${E}) and < 2 ** ${(x2 + 1) * 8 - 1}${E}`, new R2.ERR_OUT_OF_RANGE("value", q, c2);
    }
    d2(h, y, x2);
  }
  function A(c2, s4) {
    if (typeof c2 != "number")
      throw new R2.ERR_INVALID_ARG_TYPE(s4, "number", c2);
  }
  function U(c2, s4, o4) {
    throw Math.floor(c2) !== c2 ? (A(c2, o4), new R2.ERR_OUT_OF_RANGE("offset", "an integer", c2)) : s4 < 0 ? new R2.ERR_BUFFER_OUT_OF_BOUNDS() : new R2.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${s4}`,
      c2
    );
  }
  const Z = /[^+/0-9A-Za-z-_]/g;
  function G(c2) {
    if (c2 = c2.split("=")[0], c2 = c2.trim().replace(Z, ""), c2.length < 2) return "";
    for (; c2.length % 4 !== 0; )
      c2 = c2 + "=";
    return c2;
  }
  function V(c2, s4) {
    s4 = s4 || 1 / 0;
    let o4;
    const h = c2.length;
    let y = null;
    const x2 = [];
    for (let E = 0; E < h; ++E) {
      if (o4 = c2.charCodeAt(E), o4 > 55295 && o4 < 57344) {
        if (!y) {
          if (o4 > 56319) {
            (s4 -= 3) > -1 && x2.push(239, 191, 189);
            continue;
          } else if (E + 1 === h) {
            (s4 -= 3) > -1 && x2.push(239, 191, 189);
            continue;
          }
          y = o4;
          continue;
        }
        if (o4 < 56320) {
          (s4 -= 3) > -1 && x2.push(239, 191, 189), y = o4;
          continue;
        }
        o4 = (y - 55296 << 10 | o4 - 56320) + 65536;
      } else y && (s4 -= 3) > -1 && x2.push(239, 191, 189);
      if (y = null, o4 < 128) {
        if ((s4 -= 1) < 0) break;
        x2.push(o4);
      } else if (o4 < 2048) {
        if ((s4 -= 2) < 0) break;
        x2.push(
          o4 >> 6 | 192,
          o4 & 63 | 128
        );
      } else if (o4 < 65536) {
        if ((s4 -= 3) < 0) break;
        x2.push(
          o4 >> 12 | 224,
          o4 >> 6 & 63 | 128,
          o4 & 63 | 128
        );
      } else if (o4 < 1114112) {
        if ((s4 -= 4) < 0) break;
        x2.push(
          o4 >> 18 | 240,
          o4 >> 12 & 63 | 128,
          o4 >> 6 & 63 | 128,
          o4 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return x2;
  }
  function Ve(c2) {
    const s4 = [];
    for (let o4 = 0; o4 < c2.length; ++o4)
      s4.push(c2.charCodeAt(o4) & 255);
    return s4;
  }
  function dt(c2, s4) {
    let o4, h, y;
    const x2 = [];
    for (let E = 0; E < c2.length && !((s4 -= 2) < 0); ++E)
      o4 = c2.charCodeAt(E), h = o4 >> 8, y = o4 % 256, x2.push(y), x2.push(h);
    return x2;
  }
  function Pt(c2) {
    return t3.toByteArray(G(c2));
  }
  function pt(c2, s4, o4, h) {
    let y;
    for (y = 0; y < h && !(y + o4 >= s4.length || y >= c2.length); ++y)
      s4[y + o4] = c2[y];
    return y;
  }
  function Se(c2, s4) {
    return c2 instanceof s4 || c2 != null && c2.constructor != null && c2.constructor.name != null && c2.constructor.name === s4.name;
  }
  function tt(c2) {
    return c2 !== c2;
  }
  const Ct = function() {
    const c2 = "0123456789abcdef", s4 = new Array(256);
    for (let o4 = 0; o4 < 16; ++o4) {
      const h = o4 * 16;
      for (let y = 0; y < 16; ++y)
        s4[h + y] = c2[o4] + c2[y];
    }
    return s4;
  }();
  function Ie(c2) {
    return typeof BigInt > "u" ? rt : c2;
  }
  function rt() {
    throw new Error("BigInt not supported");
  }
})(Rt);
(function(e2, t3) {
  var r4 = Rt, n4 = r4.Buffer;
  function i5(f, u2) {
    for (var l in f)
      u2[l] = f[l];
  }
  n4.from && n4.alloc && n4.allocUnsafe && n4.allocUnsafeSlow ? e2.exports = r4 : (i5(r4, t3), t3.Buffer = a2);
  function a2(f, u2, l) {
    return n4(f, u2, l);
  }
  a2.prototype = Object.create(n4.prototype), i5(n4, a2), a2.from = function(f, u2, l) {
    if (typeof f == "number")
      throw new TypeError("Argument must not be a number");
    return n4(f, u2, l);
  }, a2.alloc = function(f, u2, l) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    var b2 = n4(f);
    return u2 !== void 0 ? typeof l == "string" ? b2.fill(u2, l) : b2.fill(u2) : b2.fill(0), b2;
  }, a2.allocUnsafe = function(f) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    return n4(f);
  }, a2.allocUnsafeSlow = function(f) {
    if (typeof f != "number")
      throw new TypeError("Argument must be a number");
    return r4.SlowBuffer(f);
  };
})(sn, sn.exports);
var Ee = sn.exports;
var Hr = 65536;
var vf = 4294967295;
function Ef() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Bf = Ee.Buffer;
var gr = Xe.crypto || Xe.msCrypto;
gr && gr.getRandomValues ? nn.exports = Sf : nn.exports = Ef;
function Sf(e2, t3) {
  if (e2 > vf) throw new RangeError("requested too many random bytes");
  var r4 = Bf.allocUnsafe(e2);
  if (e2 > 0)
    if (e2 > Hr)
      for (var n4 = 0; n4 < e2; n4 += Hr)
        gr.getRandomValues(r4.slice(n4, n4 + Hr));
    else
      gr.getRandomValues(r4);
  return typeof t3 == "function" ? process.nextTick(function() {
    t3(null, r4);
  }) : r4;
}
var If = nn.exports;
var on = { exports: {} };
typeof Object.create == "function" ? on.exports = function(t3, r4) {
  r4 && (t3.super_ = r4, t3.prototype = Object.create(r4.prototype, {
    constructor: {
      value: t3,
      enumerable: false,
      writable: true,
      configurable: true
    }
  }));
} : on.exports = function(t3, r4) {
  if (r4) {
    t3.super_ = r4;
    var n4 = function() {
    };
    n4.prototype = r4.prototype, t3.prototype = new n4(), t3.prototype.constructor = t3;
  }
};
var ge = on.exports;
var an = { exports: {} };
var In = { exports: {} };
var xt = typeof Reflect == "object" ? Reflect : null;
var Zn = xt && typeof xt.apply == "function" ? xt.apply : function(t3, r4, n4) {
  return Function.prototype.apply.call(t3, r4, n4);
};
var ur;
xt && typeof xt.ownKeys == "function" ? ur = xt.ownKeys : Object.getOwnPropertySymbols ? ur = function(t3) {
  return Object.getOwnPropertyNames(t3).concat(Object.getOwnPropertySymbols(t3));
} : ur = function(t3) {
  return Object.getOwnPropertyNames(t3);
};
function Af(e2) {
  console && console.warn && console.warn(e2);
}
var as = Number.isNaN || function(t3) {
  return t3 !== t3;
};
function K() {
  K.init.call(this);
}
In.exports = K;
In.exports.once = Cf;
K.EventEmitter = K;
K.prototype._events = void 0;
K.prototype._eventsCount = 0;
K.prototype._maxListeners = void 0;
var ei = 10;
function Br(e2) {
  if (typeof e2 != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
}
Object.defineProperty(K, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return ei;
  },
  set: function(e2) {
    if (typeof e2 != "number" || e2 < 0 || as(e2))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
    ei = e2;
  }
});
K.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
K.prototype.setMaxListeners = function(t3) {
  if (typeof t3 != "number" || t3 < 0 || as(t3))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t3 + ".");
  return this._maxListeners = t3, this;
};
function fs(e2) {
  return e2._maxListeners === void 0 ? K.defaultMaxListeners : e2._maxListeners;
}
K.prototype.getMaxListeners = function() {
  return fs(this);
};
K.prototype.emit = function(t3) {
  for (var r4 = [], n4 = 1; n4 < arguments.length; n4++) r4.push(arguments[n4]);
  var i5 = t3 === "error", a2 = this._events;
  if (a2 !== void 0)
    i5 = i5 && a2.error === void 0;
  else if (!i5)
    return false;
  if (i5) {
    var f;
    if (r4.length > 0 && (f = r4[0]), f instanceof Error)
      throw f;
    var u2 = new Error("Unhandled error." + (f ? " (" + f.message + ")" : ""));
    throw u2.context = f, u2;
  }
  var l = a2[t3];
  if (l === void 0)
    return false;
  if (typeof l == "function")
    Zn(l, this, r4);
  else
    for (var b2 = l.length, g = ds(l, b2), n4 = 0; n4 < b2; ++n4)
      Zn(g[n4], this, r4);
  return true;
};
function us(e2, t3, r4, n4) {
  var i5, a2, f;
  if (Br(r4), a2 = e2._events, a2 === void 0 ? (a2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (a2.newListener !== void 0 && (e2.emit(
    "newListener",
    t3,
    r4.listener ? r4.listener : r4
  ), a2 = e2._events), f = a2[t3]), f === void 0)
    f = a2[t3] = r4, ++e2._eventsCount;
  else if (typeof f == "function" ? f = a2[t3] = n4 ? [r4, f] : [f, r4] : n4 ? f.unshift(r4) : f.push(r4), i5 = fs(e2), i5 > 0 && f.length > i5 && !f.warned) {
    f.warned = true;
    var u2 = new Error("Possible EventEmitter memory leak detected. " + f.length + " " + String(t3) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    u2.name = "MaxListenersExceededWarning", u2.emitter = e2, u2.type = t3, u2.count = f.length, Af(u2);
  }
  return e2;
}
K.prototype.addListener = function(t3, r4) {
  return us(this, t3, r4, false);
};
K.prototype.on = K.prototype.addListener;
K.prototype.prependListener = function(t3, r4) {
  return us(this, t3, r4, true);
};
function Rf() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function cs(e2, t3, r4) {
  var n4 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: r4 }, i5 = Rf.bind(n4);
  return i5.listener = r4, n4.wrapFn = i5, i5;
}
K.prototype.once = function(t3, r4) {
  return Br(r4), this.on(t3, cs(this, t3, r4)), this;
};
K.prototype.prependOnceListener = function(t3, r4) {
  return Br(r4), this.prependListener(t3, cs(this, t3, r4)), this;
};
K.prototype.removeListener = function(t3, r4) {
  var n4, i5, a2, f, u2;
  if (Br(r4), i5 = this._events, i5 === void 0)
    return this;
  if (n4 = i5[t3], n4 === void 0)
    return this;
  if (n4 === r4 || n4.listener === r4)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i5[t3], i5.removeListener && this.emit("removeListener", t3, n4.listener || r4));
  else if (typeof n4 != "function") {
    for (a2 = -1, f = n4.length - 1; f >= 0; f--)
      if (n4[f] === r4 || n4[f].listener === r4) {
        u2 = n4[f].listener, a2 = f;
        break;
      }
    if (a2 < 0)
      return this;
    a2 === 0 ? n4.shift() : Tf(n4, a2), n4.length === 1 && (i5[t3] = n4[0]), i5.removeListener !== void 0 && this.emit("removeListener", t3, u2 || r4);
  }
  return this;
};
K.prototype.off = K.prototype.removeListener;
K.prototype.removeAllListeners = function(t3) {
  var r4, n4, i5;
  if (n4 = this._events, n4 === void 0)
    return this;
  if (n4.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n4[t3] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n4[t3]), this;
  if (arguments.length === 0) {
    var a2 = Object.keys(n4), f;
    for (i5 = 0; i5 < a2.length; ++i5)
      f = a2[i5], f !== "removeListener" && this.removeAllListeners(f);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (r4 = n4[t3], typeof r4 == "function")
    this.removeListener(t3, r4);
  else if (r4 !== void 0)
    for (i5 = r4.length - 1; i5 >= 0; i5--)
      this.removeListener(t3, r4[i5]);
  return this;
};
function ls(e2, t3, r4) {
  var n4 = e2._events;
  if (n4 === void 0)
    return [];
  var i5 = n4[t3];
  return i5 === void 0 ? [] : typeof i5 == "function" ? r4 ? [i5.listener || i5] : [i5] : r4 ? Pf(i5) : ds(i5, i5.length);
}
K.prototype.listeners = function(t3) {
  return ls(this, t3, true);
};
K.prototype.rawListeners = function(t3) {
  return ls(this, t3, false);
};
K.listenerCount = function(e2, t3) {
  return typeof e2.listenerCount == "function" ? e2.listenerCount(t3) : hs.call(e2, t3);
};
K.prototype.listenerCount = hs;
function hs(e2) {
  var t3 = this._events;
  if (t3 !== void 0) {
    var r4 = t3[e2];
    if (typeof r4 == "function")
      return 1;
    if (r4 !== void 0)
      return r4.length;
  }
  return 0;
}
K.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ur(this._events) : [];
};
function ds(e2, t3) {
  for (var r4 = new Array(t3), n4 = 0; n4 < t3; ++n4)
    r4[n4] = e2[n4];
  return r4;
}
function Tf(e2, t3) {
  for (; t3 + 1 < e2.length; t3++)
    e2[t3] = e2[t3 + 1];
  e2.pop();
}
function Pf(e2) {
  for (var t3 = new Array(e2.length), r4 = 0; r4 < t3.length; ++r4)
    t3[r4] = e2[r4].listener || e2[r4];
  return t3;
}
function Cf(e2, t3) {
  return new Promise(function(r4, n4) {
    function i5(f) {
      e2.removeListener(t3, a2), n4(f);
    }
    function a2() {
      typeof e2.removeListener == "function" && e2.removeListener("error", i5), r4([].slice.call(arguments));
    }
    ps(e2, t3, a2, { once: true }), t3 !== "error" && Lf(e2, i5, { once: true });
  });
}
function Lf(e2, t3, r4) {
  typeof e2.on == "function" && ps(e2, "error", t3, r4);
}
function ps(e2, t3, r4, n4) {
  if (typeof e2.on == "function")
    n4.once ? e2.once(t3, r4) : e2.on(t3, r4);
  else if (typeof e2.addEventListener == "function")
    e2.addEventListener(t3, function i5(a2) {
      n4.once && e2.removeEventListener(t3, i5), r4(a2);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
}
var bs = In.exports;
var ys = bs.EventEmitter;
var kf = {};
var Ff = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: kf
}, Symbol.toStringTag, { value: "Module" }));
var An = of(Ff);
var zr;
var ti;
function Of() {
  if (ti) return zr;
  ti = 1;
  function e2(B, P) {
    var T = Object.keys(B);
    if (Object.getOwnPropertySymbols) {
      var C2 = Object.getOwnPropertySymbols(B);
      P && (C2 = C2.filter(function(F) {
        return Object.getOwnPropertyDescriptor(B, F).enumerable;
      })), T.push.apply(T, C2);
    }
    return T;
  }
  function t3(B) {
    for (var P = 1; P < arguments.length; P++) {
      var T = arguments[P] != null ? arguments[P] : {};
      P % 2 ? e2(Object(T), true).forEach(function(C2) {
        r4(B, C2, T[C2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(B, Object.getOwnPropertyDescriptors(T)) : e2(Object(T)).forEach(function(C2) {
        Object.defineProperty(B, C2, Object.getOwnPropertyDescriptor(T, C2));
      });
    }
    return B;
  }
  function r4(B, P, T) {
    return P = f(P), P in B ? Object.defineProperty(B, P, { value: T, enumerable: true, configurable: true, writable: true }) : B[P] = T, B;
  }
  function n4(B, P) {
    if (!(B instanceof P))
      throw new TypeError("Cannot call a class as a function");
  }
  function i5(B, P) {
    for (var T = 0; T < P.length; T++) {
      var C2 = P[T];
      C2.enumerable = C2.enumerable || false, C2.configurable = true, "value" in C2 && (C2.writable = true), Object.defineProperty(B, f(C2.key), C2);
    }
  }
  function a2(B, P, T) {
    return P && i5(B.prototype, P), Object.defineProperty(B, "prototype", { writable: false }), B;
  }
  function f(B) {
    var P = u2(B, "string");
    return typeof P == "symbol" ? P : String(P);
  }
  function u2(B, P) {
    if (typeof B != "object" || B === null) return B;
    var T = B[Symbol.toPrimitive];
    if (T !== void 0) {
      var C2 = T.call(B, P || "default");
      if (typeof C2 != "object") return C2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (P === "string" ? String : Number)(B);
  }
  var l = Rt, b2 = l.Buffer, g = An, m = g.inspect, v = m && m.custom || "inspect";
  function I(B, P, T) {
    b2.prototype.copy.call(B, P, T);
  }
  return zr = function() {
    function B() {
      n4(this, B), this.head = null, this.tail = null, this.length = 0;
    }
    return a2(B, [{
      key: "push",
      value: function(T) {
        var C2 = {
          data: T,
          next: null
        };
        this.length > 0 ? this.tail.next = C2 : this.head = C2, this.tail = C2, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(T) {
        var C2 = {
          data: T,
          next: this.head
        };
        this.length === 0 && (this.tail = C2), this.head = C2, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var T = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, T;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(T) {
        if (this.length === 0) return "";
        for (var C2 = this.head, F = "" + C2.data; C2 = C2.next; ) F += T + C2.data;
        return F;
      }
    }, {
      key: "concat",
      value: function(T) {
        if (this.length === 0) return b2.alloc(0);
        for (var C2 = b2.allocUnsafe(T >>> 0), F = this.head, k2 = 0; F; )
          I(F.data, C2, k2), k2 += F.data.length, F = F.next;
        return C2;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(T, C2) {
        var F;
        return T < this.head.data.length ? (F = this.head.data.slice(0, T), this.head.data = this.head.data.slice(T)) : T === this.head.data.length ? F = this.shift() : F = C2 ? this._getString(T) : this._getBuffer(T), F;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(T) {
        var C2 = this.head, F = 1, k2 = C2.data;
        for (T -= k2.length; C2 = C2.next; ) {
          var L = C2.data, O = T > L.length ? L.length : T;
          if (O === L.length ? k2 += L : k2 += L.slice(0, T), T -= O, T === 0) {
            O === L.length ? (++F, C2.next ? this.head = C2.next : this.head = this.tail = null) : (this.head = C2, C2.data = L.slice(O));
            break;
          }
          ++F;
        }
        return this.length -= F, k2;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(T) {
        var C2 = b2.allocUnsafe(T), F = this.head, k2 = 1;
        for (F.data.copy(C2), T -= F.data.length; F = F.next; ) {
          var L = F.data, O = T > L.length ? L.length : T;
          if (L.copy(C2, C2.length - T, 0, O), T -= O, T === 0) {
            O === L.length ? (++k2, F.next ? this.head = F.next : this.head = this.tail = null) : (this.head = F, F.data = L.slice(O));
            break;
          }
          ++k2;
        }
        return this.length -= k2, C2;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: v,
      value: function(T, C2) {
        return m(this, t3(t3({}, C2), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]), B;
  }(), zr;
}
function Uf(e2, t3) {
  var r4 = this, n4 = this._readableState && this._readableState.destroyed, i5 = this._writableState && this._writableState.destroyed;
  return n4 || i5 ? (t3 ? t3(e2) : e2 && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = true, process.nextTick(fn, this, e2)) : process.nextTick(fn, this, e2)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(e2 || null, function(a2) {
    !t3 && a2 ? r4._writableState ? r4._writableState.errorEmitted ? process.nextTick(cr, r4) : (r4._writableState.errorEmitted = true, process.nextTick(ri, r4, a2)) : process.nextTick(ri, r4, a2) : t3 ? (process.nextTick(cr, r4), t3(a2)) : process.nextTick(cr, r4);
  }), this);
}
function ri(e2, t3) {
  fn(e2, t3), cr(e2);
}
function cr(e2) {
  e2._writableState && !e2._writableState.emitClose || e2._readableState && !e2._readableState.emitClose || e2.emit("close");
}
function Nf() {
  this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
}
function fn(e2, t3) {
  e2.emit("error", t3);
}
function Mf(e2, t3) {
  var r4 = e2._readableState, n4 = e2._writableState;
  r4 && r4.autoDestroy || n4 && n4.autoDestroy ? e2.destroy(t3) : e2.emit("error", t3);
}
var gs = {
  destroy: Uf,
  undestroy: Nf,
  errorOrDestroy: Mf
};
var lt = {};
function Df(e2, t3) {
  e2.prototype = Object.create(t3.prototype), e2.prototype.constructor = e2, e2.__proto__ = t3;
}
var ms = {};
function Re(e2, t3, r4) {
  r4 || (r4 = Error);
  function n4(a2, f, u2) {
    return typeof t3 == "string" ? t3 : t3(a2, f, u2);
  }
  var i5 = function(a2) {
    Df(f, a2);
    function f(u2, l, b2) {
      return a2.call(this, n4(u2, l, b2)) || this;
    }
    return f;
  }(r4);
  i5.prototype.name = r4.name, i5.prototype.code = e2, ms[e2] = i5;
}
function ni(e2, t3) {
  if (Array.isArray(e2)) {
    var r4 = e2.length;
    return e2 = e2.map(function(n4) {
      return String(n4);
    }), r4 > 2 ? "one of ".concat(t3, " ").concat(e2.slice(0, r4 - 1).join(", "), ", or ") + e2[r4 - 1] : r4 === 2 ? "one of ".concat(t3, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t3, " ").concat(e2[0]);
  } else
    return "of ".concat(t3, " ").concat(String(e2));
}
function $f(e2, t3, r4) {
  return e2.substr(0, t3.length) === t3;
}
function Hf(e2, t3, r4) {
  return (r4 === void 0 || r4 > e2.length) && (r4 = e2.length), e2.substring(r4 - t3.length, r4) === t3;
}
function zf(e2, t3, r4) {
  return typeof r4 != "number" && (r4 = 0), r4 + t3.length > e2.length ? false : e2.indexOf(t3, r4) !== -1;
}
Re("ERR_INVALID_OPT_VALUE", function(e2, t3) {
  return 'The value "' + t3 + '" is invalid for option "' + e2 + '"';
}, TypeError);
Re("ERR_INVALID_ARG_TYPE", function(e2, t3, r4) {
  var n4;
  typeof t3 == "string" && $f(t3, "not ") ? (n4 = "must not be", t3 = t3.replace(/^not /, "")) : n4 = "must be";
  var i5;
  if (Hf(e2, " argument"))
    i5 = "The ".concat(e2, " ").concat(n4, " ").concat(ni(t3, "type"));
  else {
    var a2 = zf(e2, ".") ? "property" : "argument";
    i5 = 'The "'.concat(e2, '" ').concat(a2, " ").concat(n4, " ").concat(ni(t3, "type"));
  }
  return i5 += ". Received type ".concat(typeof r4), i5;
}, TypeError);
Re("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Re("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
  return "The " + e2 + " method is not implemented";
});
Re("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Re("ERR_STREAM_DESTROYED", function(e2) {
  return "Cannot call " + e2 + " after a stream was destroyed";
});
Re("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Re("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Re("ERR_STREAM_WRITE_AFTER_END", "write after end");
Re("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Re("ERR_UNKNOWN_ENCODING", function(e2) {
  return "Unknown encoding: " + e2;
}, TypeError);
Re("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
lt.codes = ms;
var jf = lt.codes.ERR_INVALID_OPT_VALUE;
function Gf(e2, t3, r4) {
  return e2.highWaterMark != null ? e2.highWaterMark : t3 ? e2[r4] : null;
}
function Wf(e2, t3, r4, n4) {
  var i5 = Gf(t3, n4, r4);
  if (i5 != null) {
    if (!(isFinite(i5) && Math.floor(i5) === i5) || i5 < 0) {
      var a2 = n4 ? r4 : "highWaterMark";
      throw new jf(a2, i5);
    }
    return Math.floor(i5);
  }
  return e2.objectMode ? 16 : 16 * 1024;
}
var _s = {
  getHighWaterMark: Wf
};
var qf = Vf;
function Vf(e2, t3) {
  if (jr("noDeprecation"))
    return e2;
  var r4 = false;
  function n4() {
    if (!r4) {
      if (jr("throwDeprecation"))
        throw new Error(t3);
      jr("traceDeprecation") ? console.trace(t3) : console.warn(t3), r4 = true;
    }
    return e2.apply(this, arguments);
  }
  return n4;
}
function jr(e2) {
  try {
    if (!Xe.localStorage) return false;
  } catch {
    return false;
  }
  var t3 = Xe.localStorage[e2];
  return t3 == null ? false : String(t3).toLowerCase() === "true";
}
var Gr;
var ii;
function ws() {
  if (ii) return Gr;
  ii = 1, Gr = M;
  function e2(w2) {
    var _ = this;
    this.next = null, this.entry = null, this.finish = function() {
      Ne(_, w2);
    };
  }
  var t3;
  M.WritableState = S;
  var r4 = {
    deprecate: qf
  }, n4 = ys, i5 = Rt.Buffer, a2 = (typeof Xe < "u" ? Xe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function f(w2) {
    return i5.from(w2);
  }
  function u2(w2) {
    return i5.isBuffer(w2) || w2 instanceof a2;
  }
  var l = gs, b2 = _s, g = b2.getHighWaterMark, m = lt.codes, v = m.ERR_INVALID_ARG_TYPE, I = m.ERR_METHOD_NOT_IMPLEMENTED, B = m.ERR_MULTIPLE_CALLBACK, P = m.ERR_STREAM_CANNOT_PIPE, T = m.ERR_STREAM_DESTROYED, C2 = m.ERR_STREAM_NULL_VALUES, F = m.ERR_STREAM_WRITE_AFTER_END, k2 = m.ERR_UNKNOWN_ENCODING, L = l.errorOrDestroy;
  ge(M, n4);
  function O() {
  }
  function S(w2, _, R2) {
    t3 = t3 || St(), w2 = w2 || {}, typeof R2 != "boolean" && (R2 = _ instanceof t3), this.objectMode = !!w2.objectMode, R2 && (this.objectMode = this.objectMode || !!w2.writableObjectMode), this.highWaterMark = g(this, w2, "writableHighWaterMark", R2), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
    var D = w2.decodeStrings === false;
    this.decodeStrings = !D, this.defaultEncoding = w2.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(j) {
      et(_, j);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = w2.emitClose !== false, this.autoDestroy = !!w2.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e2(this);
  }
  S.prototype.getBuffer = function() {
    for (var _ = this.bufferedRequest, R2 = []; _; )
      R2.push(_), _ = _.next;
    return R2;
  }, function() {
    try {
      Object.defineProperty(S.prototype, "buffer", {
        get: r4.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var z;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (z = Function.prototype[Symbol.hasInstance], Object.defineProperty(M, Symbol.hasInstance, {
    value: function(_) {
      return z.call(this, _) ? true : this !== M ? false : _ && _._writableState instanceof S;
    }
  })) : z = function(_) {
    return _ instanceof this;
  };
  function M(w2) {
    t3 = t3 || St();
    var _ = this instanceof t3;
    if (!_ && !z.call(M, this)) return new M(w2);
    this._writableState = new S(w2, this, _), this.writable = true, w2 && (typeof w2.write == "function" && (this._write = w2.write), typeof w2.writev == "function" && (this._writev = w2.writev), typeof w2.destroy == "function" && (this._destroy = w2.destroy), typeof w2.final == "function" && (this._final = w2.final)), n4.call(this);
  }
  M.prototype.pipe = function() {
    L(this, new P());
  };
  function $(w2, _) {
    var R2 = new F();
    L(w2, R2), process.nextTick(_, R2);
  }
  function se(w2, _, R2, D) {
    var j;
    return R2 === null ? j = new C2() : typeof R2 != "string" && !_.objectMode && (j = new v("chunk", ["string", "Buffer"], R2)), j ? (L(w2, j), process.nextTick(D, j), false) : true;
  }
  M.prototype.write = function(w2, _, R2) {
    var D = this._writableState, j = false, d2 = !D.objectMode && u2(w2);
    return d2 && !i5.isBuffer(w2) && (w2 = f(w2)), typeof _ == "function" && (R2 = _, _ = null), d2 ? _ = "buffer" : _ || (_ = D.defaultEncoding), typeof R2 != "function" && (R2 = O), D.ending ? $(this, R2) : (d2 || se(this, D, w2, R2)) && (D.pendingcb++, j = je(this, D, d2, w2, _, R2)), j;
  }, M.prototype.cork = function() {
    this._writableState.corked++;
  }, M.prototype.uncork = function() {
    var w2 = this._writableState;
    w2.corked && (w2.corked--, !w2.writing && !w2.corked && !w2.bufferProcessing && w2.bufferedRequest && Ce(this, w2));
  }, M.prototype.setDefaultEncoding = function(_) {
    if (typeof _ == "string" && (_ = _.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((_ + "").toLowerCase()) > -1)) throw new k2(_);
    return this._writableState.defaultEncoding = _, this;
  }, Object.defineProperty(M.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function Te(w2, _, R2) {
    return !w2.objectMode && w2.decodeStrings !== false && typeof _ == "string" && (_ = i5.from(_, R2)), _;
  }
  Object.defineProperty(M.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function je(w2, _, R2, D, j, d2) {
    if (!R2) {
      var p = Te(_, D, j);
      D !== p && (R2 = true, j = "buffer", D = p);
    }
    var A = _.objectMode ? 1 : D.length;
    _.length += A;
    var U = _.length < _.highWaterMark;
    if (U || (_.needDrain = true), _.writing || _.corked) {
      var Z = _.lastBufferedRequest;
      _.lastBufferedRequest = {
        chunk: D,
        encoding: j,
        isBuf: R2,
        callback: d2,
        next: null
      }, Z ? Z.next = _.lastBufferedRequest : _.bufferedRequest = _.lastBufferedRequest, _.bufferedRequestCount += 1;
    } else
      ae(w2, _, false, A, D, j, d2);
    return U;
  }
  function ae(w2, _, R2, D, j, d2, p) {
    _.writelen = D, _.writecb = p, _.writing = true, _.sync = true, _.destroyed ? _.onwrite(new T("write")) : R2 ? w2._writev(j, _.onwrite) : w2._write(j, d2, _.onwrite), _.sync = false;
  }
  function xe(w2, _, R2, D, j) {
    --_.pendingcb, R2 ? (process.nextTick(j, D), process.nextTick(Be, w2, _), w2._writableState.errorEmitted = true, L(w2, D)) : (j(D), w2._writableState.errorEmitted = true, L(w2, D), Be(w2, _));
  }
  function ve(w2) {
    w2.writing = false, w2.writecb = null, w2.length -= w2.writelen, w2.writelen = 0;
  }
  function et(w2, _) {
    var R2 = w2._writableState, D = R2.sync, j = R2.writecb;
    if (typeof j != "function") throw new B();
    if (ve(R2), _) xe(w2, R2, D, _, j);
    else {
      var d2 = We(R2) || w2.destroyed;
      !d2 && !R2.corked && !R2.bufferProcessing && R2.bufferedRequest && Ce(w2, R2), D ? process.nextTick(Pe, w2, R2, d2, j) : Pe(w2, R2, d2, j);
    }
  }
  function Pe(w2, _, R2, D) {
    R2 || Ge(w2, _), _.pendingcb--, D(), Be(w2, _);
  }
  function Ge(w2, _) {
    _.length === 0 && _.needDrain && (_.needDrain = false, w2.emit("drain"));
  }
  function Ce(w2, _) {
    _.bufferProcessing = true;
    var R2 = _.bufferedRequest;
    if (w2._writev && R2 && R2.next) {
      var D = _.bufferedRequestCount, j = new Array(D), d2 = _.corkedRequestsFree;
      d2.entry = R2;
      for (var p = 0, A = true; R2; )
        j[p] = R2, R2.isBuf || (A = false), R2 = R2.next, p += 1;
      j.allBuffers = A, ae(w2, _, true, _.length, j, "", d2.finish), _.pendingcb++, _.lastBufferedRequest = null, d2.next ? (_.corkedRequestsFree = d2.next, d2.next = null) : _.corkedRequestsFree = new e2(_), _.bufferedRequestCount = 0;
    } else {
      for (; R2; ) {
        var U = R2.chunk, Z = R2.encoding, G = R2.callback, V = _.objectMode ? 1 : U.length;
        if (ae(w2, _, false, V, U, Z, G), R2 = R2.next, _.bufferedRequestCount--, _.writing)
          break;
      }
      R2 === null && (_.lastBufferedRequest = null);
    }
    _.bufferedRequest = R2, _.bufferProcessing = false;
  }
  M.prototype._write = function(w2, _, R2) {
    R2(new I("_write()"));
  }, M.prototype._writev = null, M.prototype.end = function(w2, _, R2) {
    var D = this._writableState;
    return typeof w2 == "function" ? (R2 = w2, w2 = null, _ = null) : typeof _ == "function" && (R2 = _, _ = null), w2 != null && this.write(w2, _), D.corked && (D.corked = 1, this.uncork()), D.ending || qe(this, D, R2), this;
  }, Object.defineProperty(M.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function We(w2) {
    return w2.ending && w2.length === 0 && w2.bufferedRequest === null && !w2.finished && !w2.writing;
  }
  function Q(w2, _) {
    w2._final(function(R2) {
      _.pendingcb--, R2 && L(w2, R2), _.prefinished = true, w2.emit("prefinish"), Be(w2, _);
    });
  }
  function oe(w2, _) {
    !_.prefinished && !_.finalCalled && (typeof w2._final == "function" && !_.destroyed ? (_.pendingcb++, _.finalCalled = true, process.nextTick(Q, w2, _)) : (_.prefinished = true, w2.emit("prefinish")));
  }
  function Be(w2, _) {
    var R2 = We(_);
    if (R2 && (oe(w2, _), _.pendingcb === 0 && (_.finished = true, w2.emit("finish"), _.autoDestroy))) {
      var D = w2._readableState;
      (!D || D.autoDestroy && D.endEmitted) && w2.destroy();
    }
    return R2;
  }
  function qe(w2, _, R2) {
    _.ending = true, Be(w2, _), R2 && (_.finished ? process.nextTick(R2) : w2.once("finish", R2)), _.ended = true, w2.writable = false;
  }
  function Ne(w2, _, R2) {
    var D = w2.entry;
    for (w2.entry = null; D; ) {
      var j = D.callback;
      _.pendingcb--, j(R2), D = D.next;
    }
    _.corkedRequestsFree.next = w2;
  }
  return Object.defineProperty(M.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState === void 0 ? false : this._writableState.destroyed;
    },
    set: function(_) {
      this._writableState && (this._writableState.destroyed = _);
    }
  }), M.prototype.destroy = l.destroy, M.prototype._undestroy = l.undestroy, M.prototype._destroy = function(w2, _) {
    _(w2);
  }, Gr;
}
var Wr;
var si;
function St() {
  if (si) return Wr;
  si = 1;
  var e2 = Object.keys || function(b2) {
    var g = [];
    for (var m in b2) g.push(m);
    return g;
  };
  Wr = f;
  var t3 = vs(), r4 = ws();
  ge(f, t3);
  for (var n4 = e2(r4.prototype), i5 = 0; i5 < n4.length; i5++) {
    var a2 = n4[i5];
    f.prototype[a2] || (f.prototype[a2] = r4.prototype[a2]);
  }
  function f(b2) {
    if (!(this instanceof f)) return new f(b2);
    t3.call(this, b2), r4.call(this, b2), this.allowHalfOpen = true, b2 && (b2.readable === false && (this.readable = false), b2.writable === false && (this.writable = false), b2.allowHalfOpen === false && (this.allowHalfOpen = false, this.once("end", u2)));
  }
  Object.defineProperty(f.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(f.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(f.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.length;
    }
  });
  function u2() {
    this._writableState.ended || process.nextTick(l, this);
  }
  function l(b2) {
    b2.end();
  }
  return Object.defineProperty(f.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? false : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), Wr;
}
var mr = {};
var Rn = Ee.Buffer;
var oi = Rn.isEncoding || function(e2) {
  switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function Kf(e2) {
  if (!e2) return "utf8";
  for (var t3; ; )
    switch (e2) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e2;
      default:
        if (t3) return;
        e2 = ("" + e2).toLowerCase(), t3 = true;
    }
}
function Yf(e2) {
  var t3 = Kf(e2);
  if (typeof t3 != "string" && (Rn.isEncoding === oi || !oi(e2))) throw new Error("Unknown encoding: " + e2);
  return t3 || e2;
}
mr.StringDecoder = Xt;
function Xt(e2) {
  this.encoding = Yf(e2);
  var t3;
  switch (this.encoding) {
    case "utf16le":
      this.text = tu, this.end = ru, t3 = 4;
      break;
    case "utf8":
      this.fillLast = Qf, t3 = 4;
      break;
    case "base64":
      this.text = nu, this.end = iu, t3 = 3;
      break;
    default:
      this.write = su, this.end = ou;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Rn.allocUnsafe(t3);
}
Xt.prototype.write = function(e2) {
  if (e2.length === 0) return "";
  var t3, r4;
  if (this.lastNeed) {
    if (t3 = this.fillLast(e2), t3 === void 0) return "";
    r4 = this.lastNeed, this.lastNeed = 0;
  } else
    r4 = 0;
  return r4 < e2.length ? t3 ? t3 + this.text(e2, r4) : this.text(e2, r4) : t3 || "";
};
Xt.prototype.end = eu;
Xt.prototype.text = Zf;
Xt.prototype.fillLast = function(e2) {
  if (this.lastNeed <= e2.length)
    return e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length;
};
function qr(e2) {
  return e2 <= 127 ? 0 : e2 >> 5 === 6 ? 2 : e2 >> 4 === 14 ? 3 : e2 >> 3 === 30 ? 4 : e2 >> 6 === 2 ? -1 : -2;
}
function Jf(e2, t3, r4) {
  var n4 = t3.length - 1;
  if (n4 < r4) return 0;
  var i5 = qr(t3[n4]);
  return i5 >= 0 ? (i5 > 0 && (e2.lastNeed = i5 - 1), i5) : --n4 < r4 || i5 === -2 ? 0 : (i5 = qr(t3[n4]), i5 >= 0 ? (i5 > 0 && (e2.lastNeed = i5 - 2), i5) : --n4 < r4 || i5 === -2 ? 0 : (i5 = qr(t3[n4]), i5 >= 0 ? (i5 > 0 && (i5 === 2 ? i5 = 0 : e2.lastNeed = i5 - 3), i5) : 0));
}
function Xf(e2, t3, r4) {
  if ((t3[0] & 192) !== 128)
    return e2.lastNeed = 0, "�";
  if (e2.lastNeed > 1 && t3.length > 1) {
    if ((t3[1] & 192) !== 128)
      return e2.lastNeed = 1, "�";
    if (e2.lastNeed > 2 && t3.length > 2 && (t3[2] & 192) !== 128)
      return e2.lastNeed = 2, "�";
  }
}
function Qf(e2) {
  var t3 = this.lastTotal - this.lastNeed, r4 = Xf(this, e2);
  if (r4 !== void 0) return r4;
  if (this.lastNeed <= e2.length)
    return e2.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e2.copy(this.lastChar, t3, 0, e2.length), this.lastNeed -= e2.length;
}
function Zf(e2, t3) {
  var r4 = Jf(this, e2, t3);
  if (!this.lastNeed) return e2.toString("utf8", t3);
  this.lastTotal = r4;
  var n4 = e2.length - (r4 - this.lastNeed);
  return e2.copy(this.lastChar, 0, n4), e2.toString("utf8", t3, n4);
}
function eu(e2) {
  var t3 = e2 && e2.length ? this.write(e2) : "";
  return this.lastNeed ? t3 + "�" : t3;
}
function tu(e2, t3) {
  if ((e2.length - t3) % 2 === 0) {
    var r4 = e2.toString("utf16le", t3);
    if (r4) {
      var n4 = r4.charCodeAt(r4.length - 1);
      if (n4 >= 55296 && n4 <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], r4.slice(0, -1);
    }
    return r4;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t3, e2.length - 1);
}
function ru(e2) {
  var t3 = e2 && e2.length ? this.write(e2) : "";
  if (this.lastNeed) {
    var r4 = this.lastTotal - this.lastNeed;
    return t3 + this.lastChar.toString("utf16le", 0, r4);
  }
  return t3;
}
function nu(e2, t3) {
  var r4 = (e2.length - t3) % 3;
  return r4 === 0 ? e2.toString("base64", t3) : (this.lastNeed = 3 - r4, this.lastTotal = 3, r4 === 1 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t3, e2.length - r4));
}
function iu(e2) {
  var t3 = e2 && e2.length ? this.write(e2) : "";
  return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
}
function su(e2) {
  return e2.toString(this.encoding);
}
function ou(e2) {
  return e2 && e2.length ? this.write(e2) : "";
}
var ai = lt.codes.ERR_STREAM_PREMATURE_CLOSE;
function au(e2) {
  var t3 = false;
  return function() {
    if (!t3) {
      t3 = true;
      for (var r4 = arguments.length, n4 = new Array(r4), i5 = 0; i5 < r4; i5++)
        n4[i5] = arguments[i5];
      e2.apply(this, n4);
    }
  };
}
function fu() {
}
function uu(e2) {
  return e2.setHeader && typeof e2.abort == "function";
}
function xs(e2, t3, r4) {
  if (typeof t3 == "function") return xs(e2, null, t3);
  t3 || (t3 = {}), r4 = au(r4 || fu);
  var n4 = t3.readable || t3.readable !== false && e2.readable, i5 = t3.writable || t3.writable !== false && e2.writable, a2 = function() {
    e2.writable || u2();
  }, f = e2._writableState && e2._writableState.finished, u2 = function() {
    i5 = false, f = true, n4 || r4.call(e2);
  }, l = e2._readableState && e2._readableState.endEmitted, b2 = function() {
    n4 = false, l = true, i5 || r4.call(e2);
  }, g = function(B) {
    r4.call(e2, B);
  }, m = function() {
    var B;
    if (n4 && !l)
      return (!e2._readableState || !e2._readableState.ended) && (B = new ai()), r4.call(e2, B);
    if (i5 && !f)
      return (!e2._writableState || !e2._writableState.ended) && (B = new ai()), r4.call(e2, B);
  }, v = function() {
    e2.req.on("finish", u2);
  };
  return uu(e2) ? (e2.on("complete", u2), e2.on("abort", m), e2.req ? v() : e2.on("request", v)) : i5 && !e2._writableState && (e2.on("end", a2), e2.on("close", a2)), e2.on("end", b2), e2.on("finish", u2), t3.error !== false && e2.on("error", g), e2.on("close", m), function() {
    e2.removeListener("complete", u2), e2.removeListener("abort", m), e2.removeListener("request", v), e2.req && e2.req.removeListener("finish", u2), e2.removeListener("end", a2), e2.removeListener("close", a2), e2.removeListener("finish", u2), e2.removeListener("end", b2), e2.removeListener("error", g), e2.removeListener("close", m);
  };
}
var Tn = xs;
var Vr;
var fi;
function cu() {
  if (fi) return Vr;
  fi = 1;
  var e2;
  function t3(k2, L, O) {
    return L = r4(L), L in k2 ? Object.defineProperty(k2, L, { value: O, enumerable: true, configurable: true, writable: true }) : k2[L] = O, k2;
  }
  function r4(k2) {
    var L = n4(k2, "string");
    return typeof L == "symbol" ? L : String(L);
  }
  function n4(k2, L) {
    if (typeof k2 != "object" || k2 === null) return k2;
    var O = k2[Symbol.toPrimitive];
    if (O !== void 0) {
      var S = O.call(k2, L || "default");
      if (typeof S != "object") return S;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (L === "string" ? String : Number)(k2);
  }
  var i5 = Tn, a2 = Symbol("lastResolve"), f = Symbol("lastReject"), u2 = Symbol("error"), l = Symbol("ended"), b2 = Symbol("lastPromise"), g = Symbol("handlePromise"), m = Symbol("stream");
  function v(k2, L) {
    return {
      value: k2,
      done: L
    };
  }
  function I(k2) {
    var L = k2[a2];
    if (L !== null) {
      var O = k2[m].read();
      O !== null && (k2[b2] = null, k2[a2] = null, k2[f] = null, L(v(O, false)));
    }
  }
  function B(k2) {
    process.nextTick(I, k2);
  }
  function P(k2, L) {
    return function(O, S) {
      k2.then(function() {
        if (L[l]) {
          O(v(void 0, true));
          return;
        }
        L[g](O, S);
      }, S);
    };
  }
  var T = Object.getPrototypeOf(function() {
  }), C2 = Object.setPrototypeOf((e2 = {
    get stream() {
      return this[m];
    },
    next: function() {
      var L = this, O = this[u2];
      if (O !== null)
        return Promise.reject(O);
      if (this[l])
        return Promise.resolve(v(void 0, true));
      if (this[m].destroyed)
        return new Promise(function($, se) {
          process.nextTick(function() {
            L[u2] ? se(L[u2]) : $(v(void 0, true));
          });
        });
      var S = this[b2], z;
      if (S)
        z = new Promise(P(S, this));
      else {
        var M = this[m].read();
        if (M !== null)
          return Promise.resolve(v(M, false));
        z = new Promise(this[g]);
      }
      return this[b2] = z, z;
    }
  }, t3(e2, Symbol.asyncIterator, function() {
    return this;
  }), t3(e2, "return", function() {
    var L = this;
    return new Promise(function(O, S) {
      L[m].destroy(null, function(z) {
        if (z) {
          S(z);
          return;
        }
        O(v(void 0, true));
      });
    });
  }), e2), T), F = function(L) {
    var O, S = Object.create(C2, (O = {}, t3(O, m, {
      value: L,
      writable: true
    }), t3(O, a2, {
      value: null,
      writable: true
    }), t3(O, f, {
      value: null,
      writable: true
    }), t3(O, u2, {
      value: null,
      writable: true
    }), t3(O, l, {
      value: L._readableState.endEmitted,
      writable: true
    }), t3(O, g, {
      value: function(M, $) {
        var se = S[m].read();
        se ? (S[b2] = null, S[a2] = null, S[f] = null, M(v(se, false))) : (S[a2] = M, S[f] = $);
      },
      writable: true
    }), O));
    return S[b2] = null, i5(L, function(z) {
      if (z && z.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var M = S[f];
        M !== null && (S[b2] = null, S[a2] = null, S[f] = null, M(z)), S[u2] = z;
        return;
      }
      var $ = S[a2];
      $ !== null && (S[b2] = null, S[a2] = null, S[f] = null, $(v(void 0, true))), S[l] = true;
    }), L.on("readable", B.bind(null, S)), S;
  };
  return Vr = F, Vr;
}
var Kr;
var ui;
function lu() {
  return ui || (ui = 1, Kr = function() {
    throw new Error("Readable.from is not available in the browser");
  }), Kr;
}
var Yr;
var ci;
function vs() {
  if (ci) return Yr;
  ci = 1, Yr = $;
  var e2;
  $.ReadableState = M, bs.EventEmitter;
  var t3 = function(p, A) {
    return p.listeners(A).length;
  }, r4 = ys, n4 = Rt.Buffer, i5 = (typeof Xe < "u" ? Xe : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a2(d2) {
    return n4.from(d2);
  }
  function f(d2) {
    return n4.isBuffer(d2) || d2 instanceof i5;
  }
  var u2 = An, l;
  u2 && u2.debuglog ? l = u2.debuglog("stream") : l = function() {
  };
  var b2 = Of(), g = gs, m = _s, v = m.getHighWaterMark, I = lt.codes, B = I.ERR_INVALID_ARG_TYPE, P = I.ERR_STREAM_PUSH_AFTER_EOF, T = I.ERR_METHOD_NOT_IMPLEMENTED, C2 = I.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, F, k2, L;
  ge($, r4);
  var O = g.errorOrDestroy, S = ["error", "close", "destroy", "pause", "resume"];
  function z(d2, p, A) {
    if (typeof d2.prependListener == "function") return d2.prependListener(p, A);
    !d2._events || !d2._events[p] ? d2.on(p, A) : Array.isArray(d2._events[p]) ? d2._events[p].unshift(A) : d2._events[p] = [A, d2._events[p]];
  }
  function M(d2, p, A) {
    e2 = e2 || St(), d2 = d2 || {}, typeof A != "boolean" && (A = p instanceof e2), this.objectMode = !!d2.objectMode, A && (this.objectMode = this.objectMode || !!d2.readableObjectMode), this.highWaterMark = v(this, d2, "readableHighWaterMark", A), this.buffer = new b2(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = d2.emitClose !== false, this.autoDestroy = !!d2.autoDestroy, this.destroyed = false, this.defaultEncoding = d2.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, d2.encoding && (F || (F = mr.StringDecoder), this.decoder = new F(d2.encoding), this.encoding = d2.encoding);
  }
  function $(d2) {
    if (e2 = e2 || St(), !(this instanceof $)) return new $(d2);
    var p = this instanceof e2;
    this._readableState = new M(d2, this, p), this.readable = true, d2 && (typeof d2.read == "function" && (this._read = d2.read), typeof d2.destroy == "function" && (this._destroy = d2.destroy)), r4.call(this);
  }
  Object.defineProperty($.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState === void 0 ? false : this._readableState.destroyed;
    },
    set: function(p) {
      this._readableState && (this._readableState.destroyed = p);
    }
  }), $.prototype.destroy = g.destroy, $.prototype._undestroy = g.undestroy, $.prototype._destroy = function(d2, p) {
    p(d2);
  }, $.prototype.push = function(d2, p) {
    var A = this._readableState, U;
    return A.objectMode ? U = true : typeof d2 == "string" && (p = p || A.defaultEncoding, p !== A.encoding && (d2 = n4.from(d2, p), p = ""), U = true), se(this, d2, p, false, U);
  }, $.prototype.unshift = function(d2) {
    return se(this, d2, null, true, false);
  };
  function se(d2, p, A, U, Z) {
    l("readableAddChunk", p);
    var G = d2._readableState;
    if (p === null)
      G.reading = false, et(d2, G);
    else {
      var V;
      if (Z || (V = je(G, p)), V)
        O(d2, V);
      else if (G.objectMode || p && p.length > 0)
        if (typeof p != "string" && !G.objectMode && Object.getPrototypeOf(p) !== n4.prototype && (p = a2(p)), U)
          G.endEmitted ? O(d2, new C2()) : Te(d2, G, p, true);
        else if (G.ended)
          O(d2, new P());
        else {
          if (G.destroyed)
            return false;
          G.reading = false, G.decoder && !A ? (p = G.decoder.write(p), G.objectMode || p.length !== 0 ? Te(d2, G, p, false) : Ce(d2, G)) : Te(d2, G, p, false);
        }
      else U || (G.reading = false, Ce(d2, G));
    }
    return !G.ended && (G.length < G.highWaterMark || G.length === 0);
  }
  function Te(d2, p, A, U) {
    p.flowing && p.length === 0 && !p.sync ? (p.awaitDrain = 0, d2.emit("data", A)) : (p.length += p.objectMode ? 1 : A.length, U ? p.buffer.unshift(A) : p.buffer.push(A), p.needReadable && Pe(d2)), Ce(d2, p);
  }
  function je(d2, p) {
    var A;
    return !f(p) && typeof p != "string" && p !== void 0 && !d2.objectMode && (A = new B("chunk", ["string", "Buffer", "Uint8Array"], p)), A;
  }
  $.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  }, $.prototype.setEncoding = function(d2) {
    F || (F = mr.StringDecoder);
    var p = new F(d2);
    this._readableState.decoder = p, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var A = this._readableState.buffer.head, U = ""; A !== null; )
      U += p.write(A.data), A = A.next;
    return this._readableState.buffer.clear(), U !== "" && this._readableState.buffer.push(U), this._readableState.length = U.length, this;
  };
  var ae = 1073741824;
  function xe(d2) {
    return d2 >= ae ? d2 = ae : (d2--, d2 |= d2 >>> 1, d2 |= d2 >>> 2, d2 |= d2 >>> 4, d2 |= d2 >>> 8, d2 |= d2 >>> 16, d2++), d2;
  }
  function ve(d2, p) {
    return d2 <= 0 || p.length === 0 && p.ended ? 0 : p.objectMode ? 1 : d2 !== d2 ? p.flowing && p.length ? p.buffer.head.data.length : p.length : (d2 > p.highWaterMark && (p.highWaterMark = xe(d2)), d2 <= p.length ? d2 : p.ended ? p.length : (p.needReadable = true, 0));
  }
  $.prototype.read = function(d2) {
    l("read", d2), d2 = parseInt(d2, 10);
    var p = this._readableState, A = d2;
    if (d2 !== 0 && (p.emittedReadable = false), d2 === 0 && p.needReadable && ((p.highWaterMark !== 0 ? p.length >= p.highWaterMark : p.length > 0) || p.ended))
      return l("read: emitReadable", p.length, p.ended), p.length === 0 && p.ended ? R2(this) : Pe(this), null;
    if (d2 = ve(d2, p), d2 === 0 && p.ended)
      return p.length === 0 && R2(this), null;
    var U = p.needReadable;
    l("need readable", U), (p.length === 0 || p.length - d2 < p.highWaterMark) && (U = true, l("length less than watermark", U)), p.ended || p.reading ? (U = false, l("reading or ended", U)) : U && (l("do read"), p.reading = true, p.sync = true, p.length === 0 && (p.needReadable = true), this._read(p.highWaterMark), p.sync = false, p.reading || (d2 = ve(A, p)));
    var Z;
    return d2 > 0 ? Z = _(d2, p) : Z = null, Z === null ? (p.needReadable = p.length <= p.highWaterMark, d2 = 0) : (p.length -= d2, p.awaitDrain = 0), p.length === 0 && (p.ended || (p.needReadable = true), A !== d2 && p.ended && R2(this)), Z !== null && this.emit("data", Z), Z;
  };
  function et(d2, p) {
    if (l("onEofChunk"), !p.ended) {
      if (p.decoder) {
        var A = p.decoder.end();
        A && A.length && (p.buffer.push(A), p.length += p.objectMode ? 1 : A.length);
      }
      p.ended = true, p.sync ? Pe(d2) : (p.needReadable = false, p.emittedReadable || (p.emittedReadable = true, Ge(d2)));
    }
  }
  function Pe(d2) {
    var p = d2._readableState;
    l("emitReadable", p.needReadable, p.emittedReadable), p.needReadable = false, p.emittedReadable || (l("emitReadable", p.flowing), p.emittedReadable = true, process.nextTick(Ge, d2));
  }
  function Ge(d2) {
    var p = d2._readableState;
    l("emitReadable_", p.destroyed, p.length, p.ended), !p.destroyed && (p.length || p.ended) && (d2.emit("readable"), p.emittedReadable = false), p.needReadable = !p.flowing && !p.ended && p.length <= p.highWaterMark, w2(d2);
  }
  function Ce(d2, p) {
    p.readingMore || (p.readingMore = true, process.nextTick(We, d2, p));
  }
  function We(d2, p) {
    for (; !p.reading && !p.ended && (p.length < p.highWaterMark || p.flowing && p.length === 0); ) {
      var A = p.length;
      if (l("maybeReadMore read 0"), d2.read(0), A === p.length)
        break;
    }
    p.readingMore = false;
  }
  $.prototype._read = function(d2) {
    O(this, new T("_read()"));
  }, $.prototype.pipe = function(d2, p) {
    var A = this, U = this._readableState;
    switch (U.pipesCount) {
      case 0:
        U.pipes = d2;
        break;
      case 1:
        U.pipes = [U.pipes, d2];
        break;
      default:
        U.pipes.push(d2);
        break;
    }
    U.pipesCount += 1, l("pipe count=%d opts=%j", U.pipesCount, p);
    var Z = (!p || p.end !== false) && d2 !== process.stdout && d2 !== process.stderr, G = Z ? Ve : rt;
    U.endEmitted ? process.nextTick(G) : A.once("end", G), d2.on("unpipe", V);
    function V(c2, s4) {
      l("onunpipe"), c2 === A && s4 && s4.hasUnpiped === false && (s4.hasUnpiped = true, pt());
    }
    function Ve() {
      l("onend"), d2.end();
    }
    var dt = Q(A);
    d2.on("drain", dt);
    var Pt = false;
    function pt() {
      l("cleanup"), d2.removeListener("close", Ct), d2.removeListener("finish", Ie), d2.removeListener("drain", dt), d2.removeListener("error", tt), d2.removeListener("unpipe", V), A.removeListener("end", Ve), A.removeListener("end", rt), A.removeListener("data", Se), Pt = true, U.awaitDrain && (!d2._writableState || d2._writableState.needDrain) && dt();
    }
    A.on("data", Se);
    function Se(c2) {
      l("ondata");
      var s4 = d2.write(c2);
      l("dest.write", s4), s4 === false && ((U.pipesCount === 1 && U.pipes === d2 || U.pipesCount > 1 && j(U.pipes, d2) !== -1) && !Pt && (l("false write response, pause", U.awaitDrain), U.awaitDrain++), A.pause());
    }
    function tt(c2) {
      l("onerror", c2), rt(), d2.removeListener("error", tt), t3(d2, "error") === 0 && O(d2, c2);
    }
    z(d2, "error", tt);
    function Ct() {
      d2.removeListener("finish", Ie), rt();
    }
    d2.once("close", Ct);
    function Ie() {
      l("onfinish"), d2.removeListener("close", Ct), rt();
    }
    d2.once("finish", Ie);
    function rt() {
      l("unpipe"), A.unpipe(d2);
    }
    return d2.emit("pipe", A), U.flowing || (l("pipe resume"), A.resume()), d2;
  };
  function Q(d2) {
    return function() {
      var A = d2._readableState;
      l("pipeOnDrain", A.awaitDrain), A.awaitDrain && A.awaitDrain--, A.awaitDrain === 0 && t3(d2, "data") && (A.flowing = true, w2(d2));
    };
  }
  $.prototype.unpipe = function(d2) {
    var p = this._readableState, A = {
      hasUnpiped: false
    };
    if (p.pipesCount === 0) return this;
    if (p.pipesCount === 1)
      return d2 && d2 !== p.pipes ? this : (d2 || (d2 = p.pipes), p.pipes = null, p.pipesCount = 0, p.flowing = false, d2 && d2.emit("unpipe", this, A), this);
    if (!d2) {
      var U = p.pipes, Z = p.pipesCount;
      p.pipes = null, p.pipesCount = 0, p.flowing = false;
      for (var G = 0; G < Z; G++) U[G].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var V = j(p.pipes, d2);
    return V === -1 ? this : (p.pipes.splice(V, 1), p.pipesCount -= 1, p.pipesCount === 1 && (p.pipes = p.pipes[0]), d2.emit("unpipe", this, A), this);
  }, $.prototype.on = function(d2, p) {
    var A = r4.prototype.on.call(this, d2, p), U = this._readableState;
    return d2 === "data" ? (U.readableListening = this.listenerCount("readable") > 0, U.flowing !== false && this.resume()) : d2 === "readable" && !U.endEmitted && !U.readableListening && (U.readableListening = U.needReadable = true, U.flowing = false, U.emittedReadable = false, l("on readable", U.length, U.reading), U.length ? Pe(this) : U.reading || process.nextTick(Be, this)), A;
  }, $.prototype.addListener = $.prototype.on, $.prototype.removeListener = function(d2, p) {
    var A = r4.prototype.removeListener.call(this, d2, p);
    return d2 === "readable" && process.nextTick(oe, this), A;
  }, $.prototype.removeAllListeners = function(d2) {
    var p = r4.prototype.removeAllListeners.apply(this, arguments);
    return (d2 === "readable" || d2 === void 0) && process.nextTick(oe, this), p;
  };
  function oe(d2) {
    var p = d2._readableState;
    p.readableListening = d2.listenerCount("readable") > 0, p.resumeScheduled && !p.paused ? p.flowing = true : d2.listenerCount("data") > 0 && d2.resume();
  }
  function Be(d2) {
    l("readable nexttick read 0"), d2.read(0);
  }
  $.prototype.resume = function() {
    var d2 = this._readableState;
    return d2.flowing || (l("resume"), d2.flowing = !d2.readableListening, qe(this, d2)), d2.paused = false, this;
  };
  function qe(d2, p) {
    p.resumeScheduled || (p.resumeScheduled = true, process.nextTick(Ne, d2, p));
  }
  function Ne(d2, p) {
    l("resume", p.reading), p.reading || d2.read(0), p.resumeScheduled = false, d2.emit("resume"), w2(d2), p.flowing && !p.reading && d2.read(0);
  }
  $.prototype.pause = function() {
    return l("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== false && (l("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
  };
  function w2(d2) {
    var p = d2._readableState;
    for (l("flow", p.flowing); p.flowing && d2.read() !== null; ) ;
  }
  $.prototype.wrap = function(d2) {
    var p = this, A = this._readableState, U = false;
    d2.on("end", function() {
      if (l("wrapped end"), A.decoder && !A.ended) {
        var V = A.decoder.end();
        V && V.length && p.push(V);
      }
      p.push(null);
    }), d2.on("data", function(V) {
      if (l("wrapped data"), A.decoder && (V = A.decoder.write(V)), !(A.objectMode && V == null) && !(!A.objectMode && (!V || !V.length))) {
        var Ve = p.push(V);
        Ve || (U = true, d2.pause());
      }
    });
    for (var Z in d2)
      this[Z] === void 0 && typeof d2[Z] == "function" && (this[Z] = /* @__PURE__ */ function(Ve) {
        return function() {
          return d2[Ve].apply(d2, arguments);
        };
      }(Z));
    for (var G = 0; G < S.length; G++)
      d2.on(S[G], this.emit.bind(this, S[G]));
    return this._read = function(V) {
      l("wrapped _read", V), U && (U = false, d2.resume());
    }, this;
  }, typeof Symbol == "function" && ($.prototype[Symbol.asyncIterator] = function() {
    return k2 === void 0 && (k2 = cu()), k2(this);
  }), Object.defineProperty($.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty($.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty($.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(p) {
      this._readableState && (this._readableState.flowing = p);
    }
  }), $._fromList = _, Object.defineProperty($.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.length;
    }
  });
  function _(d2, p) {
    if (p.length === 0) return null;
    var A;
    return p.objectMode ? A = p.buffer.shift() : !d2 || d2 >= p.length ? (p.decoder ? A = p.buffer.join("") : p.buffer.length === 1 ? A = p.buffer.first() : A = p.buffer.concat(p.length), p.buffer.clear()) : A = p.buffer.consume(d2, p.decoder), A;
  }
  function R2(d2) {
    var p = d2._readableState;
    l("endReadable", p.endEmitted), p.endEmitted || (p.ended = true, process.nextTick(D, p, d2));
  }
  function D(d2, p) {
    if (l("endReadableNT", d2.endEmitted, d2.length), !d2.endEmitted && d2.length === 0 && (d2.endEmitted = true, p.readable = false, p.emit("end"), d2.autoDestroy)) {
      var A = p._writableState;
      (!A || A.autoDestroy && A.finished) && p.destroy();
    }
  }
  typeof Symbol == "function" && ($.from = function(d2, p) {
    return L === void 0 && (L = lu()), L($, d2, p);
  });
  function j(d2, p) {
    for (var A = 0, U = d2.length; A < U; A++)
      if (d2[A] === p) return A;
    return -1;
  }
  return Yr;
}
var Es = ze;
var Sr = lt.codes;
var hu = Sr.ERR_METHOD_NOT_IMPLEMENTED;
var du = Sr.ERR_MULTIPLE_CALLBACK;
var pu = Sr.ERR_TRANSFORM_ALREADY_TRANSFORMING;
var bu = Sr.ERR_TRANSFORM_WITH_LENGTH_0;
var Ir = St();
ge(ze, Ir);
function yu(e2, t3) {
  var r4 = this._transformState;
  r4.transforming = false;
  var n4 = r4.writecb;
  if (n4 === null)
    return this.emit("error", new du());
  r4.writechunk = null, r4.writecb = null, t3 != null && this.push(t3), n4(e2);
  var i5 = this._readableState;
  i5.reading = false, (i5.needReadable || i5.length < i5.highWaterMark) && this._read(i5.highWaterMark);
}
function ze(e2) {
  if (!(this instanceof ze)) return new ze(e2);
  Ir.call(this, e2), this._transformState = {
    afterTransform: yu.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && (typeof e2.transform == "function" && (this._transform = e2.transform), typeof e2.flush == "function" && (this._flush = e2.flush)), this.on("prefinish", gu);
}
function gu() {
  var e2 = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t3, r4) {
    li(e2, t3, r4);
  }) : li(this, null, null);
}
ze.prototype.push = function(e2, t3) {
  return this._transformState.needTransform = false, Ir.prototype.push.call(this, e2, t3);
};
ze.prototype._transform = function(e2, t3, r4) {
  r4(new hu("_transform()"));
};
ze.prototype._write = function(e2, t3, r4) {
  var n4 = this._transformState;
  if (n4.writecb = r4, n4.writechunk = e2, n4.writeencoding = t3, !n4.transforming) {
    var i5 = this._readableState;
    (n4.needTransform || i5.needReadable || i5.length < i5.highWaterMark) && this._read(i5.highWaterMark);
  }
};
ze.prototype._read = function(e2) {
  var t3 = this._transformState;
  t3.writechunk !== null && !t3.transforming ? (t3.transforming = true, this._transform(t3.writechunk, t3.writeencoding, t3.afterTransform)) : t3.needTransform = true;
};
ze.prototype._destroy = function(e2, t3) {
  Ir.prototype._destroy.call(this, e2, function(r4) {
    t3(r4);
  });
};
function li(e2, t3, r4) {
  if (t3) return e2.emit("error", t3);
  if (r4 != null && e2.push(r4), e2._writableState.length) throw new bu();
  if (e2._transformState.transforming) throw new pu();
  return e2.push(null);
}
var mu = Wt;
var Bs = Es;
ge(Wt, Bs);
function Wt(e2) {
  if (!(this instanceof Wt)) return new Wt(e2);
  Bs.call(this, e2);
}
Wt.prototype._transform = function(e2, t3, r4) {
  r4(null, e2);
};
var Jr;
function _u(e2) {
  var t3 = false;
  return function() {
    t3 || (t3 = true, e2.apply(void 0, arguments));
  };
}
var Ss = lt.codes;
var wu = Ss.ERR_MISSING_ARGS;
var xu = Ss.ERR_STREAM_DESTROYED;
function hi(e2) {
  if (e2) throw e2;
}
function vu(e2) {
  return e2.setHeader && typeof e2.abort == "function";
}
function Eu(e2, t3, r4, n4) {
  n4 = _u(n4);
  var i5 = false;
  e2.on("close", function() {
    i5 = true;
  }), Jr === void 0 && (Jr = Tn), Jr(e2, {
    readable: t3,
    writable: r4
  }, function(f) {
    if (f) return n4(f);
    i5 = true, n4();
  });
  var a2 = false;
  return function(f) {
    if (!i5 && !a2) {
      if (a2 = true, vu(e2)) return e2.abort();
      if (typeof e2.destroy == "function") return e2.destroy();
      n4(f || new xu("pipe"));
    }
  };
}
function di(e2) {
  e2();
}
function Bu(e2, t3) {
  return e2.pipe(t3);
}
function Su(e2) {
  return !e2.length || typeof e2[e2.length - 1] != "function" ? hi : e2.pop();
}
function Iu() {
  for (var e2 = arguments.length, t3 = new Array(e2), r4 = 0; r4 < e2; r4++)
    t3[r4] = arguments[r4];
  var n4 = Su(t3);
  if (Array.isArray(t3[0]) && (t3 = t3[0]), t3.length < 2)
    throw new wu("streams");
  var i5, a2 = t3.map(function(f, u2) {
    var l = u2 < t3.length - 1, b2 = u2 > 0;
    return Eu(f, l, b2, function(g) {
      i5 || (i5 = g), g && a2.forEach(di), !l && (a2.forEach(di), n4(i5));
    });
  });
  return t3.reduce(Bu);
}
var Au = Iu;
(function(e2, t3) {
  t3 = e2.exports = vs(), t3.Stream = t3, t3.Readable = t3, t3.Writable = ws(), t3.Duplex = St(), t3.Transform = Es, t3.PassThrough = mu, t3.finished = Tn, t3.pipeline = Au;
})(an, an.exports);
var Ru = an.exports;
var _r = Ee.Buffer;
var Is = Ru.Transform;
var Tu = ge;
function Pu(e2, t3) {
  if (!_r.isBuffer(e2) && typeof e2 != "string")
    throw new TypeError(t3 + " must be a string or a buffer");
}
function Ze(e2) {
  Is.call(this), this._block = _r.allocUnsafe(e2), this._blockSize = e2, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = false;
}
Tu(Ze, Is);
Ze.prototype._transform = function(e2, t3, r4) {
  var n4 = null;
  try {
    this.update(e2, t3);
  } catch (i5) {
    n4 = i5;
  }
  r4(n4);
};
Ze.prototype._flush = function(e2) {
  var t3 = null;
  try {
    this.push(this.digest());
  } catch (r4) {
    t3 = r4;
  }
  e2(t3);
};
Ze.prototype.update = function(e2, t3) {
  if (Pu(e2, "Data"), this._finalized) throw new Error("Digest already called");
  _r.isBuffer(e2) || (e2 = _r.from(e2, t3));
  for (var r4 = this._block, n4 = 0; this._blockOffset + e2.length - n4 >= this._blockSize; ) {
    for (var i5 = this._blockOffset; i5 < this._blockSize; ) r4[i5++] = e2[n4++];
    this._update(), this._blockOffset = 0;
  }
  for (; n4 < e2.length; ) r4[this._blockOffset++] = e2[n4++];
  for (var a2 = 0, f = e2.length * 8; f > 0; ++a2)
    this._length[a2] += f, f = this._length[a2] / 4294967296 | 0, f > 0 && (this._length[a2] -= 4294967296 * f);
  return this;
};
Ze.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Ze.prototype.digest = function(e2) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = true;
  var t3 = this._digest();
  e2 !== void 0 && (t3 = t3.toString(e2)), this._block.fill(0), this._blockOffset = 0;
  for (var r4 = 0; r4 < 4; ++r4) this._length[r4] = 0;
  return t3;
};
Ze.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var As = Ze;
var Cu = ge;
var Rs = As;
var Lu = Ee.Buffer;
var ku = new Array(16);
function Ar() {
  Rs.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
Cu(Ar, Rs);
Ar.prototype._update = function() {
  for (var e2 = ku, t3 = 0; t3 < 16; ++t3) e2[t3] = this._block.readInt32LE(t3 * 4);
  var r4 = this._a, n4 = this._b, i5 = this._c, a2 = this._d;
  r4 = de(r4, n4, i5, a2, e2[0], 3614090360, 7), a2 = de(a2, r4, n4, i5, e2[1], 3905402710, 12), i5 = de(i5, a2, r4, n4, e2[2], 606105819, 17), n4 = de(n4, i5, a2, r4, e2[3], 3250441966, 22), r4 = de(r4, n4, i5, a2, e2[4], 4118548399, 7), a2 = de(a2, r4, n4, i5, e2[5], 1200080426, 12), i5 = de(i5, a2, r4, n4, e2[6], 2821735955, 17), n4 = de(n4, i5, a2, r4, e2[7], 4249261313, 22), r4 = de(r4, n4, i5, a2, e2[8], 1770035416, 7), a2 = de(a2, r4, n4, i5, e2[9], 2336552879, 12), i5 = de(i5, a2, r4, n4, e2[10], 4294925233, 17), n4 = de(n4, i5, a2, r4, e2[11], 2304563134, 22), r4 = de(r4, n4, i5, a2, e2[12], 1804603682, 7), a2 = de(a2, r4, n4, i5, e2[13], 4254626195, 12), i5 = de(i5, a2, r4, n4, e2[14], 2792965006, 17), n4 = de(n4, i5, a2, r4, e2[15], 1236535329, 22), r4 = pe(r4, n4, i5, a2, e2[1], 4129170786, 5), a2 = pe(a2, r4, n4, i5, e2[6], 3225465664, 9), i5 = pe(i5, a2, r4, n4, e2[11], 643717713, 14), n4 = pe(n4, i5, a2, r4, e2[0], 3921069994, 20), r4 = pe(r4, n4, i5, a2, e2[5], 3593408605, 5), a2 = pe(a2, r4, n4, i5, e2[10], 38016083, 9), i5 = pe(i5, a2, r4, n4, e2[15], 3634488961, 14), n4 = pe(n4, i5, a2, r4, e2[4], 3889429448, 20), r4 = pe(r4, n4, i5, a2, e2[9], 568446438, 5), a2 = pe(a2, r4, n4, i5, e2[14], 3275163606, 9), i5 = pe(i5, a2, r4, n4, e2[3], 4107603335, 14), n4 = pe(n4, i5, a2, r4, e2[8], 1163531501, 20), r4 = pe(r4, n4, i5, a2, e2[13], 2850285829, 5), a2 = pe(a2, r4, n4, i5, e2[2], 4243563512, 9), i5 = pe(i5, a2, r4, n4, e2[7], 1735328473, 14), n4 = pe(n4, i5, a2, r4, e2[12], 2368359562, 20), r4 = be(r4, n4, i5, a2, e2[5], 4294588738, 4), a2 = be(a2, r4, n4, i5, e2[8], 2272392833, 11), i5 = be(i5, a2, r4, n4, e2[11], 1839030562, 16), n4 = be(n4, i5, a2, r4, e2[14], 4259657740, 23), r4 = be(r4, n4, i5, a2, e2[1], 2763975236, 4), a2 = be(a2, r4, n4, i5, e2[4], 1272893353, 11), i5 = be(i5, a2, r4, n4, e2[7], 4139469664, 16), n4 = be(n4, i5, a2, r4, e2[10], 3200236656, 23), r4 = be(r4, n4, i5, a2, e2[13], 681279174, 4), a2 = be(a2, r4, n4, i5, e2[0], 3936430074, 11), i5 = be(i5, a2, r4, n4, e2[3], 3572445317, 16), n4 = be(n4, i5, a2, r4, e2[6], 76029189, 23), r4 = be(r4, n4, i5, a2, e2[9], 3654602809, 4), a2 = be(a2, r4, n4, i5, e2[12], 3873151461, 11), i5 = be(i5, a2, r4, n4, e2[15], 530742520, 16), n4 = be(n4, i5, a2, r4, e2[2], 3299628645, 23), r4 = ye(r4, n4, i5, a2, e2[0], 4096336452, 6), a2 = ye(a2, r4, n4, i5, e2[7], 1126891415, 10), i5 = ye(i5, a2, r4, n4, e2[14], 2878612391, 15), n4 = ye(n4, i5, a2, r4, e2[5], 4237533241, 21), r4 = ye(r4, n4, i5, a2, e2[12], 1700485571, 6), a2 = ye(a2, r4, n4, i5, e2[3], 2399980690, 10), i5 = ye(i5, a2, r4, n4, e2[10], 4293915773, 15), n4 = ye(n4, i5, a2, r4, e2[1], 2240044497, 21), r4 = ye(r4, n4, i5, a2, e2[8], 1873313359, 6), a2 = ye(a2, r4, n4, i5, e2[15], 4264355552, 10), i5 = ye(i5, a2, r4, n4, e2[6], 2734768916, 15), n4 = ye(n4, i5, a2, r4, e2[13], 1309151649, 21), r4 = ye(r4, n4, i5, a2, e2[4], 4149444226, 6), a2 = ye(a2, r4, n4, i5, e2[11], 3174756917, 10), i5 = ye(i5, a2, r4, n4, e2[2], 718787259, 15), n4 = ye(n4, i5, a2, r4, e2[9], 3951481745, 21), this._a = this._a + r4 | 0, this._b = this._b + n4 | 0, this._c = this._c + i5 | 0, this._d = this._d + a2 | 0;
};
Ar.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e2 = Lu.allocUnsafe(16);
  return e2.writeInt32LE(this._a, 0), e2.writeInt32LE(this._b, 4), e2.writeInt32LE(this._c, 8), e2.writeInt32LE(this._d, 12), e2;
};
function Rr(e2, t3) {
  return e2 << t3 | e2 >>> 32 - t3;
}
function de(e2, t3, r4, n4, i5, a2, f) {
  return Rr(e2 + (t3 & r4 | ~t3 & n4) + i5 + a2 | 0, f) + t3 | 0;
}
function pe(e2, t3, r4, n4, i5, a2, f) {
  return Rr(e2 + (t3 & n4 | r4 & ~n4) + i5 + a2 | 0, f) + t3 | 0;
}
function be(e2, t3, r4, n4, i5, a2, f) {
  return Rr(e2 + (t3 ^ r4 ^ n4) + i5 + a2 | 0, f) + t3 | 0;
}
function ye(e2, t3, r4, n4, i5, a2, f) {
  return Rr(e2 + (r4 ^ (t3 | ~n4)) + i5 + a2 | 0, f) + t3 | 0;
}
var Fu = Ar;
var Xr = Rt.Buffer;
var Ou = ge;
var Ts = As;
var Uu = new Array(16);
var Mt = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
];
var Dt = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
];
var $t = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
];
var Ht = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
];
var zt = [0, 1518500249, 1859775393, 2400959708, 2840853838];
var jt = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function Tr() {
  Ts.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
Ou(Tr, Ts);
Tr.prototype._update = function() {
  for (var e2 = Uu, t3 = 0; t3 < 16; ++t3) e2[t3] = this._block.readInt32LE(t3 * 4);
  for (var r4 = this._a | 0, n4 = this._b | 0, i5 = this._c | 0, a2 = this._d | 0, f = this._e | 0, u2 = this._a | 0, l = this._b | 0, b2 = this._c | 0, g = this._d | 0, m = this._e | 0, v = 0; v < 80; v += 1) {
    var I, B;
    v < 16 ? (I = pi(r4, n4, i5, a2, f, e2[Mt[v]], zt[0], $t[v]), B = mi(u2, l, b2, g, m, e2[Dt[v]], jt[0], Ht[v])) : v < 32 ? (I = bi(r4, n4, i5, a2, f, e2[Mt[v]], zt[1], $t[v]), B = gi(u2, l, b2, g, m, e2[Dt[v]], jt[1], Ht[v])) : v < 48 ? (I = yi(r4, n4, i5, a2, f, e2[Mt[v]], zt[2], $t[v]), B = yi(u2, l, b2, g, m, e2[Dt[v]], jt[2], Ht[v])) : v < 64 ? (I = gi(r4, n4, i5, a2, f, e2[Mt[v]], zt[3], $t[v]), B = bi(u2, l, b2, g, m, e2[Dt[v]], jt[3], Ht[v])) : (I = mi(r4, n4, i5, a2, f, e2[Mt[v]], zt[4], $t[v]), B = pi(u2, l, b2, g, m, e2[Dt[v]], jt[4], Ht[v])), r4 = f, f = a2, a2 = ct(i5, 10), i5 = n4, n4 = I, u2 = m, m = g, g = ct(b2, 10), b2 = l, l = B;
  }
  var P = this._b + i5 + g | 0;
  this._b = this._c + a2 + m | 0, this._c = this._d + f + u2 | 0, this._d = this._e + r4 + l | 0, this._e = this._a + n4 + b2 | 0, this._a = P;
};
Tr.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e2 = Xr.alloc ? Xr.alloc(20) : new Xr(20);
  return e2.writeInt32LE(this._a, 0), e2.writeInt32LE(this._b, 4), e2.writeInt32LE(this._c, 8), e2.writeInt32LE(this._d, 12), e2.writeInt32LE(this._e, 16), e2;
};
function ct(e2, t3) {
  return e2 << t3 | e2 >>> 32 - t3;
}
function pi(e2, t3, r4, n4, i5, a2, f, u2) {
  return ct(e2 + (t3 ^ r4 ^ n4) + a2 + f | 0, u2) + i5 | 0;
}
function bi(e2, t3, r4, n4, i5, a2, f, u2) {
  return ct(e2 + (t3 & r4 | ~t3 & n4) + a2 + f | 0, u2) + i5 | 0;
}
function yi(e2, t3, r4, n4, i5, a2, f, u2) {
  return ct(e2 + ((t3 | ~r4) ^ n4) + a2 + f | 0, u2) + i5 | 0;
}
function gi(e2, t3, r4, n4, i5, a2, f, u2) {
  return ct(e2 + (t3 & n4 | r4 & ~n4) + a2 + f | 0, u2) + i5 | 0;
}
function mi(e2, t3, r4, n4, i5, a2, f, u2) {
  return ct(e2 + (t3 ^ (r4 | ~n4)) + a2 + f | 0, u2) + i5 | 0;
}
var Nu = Tr;
var Ps = { exports: {} };
var Cs = Ee.Buffer;
function Pr(e2, t3) {
  this._block = Cs.alloc(e2), this._finalSize = t3, this._blockSize = e2, this._len = 0;
}
Pr.prototype.update = function(e2, t3) {
  typeof e2 == "string" && (t3 = t3 || "utf8", e2 = Cs.from(e2, t3));
  for (var r4 = this._block, n4 = this._blockSize, i5 = e2.length, a2 = this._len, f = 0; f < i5; ) {
    for (var u2 = a2 % n4, l = Math.min(i5 - f, n4 - u2), b2 = 0; b2 < l; b2++)
      r4[u2 + b2] = e2[f + b2];
    a2 += l, f += l, a2 % n4 === 0 && this._update(r4);
  }
  return this._len += i5, this;
};
Pr.prototype.digest = function(e2) {
  var t3 = this._len % this._blockSize;
  this._block[t3] = 128, this._block.fill(0, t3 + 1), t3 >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var r4 = this._len * 8;
  if (r4 <= 4294967295)
    this._block.writeUInt32BE(r4, this._blockSize - 4);
  else {
    var n4 = (r4 & 4294967295) >>> 0, i5 = (r4 - n4) / 4294967296;
    this._block.writeUInt32BE(i5, this._blockSize - 8), this._block.writeUInt32BE(n4, this._blockSize - 4);
  }
  this._update(this._block);
  var a2 = this._hash();
  return e2 ? a2.toString(e2) : a2;
};
Pr.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Tt = Pr;
var Mu = ge;
var Ls = Tt;
var Du = Ee.Buffer;
var $u = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
];
var Hu = new Array(80);
function Qt() {
  this.init(), this._w = Hu, Ls.call(this, 64, 56);
}
Mu(Qt, Ls);
Qt.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function zu(e2) {
  return e2 << 5 | e2 >>> 27;
}
function ju(e2) {
  return e2 << 30 | e2 >>> 2;
}
function Gu(e2, t3, r4, n4) {
  return e2 === 0 ? t3 & r4 | ~t3 & n4 : e2 === 2 ? t3 & r4 | t3 & n4 | r4 & n4 : t3 ^ r4 ^ n4;
}
Qt.prototype._update = function(e2) {
  for (var t3 = this._w, r4 = this._a | 0, n4 = this._b | 0, i5 = this._c | 0, a2 = this._d | 0, f = this._e | 0, u2 = 0; u2 < 16; ++u2) t3[u2] = e2.readInt32BE(u2 * 4);
  for (; u2 < 80; ++u2) t3[u2] = t3[u2 - 3] ^ t3[u2 - 8] ^ t3[u2 - 14] ^ t3[u2 - 16];
  for (var l = 0; l < 80; ++l) {
    var b2 = ~~(l / 20), g = zu(r4) + Gu(b2, n4, i5, a2) + f + t3[l] + $u[b2] | 0;
    f = a2, a2 = i5, i5 = ju(n4), n4 = r4, r4 = g;
  }
  this._a = r4 + this._a | 0, this._b = n4 + this._b | 0, this._c = i5 + this._c | 0, this._d = a2 + this._d | 0, this._e = f + this._e | 0;
};
Qt.prototype._hash = function() {
  var e2 = Du.allocUnsafe(20);
  return e2.writeInt32BE(this._a | 0, 0), e2.writeInt32BE(this._b | 0, 4), e2.writeInt32BE(this._c | 0, 8), e2.writeInt32BE(this._d | 0, 12), e2.writeInt32BE(this._e | 0, 16), e2;
};
var Wu = Qt;
var qu = ge;
var ks = Tt;
var Vu = Ee.Buffer;
var Ku = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
];
var Yu = new Array(80);
function Zt() {
  this.init(), this._w = Yu, ks.call(this, 64, 56);
}
qu(Zt, ks);
Zt.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Ju(e2) {
  return e2 << 1 | e2 >>> 31;
}
function Xu(e2) {
  return e2 << 5 | e2 >>> 27;
}
function Qu(e2) {
  return e2 << 30 | e2 >>> 2;
}
function Zu(e2, t3, r4, n4) {
  return e2 === 0 ? t3 & r4 | ~t3 & n4 : e2 === 2 ? t3 & r4 | t3 & n4 | r4 & n4 : t3 ^ r4 ^ n4;
}
Zt.prototype._update = function(e2) {
  for (var t3 = this._w, r4 = this._a | 0, n4 = this._b | 0, i5 = this._c | 0, a2 = this._d | 0, f = this._e | 0, u2 = 0; u2 < 16; ++u2) t3[u2] = e2.readInt32BE(u2 * 4);
  for (; u2 < 80; ++u2) t3[u2] = Ju(t3[u2 - 3] ^ t3[u2 - 8] ^ t3[u2 - 14] ^ t3[u2 - 16]);
  for (var l = 0; l < 80; ++l) {
    var b2 = ~~(l / 20), g = Xu(r4) + Zu(b2, n4, i5, a2) + f + t3[l] + Ku[b2] | 0;
    f = a2, a2 = i5, i5 = Qu(n4), n4 = r4, r4 = g;
  }
  this._a = r4 + this._a | 0, this._b = n4 + this._b | 0, this._c = i5 + this._c | 0, this._d = a2 + this._d | 0, this._e = f + this._e | 0;
};
Zt.prototype._hash = function() {
  var e2 = Vu.allocUnsafe(20);
  return e2.writeInt32BE(this._a | 0, 0), e2.writeInt32BE(this._b | 0, 4), e2.writeInt32BE(this._c | 0, 8), e2.writeInt32BE(this._d | 0, 12), e2.writeInt32BE(this._e | 0, 16), e2;
};
var ec = Zt;
var tc = ge;
var Fs = Tt;
var rc = Ee.Buffer;
var nc = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
var ic = new Array(64);
function er() {
  this.init(), this._w = ic, Fs.call(this, 64, 56);
}
tc(er, Fs);
er.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function sc(e2, t3, r4) {
  return r4 ^ e2 & (t3 ^ r4);
}
function oc(e2, t3, r4) {
  return e2 & t3 | r4 & (e2 | t3);
}
function ac(e2) {
  return (e2 >>> 2 | e2 << 30) ^ (e2 >>> 13 | e2 << 19) ^ (e2 >>> 22 | e2 << 10);
}
function fc(e2) {
  return (e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7);
}
function uc(e2) {
  return (e2 >>> 7 | e2 << 25) ^ (e2 >>> 18 | e2 << 14) ^ e2 >>> 3;
}
function cc(e2) {
  return (e2 >>> 17 | e2 << 15) ^ (e2 >>> 19 | e2 << 13) ^ e2 >>> 10;
}
er.prototype._update = function(e2) {
  for (var t3 = this._w, r4 = this._a | 0, n4 = this._b | 0, i5 = this._c | 0, a2 = this._d | 0, f = this._e | 0, u2 = this._f | 0, l = this._g | 0, b2 = this._h | 0, g = 0; g < 16; ++g) t3[g] = e2.readInt32BE(g * 4);
  for (; g < 64; ++g) t3[g] = cc(t3[g - 2]) + t3[g - 7] + uc(t3[g - 15]) + t3[g - 16] | 0;
  for (var m = 0; m < 64; ++m) {
    var v = b2 + fc(f) + sc(f, u2, l) + nc[m] + t3[m] | 0, I = ac(r4) + oc(r4, n4, i5) | 0;
    b2 = l, l = u2, u2 = f, f = a2 + v | 0, a2 = i5, i5 = n4, n4 = r4, r4 = v + I | 0;
  }
  this._a = r4 + this._a | 0, this._b = n4 + this._b | 0, this._c = i5 + this._c | 0, this._d = a2 + this._d | 0, this._e = f + this._e | 0, this._f = u2 + this._f | 0, this._g = l + this._g | 0, this._h = b2 + this._h | 0;
};
er.prototype._hash = function() {
  var e2 = rc.allocUnsafe(32);
  return e2.writeInt32BE(this._a, 0), e2.writeInt32BE(this._b, 4), e2.writeInt32BE(this._c, 8), e2.writeInt32BE(this._d, 12), e2.writeInt32BE(this._e, 16), e2.writeInt32BE(this._f, 20), e2.writeInt32BE(this._g, 24), e2.writeInt32BE(this._h, 28), e2;
};
var Os = er;
var lc = ge;
var hc = Os;
var dc = Tt;
var pc = Ee.Buffer;
var bc = new Array(64);
function Cr() {
  this.init(), this._w = bc, dc.call(this, 64, 56);
}
lc(Cr, hc);
Cr.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Cr.prototype._hash = function() {
  var e2 = pc.allocUnsafe(28);
  return e2.writeInt32BE(this._a, 0), e2.writeInt32BE(this._b, 4), e2.writeInt32BE(this._c, 8), e2.writeInt32BE(this._d, 12), e2.writeInt32BE(this._e, 16), e2.writeInt32BE(this._f, 20), e2.writeInt32BE(this._g, 24), e2;
};
var yc = Cr;
var gc = ge;
var Us = Tt;
var mc = Ee.Buffer;
var _i = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
var _c = new Array(160);
function tr() {
  this.init(), this._w = _c, Us.call(this, 128, 112);
}
gc(tr, Us);
tr.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function wi(e2, t3, r4) {
  return r4 ^ e2 & (t3 ^ r4);
}
function xi(e2, t3, r4) {
  return e2 & t3 | r4 & (e2 | t3);
}
function vi(e2, t3) {
  return (e2 >>> 28 | t3 << 4) ^ (t3 >>> 2 | e2 << 30) ^ (t3 >>> 7 | e2 << 25);
}
function Ei(e2, t3) {
  return (e2 >>> 14 | t3 << 18) ^ (e2 >>> 18 | t3 << 14) ^ (t3 >>> 9 | e2 << 23);
}
function wc(e2, t3) {
  return (e2 >>> 1 | t3 << 31) ^ (e2 >>> 8 | t3 << 24) ^ e2 >>> 7;
}
function xc(e2, t3) {
  return (e2 >>> 1 | t3 << 31) ^ (e2 >>> 8 | t3 << 24) ^ (e2 >>> 7 | t3 << 25);
}
function vc(e2, t3) {
  return (e2 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e2 << 3) ^ e2 >>> 6;
}
function Ec(e2, t3) {
  return (e2 >>> 19 | t3 << 13) ^ (t3 >>> 29 | e2 << 3) ^ (e2 >>> 6 | t3 << 26);
}
function ce(e2, t3) {
  return e2 >>> 0 < t3 >>> 0 ? 1 : 0;
}
tr.prototype._update = function(e2) {
  for (var t3 = this._w, r4 = this._ah | 0, n4 = this._bh | 0, i5 = this._ch | 0, a2 = this._dh | 0, f = this._eh | 0, u2 = this._fh | 0, l = this._gh | 0, b2 = this._hh | 0, g = this._al | 0, m = this._bl | 0, v = this._cl | 0, I = this._dl | 0, B = this._el | 0, P = this._fl | 0, T = this._gl | 0, C2 = this._hl | 0, F = 0; F < 32; F += 2)
    t3[F] = e2.readInt32BE(F * 4), t3[F + 1] = e2.readInt32BE(F * 4 + 4);
  for (; F < 160; F += 2) {
    var k2 = t3[F - 30], L = t3[F - 15 * 2 + 1], O = wc(k2, L), S = xc(L, k2);
    k2 = t3[F - 2 * 2], L = t3[F - 2 * 2 + 1];
    var z = vc(k2, L), M = Ec(L, k2), $ = t3[F - 7 * 2], se = t3[F - 7 * 2 + 1], Te = t3[F - 16 * 2], je = t3[F - 16 * 2 + 1], ae = S + se | 0, xe = O + $ + ce(ae, S) | 0;
    ae = ae + M | 0, xe = xe + z + ce(ae, M) | 0, ae = ae + je | 0, xe = xe + Te + ce(ae, je) | 0, t3[F] = xe, t3[F + 1] = ae;
  }
  for (var ve = 0; ve < 160; ve += 2) {
    xe = t3[ve], ae = t3[ve + 1];
    var et = xi(r4, n4, i5), Pe = xi(g, m, v), Ge = vi(r4, g), Ce = vi(g, r4), We = Ei(f, B), Q = Ei(B, f), oe = _i[ve], Be = _i[ve + 1], qe = wi(f, u2, l), Ne = wi(B, P, T), w2 = C2 + Q | 0, _ = b2 + We + ce(w2, C2) | 0;
    w2 = w2 + Ne | 0, _ = _ + qe + ce(w2, Ne) | 0, w2 = w2 + Be | 0, _ = _ + oe + ce(w2, Be) | 0, w2 = w2 + ae | 0, _ = _ + xe + ce(w2, ae) | 0;
    var R2 = Ce + Pe | 0, D = Ge + et + ce(R2, Ce) | 0;
    b2 = l, C2 = T, l = u2, T = P, u2 = f, P = B, B = I + w2 | 0, f = a2 + _ + ce(B, I) | 0, a2 = i5, I = v, i5 = n4, v = m, n4 = r4, m = g, g = w2 + R2 | 0, r4 = _ + D + ce(g, w2) | 0;
  }
  this._al = this._al + g | 0, this._bl = this._bl + m | 0, this._cl = this._cl + v | 0, this._dl = this._dl + I | 0, this._el = this._el + B | 0, this._fl = this._fl + P | 0, this._gl = this._gl + T | 0, this._hl = this._hl + C2 | 0, this._ah = this._ah + r4 + ce(this._al, g) | 0, this._bh = this._bh + n4 + ce(this._bl, m) | 0, this._ch = this._ch + i5 + ce(this._cl, v) | 0, this._dh = this._dh + a2 + ce(this._dl, I) | 0, this._eh = this._eh + f + ce(this._el, B) | 0, this._fh = this._fh + u2 + ce(this._fl, P) | 0, this._gh = this._gh + l + ce(this._gl, T) | 0, this._hh = this._hh + b2 + ce(this._hl, C2) | 0;
};
tr.prototype._hash = function() {
  var e2 = mc.allocUnsafe(64);
  function t3(r4, n4, i5) {
    e2.writeInt32BE(r4, i5), e2.writeInt32BE(n4, i5 + 4);
  }
  return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), t3(this._gh, this._gl, 48), t3(this._hh, this._hl, 56), e2;
};
var Ns = tr;
var Bc = ge;
var Sc = Ns;
var Ic = Tt;
var Ac = Ee.Buffer;
var Rc = new Array(160);
function Lr() {
  this.init(), this._w = Rc, Ic.call(this, 128, 112);
}
Bc(Lr, Sc);
Lr.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Lr.prototype._hash = function() {
  var e2 = Ac.allocUnsafe(48);
  function t3(r4, n4, i5) {
    e2.writeInt32BE(r4, i5), e2.writeInt32BE(n4, i5 + 4);
  }
  return t3(this._ah, this._al, 0), t3(this._bh, this._bl, 8), t3(this._ch, this._cl, 16), t3(this._dh, this._dl, 24), t3(this._eh, this._el, 32), t3(this._fh, this._fl, 40), e2;
};
var Tc = Lr;
var ht = Ps.exports = function(t3) {
  t3 = t3.toLowerCase();
  var r4 = ht[t3];
  if (!r4) throw new Error(t3 + " is not supported (we accept pull requests)");
  return new r4();
};
ht.sha = Wu;
ht.sha1 = ec;
ht.sha224 = yc;
ht.sha256 = Os;
ht.sha384 = Tc;
ht.sha512 = Ns;
var Pc = Ps.exports;
var Ms = Ee.Buffer;
var Ds = An.Transform;
var Cc = mr.StringDecoder;
var Lc = ge;
function Le(e2) {
  Ds.call(this), this.hashMode = typeof e2 == "string", this.hashMode ? this[e2] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
Lc(Le, Ds);
Le.prototype.update = function(e2, t3, r4) {
  typeof e2 == "string" && (e2 = Ms.from(e2, t3));
  var n4 = this._update(e2);
  return this.hashMode ? this : (r4 && (n4 = this._toString(n4, r4)), n4);
};
Le.prototype.setAutoPadding = function() {
};
Le.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
Le.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
Le.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
Le.prototype._transform = function(e2, t3, r4) {
  var n4;
  try {
    this.hashMode ? this._update(e2) : this.push(this._update(e2));
  } catch (i5) {
    n4 = i5;
  } finally {
    r4(n4);
  }
};
Le.prototype._flush = function(e2) {
  var t3;
  try {
    this.push(this.__final());
  } catch (r4) {
    t3 = r4;
  }
  e2(t3);
};
Le.prototype._finalOrDigest = function(e2) {
  var t3 = this.__final() || Ms.alloc(0);
  return e2 && (t3 = this._toString(t3, e2, true)), t3;
};
Le.prototype._toString = function(e2, t3, r4) {
  if (this._decoder || (this._decoder = new Cc(t3), this._encoding = t3), this._encoding !== t3) throw new Error("can't switch encodings");
  var n4 = this._decoder.write(e2);
  return r4 && (n4 += this._decoder.end()), n4;
};
var kc = Le;
var Fc = ge;
var Oc = Fu;
var Uc = Nu;
var Nc = Pc;
var $s = kc;
function kr(e2) {
  $s.call(this, "digest"), this._hash = e2;
}
Fc(kr, $s);
kr.prototype._update = function(e2) {
  this._hash.update(e2);
};
kr.prototype._final = function() {
  return this._hash.digest();
};
var Mc = function(t3) {
  return t3 = t3.toLowerCase(), t3 === "md5" ? new Oc() : t3 === "rmd160" || t3 === "ripemd160" ? new Uc() : new kr(Nc(t3));
};
var ar = Ee.Buffer;
function Dc(e2) {
  if (e2.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t3 = new Uint8Array(256), r4 = 0; r4 < t3.length; r4++)
    t3[r4] = 255;
  for (var n4 = 0; n4 < e2.length; n4++) {
    var i5 = e2.charAt(n4), a2 = i5.charCodeAt(0);
    if (t3[a2] !== 255)
      throw new TypeError(i5 + " is ambiguous");
    t3[a2] = n4;
  }
  var f = e2.length, u2 = e2.charAt(0), l = Math.log(f) / Math.log(256), b2 = Math.log(256) / Math.log(f);
  function g(I) {
    if ((Array.isArray(I) || I instanceof Uint8Array) && (I = ar.from(I)), !ar.isBuffer(I))
      throw new TypeError("Expected Buffer");
    if (I.length === 0)
      return "";
    for (var B = 0, P = 0, T = 0, C2 = I.length; T !== C2 && I[T] === 0; )
      T++, B++;
    for (var F = (C2 - T) * b2 + 1 >>> 0, k2 = new Uint8Array(F); T !== C2; ) {
      for (var L = I[T], O = 0, S = F - 1; (L !== 0 || O < P) && S !== -1; S--, O++)
        L += 256 * k2[S] >>> 0, k2[S] = L % f >>> 0, L = L / f >>> 0;
      if (L !== 0)
        throw new Error("Non-zero carry");
      P = O, T++;
    }
    for (var z = F - P; z !== F && k2[z] === 0; )
      z++;
    for (var M = u2.repeat(B); z < F; ++z)
      M += e2.charAt(k2[z]);
    return M;
  }
  function m(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return ar.alloc(0);
    for (var B = 0, P = 0, T = 0; I[B] === u2; )
      P++, B++;
    for (var C2 = (I.length - B) * l + 1 >>> 0, F = new Uint8Array(C2); B < I.length; ) {
      var k2 = t3[I.charCodeAt(B)];
      if (k2 === 255)
        return;
      for (var L = 0, O = C2 - 1; (k2 !== 0 || L < T) && O !== -1; O--, L++)
        k2 += f * F[O] >>> 0, F[O] = k2 % 256 >>> 0, k2 = k2 / 256 >>> 0;
      if (k2 !== 0)
        throw new Error("Non-zero carry");
      T = L, B++;
    }
    for (var S = C2 - T; S !== C2 && F[S] === 0; )
      S++;
    var z = ar.allocUnsafe(P + (C2 - S));
    z.fill(0, 0, P);
    for (var M = P; S !== C2; )
      z[M++] = F[S++];
    return z;
  }
  function v(I) {
    var B = m(I);
    if (B)
      return B;
    throw new Error("Non-base" + f + " character");
  }
  return {
    encode: g,
    decodeUnsafe: m,
    decode: v
  };
}
var $c = Dc;
var Hc = $c;
var zc = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var jc = Hc(zc);
var Qr = jc;
var Gc = Ee.Buffer;
var Wc = function(e2) {
  function t3(a2) {
    var f = e2(a2);
    return Qr.encode(Gc.concat([
      a2,
      f
    ], a2.length + 4));
  }
  function r4(a2) {
    var f = a2.slice(0, -4), u2 = a2.slice(-4), l = e2(f);
    if (!(u2[0] ^ l[0] | u2[1] ^ l[1] | u2[2] ^ l[2] | u2[3] ^ l[3]))
      return f;
  }
  function n4(a2) {
    var f = Qr.decodeUnsafe(a2);
    if (f)
      return r4(f);
  }
  function i5(a2) {
    var f = Qr.decode(a2), u2 = r4(f);
    if (!u2) throw new Error("Invalid checksum");
    return u2;
  }
  return {
    encode: t3,
    decode: i5,
    decodeUnsafe: n4
  };
};
var Bi = Mc;
var qc = Wc;
function Vc(e2) {
  var t3 = Bi("sha256").update(e2).digest();
  return Bi("sha256").update(t3).digest();
}
var Kc = qc(Vc);
var un = Kc;
function Hs(e2, t3) {
  if (t3 !== void 0 && e2[0] !== t3) throw new Error("Invalid network version");
  if (e2.length === 33)
    return {
      version: e2[0],
      privateKey: e2.slice(1, 33),
      compressed: false
    };
  if (e2.length !== 34) throw new Error("Invalid WIF length");
  if (e2[33] !== 1) throw new Error("Invalid compression flag");
  return {
    version: e2[0],
    privateKey: e2.slice(1, 33),
    compressed: true
  };
}
function cn(e2, t3, r4) {
  var n4 = new Buffer(r4 ? 34 : 33);
  return n4.writeUInt8(e2, 0), t3.copy(n4, 1), r4 && (n4[33] = 1), n4;
}
function Yc(e2, t3) {
  return Hs(un.decode(e2), t3);
}
function Jc(e2, t3, r4) {
  return typeof e2 == "number" ? un.encode(cn(e2, t3, r4)) : un.encode(
    cn(
      e2.version,
      e2.privateKey,
      e2.compressed
    )
  );
}
var Xc = {
  decode: Yc,
  decodeRaw: Hs,
  encode: Jc,
  encodeRaw: cn
};
var Fr = {};
Object.defineProperty(Fr, "__esModule", { value: true });
Fr.testEcc = void 0;
var H = (e2) => Buffer.from(e2, "hex");
function Qc(e2) {
  J(
    e2.isPoint(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    !e2.isPoint(
      H("030000000000000000000000000000000000000000000000000000000000000005")
    )
  ), J(
    e2.isPrivate(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    e2.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), J(
    !e2.isPrivate(
      H("0000000000000000000000000000000000000000000000000000000000000000")
    )
  ), J(
    !e2.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
    )
  ), J(
    !e2.isPrivate(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
    )
  ), J(
    Buffer.from(
      e2.privateAdd(
        H("0000000000000000000000000000000000000000000000000000000000000001"),
        H("0000000000000000000000000000000000000000000000000000000000000000")
      )
    ).equals(
      H("0000000000000000000000000000000000000000000000000000000000000001")
    )
  ), J(
    e2.privateAdd(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
      H("0000000000000000000000000000000000000000000000000000000000000003")
    ) === null
  ), J(
    Buffer.from(
      e2.privateAdd(
        H("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
        H("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
      )
    ).equals(
      H("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
    )
  ), J(
    Buffer.from(
      e2.privateNegate(
        H("0000000000000000000000000000000000000000000000000000000000000001")
      )
    ).equals(
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    )
  ), J(
    Buffer.from(
      e2.privateNegate(
        H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
      )
    ).equals(
      H("0000000000000000000000000000000000000000000000000000000000000003")
    )
  ), J(
    Buffer.from(
      e2.privateNegate(
        H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      H("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
    )
  ), J(
    Buffer.from(
      e2.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        true
      )
    ).equals(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    Buffer.from(
      e2.pointCompress(
        H(
          "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
        ),
        false
      )
    ).equals(
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), J(
    Buffer.from(
      e2.pointCompress(
        H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        true
      )
    ).equals(
      H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
    )
  ), J(
    Buffer.from(
      e2.pointCompress(
        H("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        false
      )
    ).equals(
      H(
        "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
      )
    )
  ), J(
    Buffer.from(
      e2.pointFromScalar(
        H("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
      )
    ).equals(
      H("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
    )
  ), J(
    e2.xOnlyPointAddTweak(
      H("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
    ) === null
  );
  let t3 = e2.xOnlyPointAddTweak(
    H("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
    H("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
  );
  J(
    Buffer.from(t3.xOnlyPubkey).equals(
      H("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
    ) && t3.parity === 1
  ), t3 = e2.xOnlyPointAddTweak(
    H("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
    H("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
  ), J(
    Buffer.from(t3.xOnlyPubkey).equals(
      H("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
    ) && t3.parity === 0
  ), J(
    Buffer.from(
      e2.sign(
        H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
        H("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
      )
    ).equals(
      H(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), J(
    e2.verify(
      H("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
      H("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
      H(
        "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
      )
    )
  ), e2.signSchnorr && J(
    Buffer.from(
      e2.signSchnorr(
        H("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
        H("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
        H("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
      )
    ).equals(
      H(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  ), e2.verifySchnorr && J(
    e2.verifySchnorr(
      H("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
      H("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
      H(
        "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
      )
    )
  );
}
Fr.testEcc = Qc;
function J(e2) {
  if (!e2) throw new Error("ecc library invalid");
}
Object.defineProperty(Et, "__esModule", { value: true });
Et.ECPairFactory = Et.networks = void 0;
var ln = Bt;
Et.networks = ln;
var _e = es;
var Zc = If;
var Si = Xc;
var el = Fr;
var Zr = _e.typeforce.maybe(
  _e.typeforce.compile({
    compressed: _e.maybe(_e.Boolean),
    network: _e.maybe(_e.Network)
  })
);
var tl = (e2) => e2.length === 32 ? e2 : e2.slice(1, 33);
function rl(e2) {
  (0, el.testEcc)(e2);
  function t3(u2) {
    return e2.isPoint(u2);
  }
  function r4(u2, l) {
    if (_e.typeforce(_e.Buffer256bit, u2), !e2.isPrivate(u2))
      throw new TypeError("Private key not in range [1, n)");
    return _e.typeforce(Zr, l), new f(u2, void 0, l);
  }
  function n4(u2, l) {
    return _e.typeforce(e2.isPoint, u2), _e.typeforce(Zr, l), new f(void 0, u2, l);
  }
  function i5(u2, l) {
    const b2 = Si.decode(u2), g = b2.version;
    if (_e.Array(l)) {
      if (l = l.filter((m) => g === m.wif).pop(), !l) throw new Error("Unknown network version");
    } else if (l = l || ln.bitcoin, g !== l.wif) throw new Error("Invalid network version");
    return r4(b2.privateKey, {
      compressed: b2.compressed,
      network: l
    });
  }
  function a2(u2) {
    _e.typeforce(Zr, u2), u2 === void 0 && (u2 = {});
    const l = u2.rng || Zc;
    let b2;
    do
      b2 = l(32), _e.typeforce(_e.Buffer256bit, b2);
    while (!e2.isPrivate(b2));
    return r4(b2, u2);
  }
  class f {
    constructor(l, b2, g) {
      bt(this, "__D");
      bt(this, "__Q");
      bt(this, "compressed");
      bt(this, "network");
      bt(this, "lowR");
      this.__D = l, this.__Q = b2, this.lowR = false, g === void 0 && (g = {}), this.compressed = g.compressed === void 0 ? true : g.compressed, this.network = g.network || ln.bitcoin, b2 !== void 0 && (this.__Q = Buffer.from(e2.pointCompress(b2, this.compressed)));
    }
    get privateKey() {
      return this.__D;
    }
    get publicKey() {
      if (!this.__Q) {
        const l = e2.pointFromScalar(this.__D, this.compressed);
        this.__Q = Buffer.from(l);
      }
      return this.__Q;
    }
    toWIF() {
      if (!this.__D) throw new Error("Missing private key");
      return Si.encode(this.network.wif, this.__D, this.compressed);
    }
    tweak(l) {
      return this.privateKey ? this.tweakFromPrivateKey(l) : this.tweakFromPublicKey(l);
    }
    sign(l, b2) {
      if (!this.__D) throw new Error("Missing private key");
      if (b2 === void 0 && (b2 = this.lowR), b2 === false)
        return Buffer.from(e2.sign(l, this.__D));
      {
        let g = e2.sign(l, this.__D);
        const m = Buffer.alloc(32, 0);
        let v = 0;
        for (; g[0] > 127; )
          v++, m.writeUIntLE(v, 0, 6), g = e2.sign(l, this.__D, m);
        return Buffer.from(g);
      }
    }
    signSchnorr(l) {
      if (!this.privateKey) throw new Error("Missing private key");
      if (!e2.signSchnorr)
        throw new Error("signSchnorr not supported by ecc library");
      return Buffer.from(e2.signSchnorr(l, this.privateKey));
    }
    verify(l, b2) {
      return e2.verify(l, this.publicKey, b2);
    }
    verifySchnorr(l, b2) {
      if (!e2.verifySchnorr)
        throw new Error("verifySchnorr not supported by ecc library");
      return e2.verifySchnorr(l, this.publicKey.subarray(1, 33), b2);
    }
    tweakFromPublicKey(l) {
      const b2 = tl(this.publicKey), g = e2.xOnlyPointAddTweak(b2, l);
      if (!g || g.xOnlyPubkey === null)
        throw new Error("Cannot tweak public key!");
      const m = Buffer.from([
        g.parity === 0 ? 2 : 3
      ]);
      return n4(
        Buffer.concat([m, g.xOnlyPubkey]),
        { network: this.network, compressed: this.compressed }
      );
    }
    tweakFromPrivateKey(l) {
      const g = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1 ? e2.privateNegate(this.privateKey) : this.privateKey, m = e2.privateAdd(g, l);
      if (!m) throw new Error("Invalid tweaked private key!");
      return r4(Buffer.from(m), {
        network: this.network,
        compressed: this.compressed
      });
    }
  }
  return {
    isPoint: t3,
    fromPrivateKey: r4,
    fromPublicKey: n4,
    fromWIF: i5,
    makeRandom: a2
  };
}
Et.ECPairFactory = rl;
(function(e2) {
  Object.defineProperty(e2, "__esModule", { value: true }), e2.networks = e2.ECPairFactory = e2.default = void 0;
  var t3 = Et;
  Object.defineProperty(e2, "default", {
    enumerable: true,
    get: function() {
      return t3.ECPairFactory;
    }
  }), Object.defineProperty(e2, "ECPairFactory", {
    enumerable: true,
    get: function() {
      return t3.ECPairFactory;
    }
  }), Object.defineProperty(e2, "networks", {
    enumerable: true,
    get: function() {
      return t3.networks;
    }
  });
})(Zi);
var nl = sf(Zi);
var hn = class _hn {
  constructor(t3) {
    this.privKey = t3;
  }
  static fromPrivKey(t3) {
    return new _hn(R(t3));
  }
  static async fromWalletClient(t3) {
    if (!t3.account) return b("No account found");
    try {
      const r4 = await t3.signTypedData({
        account: t3.account,
        types: {
          EIP712Domain: [
            { name: "name", type: "string" },
            { name: "version", type: "string" }
          ],
          Data: [
            { name: "Message", type: "string" },
            { name: "Version", type: "string" },
            { name: "Nonce", type: "uint256" }
          ]
        },
        domain: {
          name: "WBTC GARDEN",
          version: "1"
        },
        primaryType: "Data",
        message: {
          Message: "Initialize your account",
          Version: "1.0.2",
          Nonce: 1n
        }
      });
      return W(new _hn(R(sha256(r4))));
    } catch (r4) {
      return b("Failed to initialize: " + r4);
    }
  }
  getMasterPrivKey() {
    return this.privKey;
  }
  generateSecret(t3) {
    const r4 = this.signMessage(t3), n4 = sha256(o2(r4)), i5 = sha256(n4);
    return W({ secret: n4, secretHash: i5 });
  }
  signMessage(t3) {
    const r4 = nl(lib_exports), n4 = "Garden.fi" + t3.toString(), i5 = Buffer.from(n4, "utf8"), a2 = sha256(i5), f = Buffer.from(R(this.privKey), "hex");
    if (f.length !== 32)
      throw new Error("Invalid private key length. Expected 32 bytes.");
    return r4.fromPrivateKey(f).sign(Buffer.from(R(a2), "hex")).toString("hex");
  }
};
var _l = class {
  constructor(t3) {
    this.quoteUrl = new r2("/quote", t3);
  }
  async getQuote(t3, r4, n4 = false) {
    try {
      const i5 = this.quoteUrl.addSearchParams({
        order_pair: t3,
        amount: r4.toString(),
        exact_out: n4.toString()
      }), a2 = await k.get(i5);
      return a2.error ? b(a2.error) : a2.result ? W(a2.result) : b("GetQuote: Unexpected error, result is undefined");
    } catch (i5) {
      return b("GetQuote:", String(i5));
    }
  }
  async getAttestedQuote(t3) {
    try {
      const r4 = await k.post(this.quoteUrl.endpoint("/attested").toString(), {
        body: JSON.stringify(t3),
        headers: {
          "Content-Type": "application/json"
        }
      });
      return r4.error ? b(r4.error) : r4.result ? W(r4.result) : b("GetAttestedQuote: Unexpected error, result is undefined");
    } catch (r4) {
      return console.log("error :", r4), b("GetAttestedQuote:", String(r4));
    }
  }
  async getStrategies() {
    try {
      const t3 = await k.get(
        this.quoteUrl.endpoint("/strategies")
      );
      if (t3.error) return b(t3.error);
      if (!t3.result)
        return b("GetStrategies: Unexpected error, result is undefined");
      const r4 = {};
      for (const n4 of Object.values(t3.result)) {
        const i5 = Ka(
          n4.source_chain,
          n4.source_asset.asset,
          n4.dest_chain,
          n4.dest_asset.asset
        );
        r4[i5] = {
          id: n4.id,
          minAmount: n4.min_amount,
          maxAmount: n4.max_amount
        };
      }
      return W(r4);
    } catch (t3) {
      return b("GetStrategies:", String(t3));
    }
  }
};

export {
  en,
  le,
  qa,
  dl,
  Ka,
  pl,
  te,
  re,
  Xi,
  Kn,
  bl,
  Qi,
  pr,
  Ya,
  Xa,
  yl,
  gl,
  hn,
  _l
};
/*! Bundled license information:

@gardenfi/core/dist/index.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=chunk-WPTXHL6F.js.map
