import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_browser,
  require_browser2
} from "./chunk-7SINFEUH.js";
import {
  require_safe_buffer
} from "./chunk-5DQMGCJB.js";
import {
  dist_exports,
  init_dist
} from "./chunk-IL4DCKII.js";
import {
  lib_exports
} from "./chunk-6BCIRRQU.js";
import {
  AbiDecodingDataSizeTooSmallError,
  AbiDecodingZeroDataError,
  AbiEventNotFoundError,
  AbiEventSignatureEmptyTopicsError,
  AbiEventSignatureNotFoundError,
  BaseError,
  ChainMismatchError,
  ChainNotFoundError,
  ContractFunctionExecutionError,
  ContractFunctionRevertedError,
  ContractFunctionZeroDataError,
  DecodeLogDataMismatch,
  DecodeLogTopicsMismatch,
  InternalRpcError,
  InvalidInputRpcError,
  InvalidSerializableTransactionError,
  LruMap,
  PositionOutOfBoundsError,
  RawContractError,
  TransactionExecutionError,
  UnknownNodeError,
  assertRequest,
  bytesToHex,
  call,
  checksumAddress,
  concatHex,
  createCursor,
  decodeAbiParameters,
  decodeFunctionResult,
  defineFormatter,
  encodeAbiParameters,
  encodeFunctionData,
  extract,
  formatAbiItem,
  formatEther,
  formatGwei,
  formatTransactionRequest,
  getAbiItem,
  getNodeError,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  isAddressEqual,
  isHex,
  keccak256,
  maxUint256,
  numberToHex,
  parseAccount,
  prettyPrint,
  serializeStateOverride,
  size,
  stringify,
  toBytes,
  toEventSelector,
  toHex
} from "./chunk-YMACZOKO.js";
import {
  E,
  R,
  _,
  d,
  k
} from "./chunk-64BDWLZ5.js";
import {
  sha256
} from "./chunk-JZX67L7D.js";
import {
  parseAbiParameters
} from "./chunk-YUGJFHN2.js";
import {
  __commonJS,
  __export,
  __toCommonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-HKR3LW4X.js";

// node_modules/bip39/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number2(n13) {
      if (!Number.isSafeInteger(n13) || n13 < 0)
        throw new Error(`positive integer expected, not ${n13}`);
    }
    exports.number = number2;
    function bool(b10) {
      if (typeof b10 !== "boolean")
        throw new Error(`boolean expected, not ${b10}`);
    }
    exports.bool = bool;
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    function bytes(b10, ...lengths) {
      if (!isBytes2(b10))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b10.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b10.length}`);
    }
    exports.bytes = bytes;
    function hash(h11) {
      if (typeof h11 !== "function" || typeof h11.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(h11.outputLen);
      number2(h11.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number: number2, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/bip39/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/bip39/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert();
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u82;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n13) => n13 : (n13) => (0, exports.byteSwap)(n13);
    function byteSwap32(arr) {
      for (let i18 = 0; i18 < arr.length; i18++) {
        arr[i18] = (0, exports.byteSwap)(arr[i18]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_10, i18) => i18.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i18 = 0; i18 < bytes.length; i18++) {
        hex += hexes[bytes[i18]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes2;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i18 = 0; i18 < iters; i18++) {
        cb(i18);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i18 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        (0, _assert_js_1.bytes)(a24);
        sum += a24.length;
      }
      const res = new Uint8Array(sum);
      for (let i18 = 0, pad2 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        res.set(a24, pad2);
        pad2 += a24.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes2;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/bip39/node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h11 = isLE ? 4 : 0;
      const l23 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h11, wh, isLE);
      view.setUint32(byteOffset + l23, wl, isLE);
    }
    var Chi = (a24, b10, c10) => a24 & b10 ^ ~a24 & c10;
    exports.Chi = Chi;
    var Maj = (a24, b10, c10) => a24 & b10 ^ a24 & c10 ^ b10 & c10;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i18 = pos; i18 < blockLen; i18++)
          buffer[i18] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i18 = 0; i18 < outLen; i18++)
          oview.setUint32(4 * i18, state[i18], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/bip39/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        return [A13, B12, C7, D7, E14, F11, G6, H7];
      }
      // prettier-ignore
      set(A13, B12, C7, D7, E14, F11, G6, H7) {
        this.A = A13 | 0;
        this.B = B12 | 0;
        this.C = C7 | 0;
        this.D = D7 | 0;
        this.E = E14 | 0;
        this.F = F11 | 0;
        this.G = G6 | 0;
        this.H = H7 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          SHA256_W[i18] = view.getUint32(offset, false);
        for (let i18 = 16; i18 < 64; i18++) {
          const W15 = SHA256_W[i18 - 15];
          const W2 = SHA256_W[i18 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i18] = s1 + SHA256_W[i18 - 7] + s0 + SHA256_W[i18 - 16] | 0;
        }
        let { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        for (let i18 = 0; i18 < 64; i18++) {
          const sigma1 = (0, utils_js_1.rotr)(E14, 6) ^ (0, utils_js_1.rotr)(E14, 11) ^ (0, utils_js_1.rotr)(E14, 25);
          const T1 = H7 + sigma1 + (0, _md_js_1.Chi)(E14, F11, G6) + SHA256_K[i18] + SHA256_W[i18] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A13, 2) ^ (0, utils_js_1.rotr)(A13, 13) ^ (0, utils_js_1.rotr)(A13, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A13, B12, C7) | 0;
          H7 = G6;
          G6 = F11;
          F11 = E14;
          E14 = D7 + T1 | 0;
          D7 = C7;
          C7 = B12;
          B12 = A13;
          A13 = T1 + T22 | 0;
        }
        A13 = A13 + this.A | 0;
        B12 = B12 + this.B | 0;
        C7 = C7 + this.C | 0;
        D7 = D7 + this.D | 0;
        E14 = E14 + this.E | 0;
        F11 = F11 + this.F | 0;
        G6 = G6 + this.G | 0;
        H7 = H7 + this.H | 0;
        this.set(A13, B12, C7, D7, E14, F11, G6, H7);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/bip39/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n13, le = false) {
      if (le)
        return { h: Number(n13 & U32_MASK64), l: Number(n13 >> _32n & U32_MASK64) };
      return { h: Number(n13 >> _32n & U32_MASK64) | 0, l: Number(n13 & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i18 = 0; i18 < lst.length; i18++) {
        const { h: h11, l: l23 } = fromBig(lst[i18], le);
        [Ah[i18], Al[i18]] = [h11, l23];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig = (h11, l23) => BigInt(h11 >>> 0) << _32n | BigInt(l23 >>> 0);
    exports.toBig = toBig;
    var shrSH = (h11, _l, s15) => h11 >>> s15;
    exports.shrSH = shrSH;
    var shrSL = (h11, l23, s15) => h11 << 32 - s15 | l23 >>> s15;
    exports.shrSL = shrSL;
    var rotrSH = (h11, l23, s15) => h11 >>> s15 | l23 << 32 - s15;
    exports.rotrSH = rotrSH;
    var rotrSL = (h11, l23, s15) => h11 << 32 - s15 | l23 >>> s15;
    exports.rotrSL = rotrSL;
    var rotrBH = (h11, l23, s15) => h11 << 64 - s15 | l23 >>> s15 - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h11, l23, s15) => h11 >>> s15 - 32 | l23 << 64 - s15;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l23) => l23;
    exports.rotr32H = rotr32H;
    var rotr32L = (h11, _l) => h11;
    exports.rotr32L = rotr32L;
    var rotlSH = (h11, l23, s15) => h11 << s15 | l23 >>> 32 - s15;
    exports.rotlSH = rotlSH;
    var rotlSL = (h11, l23, s15) => l23 << s15 | h11 >>> 32 - s15;
    exports.rotlSL = rotlSL;
    var rotlBH = (h11, l23, s15) => l23 << s15 - 32 | h11 >>> 64 - s15;
    exports.rotlBH = rotlBH;
    var rotlBL = (h11, l23, s15) => h11 << s15 - 32 | l23 >>> 64 - s15;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l23 = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l23 / 2 ** 32 | 0) | 0, l: l23 | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split: split2,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/bip39/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _md_js_1 = require_md();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n13) => BigInt(n13))))();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_js_1.HashMD {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4) {
          SHA512_W_H[i18] = view.getUint32(offset);
          SHA512_W_L[i18] = view.getUint32(offset += 4);
        }
        for (let i18 = 16; i18 < 80; i18++) {
          const W15h = SHA512_W_H[i18 - 15] | 0;
          const W15l = SHA512_W_L[i18 - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i18 - 2] | 0;
          const W2l = SHA512_W_L[i18 - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i18 - 7], SHA512_W_L[i18 - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i18 - 7], SHA512_W_H[i18 - 16]);
          SHA512_W_H[i18] = SUMh | 0;
          SHA512_W_L[i18] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i18 = 0; i18 < 80; i18++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i18], SHA512_W_L[i18]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i18], SHA512_W_H[i18]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/bip39/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad2 = new Uint8Array(blockLen);
        pad2.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i18 = 0; i18 < pad2.length; i18++)
          pad2[i18] ^= 54;
        this.iHash.update(pad2);
        this.oHash = hash.create();
        for (let i18 = 0; i18 < pad2.length; i18++)
          pad2[i18] ^= 54 ^ 92;
        this.oHash.update(pad2);
        pad2.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/bip39/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/bip39/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0, _assert_js_1.hash)(hash);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c10, dkLen, asyncTick } = opts;
      (0, _assert_js_1.number)(c10);
      (0, _assert_js_1.number)(dkLen);
      (0, _assert_js_1.number)(asyncTick);
      if (c10 < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c10, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u22) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u22.fill(0);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c: c10, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u22 = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u22);
        Ti.set(u22.subarray(0, Ti.length));
        for (let ui = 1; ui < c10; ui++) {
          PRF._cloneInto(prfW).update(u22).digestInto(u22);
          for (let i18 = 0; i18 < Ti.length; i18++)
            Ti[i18] ^= u22[i18];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u22);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c: c10, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u22 = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u22);
        Ti.set(u22.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c10 - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u22).digestInto(u22);
          for (let i18 = 0; i18 < Ti.length; i18++)
            Ti[i18] ^= u22[i18];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u22);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/bip39/src/wordlists/czech.json
var require_czech = __commonJS({
  "node_modules/bip39/src/wordlists/czech.json"(exports, module) {
    module.exports = [
      "abdikace",
      "abeceda",
      "adresa",
      "agrese",
      "akce",
      "aktovka",
      "alej",
      "alkohol",
      "amputace",
      "ananas",
      "andulka",
      "anekdota",
      "anketa",
      "antika",
      "anulovat",
      "archa",
      "arogance",
      "asfalt",
      "asistent",
      "aspirace",
      "astma",
      "astronom",
      "atlas",
      "atletika",
      "atol",
      "autobus",
      "azyl",
      "babka",
      "bachor",
      "bacil",
      "baculka",
      "badatel",
      "bageta",
      "bagr",
      "bahno",
      "bakterie",
      "balada",
      "baletka",
      "balkon",
      "balonek",
      "balvan",
      "balza",
      "bambus",
      "bankomat",
      "barbar",
      "baret",
      "barman",
      "baroko",
      "barva",
      "baterka",
      "batoh",
      "bavlna",
      "bazalka",
      "bazilika",
      "bazuka",
      "bedna",
      "beran",
      "beseda",
      "bestie",
      "beton",
      "bezinka",
      "bezmoc",
      "beztak",
      "bicykl",
      "bidlo",
      "biftek",
      "bikiny",
      "bilance",
      "biograf",
      "biolog",
      "bitva",
      "bizon",
      "blahobyt",
      "blatouch",
      "blecha",
      "bledule",
      "blesk",
      "blikat",
      "blizna",
      "blokovat",
      "bloudit",
      "blud",
      "bobek",
      "bobr",
      "bodlina",
      "bodnout",
      "bohatost",
      "bojkot",
      "bojovat",
      "bokorys",
      "bolest",
      "borec",
      "borovice",
      "bota",
      "boubel",
      "bouchat",
      "bouda",
      "boule",
      "bourat",
      "boxer",
      "bradavka",
      "brambora",
      "branka",
      "bratr",
      "brepta",
      "briketa",
      "brko",
      "brloh",
      "bronz",
      "broskev",
      "brunetka",
      "brusinka",
      "brzda",
      "brzy",
      "bublina",
      "bubnovat",
      "buchta",
      "buditel",
      "budka",
      "budova",
      "bufet",
      "bujarost",
      "bukvice",
      "buldok",
      "bulva",
      "bunda",
      "bunkr",
      "burza",
      "butik",
      "buvol",
      "buzola",
      "bydlet",
      "bylina",
      "bytovka",
      "bzukot",
      "capart",
      "carevna",
      "cedr",
      "cedule",
      "cejch",
      "cejn",
      "cela",
      "celer",
      "celkem",
      "celnice",
      "cenina",
      "cennost",
      "cenovka",
      "centrum",
      "cenzor",
      "cestopis",
      "cetka",
      "chalupa",
      "chapadlo",
      "charita",
      "chata",
      "chechtat",
      "chemie",
      "chichot",
      "chirurg",
      "chlad",
      "chleba",
      "chlubit",
      "chmel",
      "chmura",
      "chobot",
      "chochol",
      "chodba",
      "cholera",
      "chomout",
      "chopit",
      "choroba",
      "chov",
      "chrapot",
      "chrlit",
      "chrt",
      "chrup",
      "chtivost",
      "chudina",
      "chutnat",
      "chvat",
      "chvilka",
      "chvost",
      "chyba",
      "chystat",
      "chytit",
      "cibule",
      "cigareta",
      "cihelna",
      "cihla",
      "cinkot",
      "cirkus",
      "cisterna",
      "citace",
      "citrus",
      "cizinec",
      "cizost",
      "clona",
      "cokoliv",
      "couvat",
      "ctitel",
      "ctnost",
      "cudnost",
      "cuketa",
      "cukr",
      "cupot",
      "cvaknout",
      "cval",
      "cvik",
      "cvrkot",
      "cyklista",
      "daleko",
      "dareba",
      "datel",
      "datum",
      "dcera",
      "debata",
      "dechovka",
      "decibel",
      "deficit",
      "deflace",
      "dekl",
      "dekret",
      "demokrat",
      "deprese",
      "derby",
      "deska",
      "detektiv",
      "dikobraz",
      "diktovat",
      "dioda",
      "diplom",
      "disk",
      "displej",
      "divadlo",
      "divoch",
      "dlaha",
      "dlouho",
      "dluhopis",
      "dnes",
      "dobro",
      "dobytek",
      "docent",
      "dochutit",
      "dodnes",
      "dohled",
      "dohoda",
      "dohra",
      "dojem",
      "dojnice",
      "doklad",
      "dokola",
      "doktor",
      "dokument",
      "dolar",
      "doleva",
      "dolina",
      "doma",
      "dominant",
      "domluvit",
      "domov",
      "donutit",
      "dopad",
      "dopis",
      "doplnit",
      "doposud",
      "doprovod",
      "dopustit",
      "dorazit",
      "dorost",
      "dort",
      "dosah",
      "doslov",
      "dostatek",
      "dosud",
      "dosyta",
      "dotaz",
      "dotek",
      "dotknout",
      "doufat",
      "doutnat",
      "dovozce",
      "dozadu",
      "doznat",
      "dozorce",
      "drahota",
      "drak",
      "dramatik",
      "dravec",
      "draze",
      "drdol",
      "drobnost",
      "drogerie",
      "drozd",
      "drsnost",
      "drtit",
      "drzost",
      "duben",
      "duchovno",
      "dudek",
      "duha",
      "duhovka",
      "dusit",
      "dusno",
      "dutost",
      "dvojice",
      "dvorec",
      "dynamit",
      "ekolog",
      "ekonomie",
      "elektron",
      "elipsa",
      "email",
      "emise",
      "emoce",
      "empatie",
      "epizoda",
      "epocha",
      "epopej",
      "epos",
      "esej",
      "esence",
      "eskorta",
      "eskymo",
      "etiketa",
      "euforie",
      "evoluce",
      "exekuce",
      "exkurze",
      "expedice",
      "exploze",
      "export",
      "extrakt",
      "facka",
      "fajfka",
      "fakulta",
      "fanatik",
      "fantazie",
      "farmacie",
      "favorit",
      "fazole",
      "federace",
      "fejeton",
      "fenka",
      "fialka",
      "figurant",
      "filozof",
      "filtr",
      "finance",
      "finta",
      "fixace",
      "fjord",
      "flanel",
      "flirt",
      "flotila",
      "fond",
      "fosfor",
      "fotbal",
      "fotka",
      "foton",
      "frakce",
      "freska",
      "fronta",
      "fukar",
      "funkce",
      "fyzika",
      "galeje",
      "garant",
      "genetika",
      "geolog",
      "gilotina",
      "glazura",
      "glejt",
      "golem",
      "golfista",
      "gotika",
      "graf",
      "gramofon",
      "granule",
      "grep",
      "gril",
      "grog",
      "groteska",
      "guma",
      "hadice",
      "hadr",
      "hala",
      "halenka",
      "hanba",
      "hanopis",
      "harfa",
      "harpuna",
      "havran",
      "hebkost",
      "hejkal",
      "hejno",
      "hejtman",
      "hektar",
      "helma",
      "hematom",
      "herec",
      "herna",
      "heslo",
      "hezky",
      "historik",
      "hladovka",
      "hlasivky",
      "hlava",
      "hledat",
      "hlen",
      "hlodavec",
      "hloh",
      "hloupost",
      "hltat",
      "hlubina",
      "hluchota",
      "hmat",
      "hmota",
      "hmyz",
      "hnis",
      "hnojivo",
      "hnout",
      "hoblina",
      "hoboj",
      "hoch",
      "hodiny",
      "hodlat",
      "hodnota",
      "hodovat",
      "hojnost",
      "hokej",
      "holinka",
      "holka",
      "holub",
      "homole",
      "honitba",
      "honorace",
      "horal",
      "horda",
      "horizont",
      "horko",
      "horlivec",
      "hormon",
      "hornina",
      "horoskop",
      "horstvo",
      "hospoda",
      "hostina",
      "hotovost",
      "houba",
      "houf",
      "houpat",
      "houska",
      "hovor",
      "hradba",
      "hranice",
      "hravost",
      "hrazda",
      "hrbolek",
      "hrdina",
      "hrdlo",
      "hrdost",
      "hrnek",
      "hrobka",
      "hromada",
      "hrot",
      "hrouda",
      "hrozen",
      "hrstka",
      "hrubost",
      "hryzat",
      "hubenost",
      "hubnout",
      "hudba",
      "hukot",
      "humr",
      "husita",
      "hustota",
      "hvozd",
      "hybnost",
      "hydrant",
      "hygiena",
      "hymna",
      "hysterik",
      "idylka",
      "ihned",
      "ikona",
      "iluze",
      "imunita",
      "infekce",
      "inflace",
      "inkaso",
      "inovace",
      "inspekce",
      "internet",
      "invalida",
      "investor",
      "inzerce",
      "ironie",
      "jablko",
      "jachta",
      "jahoda",
      "jakmile",
      "jakost",
      "jalovec",
      "jantar",
      "jarmark",
      "jaro",
      "jasan",
      "jasno",
      "jatka",
      "javor",
      "jazyk",
      "jedinec",
      "jedle",
      "jednatel",
      "jehlan",
      "jekot",
      "jelen",
      "jelito",
      "jemnost",
      "jenom",
      "jepice",
      "jeseter",
      "jevit",
      "jezdec",
      "jezero",
      "jinak",
      "jindy",
      "jinoch",
      "jiskra",
      "jistota",
      "jitrnice",
      "jizva",
      "jmenovat",
      "jogurt",
      "jurta",
      "kabaret",
      "kabel",
      "kabinet",
      "kachna",
      "kadet",
      "kadidlo",
      "kahan",
      "kajak",
      "kajuta",
      "kakao",
      "kaktus",
      "kalamita",
      "kalhoty",
      "kalibr",
      "kalnost",
      "kamera",
      "kamkoliv",
      "kamna",
      "kanibal",
      "kanoe",
      "kantor",
      "kapalina",
      "kapela",
      "kapitola",
      "kapka",
      "kaple",
      "kapota",
      "kapr",
      "kapusta",
      "kapybara",
      "karamel",
      "karotka",
      "karton",
      "kasa",
      "katalog",
      "katedra",
      "kauce",
      "kauza",
      "kavalec",
      "kazajka",
      "kazeta",
      "kazivost",
      "kdekoliv",
      "kdesi",
      "kedluben",
      "kemp",
      "keramika",
      "kino",
      "klacek",
      "kladivo",
      "klam",
      "klapot",
      "klasika",
      "klaun",
      "klec",
      "klenba",
      "klepat",
      "klesnout",
      "klid",
      "klima",
      "klisna",
      "klobouk",
      "klokan",
      "klopa",
      "kloub",
      "klubovna",
      "klusat",
      "kluzkost",
      "kmen",
      "kmitat",
      "kmotr",
      "kniha",
      "knot",
      "koalice",
      "koberec",
      "kobka",
      "kobliha",
      "kobyla",
      "kocour",
      "kohout",
      "kojenec",
      "kokos",
      "koktejl",
      "kolaps",
      "koleda",
      "kolize",
      "kolo",
      "komando",
      "kometa",
      "komik",
      "komnata",
      "komora",
      "kompas",
      "komunita",
      "konat",
      "koncept",
      "kondice",
      "konec",
      "konfese",
      "kongres",
      "konina",
      "konkurs",
      "kontakt",
      "konzerva",
      "kopanec",
      "kopie",
      "kopnout",
      "koprovka",
      "korbel",
      "korektor",
      "kormidlo",
      "koroptev",
      "korpus",
      "koruna",
      "koryto",
      "korzet",
      "kosatec",
      "kostka",
      "kotel",
      "kotleta",
      "kotoul",
      "koukat",
      "koupelna",
      "kousek",
      "kouzlo",
      "kovboj",
      "koza",
      "kozoroh",
      "krabice",
      "krach",
      "krajina",
      "kralovat",
      "krasopis",
      "kravata",
      "kredit",
      "krejcar",
      "kresba",
      "kreveta",
      "kriket",
      "kritik",
      "krize",
      "krkavec",
      "krmelec",
      "krmivo",
      "krocan",
      "krok",
      "kronika",
      "kropit",
      "kroupa",
      "krovka",
      "krtek",
      "kruhadlo",
      "krupice",
      "krutost",
      "krvinka",
      "krychle",
      "krypta",
      "krystal",
      "kryt",
      "kudlanka",
      "kufr",
      "kujnost",
      "kukla",
      "kulajda",
      "kulich",
      "kulka",
      "kulomet",
      "kultura",
      "kuna",
      "kupodivu",
      "kurt",
      "kurzor",
      "kutil",
      "kvalita",
      "kvasinka",
      "kvestor",
      "kynolog",
      "kyselina",
      "kytara",
      "kytice",
      "kytka",
      "kytovec",
      "kyvadlo",
      "labrador",
      "lachtan",
      "ladnost",
      "laik",
      "lakomec",
      "lamela",
      "lampa",
      "lanovka",
      "lasice",
      "laso",
      "lastura",
      "latinka",
      "lavina",
      "lebka",
      "leckdy",
      "leden",
      "lednice",
      "ledovka",
      "ledvina",
      "legenda",
      "legie",
      "legrace",
      "lehce",
      "lehkost",
      "lehnout",
      "lektvar",
      "lenochod",
      "lentilka",
      "lepenka",
      "lepidlo",
      "letadlo",
      "letec",
      "letmo",
      "letokruh",
      "levhart",
      "levitace",
      "levobok",
      "libra",
      "lichotka",
      "lidojed",
      "lidskost",
      "lihovina",
      "lijavec",
      "lilek",
      "limetka",
      "linie",
      "linka",
      "linoleum",
      "listopad",
      "litina",
      "litovat",
      "lobista",
      "lodivod",
      "logika",
      "logoped",
      "lokalita",
      "loket",
      "lomcovat",
      "lopata",
      "lopuch",
      "lord",
      "losos",
      "lotr",
      "loudal",
      "louh",
      "louka",
      "louskat",
      "lovec",
      "lstivost",
      "lucerna",
      "lucifer",
      "lump",
      "lusk",
      "lustrace",
      "lvice",
      "lyra",
      "lyrika",
      "lysina",
      "madam",
      "madlo",
      "magistr",
      "mahagon",
      "majetek",
      "majitel",
      "majorita",
      "makak",
      "makovice",
      "makrela",
      "malba",
      "malina",
      "malovat",
      "malvice",
      "maminka",
      "mandle",
      "manko",
      "marnost",
      "masakr",
      "maskot",
      "masopust",
      "matice",
      "matrika",
      "maturita",
      "mazanec",
      "mazivo",
      "mazlit",
      "mazurka",
      "mdloba",
      "mechanik",
      "meditace",
      "medovina",
      "melasa",
      "meloun",
      "mentolka",
      "metla",
      "metoda",
      "metr",
      "mezera",
      "migrace",
      "mihnout",
      "mihule",
      "mikina",
      "mikrofon",
      "milenec",
      "milimetr",
      "milost",
      "mimika",
      "mincovna",
      "minibar",
      "minomet",
      "minulost",
      "miska",
      "mistr",
      "mixovat",
      "mladost",
      "mlha",
      "mlhovina",
      "mlok",
      "mlsat",
      "mluvit",
      "mnich",
      "mnohem",
      "mobil",
      "mocnost",
      "modelka",
      "modlitba",
      "mohyla",
      "mokro",
      "molekula",
      "momentka",
      "monarcha",
      "monokl",
      "monstrum",
      "montovat",
      "monzun",
      "mosaz",
      "moskyt",
      "most",
      "motivace",
      "motorka",
      "motyka",
      "moucha",
      "moudrost",
      "mozaika",
      "mozek",
      "mozol",
      "mramor",
      "mravenec",
      "mrkev",
      "mrtvola",
      "mrzet",
      "mrzutost",
      "mstitel",
      "mudrc",
      "muflon",
      "mulat",
      "mumie",
      "munice",
      "muset",
      "mutace",
      "muzeum",
      "muzikant",
      "myslivec",
      "mzda",
      "nabourat",
      "nachytat",
      "nadace",
      "nadbytek",
      "nadhoz",
      "nadobro",
      "nadpis",
      "nahlas",
      "nahnat",
      "nahodile",
      "nahradit",
      "naivita",
      "najednou",
      "najisto",
      "najmout",
      "naklonit",
      "nakonec",
      "nakrmit",
      "nalevo",
      "namazat",
      "namluvit",
      "nanometr",
      "naoko",
      "naopak",
      "naostro",
      "napadat",
      "napevno",
      "naplnit",
      "napnout",
      "naposled",
      "naprosto",
      "narodit",
      "naruby",
      "narychlo",
      "nasadit",
      "nasekat",
      "naslepo",
      "nastat",
      "natolik",
      "navenek",
      "navrch",
      "navzdory",
      "nazvat",
      "nebe",
      "nechat",
      "necky",
      "nedaleko",
      "nedbat",
      "neduh",
      "negace",
      "nehet",
      "nehoda",
      "nejen",
      "nejprve",
      "neklid",
      "nelibost",
      "nemilost",
      "nemoc",
      "neochota",
      "neonka",
      "nepokoj",
      "nerost",
      "nerv",
      "nesmysl",
      "nesoulad",
      "netvor",
      "neuron",
      "nevina",
      "nezvykle",
      "nicota",
      "nijak",
      "nikam",
      "nikdy",
      "nikl",
      "nikterak",
      "nitro",
      "nocleh",
      "nohavice",
      "nominace",
      "nora",
      "norek",
      "nositel",
      "nosnost",
      "nouze",
      "noviny",
      "novota",
      "nozdra",
      "nuda",
      "nudle",
      "nuget",
      "nutit",
      "nutnost",
      "nutrie",
      "nymfa",
      "obal",
      "obarvit",
      "obava",
      "obdiv",
      "obec",
      "obehnat",
      "obejmout",
      "obezita",
      "obhajoba",
      "obilnice",
      "objasnit",
      "objekt",
      "obklopit",
      "oblast",
      "oblek",
      "obliba",
      "obloha",
      "obluda",
      "obnos",
      "obohatit",
      "obojek",
      "obout",
      "obrazec",
      "obrna",
      "obruba",
      "obrys",
      "obsah",
      "obsluha",
      "obstarat",
      "obuv",
      "obvaz",
      "obvinit",
      "obvod",
      "obvykle",
      "obyvatel",
      "obzor",
      "ocas",
      "ocel",
      "ocenit",
      "ochladit",
      "ochota",
      "ochrana",
      "ocitnout",
      "odboj",
      "odbyt",
      "odchod",
      "odcizit",
      "odebrat",
      "odeslat",
      "odevzdat",
      "odezva",
      "odhadce",
      "odhodit",
      "odjet",
      "odjinud",
      "odkaz",
      "odkoupit",
      "odliv",
      "odluka",
      "odmlka",
      "odolnost",
      "odpad",
      "odpis",
      "odplout",
      "odpor",
      "odpustit",
      "odpykat",
      "odrazka",
      "odsoudit",
      "odstup",
      "odsun",
      "odtok",
      "odtud",
      "odvaha",
      "odveta",
      "odvolat",
      "odvracet",
      "odznak",
      "ofina",
      "ofsajd",
      "ohlas",
      "ohnisko",
      "ohrada",
      "ohrozit",
      "ohryzek",
      "okap",
      "okenice",
      "oklika",
      "okno",
      "okouzlit",
      "okovy",
      "okrasa",
      "okres",
      "okrsek",
      "okruh",
      "okupant",
      "okurka",
      "okusit",
      "olejnina",
      "olizovat",
      "omak",
      "omeleta",
      "omezit",
      "omladina",
      "omlouvat",
      "omluva",
      "omyl",
      "onehdy",
      "opakovat",
      "opasek",
      "operace",
      "opice",
      "opilost",
      "opisovat",
      "opora",
      "opozice",
      "opravdu",
      "oproti",
      "orbital",
      "orchestr",
      "orgie",
      "orlice",
      "orloj",
      "ortel",
      "osada",
      "oschnout",
      "osika",
      "osivo",
      "oslava",
      "oslepit",
      "oslnit",
      "oslovit",
      "osnova",
      "osoba",
      "osolit",
      "ospalec",
      "osten",
      "ostraha",
      "ostuda",
      "ostych",
      "osvojit",
      "oteplit",
      "otisk",
      "otop",
      "otrhat",
      "otrlost",
      "otrok",
      "otruby",
      "otvor",
      "ovanout",
      "ovar",
      "oves",
      "ovlivnit",
      "ovoce",
      "oxid",
      "ozdoba",
      "pachatel",
      "pacient",
      "padouch",
      "pahorek",
      "pakt",
      "palanda",
      "palec",
      "palivo",
      "paluba",
      "pamflet",
      "pamlsek",
      "panenka",
      "panika",
      "panna",
      "panovat",
      "panstvo",
      "pantofle",
      "paprika",
      "parketa",
      "parodie",
      "parta",
      "paruka",
      "paryba",
      "paseka",
      "pasivita",
      "pastelka",
      "patent",
      "patrona",
      "pavouk",
      "pazneht",
      "pazourek",
      "pecka",
      "pedagog",
      "pejsek",
      "peklo",
      "peloton",
      "penalta",
      "pendrek",
      "penze",
      "periskop",
      "pero",
      "pestrost",
      "petarda",
      "petice",
      "petrolej",
      "pevnina",
      "pexeso",
      "pianista",
      "piha",
      "pijavice",
      "pikle",
      "piknik",
      "pilina",
      "pilnost",
      "pilulka",
      "pinzeta",
      "pipeta",
      "pisatel",
      "pistole",
      "pitevna",
      "pivnice",
      "pivovar",
      "placenta",
      "plakat",
      "plamen",
      "planeta",
      "plastika",
      "platit",
      "plavidlo",
      "plaz",
      "plech",
      "plemeno",
      "plenta",
      "ples",
      "pletivo",
      "plevel",
      "plivat",
      "plnit",
      "plno",
      "plocha",
      "plodina",
      "plomba",
      "plout",
      "pluk",
      "plyn",
      "pobavit",
      "pobyt",
      "pochod",
      "pocit",
      "poctivec",
      "podat",
      "podcenit",
      "podepsat",
      "podhled",
      "podivit",
      "podklad",
      "podmanit",
      "podnik",
      "podoba",
      "podpora",
      "podraz",
      "podstata",
      "podvod",
      "podzim",
      "poezie",
      "pohanka",
      "pohnutka",
      "pohovor",
      "pohroma",
      "pohyb",
      "pointa",
      "pojistka",
      "pojmout",
      "pokazit",
      "pokles",
      "pokoj",
      "pokrok",
      "pokuta",
      "pokyn",
      "poledne",
      "polibek",
      "polknout",
      "poloha",
      "polynom",
      "pomalu",
      "pominout",
      "pomlka",
      "pomoc",
      "pomsta",
      "pomyslet",
      "ponechat",
      "ponorka",
      "ponurost",
      "popadat",
      "popel",
      "popisek",
      "poplach",
      "poprosit",
      "popsat",
      "popud",
      "poradce",
      "porce",
      "porod",
      "porucha",
      "poryv",
      "posadit",
      "posed",
      "posila",
      "poskok",
      "poslanec",
      "posoudit",
      "pospolu",
      "postava",
      "posudek",
      "posyp",
      "potah",
      "potkan",
      "potlesk",
      "potomek",
      "potrava",
      "potupa",
      "potvora",
      "poukaz",
      "pouto",
      "pouzdro",
      "povaha",
      "povidla",
      "povlak",
      "povoz",
      "povrch",
      "povstat",
      "povyk",
      "povzdech",
      "pozdrav",
      "pozemek",
      "poznatek",
      "pozor",
      "pozvat",
      "pracovat",
      "prahory",
      "praktika",
      "prales",
      "praotec",
      "praporek",
      "prase",
      "pravda",
      "princip",
      "prkno",
      "probudit",
      "procento",
      "prodej",
      "profese",
      "prohra",
      "projekt",
      "prolomit",
      "promile",
      "pronikat",
      "propad",
      "prorok",
      "prosba",
      "proton",
      "proutek",
      "provaz",
      "prskavka",
      "prsten",
      "prudkost",
      "prut",
      "prvek",
      "prvohory",
      "psanec",
      "psovod",
      "pstruh",
      "ptactvo",
      "puberta",
      "puch",
      "pudl",
      "pukavec",
      "puklina",
      "pukrle",
      "pult",
      "pumpa",
      "punc",
      "pupen",
      "pusa",
      "pusinka",
      "pustina",
      "putovat",
      "putyka",
      "pyramida",
      "pysk",
      "pytel",
      "racek",
      "rachot",
      "radiace",
      "radnice",
      "radon",
      "raft",
      "ragby",
      "raketa",
      "rakovina",
      "rameno",
      "rampouch",
      "rande",
      "rarach",
      "rarita",
      "rasovna",
      "rastr",
      "ratolest",
      "razance",
      "razidlo",
      "reagovat",
      "reakce",
      "recept",
      "redaktor",
      "referent",
      "reflex",
      "rejnok",
      "reklama",
      "rekord",
      "rekrut",
      "rektor",
      "reputace",
      "revize",
      "revma",
      "revolver",
      "rezerva",
      "riskovat",
      "riziko",
      "robotika",
      "rodokmen",
      "rohovka",
      "rokle",
      "rokoko",
      "romaneto",
      "ropovod",
      "ropucha",
      "rorejs",
      "rosol",
      "rostlina",
      "rotmistr",
      "rotoped",
      "rotunda",
      "roubenka",
      "roucho",
      "roup",
      "roura",
      "rovina",
      "rovnice",
      "rozbor",
      "rozchod",
      "rozdat",
      "rozeznat",
      "rozhodce",
      "rozinka",
      "rozjezd",
      "rozkaz",
      "rozloha",
      "rozmar",
      "rozpad",
      "rozruch",
      "rozsah",
      "roztok",
      "rozum",
      "rozvod",
      "rubrika",
      "ruchadlo",
      "rukavice",
      "rukopis",
      "ryba",
      "rybolov",
      "rychlost",
      "rydlo",
      "rypadlo",
      "rytina",
      "ryzost",
      "sadista",
      "sahat",
      "sako",
      "samec",
      "samizdat",
      "samota",
      "sanitka",
      "sardinka",
      "sasanka",
      "satelit",
      "sazba",
      "sazenice",
      "sbor",
      "schovat",
      "sebranka",
      "secese",
      "sedadlo",
      "sediment",
      "sedlo",
      "sehnat",
      "sejmout",
      "sekera",
      "sekta",
      "sekunda",
      "sekvoje",
      "semeno",
      "seno",
      "servis",
      "sesadit",
      "seshora",
      "seskok",
      "seslat",
      "sestra",
      "sesuv",
      "sesypat",
      "setba",
      "setina",
      "setkat",
      "setnout",
      "setrvat",
      "sever",
      "seznam",
      "shoda",
      "shrnout",
      "sifon",
      "silnice",
      "sirka",
      "sirotek",
      "sirup",
      "situace",
      "skafandr",
      "skalisko",
      "skanzen",
      "skaut",
      "skeptik",
      "skica",
      "skladba",
      "sklenice",
      "sklo",
      "skluz",
      "skoba",
      "skokan",
      "skoro",
      "skripta",
      "skrz",
      "skupina",
      "skvost",
      "skvrna",
      "slabika",
      "sladidlo",
      "slanina",
      "slast",
      "slavnost",
      "sledovat",
      "slepec",
      "sleva",
      "slezina",
      "slib",
      "slina",
      "sliznice",
      "slon",
      "sloupek",
      "slovo",
      "sluch",
      "sluha",
      "slunce",
      "slupka",
      "slza",
      "smaragd",
      "smetana",
      "smilstvo",
      "smlouva",
      "smog",
      "smrad",
      "smrk",
      "smrtka",
      "smutek",
      "smysl",
      "snad",
      "snaha",
      "snob",
      "sobota",
      "socha",
      "sodovka",
      "sokol",
      "sopka",
      "sotva",
      "souboj",
      "soucit",
      "soudce",
      "souhlas",
      "soulad",
      "soumrak",
      "souprava",
      "soused",
      "soutok",
      "souviset",
      "spalovna",
      "spasitel",
      "spis",
      "splav",
      "spodek",
      "spojenec",
      "spolu",
      "sponzor",
      "spornost",
      "spousta",
      "sprcha",
      "spustit",
      "sranda",
      "sraz",
      "srdce",
      "srna",
      "srnec",
      "srovnat",
      "srpen",
      "srst",
      "srub",
      "stanice",
      "starosta",
      "statika",
      "stavba",
      "stehno",
      "stezka",
      "stodola",
      "stolek",
      "stopa",
      "storno",
      "stoupat",
      "strach",
      "stres",
      "strhnout",
      "strom",
      "struna",
      "studna",
      "stupnice",
      "stvol",
      "styk",
      "subjekt",
      "subtropy",
      "suchar",
      "sudost",
      "sukno",
      "sundat",
      "sunout",
      "surikata",
      "surovina",
      "svah",
      "svalstvo",
      "svetr",
      "svatba",
      "svazek",
      "svisle",
      "svitek",
      "svoboda",
      "svodidlo",
      "svorka",
      "svrab",
      "sykavka",
      "sykot",
      "synek",
      "synovec",
      "sypat",
      "sypkost",
      "syrovost",
      "sysel",
      "sytost",
      "tabletka",
      "tabule",
      "tahoun",
      "tajemno",
      "tajfun",
      "tajga",
      "tajit",
      "tajnost",
      "taktika",
      "tamhle",
      "tampon",
      "tancovat",
      "tanec",
      "tanker",
      "tapeta",
      "tavenina",
      "tazatel",
      "technika",
      "tehdy",
      "tekutina",
      "telefon",
      "temnota",
      "tendence",
      "tenista",
      "tenor",
      "teplota",
      "tepna",
      "teprve",
      "terapie",
      "termoska",
      "textil",
      "ticho",
      "tiskopis",
      "titulek",
      "tkadlec",
      "tkanina",
      "tlapka",
      "tleskat",
      "tlukot",
      "tlupa",
      "tmel",
      "toaleta",
      "topinka",
      "topol",
      "torzo",
      "touha",
      "toulec",
      "tradice",
      "traktor",
      "tramp",
      "trasa",
      "traverza",
      "trefit",
      "trest",
      "trezor",
      "trhavina",
      "trhlina",
      "trochu",
      "trojice",
      "troska",
      "trouba",
      "trpce",
      "trpitel",
      "trpkost",
      "trubec",
      "truchlit",
      "truhlice",
      "trus",
      "trvat",
      "tudy",
      "tuhnout",
      "tuhost",
      "tundra",
      "turista",
      "turnaj",
      "tuzemsko",
      "tvaroh",
      "tvorba",
      "tvrdost",
      "tvrz",
      "tygr",
      "tykev",
      "ubohost",
      "uboze",
      "ubrat",
      "ubrousek",
      "ubrus",
      "ubytovna",
      "ucho",
      "uctivost",
      "udivit",
      "uhradit",
      "ujednat",
      "ujistit",
      "ujmout",
      "ukazatel",
      "uklidnit",
      "uklonit",
      "ukotvit",
      "ukrojit",
      "ulice",
      "ulita",
      "ulovit",
      "umyvadlo",
      "unavit",
      "uniforma",
      "uniknout",
      "upadnout",
      "uplatnit",
      "uplynout",
      "upoutat",
      "upravit",
      "uran",
      "urazit",
      "usednout",
      "usilovat",
      "usmrtit",
      "usnadnit",
      "usnout",
      "usoudit",
      "ustlat",
      "ustrnout",
      "utahovat",
      "utkat",
      "utlumit",
      "utonout",
      "utopenec",
      "utrousit",
      "uvalit",
      "uvolnit",
      "uvozovka",
      "uzdravit",
      "uzel",
      "uzenina",
      "uzlina",
      "uznat",
      "vagon",
      "valcha",
      "valoun",
      "vana",
      "vandal",
      "vanilka",
      "varan",
      "varhany",
      "varovat",
      "vcelku",
      "vchod",
      "vdova",
      "vedro",
      "vegetace",
      "vejce",
      "velbloud",
      "veletrh",
      "velitel",
      "velmoc",
      "velryba",
      "venkov",
      "veranda",
      "verze",
      "veselka",
      "veskrze",
      "vesnice",
      "vespodu",
      "vesta",
      "veterina",
      "veverka",
      "vibrace",
      "vichr",
      "videohra",
      "vidina",
      "vidle",
      "vila",
      "vinice",
      "viset",
      "vitalita",
      "vize",
      "vizitka",
      "vjezd",
      "vklad",
      "vkus",
      "vlajka",
      "vlak",
      "vlasec",
      "vlevo",
      "vlhkost",
      "vliv",
      "vlnovka",
      "vloupat",
      "vnucovat",
      "vnuk",
      "voda",
      "vodivost",
      "vodoznak",
      "vodstvo",
      "vojensky",
      "vojna",
      "vojsko",
      "volant",
      "volba",
      "volit",
      "volno",
      "voskovka",
      "vozidlo",
      "vozovna",
      "vpravo",
      "vrabec",
      "vracet",
      "vrah",
      "vrata",
      "vrba",
      "vrcholek",
      "vrhat",
      "vrstva",
      "vrtule",
      "vsadit",
      "vstoupit",
      "vstup",
      "vtip",
      "vybavit",
      "vybrat",
      "vychovat",
      "vydat",
      "vydra",
      "vyfotit",
      "vyhledat",
      "vyhnout",
      "vyhodit",
      "vyhradit",
      "vyhubit",
      "vyjasnit",
      "vyjet",
      "vyjmout",
      "vyklopit",
      "vykonat",
      "vylekat",
      "vymazat",
      "vymezit",
      "vymizet",
      "vymyslet",
      "vynechat",
      "vynikat",
      "vynutit",
      "vypadat",
      "vyplatit",
      "vypravit",
      "vypustit",
      "vyrazit",
      "vyrovnat",
      "vyrvat",
      "vyslovit",
      "vysoko",
      "vystavit",
      "vysunout",
      "vysypat",
      "vytasit",
      "vytesat",
      "vytratit",
      "vyvinout",
      "vyvolat",
      "vyvrhel",
      "vyzdobit",
      "vyznat",
      "vzadu",
      "vzbudit",
      "vzchopit",
      "vzdor",
      "vzduch",
      "vzdychat",
      "vzestup",
      "vzhledem",
      "vzkaz",
      "vzlykat",
      "vznik",
      "vzorek",
      "vzpoura",
      "vztah",
      "vztek",
      "xylofon",
      "zabrat",
      "zabydlet",
      "zachovat",
      "zadarmo",
      "zadusit",
      "zafoukat",
      "zahltit",
      "zahodit",
      "zahrada",
      "zahynout",
      "zajatec",
      "zajet",
      "zajistit",
      "zaklepat",
      "zakoupit",
      "zalepit",
      "zamezit",
      "zamotat",
      "zamyslet",
      "zanechat",
      "zanikat",
      "zaplatit",
      "zapojit",
      "zapsat",
      "zarazit",
      "zastavit",
      "zasunout",
      "zatajit",
      "zatemnit",
      "zatknout",
      "zaujmout",
      "zavalit",
      "zavelet",
      "zavinit",
      "zavolat",
      "zavrtat",
      "zazvonit",
      "zbavit",
      "zbrusu",
      "zbudovat",
      "zbytek",
      "zdaleka",
      "zdarma",
      "zdatnost",
      "zdivo",
      "zdobit",
      "zdroj",
      "zdvih",
      "zdymadlo",
      "zelenina",
      "zeman",
      "zemina",
      "zeptat",
      "zezadu",
      "zezdola",
      "zhatit",
      "zhltnout",
      "zhluboka",
      "zhotovit",
      "zhruba",
      "zima",
      "zimnice",
      "zjemnit",
      "zklamat",
      "zkoumat",
      "zkratka",
      "zkumavka",
      "zlato",
      "zlehka",
      "zloba",
      "zlom",
      "zlost",
      "zlozvyk",
      "zmapovat",
      "zmar",
      "zmatek",
      "zmije",
      "zmizet",
      "zmocnit",
      "zmodrat",
      "zmrzlina",
      "zmutovat",
      "znak",
      "znalost",
      "znamenat",
      "znovu",
      "zobrazit",
      "zotavit",
      "zoubek",
      "zoufale",
      "zplodit",
      "zpomalit",
      "zprava",
      "zprostit",
      "zprudka",
      "zprvu",
      "zrada",
      "zranit",
      "zrcadlo",
      "zrnitost",
      "zrno",
      "zrovna",
      "zrychlit",
      "zrzavost",
      "zticha",
      "ztratit",
      "zubovina",
      "zubr",
      "zvednout",
      "zvenku",
      "zvesela",
      "zvon",
      "zvrat",
      "zvukovod",
      "zvyk"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_simplified.json
var require_chinese_simplified = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_simplified.json"(exports, module) {
    module.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "这",
      "中",
      "大",
      "为",
      "上",
      "个",
      "国",
      "我",
      "以",
      "要",
      "他",
      "时",
      "来",
      "用",
      "们",
      "生",
      "到",
      "作",
      "地",
      "于",
      "出",
      "就",
      "分",
      "对",
      "成",
      "会",
      "可",
      "主",
      "发",
      "年",
      "动",
      "同",
      "工",
      "也",
      "能",
      "下",
      "过",
      "子",
      "说",
      "产",
      "种",
      "面",
      "而",
      "方",
      "后",
      "多",
      "定",
      "行",
      "学",
      "法",
      "所",
      "民",
      "得",
      "经",
      "十",
      "三",
      "之",
      "进",
      "着",
      "等",
      "部",
      "度",
      "家",
      "电",
      "力",
      "里",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "现",
      "实",
      "加",
      "量",
      "都",
      "两",
      "体",
      "制",
      "机",
      "当",
      "使",
      "点",
      "从",
      "业",
      "本",
      "去",
      "把",
      "性",
      "好",
      "应",
      "开",
      "它",
      "合",
      "还",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "义",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "间",
      "样",
      "与",
      "关",
      "各",
      "重",
      "新",
      "线",
      "内",
      "数",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "么",
      "利",
      "比",
      "或",
      "但",
      "质",
      "气",
      "第",
      "向",
      "道",
      "命",
      "此",
      "变",
      "条",
      "只",
      "没",
      "结",
      "解",
      "问",
      "意",
      "建",
      "月",
      "公",
      "无",
      "系",
      "军",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "并",
      "提",
      "直",
      "题",
      "党",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "员",
      "革",
      "位",
      "入",
      "常",
      "文",
      "总",
      "次",
      "品",
      "式",
      "活",
      "设",
      "及",
      "管",
      "特",
      "件",
      "长",
      "求",
      "老",
      "头",
      "基",
      "资",
      "边",
      "流",
      "路",
      "级",
      "少",
      "图",
      "山",
      "统",
      "接",
      "知",
      "较",
      "将",
      "组",
      "见",
      "计",
      "别",
      "她",
      "手",
      "角",
      "期",
      "根",
      "论",
      "运",
      "农",
      "指",
      "几",
      "九",
      "区",
      "强",
      "放",
      "决",
      "西",
      "被",
      "干",
      "做",
      "必",
      "战",
      "先",
      "回",
      "则",
      "任",
      "取",
      "据",
      "处",
      "队",
      "南",
      "给",
      "色",
      "光",
      "门",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "规",
      "热",
      "领",
      "七",
      "海",
      "口",
      "东",
      "导",
      "器",
      "压",
      "志",
      "世",
      "金",
      "增",
      "争",
      "济",
      "阶",
      "油",
      "思",
      "术",
      "极",
      "交",
      "受",
      "联",
      "什",
      "认",
      "六",
      "共",
      "权",
      "收",
      "证",
      "改",
      "清",
      "美",
      "再",
      "采",
      "转",
      "更",
      "单",
      "风",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "带",
      "安",
      "场",
      "身",
      "车",
      "例",
      "真",
      "务",
      "具",
      "万",
      "每",
      "目",
      "至",
      "达",
      "走",
      "积",
      "示",
      "议",
      "声",
      "报",
      "斗",
      "完",
      "类",
      "八",
      "离",
      "华",
      "名",
      "确",
      "才",
      "科",
      "张",
      "信",
      "马",
      "节",
      "话",
      "米",
      "整",
      "空",
      "元",
      "况",
      "今",
      "集",
      "温",
      "传",
      "土",
      "许",
      "步",
      "群",
      "广",
      "石",
      "记",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "观",
      "越",
      "织",
      "装",
      "影",
      "算",
      "低",
      "持",
      "音",
      "众",
      "书",
      "布",
      "复",
      "容",
      "儿",
      "须",
      "际",
      "商",
      "非",
      "验",
      "连",
      "断",
      "深",
      "难",
      "近",
      "矿",
      "千",
      "周",
      "委",
      "素",
      "技",
      "备",
      "半",
      "办",
      "青",
      "省",
      "列",
      "习",
      "响",
      "约",
      "支",
      "般",
      "史",
      "感",
      "劳",
      "便",
      "团",
      "往",
      "酸",
      "历",
      "市",
      "克",
      "何",
      "除",
      "消",
      "构",
      "府",
      "称",
      "太",
      "准",
      "精",
      "值",
      "号",
      "率",
      "族",
      "维",
      "划",
      "选",
      "标",
      "写",
      "存",
      "候",
      "毛",
      "亲",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "养",
      "易",
      "置",
      "派",
      "层",
      "片",
      "始",
      "却",
      "专",
      "状",
      "育",
      "厂",
      "京",
      "识",
      "适",
      "属",
      "圆",
      "包",
      "火",
      "住",
      "调",
      "满",
      "县",
      "局",
      "照",
      "参",
      "红",
      "细",
      "引",
      "听",
      "该",
      "铁",
      "价",
      "严",
      "首",
      "底",
      "液",
      "官",
      "德",
      "随",
      "病",
      "苏",
      "失",
      "尔",
      "死",
      "讲",
      "配",
      "女",
      "黄",
      "推",
      "显",
      "谈",
      "罪",
      "神",
      "艺",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "营",
      "项",
      "防",
      "举",
      "球",
      "英",
      "氧",
      "势",
      "告",
      "李",
      "台",
      "落",
      "木",
      "帮",
      "轮",
      "破",
      "亚",
      "师",
      "围",
      "注",
      "远",
      "字",
      "材",
      "排",
      "供",
      "河",
      "态",
      "封",
      "另",
      "施",
      "减",
      "树",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "叶",
      "鱼",
      "波",
      "视",
      "仅",
      "费",
      "紧",
      "爱",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "续",
      "轻",
      "服",
      "试",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "护",
      "司",
      "足",
      "某",
      "练",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "负",
      "击",
      "范",
      "继",
      "兴",
      "似",
      "余",
      "坚",
      "曲",
      "输",
      "修",
      "故",
      "城",
      "夫",
      "够",
      "送",
      "笔",
      "船",
      "占",
      "右",
      "财",
      "吃",
      "富",
      "春",
      "职",
      "觉",
      "汉",
      "画",
      "功",
      "巴",
      "跟",
      "虽",
      "杂",
      "飞",
      "检",
      "吸",
      "助",
      "升",
      "阳",
      "互",
      "初",
      "创",
      "抗",
      "考",
      "投",
      "坏",
      "策",
      "古",
      "径",
      "换",
      "未",
      "跑",
      "留",
      "钢",
      "曾",
      "端",
      "责",
      "站",
      "简",
      "述",
      "钱",
      "副",
      "尽",
      "帝",
      "射",
      "草",
      "冲",
      "承",
      "独",
      "令",
      "限",
      "阿",
      "宣",
      "环",
      "双",
      "请",
      "超",
      "微",
      "让",
      "控",
      "州",
      "良",
      "轴",
      "找",
      "否",
      "纪",
      "益",
      "依",
      "优",
      "顶",
      "础",
      "载",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敌",
      "略",
      "客",
      "袁",
      "冷",
      "胜",
      "绝",
      "析",
      "块",
      "剂",
      "测",
      "丝",
      "协",
      "诉",
      "念",
      "陈",
      "仍",
      "罗",
      "盐",
      "友",
      "洋",
      "错",
      "苦",
      "夜",
      "刑",
      "移",
      "频",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "终",
      "聚",
      "汽",
      "村",
      "云",
      "哪",
      "既",
      "距",
      "卫",
      "停",
      "烈",
      "央",
      "察",
      "烧",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "游",
      "久",
      "菜",
      "味",
      "旧",
      "模",
      "湖",
      "货",
      "损",
      "预",
      "阻",
      "毫",
      "普",
      "稳",
      "乙",
      "妈",
      "植",
      "息",
      "扩",
      "银",
      "语",
      "挥",
      "酒",
      "守",
      "拿",
      "序",
      "纸",
      "医",
      "缺",
      "雨",
      "吗",
      "针",
      "刘",
      "啊",
      "急",
      "唱",
      "误",
      "训",
      "愿",
      "审",
      "附",
      "获",
      "茶",
      "鲜",
      "粮",
      "斤",
      "孩",
      "脱",
      "硫",
      "肥",
      "善",
      "龙",
      "演",
      "父",
      "渐",
      "血",
      "欢",
      "械",
      "掌",
      "歌",
      "沙",
      "刚",
      "攻",
      "谓",
      "盾",
      "讨",
      "晚",
      "粒",
      "乱",
      "燃",
      "矛",
      "乎",
      "杀",
      "药",
      "宁",
      "鲁",
      "贵",
      "钟",
      "煤",
      "读",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "丰",
      "培",
      "握",
      "兰",
      "担",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "执",
      "答",
      "乐",
      "谁",
      "顺",
      "烟",
      "缩",
      "征",
      "脸",
      "喜",
      "松",
      "脚",
      "困",
      "异",
      "免",
      "背",
      "星",
      "福",
      "买",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "静",
      "补",
      "评",
      "翻",
      "肉",
      "践",
      "尼",
      "衣",
      "宽",
      "扬",
      "棉",
      "希",
      "伤",
      "操",
      "垂",
      "秋",
      "宜",
      "氢",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "宪",
      "庆",
      "编",
      "牛",
      "触",
      "映",
      "雷",
      "销",
      "诗",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "绿",
      "晶",
      "厚",
      "盟",
      "衡",
      "鸡",
      "孙",
      "延",
      "危",
      "胶",
      "屋",
      "乡",
      "临",
      "陆",
      "顾",
      "掉",
      "呀",
      "灯",
      "岁",
      "措",
      "束",
      "耐",
      "剧",
      "玉",
      "赵",
      "跳",
      "哥",
      "季",
      "课",
      "凯",
      "胡",
      "额",
      "款",
      "绍",
      "卷",
      "齐",
      "伟",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "炉",
      "岩",
      "弱",
      "零",
      "杨",
      "奏",
      "沿",
      "露",
      "杆",
      "探",
      "滑",
      "镇",
      "饭",
      "浓",
      "航",
      "怀",
      "赶",
      "库",
      "夺",
      "伊",
      "灵",
      "税",
      "途",
      "灭",
      "赛",
      "归",
      "召",
      "鼓",
      "播",
      "盘",
      "裁",
      "险",
      "康",
      "唯",
      "录",
      "菌",
      "纯",
      "借",
      "糖",
      "盖",
      "横",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "枪",
      "润",
      "幅",
      "哈",
      "竟",
      "熟",
      "虫",
      "泽",
      "脑",
      "壤",
      "碳",
      "欧",
      "遍",
      "侧",
      "寨",
      "敢",
      "彻",
      "虑",
      "斜",
      "薄",
      "庭",
      "纳",
      "弹",
      "饲",
      "伸",
      "折",
      "麦",
      "湿",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "筑",
      "恶",
      "户",
      "访",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "迹",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "摆",
      "灰",
      "彩",
      "卖",
      "耗",
      "夏",
      "择",
      "忙",
      "铜",
      "献",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "阵",
      "阴",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "楼",
      "避",
      "谋",
      "吨",
      "野",
      "猪",
      "旗",
      "累",
      "偏",
      "典",
      "馆",
      "索",
      "秦",
      "脂",
      "潮",
      "爷",
      "豆",
      "忽",
      "托",
      "惊",
      "塑",
      "遗",
      "愈",
      "朱",
      "替",
      "纤",
      "粗",
      "倾",
      "尚",
      "痛",
      "楚",
      "谢",
      "奋",
      "购",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "监",
      "捕",
      "弟",
      "暴",
      "割",
      "贯",
      "殊",
      "释",
      "词",
      "亡",
      "壁",
      "顿",
      "宝",
      "午",
      "尘",
      "闻",
      "揭",
      "炮",
      "残",
      "冬",
      "桥",
      "妇",
      "警",
      "综",
      "招",
      "吴",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "摇",
      "谷",
      "赞",
      "箱",
      "隔",
      "订",
      "男",
      "吹",
      "园",
      "纷",
      "唐",
      "败",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "荣",
      "闭",
      "湾",
      "键",
      "凡",
      "驻",
      "锅",
      "救",
      "恩",
      "剥",
      "凝",
      "碱",
      "齿",
      "截",
      "炼",
      "麻",
      "纺",
      "禁",
      "废",
      "盛",
      "版",
      "缓",
      "净",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "庄",
      "街",
      "藏",
      "姑",
      "贸",
      "腐",
      "奴",
      "啦",
      "惯",
      "乘",
      "伙",
      "恢",
      "匀",
      "纱",
      "扎",
      "辩",
      "耳",
      "彪",
      "臣",
      "亿",
      "璃",
      "抵",
      "脉",
      "秀",
      "萨",
      "俄",
      "网",
      "舞",
      "店",
      "喷",
      "纵",
      "寸",
      "汗",
      "挂",
      "洪",
      "贺",
      "闪",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "墙",
      "软",
      "勇",
      "像",
      "滚",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "荡",
      "腿",
      "仪",
      "旅",
      "尾",
      "轧",
      "冰",
      "贡",
      "登",
      "黎",
      "削",
      "钻",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "币",
      "港",
      "伏",
      "轨",
      "亩",
      "毕",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "岛",
      "甘",
      "泡",
      "睡",
      "童",
      "铸",
      "汤",
      "阀",
      "休",
      "汇",
      "舍",
      "牧",
      "绕",
      "炸",
      "哲",
      "磷",
      "绩",
      "朋",
      "淡",
      "尖",
      "启",
      "陷",
      "柴",
      "呈",
      "徒",
      "颜",
      "泪",
      "稍",
      "忘",
      "泵",
      "蓝",
      "拖",
      "洞",
      "授",
      "镜",
      "辛",
      "壮",
      "锋",
      "贫",
      "虚",
      "弯",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "纲",
      "弄",
      "隶",
      "疑",
      "氏",
      "宫",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "违",
      "夹",
      "腰",
      "缘",
      "珠",
      "穷",
      "森",
      "枝",
      "竹",
      "沟",
      "催",
      "绳",
      "忆",
      "邦",
      "剩",
      "幸",
      "浆",
      "栏",
      "拥",
      "牙",
      "贮",
      "礼",
      "滤",
      "钠",
      "纹",
      "罢",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罚",
      "焦",
      "潜",
      "伍",
      "墨",
      "欲",
      "缝",
      "姓",
      "刊",
      "饱",
      "仿",
      "奖",
      "铝",
      "鬼",
      "丽",
      "跨",
      "默",
      "挖",
      "链",
      "扫",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "诸",
      "弧",
      "励",
      "梅",
      "奶",
      "洁",
      "灾",
      "舟",
      "鉴",
      "苯",
      "讼",
      "抱",
      "毁",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "届",
      "跃",
      "渡",
      "挑",
      "丹",
      "艰",
      "贝",
      "碰",
      "拔",
      "爹",
      "戴",
      "码",
      "梦",
      "芽",
      "熔",
      "赤",
      "渔",
      "哭",
      "敬",
      "颗",
      "奔",
      "铅",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "仓",
      "魏",
      "锐",
      "晓",
      "氮",
      "兼",
      "隐",
      "碍",
      "赫",
      "拨",
      "忠",
      "肃",
      "缸",
      "牵",
      "抢",
      "博",
      "巧",
      "壳",
      "兄",
      "杜",
      "讯",
      "诚",
      "碧",
      "祥",
      "柯",
      "页",
      "巡",
      "矩",
      "悲",
      "灌",
      "龄",
      "伦",
      "票",
      "寻",
      "桂",
      "铺",
      "圣",
      "恐",
      "恰",
      "郑",
      "趣",
      "抬",
      "荒",
      "腾",
      "贴",
      "柔",
      "滴",
      "猛",
      "阔",
      "辆",
      "妻",
      "填",
      "撤",
      "储",
      "签",
      "闹",
      "扰",
      "紫",
      "砂",
      "递",
      "戏",
      "吊",
      "陶",
      "伐",
      "喂",
      "疗",
      "瓶",
      "婆",
      "抚",
      "臂",
      "摸",
      "忍",
      "虾",
      "蜡",
      "邻",
      "胸",
      "巩",
      "挤",
      "偶",
      "弃",
      "槽",
      "劲",
      "乳",
      "邓",
      "吉",
      "仁",
      "烂",
      "砖",
      "租",
      "乌",
      "舰",
      "伴",
      "瓜",
      "浅",
      "丙",
      "暂",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "胆",
      "详",
      "簧",
      "踏",
      "瓷",
      "谱",
      "呆",
      "宾",
      "糊",
      "洛",
      "辉",
      "愤",
      "竞",
      "隙",
      "怒",
      "粘",
      "乃",
      "绪",
      "肩",
      "籍",
      "敏",
      "涂",
      "熙",
      "皆",
      "侦",
      "悬",
      "掘",
      "享",
      "纠",
      "醒",
      "狂",
      "锁",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "赏",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鸭",
      "趋",
      "凤",
      "晨",
      "畜",
      "辈",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "滩",
      "棋",
      "驱",
      "筛",
      "峡",
      "冒",
      "啥",
      "寿",
      "译",
      "浸",
      "泉",
      "帽",
      "迟",
      "硅",
      "疆",
      "贷",
      "漏",
      "稿",
      "冠",
      "嫩",
      "胁",
      "芯",
      "牢",
      "叛",
      "蚀",
      "奥",
      "鸣",
      "岭",
      "羊",
      "凭",
      "串",
      "塘",
      "绘",
      "酵",
      "融",
      "盆",
      "锡",
      "庙",
      "筹",
      "冻",
      "辅",
      "摄",
      "袭",
      "筋",
      "拒",
      "僚",
      "旱",
      "钾",
      "鸟",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韩",
      "逼",
      "扭",
      "侨",
      "凉",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "馏",
      "劝",
      "豪",
      "辽",
      "勃",
      "鸿",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "辊",
      "掩",
      "饮",
      "搬",
      "骂",
      "辞",
      "勾",
      "扣",
      "估",
      "蒋",
      "绒",
      "雾",
      "丈",
      "朵",
      "姆",
      "拟",
      "宇",
      "辑",
      "陕",
      "雕",
      "偿",
      "蓄",
      "崇",
      "剪",
      "倡",
      "厅",
      "咬",
      "驶",
      "薯",
      "刷",
      "斥",
      "番",
      "赋",
      "奉",
      "佛",
      "浇",
      "漫",
      "曼",
      "扇",
      "钙",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "亏",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "骗",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "胀",
      "谐",
      "抛",
      "霉",
      "桑",
      "岗",
      "嘛",
      "衰",
      "盗",
      "渗",
      "脏",
      "赖",
      "涌",
      "甜",
      "曹",
      "阅",
      "肌",
      "哩",
      "厉",
      "烃",
      "纬",
      "毅",
      "昨",
      "伪",
      "症",
      "煮",
      "叹",
      "钉",
      "搭",
      "茎",
      "笼",
      "酷",
      "偷",
      "弓",
      "锥",
      "恒",
      "杰",
      "坑",
      "鼻",
      "翼",
      "纶",
      "叙",
      "狱",
      "逮",
      "罐",
      "络",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "骤",
      "穆",
      "冶",
      "枯",
      "册",
      "尸",
      "凸",
      "绅",
      "坯",
      "牺",
      "焰",
      "轰",
      "欣",
      "晋",
      "瘦",
      "御",
      "锭",
      "锦",
      "丧",
      "旬",
      "锻",
      "垄",
      "搜",
      "扑",
      "邀",
      "亭",
      "酯",
      "迈",
      "舒",
      "脆",
      "酶",
      "闲",
      "忧",
      "酚",
      "顽",
      "羽",
      "涨",
      "卸",
      "仗",
      "陪",
      "辟",
      "惩",
      "杭",
      "姚",
      "肚",
      "捉",
      "飘",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "饰",
      "萧",
      "雅",
      "邮",
      "迁",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "烦",
      "债",
      "帐",
      "斑",
      "铃",
      "旨",
      "醇",
      "董",
      "饼",
      "雏",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "贤",
      "拆",
      "歪",
      "葡",
      "胺",
      "丢",
      "浩",
      "徽",
      "昂",
      "垫",
      "挡",
      "览",
      "贪",
      "慰",
      "缴",
      "汪",
      "慌",
      "冯",
      "诺",
      "姜",
      "谊",
      "凶",
      "劣",
      "诬",
      "耀",
      "昏",
      "躺",
      "盈",
      "骑",
      "乔",
      "溪",
      "丛",
      "卢",
      "抹",
      "闷",
      "咨",
      "刮",
      "驾",
      "缆",
      "悟",
      "摘",
      "铒",
      "掷",
      "颇",
      "幻",
      "柄",
      "惠",
      "惨",
      "佳",
      "仇",
      "腊",
      "窝",
      "涤",
      "剑",
      "瞧",
      "堡",
      "泼",
      "葱",
      "罩",
      "霍",
      "捞",
      "胎",
      "苍",
      "滨",
      "俩",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "疯",
      "淮",
      "遂",
      "熊",
      "粪",
      "烘",
      "宿",
      "档",
      "戈",
      "驳",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "肠",
      "撑",
      "晒",
      "辨",
      "殿",
      "莲",
      "摊",
      "搅",
      "酱",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皱",
      "畅",
      "叠",
      "阁",
      "莱",
      "敲",
      "辖",
      "钩",
      "痕",
      "坝",
      "巷",
      "饿",
      "祸",
      "丘",
      "玄",
      "溜",
      "曰",
      "逻",
      "彭",
      "尝",
      "卿",
      "妨",
      "艇",
      "吞",
      "韦",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// node_modules/bip39/src/wordlists/chinese_traditional.json
var require_chinese_traditional = __commonJS({
  "node_modules/bip39/src/wordlists/chinese_traditional.json"(exports, module) {
    module.exports = [
      "的",
      "一",
      "是",
      "在",
      "不",
      "了",
      "有",
      "和",
      "人",
      "這",
      "中",
      "大",
      "為",
      "上",
      "個",
      "國",
      "我",
      "以",
      "要",
      "他",
      "時",
      "來",
      "用",
      "們",
      "生",
      "到",
      "作",
      "地",
      "於",
      "出",
      "就",
      "分",
      "對",
      "成",
      "會",
      "可",
      "主",
      "發",
      "年",
      "動",
      "同",
      "工",
      "也",
      "能",
      "下",
      "過",
      "子",
      "說",
      "產",
      "種",
      "面",
      "而",
      "方",
      "後",
      "多",
      "定",
      "行",
      "學",
      "法",
      "所",
      "民",
      "得",
      "經",
      "十",
      "三",
      "之",
      "進",
      "著",
      "等",
      "部",
      "度",
      "家",
      "電",
      "力",
      "裡",
      "如",
      "水",
      "化",
      "高",
      "自",
      "二",
      "理",
      "起",
      "小",
      "物",
      "現",
      "實",
      "加",
      "量",
      "都",
      "兩",
      "體",
      "制",
      "機",
      "當",
      "使",
      "點",
      "從",
      "業",
      "本",
      "去",
      "把",
      "性",
      "好",
      "應",
      "開",
      "它",
      "合",
      "還",
      "因",
      "由",
      "其",
      "些",
      "然",
      "前",
      "外",
      "天",
      "政",
      "四",
      "日",
      "那",
      "社",
      "義",
      "事",
      "平",
      "形",
      "相",
      "全",
      "表",
      "間",
      "樣",
      "與",
      "關",
      "各",
      "重",
      "新",
      "線",
      "內",
      "數",
      "正",
      "心",
      "反",
      "你",
      "明",
      "看",
      "原",
      "又",
      "麼",
      "利",
      "比",
      "或",
      "但",
      "質",
      "氣",
      "第",
      "向",
      "道",
      "命",
      "此",
      "變",
      "條",
      "只",
      "沒",
      "結",
      "解",
      "問",
      "意",
      "建",
      "月",
      "公",
      "無",
      "系",
      "軍",
      "很",
      "情",
      "者",
      "最",
      "立",
      "代",
      "想",
      "已",
      "通",
      "並",
      "提",
      "直",
      "題",
      "黨",
      "程",
      "展",
      "五",
      "果",
      "料",
      "象",
      "員",
      "革",
      "位",
      "入",
      "常",
      "文",
      "總",
      "次",
      "品",
      "式",
      "活",
      "設",
      "及",
      "管",
      "特",
      "件",
      "長",
      "求",
      "老",
      "頭",
      "基",
      "資",
      "邊",
      "流",
      "路",
      "級",
      "少",
      "圖",
      "山",
      "統",
      "接",
      "知",
      "較",
      "將",
      "組",
      "見",
      "計",
      "別",
      "她",
      "手",
      "角",
      "期",
      "根",
      "論",
      "運",
      "農",
      "指",
      "幾",
      "九",
      "區",
      "強",
      "放",
      "決",
      "西",
      "被",
      "幹",
      "做",
      "必",
      "戰",
      "先",
      "回",
      "則",
      "任",
      "取",
      "據",
      "處",
      "隊",
      "南",
      "給",
      "色",
      "光",
      "門",
      "即",
      "保",
      "治",
      "北",
      "造",
      "百",
      "規",
      "熱",
      "領",
      "七",
      "海",
      "口",
      "東",
      "導",
      "器",
      "壓",
      "志",
      "世",
      "金",
      "增",
      "爭",
      "濟",
      "階",
      "油",
      "思",
      "術",
      "極",
      "交",
      "受",
      "聯",
      "什",
      "認",
      "六",
      "共",
      "權",
      "收",
      "證",
      "改",
      "清",
      "美",
      "再",
      "採",
      "轉",
      "更",
      "單",
      "風",
      "切",
      "打",
      "白",
      "教",
      "速",
      "花",
      "帶",
      "安",
      "場",
      "身",
      "車",
      "例",
      "真",
      "務",
      "具",
      "萬",
      "每",
      "目",
      "至",
      "達",
      "走",
      "積",
      "示",
      "議",
      "聲",
      "報",
      "鬥",
      "完",
      "類",
      "八",
      "離",
      "華",
      "名",
      "確",
      "才",
      "科",
      "張",
      "信",
      "馬",
      "節",
      "話",
      "米",
      "整",
      "空",
      "元",
      "況",
      "今",
      "集",
      "溫",
      "傳",
      "土",
      "許",
      "步",
      "群",
      "廣",
      "石",
      "記",
      "需",
      "段",
      "研",
      "界",
      "拉",
      "林",
      "律",
      "叫",
      "且",
      "究",
      "觀",
      "越",
      "織",
      "裝",
      "影",
      "算",
      "低",
      "持",
      "音",
      "眾",
      "書",
      "布",
      "复",
      "容",
      "兒",
      "須",
      "際",
      "商",
      "非",
      "驗",
      "連",
      "斷",
      "深",
      "難",
      "近",
      "礦",
      "千",
      "週",
      "委",
      "素",
      "技",
      "備",
      "半",
      "辦",
      "青",
      "省",
      "列",
      "習",
      "響",
      "約",
      "支",
      "般",
      "史",
      "感",
      "勞",
      "便",
      "團",
      "往",
      "酸",
      "歷",
      "市",
      "克",
      "何",
      "除",
      "消",
      "構",
      "府",
      "稱",
      "太",
      "準",
      "精",
      "值",
      "號",
      "率",
      "族",
      "維",
      "劃",
      "選",
      "標",
      "寫",
      "存",
      "候",
      "毛",
      "親",
      "快",
      "效",
      "斯",
      "院",
      "查",
      "江",
      "型",
      "眼",
      "王",
      "按",
      "格",
      "養",
      "易",
      "置",
      "派",
      "層",
      "片",
      "始",
      "卻",
      "專",
      "狀",
      "育",
      "廠",
      "京",
      "識",
      "適",
      "屬",
      "圓",
      "包",
      "火",
      "住",
      "調",
      "滿",
      "縣",
      "局",
      "照",
      "參",
      "紅",
      "細",
      "引",
      "聽",
      "該",
      "鐵",
      "價",
      "嚴",
      "首",
      "底",
      "液",
      "官",
      "德",
      "隨",
      "病",
      "蘇",
      "失",
      "爾",
      "死",
      "講",
      "配",
      "女",
      "黃",
      "推",
      "顯",
      "談",
      "罪",
      "神",
      "藝",
      "呢",
      "席",
      "含",
      "企",
      "望",
      "密",
      "批",
      "營",
      "項",
      "防",
      "舉",
      "球",
      "英",
      "氧",
      "勢",
      "告",
      "李",
      "台",
      "落",
      "木",
      "幫",
      "輪",
      "破",
      "亞",
      "師",
      "圍",
      "注",
      "遠",
      "字",
      "材",
      "排",
      "供",
      "河",
      "態",
      "封",
      "另",
      "施",
      "減",
      "樹",
      "溶",
      "怎",
      "止",
      "案",
      "言",
      "士",
      "均",
      "武",
      "固",
      "葉",
      "魚",
      "波",
      "視",
      "僅",
      "費",
      "緊",
      "愛",
      "左",
      "章",
      "早",
      "朝",
      "害",
      "續",
      "輕",
      "服",
      "試",
      "食",
      "充",
      "兵",
      "源",
      "判",
      "護",
      "司",
      "足",
      "某",
      "練",
      "差",
      "致",
      "板",
      "田",
      "降",
      "黑",
      "犯",
      "負",
      "擊",
      "范",
      "繼",
      "興",
      "似",
      "餘",
      "堅",
      "曲",
      "輸",
      "修",
      "故",
      "城",
      "夫",
      "夠",
      "送",
      "筆",
      "船",
      "佔",
      "右",
      "財",
      "吃",
      "富",
      "春",
      "職",
      "覺",
      "漢",
      "畫",
      "功",
      "巴",
      "跟",
      "雖",
      "雜",
      "飛",
      "檢",
      "吸",
      "助",
      "昇",
      "陽",
      "互",
      "初",
      "創",
      "抗",
      "考",
      "投",
      "壞",
      "策",
      "古",
      "徑",
      "換",
      "未",
      "跑",
      "留",
      "鋼",
      "曾",
      "端",
      "責",
      "站",
      "簡",
      "述",
      "錢",
      "副",
      "盡",
      "帝",
      "射",
      "草",
      "衝",
      "承",
      "獨",
      "令",
      "限",
      "阿",
      "宣",
      "環",
      "雙",
      "請",
      "超",
      "微",
      "讓",
      "控",
      "州",
      "良",
      "軸",
      "找",
      "否",
      "紀",
      "益",
      "依",
      "優",
      "頂",
      "礎",
      "載",
      "倒",
      "房",
      "突",
      "坐",
      "粉",
      "敵",
      "略",
      "客",
      "袁",
      "冷",
      "勝",
      "絕",
      "析",
      "塊",
      "劑",
      "測",
      "絲",
      "協",
      "訴",
      "念",
      "陳",
      "仍",
      "羅",
      "鹽",
      "友",
      "洋",
      "錯",
      "苦",
      "夜",
      "刑",
      "移",
      "頻",
      "逐",
      "靠",
      "混",
      "母",
      "短",
      "皮",
      "終",
      "聚",
      "汽",
      "村",
      "雲",
      "哪",
      "既",
      "距",
      "衛",
      "停",
      "烈",
      "央",
      "察",
      "燒",
      "迅",
      "境",
      "若",
      "印",
      "洲",
      "刻",
      "括",
      "激",
      "孔",
      "搞",
      "甚",
      "室",
      "待",
      "核",
      "校",
      "散",
      "侵",
      "吧",
      "甲",
      "遊",
      "久",
      "菜",
      "味",
      "舊",
      "模",
      "湖",
      "貨",
      "損",
      "預",
      "阻",
      "毫",
      "普",
      "穩",
      "乙",
      "媽",
      "植",
      "息",
      "擴",
      "銀",
      "語",
      "揮",
      "酒",
      "守",
      "拿",
      "序",
      "紙",
      "醫",
      "缺",
      "雨",
      "嗎",
      "針",
      "劉",
      "啊",
      "急",
      "唱",
      "誤",
      "訓",
      "願",
      "審",
      "附",
      "獲",
      "茶",
      "鮮",
      "糧",
      "斤",
      "孩",
      "脫",
      "硫",
      "肥",
      "善",
      "龍",
      "演",
      "父",
      "漸",
      "血",
      "歡",
      "械",
      "掌",
      "歌",
      "沙",
      "剛",
      "攻",
      "謂",
      "盾",
      "討",
      "晚",
      "粒",
      "亂",
      "燃",
      "矛",
      "乎",
      "殺",
      "藥",
      "寧",
      "魯",
      "貴",
      "鐘",
      "煤",
      "讀",
      "班",
      "伯",
      "香",
      "介",
      "迫",
      "句",
      "豐",
      "培",
      "握",
      "蘭",
      "擔",
      "弦",
      "蛋",
      "沉",
      "假",
      "穿",
      "執",
      "答",
      "樂",
      "誰",
      "順",
      "煙",
      "縮",
      "徵",
      "臉",
      "喜",
      "松",
      "腳",
      "困",
      "異",
      "免",
      "背",
      "星",
      "福",
      "買",
      "染",
      "井",
      "概",
      "慢",
      "怕",
      "磁",
      "倍",
      "祖",
      "皇",
      "促",
      "靜",
      "補",
      "評",
      "翻",
      "肉",
      "踐",
      "尼",
      "衣",
      "寬",
      "揚",
      "棉",
      "希",
      "傷",
      "操",
      "垂",
      "秋",
      "宜",
      "氫",
      "套",
      "督",
      "振",
      "架",
      "亮",
      "末",
      "憲",
      "慶",
      "編",
      "牛",
      "觸",
      "映",
      "雷",
      "銷",
      "詩",
      "座",
      "居",
      "抓",
      "裂",
      "胞",
      "呼",
      "娘",
      "景",
      "威",
      "綠",
      "晶",
      "厚",
      "盟",
      "衡",
      "雞",
      "孫",
      "延",
      "危",
      "膠",
      "屋",
      "鄉",
      "臨",
      "陸",
      "顧",
      "掉",
      "呀",
      "燈",
      "歲",
      "措",
      "束",
      "耐",
      "劇",
      "玉",
      "趙",
      "跳",
      "哥",
      "季",
      "課",
      "凱",
      "胡",
      "額",
      "款",
      "紹",
      "卷",
      "齊",
      "偉",
      "蒸",
      "殖",
      "永",
      "宗",
      "苗",
      "川",
      "爐",
      "岩",
      "弱",
      "零",
      "楊",
      "奏",
      "沿",
      "露",
      "桿",
      "探",
      "滑",
      "鎮",
      "飯",
      "濃",
      "航",
      "懷",
      "趕",
      "庫",
      "奪",
      "伊",
      "靈",
      "稅",
      "途",
      "滅",
      "賽",
      "歸",
      "召",
      "鼓",
      "播",
      "盤",
      "裁",
      "險",
      "康",
      "唯",
      "錄",
      "菌",
      "純",
      "借",
      "糖",
      "蓋",
      "橫",
      "符",
      "私",
      "努",
      "堂",
      "域",
      "槍",
      "潤",
      "幅",
      "哈",
      "竟",
      "熟",
      "蟲",
      "澤",
      "腦",
      "壤",
      "碳",
      "歐",
      "遍",
      "側",
      "寨",
      "敢",
      "徹",
      "慮",
      "斜",
      "薄",
      "庭",
      "納",
      "彈",
      "飼",
      "伸",
      "折",
      "麥",
      "濕",
      "暗",
      "荷",
      "瓦",
      "塞",
      "床",
      "築",
      "惡",
      "戶",
      "訪",
      "塔",
      "奇",
      "透",
      "梁",
      "刀",
      "旋",
      "跡",
      "卡",
      "氯",
      "遇",
      "份",
      "毒",
      "泥",
      "退",
      "洗",
      "擺",
      "灰",
      "彩",
      "賣",
      "耗",
      "夏",
      "擇",
      "忙",
      "銅",
      "獻",
      "硬",
      "予",
      "繁",
      "圈",
      "雪",
      "函",
      "亦",
      "抽",
      "篇",
      "陣",
      "陰",
      "丁",
      "尺",
      "追",
      "堆",
      "雄",
      "迎",
      "泛",
      "爸",
      "樓",
      "避",
      "謀",
      "噸",
      "野",
      "豬",
      "旗",
      "累",
      "偏",
      "典",
      "館",
      "索",
      "秦",
      "脂",
      "潮",
      "爺",
      "豆",
      "忽",
      "托",
      "驚",
      "塑",
      "遺",
      "愈",
      "朱",
      "替",
      "纖",
      "粗",
      "傾",
      "尚",
      "痛",
      "楚",
      "謝",
      "奮",
      "購",
      "磨",
      "君",
      "池",
      "旁",
      "碎",
      "骨",
      "監",
      "捕",
      "弟",
      "暴",
      "割",
      "貫",
      "殊",
      "釋",
      "詞",
      "亡",
      "壁",
      "頓",
      "寶",
      "午",
      "塵",
      "聞",
      "揭",
      "炮",
      "殘",
      "冬",
      "橋",
      "婦",
      "警",
      "綜",
      "招",
      "吳",
      "付",
      "浮",
      "遭",
      "徐",
      "您",
      "搖",
      "谷",
      "贊",
      "箱",
      "隔",
      "訂",
      "男",
      "吹",
      "園",
      "紛",
      "唐",
      "敗",
      "宋",
      "玻",
      "巨",
      "耕",
      "坦",
      "榮",
      "閉",
      "灣",
      "鍵",
      "凡",
      "駐",
      "鍋",
      "救",
      "恩",
      "剝",
      "凝",
      "鹼",
      "齒",
      "截",
      "煉",
      "麻",
      "紡",
      "禁",
      "廢",
      "盛",
      "版",
      "緩",
      "淨",
      "睛",
      "昌",
      "婚",
      "涉",
      "筒",
      "嘴",
      "插",
      "岸",
      "朗",
      "莊",
      "街",
      "藏",
      "姑",
      "貿",
      "腐",
      "奴",
      "啦",
      "慣",
      "乘",
      "夥",
      "恢",
      "勻",
      "紗",
      "扎",
      "辯",
      "耳",
      "彪",
      "臣",
      "億",
      "璃",
      "抵",
      "脈",
      "秀",
      "薩",
      "俄",
      "網",
      "舞",
      "店",
      "噴",
      "縱",
      "寸",
      "汗",
      "掛",
      "洪",
      "賀",
      "閃",
      "柬",
      "爆",
      "烯",
      "津",
      "稻",
      "牆",
      "軟",
      "勇",
      "像",
      "滾",
      "厘",
      "蒙",
      "芳",
      "肯",
      "坡",
      "柱",
      "盪",
      "腿",
      "儀",
      "旅",
      "尾",
      "軋",
      "冰",
      "貢",
      "登",
      "黎",
      "削",
      "鑽",
      "勒",
      "逃",
      "障",
      "氨",
      "郭",
      "峰",
      "幣",
      "港",
      "伏",
      "軌",
      "畝",
      "畢",
      "擦",
      "莫",
      "刺",
      "浪",
      "秘",
      "援",
      "株",
      "健",
      "售",
      "股",
      "島",
      "甘",
      "泡",
      "睡",
      "童",
      "鑄",
      "湯",
      "閥",
      "休",
      "匯",
      "舍",
      "牧",
      "繞",
      "炸",
      "哲",
      "磷",
      "績",
      "朋",
      "淡",
      "尖",
      "啟",
      "陷",
      "柴",
      "呈",
      "徒",
      "顏",
      "淚",
      "稍",
      "忘",
      "泵",
      "藍",
      "拖",
      "洞",
      "授",
      "鏡",
      "辛",
      "壯",
      "鋒",
      "貧",
      "虛",
      "彎",
      "摩",
      "泰",
      "幼",
      "廷",
      "尊",
      "窗",
      "綱",
      "弄",
      "隸",
      "疑",
      "氏",
      "宮",
      "姐",
      "震",
      "瑞",
      "怪",
      "尤",
      "琴",
      "循",
      "描",
      "膜",
      "違",
      "夾",
      "腰",
      "緣",
      "珠",
      "窮",
      "森",
      "枝",
      "竹",
      "溝",
      "催",
      "繩",
      "憶",
      "邦",
      "剩",
      "幸",
      "漿",
      "欄",
      "擁",
      "牙",
      "貯",
      "禮",
      "濾",
      "鈉",
      "紋",
      "罷",
      "拍",
      "咱",
      "喊",
      "袖",
      "埃",
      "勤",
      "罰",
      "焦",
      "潛",
      "伍",
      "墨",
      "欲",
      "縫",
      "姓",
      "刊",
      "飽",
      "仿",
      "獎",
      "鋁",
      "鬼",
      "麗",
      "跨",
      "默",
      "挖",
      "鏈",
      "掃",
      "喝",
      "袋",
      "炭",
      "污",
      "幕",
      "諸",
      "弧",
      "勵",
      "梅",
      "奶",
      "潔",
      "災",
      "舟",
      "鑑",
      "苯",
      "訟",
      "抱",
      "毀",
      "懂",
      "寒",
      "智",
      "埔",
      "寄",
      "屆",
      "躍",
      "渡",
      "挑",
      "丹",
      "艱",
      "貝",
      "碰",
      "拔",
      "爹",
      "戴",
      "碼",
      "夢",
      "芽",
      "熔",
      "赤",
      "漁",
      "哭",
      "敬",
      "顆",
      "奔",
      "鉛",
      "仲",
      "虎",
      "稀",
      "妹",
      "乏",
      "珍",
      "申",
      "桌",
      "遵",
      "允",
      "隆",
      "螺",
      "倉",
      "魏",
      "銳",
      "曉",
      "氮",
      "兼",
      "隱",
      "礙",
      "赫",
      "撥",
      "忠",
      "肅",
      "缸",
      "牽",
      "搶",
      "博",
      "巧",
      "殼",
      "兄",
      "杜",
      "訊",
      "誠",
      "碧",
      "祥",
      "柯",
      "頁",
      "巡",
      "矩",
      "悲",
      "灌",
      "齡",
      "倫",
      "票",
      "尋",
      "桂",
      "鋪",
      "聖",
      "恐",
      "恰",
      "鄭",
      "趣",
      "抬",
      "荒",
      "騰",
      "貼",
      "柔",
      "滴",
      "猛",
      "闊",
      "輛",
      "妻",
      "填",
      "撤",
      "儲",
      "簽",
      "鬧",
      "擾",
      "紫",
      "砂",
      "遞",
      "戲",
      "吊",
      "陶",
      "伐",
      "餵",
      "療",
      "瓶",
      "婆",
      "撫",
      "臂",
      "摸",
      "忍",
      "蝦",
      "蠟",
      "鄰",
      "胸",
      "鞏",
      "擠",
      "偶",
      "棄",
      "槽",
      "勁",
      "乳",
      "鄧",
      "吉",
      "仁",
      "爛",
      "磚",
      "租",
      "烏",
      "艦",
      "伴",
      "瓜",
      "淺",
      "丙",
      "暫",
      "燥",
      "橡",
      "柳",
      "迷",
      "暖",
      "牌",
      "秧",
      "膽",
      "詳",
      "簧",
      "踏",
      "瓷",
      "譜",
      "呆",
      "賓",
      "糊",
      "洛",
      "輝",
      "憤",
      "競",
      "隙",
      "怒",
      "粘",
      "乃",
      "緒",
      "肩",
      "籍",
      "敏",
      "塗",
      "熙",
      "皆",
      "偵",
      "懸",
      "掘",
      "享",
      "糾",
      "醒",
      "狂",
      "鎖",
      "淀",
      "恨",
      "牲",
      "霸",
      "爬",
      "賞",
      "逆",
      "玩",
      "陵",
      "祝",
      "秒",
      "浙",
      "貌",
      "役",
      "彼",
      "悉",
      "鴨",
      "趨",
      "鳳",
      "晨",
      "畜",
      "輩",
      "秩",
      "卵",
      "署",
      "梯",
      "炎",
      "灘",
      "棋",
      "驅",
      "篩",
      "峽",
      "冒",
      "啥",
      "壽",
      "譯",
      "浸",
      "泉",
      "帽",
      "遲",
      "矽",
      "疆",
      "貸",
      "漏",
      "稿",
      "冠",
      "嫩",
      "脅",
      "芯",
      "牢",
      "叛",
      "蝕",
      "奧",
      "鳴",
      "嶺",
      "羊",
      "憑",
      "串",
      "塘",
      "繪",
      "酵",
      "融",
      "盆",
      "錫",
      "廟",
      "籌",
      "凍",
      "輔",
      "攝",
      "襲",
      "筋",
      "拒",
      "僚",
      "旱",
      "鉀",
      "鳥",
      "漆",
      "沈",
      "眉",
      "疏",
      "添",
      "棒",
      "穗",
      "硝",
      "韓",
      "逼",
      "扭",
      "僑",
      "涼",
      "挺",
      "碗",
      "栽",
      "炒",
      "杯",
      "患",
      "餾",
      "勸",
      "豪",
      "遼",
      "勃",
      "鴻",
      "旦",
      "吏",
      "拜",
      "狗",
      "埋",
      "輥",
      "掩",
      "飲",
      "搬",
      "罵",
      "辭",
      "勾",
      "扣",
      "估",
      "蔣",
      "絨",
      "霧",
      "丈",
      "朵",
      "姆",
      "擬",
      "宇",
      "輯",
      "陝",
      "雕",
      "償",
      "蓄",
      "崇",
      "剪",
      "倡",
      "廳",
      "咬",
      "駛",
      "薯",
      "刷",
      "斥",
      "番",
      "賦",
      "奉",
      "佛",
      "澆",
      "漫",
      "曼",
      "扇",
      "鈣",
      "桃",
      "扶",
      "仔",
      "返",
      "俗",
      "虧",
      "腔",
      "鞋",
      "棱",
      "覆",
      "框",
      "悄",
      "叔",
      "撞",
      "騙",
      "勘",
      "旺",
      "沸",
      "孤",
      "吐",
      "孟",
      "渠",
      "屈",
      "疾",
      "妙",
      "惜",
      "仰",
      "狠",
      "脹",
      "諧",
      "拋",
      "黴",
      "桑",
      "崗",
      "嘛",
      "衰",
      "盜",
      "滲",
      "臟",
      "賴",
      "湧",
      "甜",
      "曹",
      "閱",
      "肌",
      "哩",
      "厲",
      "烴",
      "緯",
      "毅",
      "昨",
      "偽",
      "症",
      "煮",
      "嘆",
      "釘",
      "搭",
      "莖",
      "籠",
      "酷",
      "偷",
      "弓",
      "錐",
      "恆",
      "傑",
      "坑",
      "鼻",
      "翼",
      "綸",
      "敘",
      "獄",
      "逮",
      "罐",
      "絡",
      "棚",
      "抑",
      "膨",
      "蔬",
      "寺",
      "驟",
      "穆",
      "冶",
      "枯",
      "冊",
      "屍",
      "凸",
      "紳",
      "坯",
      "犧",
      "焰",
      "轟",
      "欣",
      "晉",
      "瘦",
      "禦",
      "錠",
      "錦",
      "喪",
      "旬",
      "鍛",
      "壟",
      "搜",
      "撲",
      "邀",
      "亭",
      "酯",
      "邁",
      "舒",
      "脆",
      "酶",
      "閒",
      "憂",
      "酚",
      "頑",
      "羽",
      "漲",
      "卸",
      "仗",
      "陪",
      "闢",
      "懲",
      "杭",
      "姚",
      "肚",
      "捉",
      "飄",
      "漂",
      "昆",
      "欺",
      "吾",
      "郎",
      "烷",
      "汁",
      "呵",
      "飾",
      "蕭",
      "雅",
      "郵",
      "遷",
      "燕",
      "撒",
      "姻",
      "赴",
      "宴",
      "煩",
      "債",
      "帳",
      "斑",
      "鈴",
      "旨",
      "醇",
      "董",
      "餅",
      "雛",
      "姿",
      "拌",
      "傅",
      "腹",
      "妥",
      "揉",
      "賢",
      "拆",
      "歪",
      "葡",
      "胺",
      "丟",
      "浩",
      "徽",
      "昂",
      "墊",
      "擋",
      "覽",
      "貪",
      "慰",
      "繳",
      "汪",
      "慌",
      "馮",
      "諾",
      "姜",
      "誼",
      "兇",
      "劣",
      "誣",
      "耀",
      "昏",
      "躺",
      "盈",
      "騎",
      "喬",
      "溪",
      "叢",
      "盧",
      "抹",
      "悶",
      "諮",
      "刮",
      "駕",
      "纜",
      "悟",
      "摘",
      "鉺",
      "擲",
      "頗",
      "幻",
      "柄",
      "惠",
      "慘",
      "佳",
      "仇",
      "臘",
      "窩",
      "滌",
      "劍",
      "瞧",
      "堡",
      "潑",
      "蔥",
      "罩",
      "霍",
      "撈",
      "胎",
      "蒼",
      "濱",
      "倆",
      "捅",
      "湘",
      "砍",
      "霞",
      "邵",
      "萄",
      "瘋",
      "淮",
      "遂",
      "熊",
      "糞",
      "烘",
      "宿",
      "檔",
      "戈",
      "駁",
      "嫂",
      "裕",
      "徙",
      "箭",
      "捐",
      "腸",
      "撐",
      "曬",
      "辨",
      "殿",
      "蓮",
      "攤",
      "攪",
      "醬",
      "屏",
      "疫",
      "哀",
      "蔡",
      "堵",
      "沫",
      "皺",
      "暢",
      "疊",
      "閣",
      "萊",
      "敲",
      "轄",
      "鉤",
      "痕",
      "壩",
      "巷",
      "餓",
      "禍",
      "丘",
      "玄",
      "溜",
      "曰",
      "邏",
      "彭",
      "嘗",
      "卿",
      "妨",
      "艇",
      "吞",
      "韋",
      "怨",
      "矮",
      "歇"
    ];
  }
});

// node_modules/bip39/src/wordlists/korean.json
var require_korean = __commonJS({
  "node_modules/bip39/src/wordlists/korean.json"(exports, module) {
    module.exports = [
      "가격",
      "가끔",
      "가난",
      "가능",
      "가득",
      "가르침",
      "가뭄",
      "가방",
      "가상",
      "가슴",
      "가운데",
      "가을",
      "가이드",
      "가입",
      "가장",
      "가정",
      "가족",
      "가죽",
      "각오",
      "각자",
      "간격",
      "간부",
      "간섭",
      "간장",
      "간접",
      "간판",
      "갈등",
      "갈비",
      "갈색",
      "갈증",
      "감각",
      "감기",
      "감소",
      "감수성",
      "감자",
      "감정",
      "갑자기",
      "강남",
      "강당",
      "강도",
      "강력히",
      "강변",
      "강북",
      "강사",
      "강수량",
      "강아지",
      "강원도",
      "강의",
      "강제",
      "강조",
      "같이",
      "개구리",
      "개나리",
      "개방",
      "개별",
      "개선",
      "개성",
      "개인",
      "객관적",
      "거실",
      "거액",
      "거울",
      "거짓",
      "거품",
      "걱정",
      "건강",
      "건물",
      "건설",
      "건조",
      "건축",
      "걸음",
      "검사",
      "검토",
      "게시판",
      "게임",
      "겨울",
      "견해",
      "결과",
      "결국",
      "결론",
      "결석",
      "결승",
      "결심",
      "결정",
      "결혼",
      "경계",
      "경고",
      "경기",
      "경력",
      "경복궁",
      "경비",
      "경상도",
      "경영",
      "경우",
      "경쟁",
      "경제",
      "경주",
      "경찰",
      "경치",
      "경향",
      "경험",
      "계곡",
      "계단",
      "계란",
      "계산",
      "계속",
      "계약",
      "계절",
      "계층",
      "계획",
      "고객",
      "고구려",
      "고궁",
      "고급",
      "고등학생",
      "고무신",
      "고민",
      "고양이",
      "고장",
      "고전",
      "고집",
      "고춧가루",
      "고통",
      "고향",
      "곡식",
      "골목",
      "골짜기",
      "골프",
      "공간",
      "공개",
      "공격",
      "공군",
      "공급",
      "공기",
      "공동",
      "공무원",
      "공부",
      "공사",
      "공식",
      "공업",
      "공연",
      "공원",
      "공장",
      "공짜",
      "공책",
      "공통",
      "공포",
      "공항",
      "공휴일",
      "과목",
      "과일",
      "과장",
      "과정",
      "과학",
      "관객",
      "관계",
      "관광",
      "관념",
      "관람",
      "관련",
      "관리",
      "관습",
      "관심",
      "관점",
      "관찰",
      "광경",
      "광고",
      "광장",
      "광주",
      "괴로움",
      "굉장히",
      "교과서",
      "교문",
      "교복",
      "교실",
      "교양",
      "교육",
      "교장",
      "교직",
      "교통",
      "교환",
      "교훈",
      "구경",
      "구름",
      "구멍",
      "구별",
      "구분",
      "구석",
      "구성",
      "구속",
      "구역",
      "구입",
      "구청",
      "구체적",
      "국가",
      "국기",
      "국내",
      "국립",
      "국물",
      "국민",
      "국수",
      "국어",
      "국왕",
      "국적",
      "국제",
      "국회",
      "군대",
      "군사",
      "군인",
      "궁극적",
      "권리",
      "권위",
      "권투",
      "귀국",
      "귀신",
      "규정",
      "규칙",
      "균형",
      "그날",
      "그냥",
      "그늘",
      "그러나",
      "그룹",
      "그릇",
      "그림",
      "그제서야",
      "그토록",
      "극복",
      "극히",
      "근거",
      "근교",
      "근래",
      "근로",
      "근무",
      "근본",
      "근원",
      "근육",
      "근처",
      "글씨",
      "글자",
      "금강산",
      "금고",
      "금년",
      "금메달",
      "금액",
      "금연",
      "금요일",
      "금지",
      "긍정적",
      "기간",
      "기관",
      "기념",
      "기능",
      "기독교",
      "기둥",
      "기록",
      "기름",
      "기법",
      "기본",
      "기분",
      "기쁨",
      "기숙사",
      "기술",
      "기억",
      "기업",
      "기온",
      "기운",
      "기원",
      "기적",
      "기준",
      "기침",
      "기혼",
      "기획",
      "긴급",
      "긴장",
      "길이",
      "김밥",
      "김치",
      "김포공항",
      "깍두기",
      "깜빡",
      "깨달음",
      "깨소금",
      "껍질",
      "꼭대기",
      "꽃잎",
      "나들이",
      "나란히",
      "나머지",
      "나물",
      "나침반",
      "나흘",
      "낙엽",
      "난방",
      "날개",
      "날씨",
      "날짜",
      "남녀",
      "남대문",
      "남매",
      "남산",
      "남자",
      "남편",
      "남학생",
      "낭비",
      "낱말",
      "내년",
      "내용",
      "내일",
      "냄비",
      "냄새",
      "냇물",
      "냉동",
      "냉면",
      "냉방",
      "냉장고",
      "넥타이",
      "넷째",
      "노동",
      "노란색",
      "노력",
      "노인",
      "녹음",
      "녹차",
      "녹화",
      "논리",
      "논문",
      "논쟁",
      "놀이",
      "농구",
      "농담",
      "농민",
      "농부",
      "농업",
      "농장",
      "농촌",
      "높이",
      "눈동자",
      "눈물",
      "눈썹",
      "뉴욕",
      "느낌",
      "늑대",
      "능동적",
      "능력",
      "다방",
      "다양성",
      "다음",
      "다이어트",
      "다행",
      "단계",
      "단골",
      "단독",
      "단맛",
      "단순",
      "단어",
      "단위",
      "단점",
      "단체",
      "단추",
      "단편",
      "단풍",
      "달걀",
      "달러",
      "달력",
      "달리",
      "닭고기",
      "담당",
      "담배",
      "담요",
      "담임",
      "답변",
      "답장",
      "당근",
      "당분간",
      "당연히",
      "당장",
      "대규모",
      "대낮",
      "대단히",
      "대답",
      "대도시",
      "대략",
      "대량",
      "대륙",
      "대문",
      "대부분",
      "대신",
      "대응",
      "대장",
      "대전",
      "대접",
      "대중",
      "대책",
      "대출",
      "대충",
      "대통령",
      "대학",
      "대한민국",
      "대합실",
      "대형",
      "덩어리",
      "데이트",
      "도대체",
      "도덕",
      "도둑",
      "도망",
      "도서관",
      "도심",
      "도움",
      "도입",
      "도자기",
      "도저히",
      "도전",
      "도중",
      "도착",
      "독감",
      "독립",
      "독서",
      "독일",
      "독창적",
      "동화책",
      "뒷모습",
      "뒷산",
      "딸아이",
      "마누라",
      "마늘",
      "마당",
      "마라톤",
      "마련",
      "마무리",
      "마사지",
      "마약",
      "마요네즈",
      "마을",
      "마음",
      "마이크",
      "마중",
      "마지막",
      "마찬가지",
      "마찰",
      "마흔",
      "막걸리",
      "막내",
      "막상",
      "만남",
      "만두",
      "만세",
      "만약",
      "만일",
      "만점",
      "만족",
      "만화",
      "많이",
      "말기",
      "말씀",
      "말투",
      "맘대로",
      "망원경",
      "매년",
      "매달",
      "매력",
      "매번",
      "매스컴",
      "매일",
      "매장",
      "맥주",
      "먹이",
      "먼저",
      "먼지",
      "멀리",
      "메일",
      "며느리",
      "며칠",
      "면담",
      "멸치",
      "명단",
      "명령",
      "명예",
      "명의",
      "명절",
      "명칭",
      "명함",
      "모금",
      "모니터",
      "모델",
      "모든",
      "모범",
      "모습",
      "모양",
      "모임",
      "모조리",
      "모집",
      "모퉁이",
      "목걸이",
      "목록",
      "목사",
      "목소리",
      "목숨",
      "목적",
      "목표",
      "몰래",
      "몸매",
      "몸무게",
      "몸살",
      "몸속",
      "몸짓",
      "몸통",
      "몹시",
      "무관심",
      "무궁화",
      "무더위",
      "무덤",
      "무릎",
      "무슨",
      "무엇",
      "무역",
      "무용",
      "무조건",
      "무지개",
      "무척",
      "문구",
      "문득",
      "문법",
      "문서",
      "문제",
      "문학",
      "문화",
      "물가",
      "물건",
      "물결",
      "물고기",
      "물론",
      "물리학",
      "물음",
      "물질",
      "물체",
      "미국",
      "미디어",
      "미사일",
      "미술",
      "미역",
      "미용실",
      "미움",
      "미인",
      "미팅",
      "미혼",
      "민간",
      "민족",
      "민주",
      "믿음",
      "밀가루",
      "밀리미터",
      "밑바닥",
      "바가지",
      "바구니",
      "바나나",
      "바늘",
      "바닥",
      "바닷가",
      "바람",
      "바이러스",
      "바탕",
      "박물관",
      "박사",
      "박수",
      "반대",
      "반드시",
      "반말",
      "반발",
      "반성",
      "반응",
      "반장",
      "반죽",
      "반지",
      "반찬",
      "받침",
      "발가락",
      "발걸음",
      "발견",
      "발달",
      "발레",
      "발목",
      "발바닥",
      "발생",
      "발음",
      "발자국",
      "발전",
      "발톱",
      "발표",
      "밤하늘",
      "밥그릇",
      "밥맛",
      "밥상",
      "밥솥",
      "방금",
      "방면",
      "방문",
      "방바닥",
      "방법",
      "방송",
      "방식",
      "방안",
      "방울",
      "방지",
      "방학",
      "방해",
      "방향",
      "배경",
      "배꼽",
      "배달",
      "배드민턴",
      "백두산",
      "백색",
      "백성",
      "백인",
      "백제",
      "백화점",
      "버릇",
      "버섯",
      "버튼",
      "번개",
      "번역",
      "번지",
      "번호",
      "벌금",
      "벌레",
      "벌써",
      "범위",
      "범인",
      "범죄",
      "법률",
      "법원",
      "법적",
      "법칙",
      "베이징",
      "벨트",
      "변경",
      "변동",
      "변명",
      "변신",
      "변호사",
      "변화",
      "별도",
      "별명",
      "별일",
      "병실",
      "병아리",
      "병원",
      "보관",
      "보너스",
      "보라색",
      "보람",
      "보름",
      "보상",
      "보안",
      "보자기",
      "보장",
      "보전",
      "보존",
      "보통",
      "보편적",
      "보험",
      "복도",
      "복사",
      "복숭아",
      "복습",
      "볶음",
      "본격적",
      "본래",
      "본부",
      "본사",
      "본성",
      "본인",
      "본질",
      "볼펜",
      "봉사",
      "봉지",
      "봉투",
      "부근",
      "부끄러움",
      "부담",
      "부동산",
      "부문",
      "부분",
      "부산",
      "부상",
      "부엌",
      "부인",
      "부작용",
      "부장",
      "부정",
      "부족",
      "부지런히",
      "부친",
      "부탁",
      "부품",
      "부회장",
      "북부",
      "북한",
      "분노",
      "분량",
      "분리",
      "분명",
      "분석",
      "분야",
      "분위기",
      "분필",
      "분홍색",
      "불고기",
      "불과",
      "불교",
      "불꽃",
      "불만",
      "불법",
      "불빛",
      "불안",
      "불이익",
      "불행",
      "브랜드",
      "비극",
      "비난",
      "비닐",
      "비둘기",
      "비디오",
      "비로소",
      "비만",
      "비명",
      "비밀",
      "비바람",
      "비빔밥",
      "비상",
      "비용",
      "비율",
      "비중",
      "비타민",
      "비판",
      "빌딩",
      "빗물",
      "빗방울",
      "빗줄기",
      "빛깔",
      "빨간색",
      "빨래",
      "빨리",
      "사건",
      "사계절",
      "사나이",
      "사냥",
      "사람",
      "사랑",
      "사립",
      "사모님",
      "사물",
      "사방",
      "사상",
      "사생활",
      "사설",
      "사슴",
      "사실",
      "사업",
      "사용",
      "사월",
      "사장",
      "사전",
      "사진",
      "사촌",
      "사춘기",
      "사탕",
      "사투리",
      "사흘",
      "산길",
      "산부인과",
      "산업",
      "산책",
      "살림",
      "살인",
      "살짝",
      "삼계탕",
      "삼국",
      "삼십",
      "삼월",
      "삼촌",
      "상관",
      "상금",
      "상대",
      "상류",
      "상반기",
      "상상",
      "상식",
      "상업",
      "상인",
      "상자",
      "상점",
      "상처",
      "상추",
      "상태",
      "상표",
      "상품",
      "상황",
      "새벽",
      "색깔",
      "색연필",
      "생각",
      "생명",
      "생물",
      "생방송",
      "생산",
      "생선",
      "생신",
      "생일",
      "생활",
      "서랍",
      "서른",
      "서명",
      "서민",
      "서비스",
      "서양",
      "서울",
      "서적",
      "서점",
      "서쪽",
      "서클",
      "석사",
      "석유",
      "선거",
      "선물",
      "선배",
      "선생",
      "선수",
      "선원",
      "선장",
      "선전",
      "선택",
      "선풍기",
      "설거지",
      "설날",
      "설렁탕",
      "설명",
      "설문",
      "설사",
      "설악산",
      "설치",
      "설탕",
      "섭씨",
      "성공",
      "성당",
      "성명",
      "성별",
      "성인",
      "성장",
      "성적",
      "성질",
      "성함",
      "세금",
      "세미나",
      "세상",
      "세월",
      "세종대왕",
      "세탁",
      "센터",
      "센티미터",
      "셋째",
      "소규모",
      "소극적",
      "소금",
      "소나기",
      "소년",
      "소득",
      "소망",
      "소문",
      "소설",
      "소속",
      "소아과",
      "소용",
      "소원",
      "소음",
      "소중히",
      "소지품",
      "소질",
      "소풍",
      "소형",
      "속담",
      "속도",
      "속옷",
      "손가락",
      "손길",
      "손녀",
      "손님",
      "손등",
      "손목",
      "손뼉",
      "손실",
      "손질",
      "손톱",
      "손해",
      "솔직히",
      "솜씨",
      "송아지",
      "송이",
      "송편",
      "쇠고기",
      "쇼핑",
      "수건",
      "수년",
      "수단",
      "수돗물",
      "수동적",
      "수면",
      "수명",
      "수박",
      "수상",
      "수석",
      "수술",
      "수시로",
      "수업",
      "수염",
      "수영",
      "수입",
      "수준",
      "수집",
      "수출",
      "수컷",
      "수필",
      "수학",
      "수험생",
      "수화기",
      "숙녀",
      "숙소",
      "숙제",
      "순간",
      "순서",
      "순수",
      "순식간",
      "순위",
      "숟가락",
      "술병",
      "술집",
      "숫자",
      "스님",
      "스물",
      "스스로",
      "스승",
      "스웨터",
      "스위치",
      "스케이트",
      "스튜디오",
      "스트레스",
      "스포츠",
      "슬쩍",
      "슬픔",
      "습관",
      "습기",
      "승객",
      "승리",
      "승부",
      "승용차",
      "승진",
      "시각",
      "시간",
      "시골",
      "시금치",
      "시나리오",
      "시댁",
      "시리즈",
      "시멘트",
      "시민",
      "시부모",
      "시선",
      "시설",
      "시스템",
      "시아버지",
      "시어머니",
      "시월",
      "시인",
      "시일",
      "시작",
      "시장",
      "시절",
      "시점",
      "시중",
      "시즌",
      "시집",
      "시청",
      "시합",
      "시험",
      "식구",
      "식기",
      "식당",
      "식량",
      "식료품",
      "식물",
      "식빵",
      "식사",
      "식생활",
      "식초",
      "식탁",
      "식품",
      "신고",
      "신규",
      "신념",
      "신문",
      "신발",
      "신비",
      "신사",
      "신세",
      "신용",
      "신제품",
      "신청",
      "신체",
      "신화",
      "실감",
      "실내",
      "실력",
      "실례",
      "실망",
      "실수",
      "실습",
      "실시",
      "실장",
      "실정",
      "실질적",
      "실천",
      "실체",
      "실컷",
      "실태",
      "실패",
      "실험",
      "실현",
      "심리",
      "심부름",
      "심사",
      "심장",
      "심정",
      "심판",
      "쌍둥이",
      "씨름",
      "씨앗",
      "아가씨",
      "아나운서",
      "아드님",
      "아들",
      "아쉬움",
      "아스팔트",
      "아시아",
      "아울러",
      "아저씨",
      "아줌마",
      "아직",
      "아침",
      "아파트",
      "아프리카",
      "아픔",
      "아홉",
      "아흔",
      "악기",
      "악몽",
      "악수",
      "안개",
      "안경",
      "안과",
      "안내",
      "안녕",
      "안동",
      "안방",
      "안부",
      "안주",
      "알루미늄",
      "알코올",
      "암시",
      "암컷",
      "압력",
      "앞날",
      "앞문",
      "애인",
      "애정",
      "액수",
      "앨범",
      "야간",
      "야단",
      "야옹",
      "약간",
      "약국",
      "약속",
      "약수",
      "약점",
      "약품",
      "약혼녀",
      "양념",
      "양력",
      "양말",
      "양배추",
      "양주",
      "양파",
      "어둠",
      "어려움",
      "어른",
      "어젯밤",
      "어쨌든",
      "어쩌다가",
      "어쩐지",
      "언니",
      "언덕",
      "언론",
      "언어",
      "얼굴",
      "얼른",
      "얼음",
      "얼핏",
      "엄마",
      "업무",
      "업종",
      "업체",
      "엉덩이",
      "엉망",
      "엉터리",
      "엊그제",
      "에너지",
      "에어컨",
      "엔진",
      "여건",
      "여고생",
      "여관",
      "여군",
      "여권",
      "여대생",
      "여덟",
      "여동생",
      "여든",
      "여론",
      "여름",
      "여섯",
      "여성",
      "여왕",
      "여인",
      "여전히",
      "여직원",
      "여학생",
      "여행",
      "역사",
      "역시",
      "역할",
      "연결",
      "연구",
      "연극",
      "연기",
      "연락",
      "연설",
      "연세",
      "연속",
      "연습",
      "연애",
      "연예인",
      "연인",
      "연장",
      "연주",
      "연출",
      "연필",
      "연합",
      "연휴",
      "열기",
      "열매",
      "열쇠",
      "열심히",
      "열정",
      "열차",
      "열흘",
      "염려",
      "엽서",
      "영국",
      "영남",
      "영상",
      "영양",
      "영역",
      "영웅",
      "영원히",
      "영하",
      "영향",
      "영혼",
      "영화",
      "옆구리",
      "옆방",
      "옆집",
      "예감",
      "예금",
      "예방",
      "예산",
      "예상",
      "예선",
      "예술",
      "예습",
      "예식장",
      "예약",
      "예전",
      "예절",
      "예정",
      "예컨대",
      "옛날",
      "오늘",
      "오락",
      "오랫동안",
      "오렌지",
      "오로지",
      "오른발",
      "오븐",
      "오십",
      "오염",
      "오월",
      "오전",
      "오직",
      "오징어",
      "오페라",
      "오피스텔",
      "오히려",
      "옥상",
      "옥수수",
      "온갖",
      "온라인",
      "온몸",
      "온종일",
      "온통",
      "올가을",
      "올림픽",
      "올해",
      "옷차림",
      "와이셔츠",
      "와인",
      "완성",
      "완전",
      "왕비",
      "왕자",
      "왜냐하면",
      "왠지",
      "외갓집",
      "외국",
      "외로움",
      "외삼촌",
      "외출",
      "외침",
      "외할머니",
      "왼발",
      "왼손",
      "왼쪽",
      "요금",
      "요일",
      "요즘",
      "요청",
      "용기",
      "용서",
      "용어",
      "우산",
      "우선",
      "우승",
      "우연히",
      "우정",
      "우체국",
      "우편",
      "운동",
      "운명",
      "운반",
      "운전",
      "운행",
      "울산",
      "울음",
      "움직임",
      "웃어른",
      "웃음",
      "워낙",
      "원고",
      "원래",
      "원서",
      "원숭이",
      "원인",
      "원장",
      "원피스",
      "월급",
      "월드컵",
      "월세",
      "월요일",
      "웨이터",
      "위반",
      "위법",
      "위성",
      "위원",
      "위험",
      "위협",
      "윗사람",
      "유난히",
      "유럽",
      "유명",
      "유물",
      "유산",
      "유적",
      "유치원",
      "유학",
      "유행",
      "유형",
      "육군",
      "육상",
      "육십",
      "육체",
      "은행",
      "음력",
      "음료",
      "음반",
      "음성",
      "음식",
      "음악",
      "음주",
      "의견",
      "의논",
      "의문",
      "의복",
      "의식",
      "의심",
      "의외로",
      "의욕",
      "의원",
      "의학",
      "이것",
      "이곳",
      "이념",
      "이놈",
      "이달",
      "이대로",
      "이동",
      "이렇게",
      "이력서",
      "이론적",
      "이름",
      "이민",
      "이발소",
      "이별",
      "이불",
      "이빨",
      "이상",
      "이성",
      "이슬",
      "이야기",
      "이용",
      "이웃",
      "이월",
      "이윽고",
      "이익",
      "이전",
      "이중",
      "이튿날",
      "이틀",
      "이혼",
      "인간",
      "인격",
      "인공",
      "인구",
      "인근",
      "인기",
      "인도",
      "인류",
      "인물",
      "인생",
      "인쇄",
      "인연",
      "인원",
      "인재",
      "인종",
      "인천",
      "인체",
      "인터넷",
      "인하",
      "인형",
      "일곱",
      "일기",
      "일단",
      "일대",
      "일등",
      "일반",
      "일본",
      "일부",
      "일상",
      "일생",
      "일손",
      "일요일",
      "일월",
      "일정",
      "일종",
      "일주일",
      "일찍",
      "일체",
      "일치",
      "일행",
      "일회용",
      "임금",
      "임무",
      "입대",
      "입력",
      "입맛",
      "입사",
      "입술",
      "입시",
      "입원",
      "입장",
      "입학",
      "자가용",
      "자격",
      "자극",
      "자동",
      "자랑",
      "자부심",
      "자식",
      "자신",
      "자연",
      "자원",
      "자율",
      "자전거",
      "자정",
      "자존심",
      "자판",
      "작가",
      "작년",
      "작성",
      "작업",
      "작용",
      "작은딸",
      "작품",
      "잔디",
      "잔뜩",
      "잔치",
      "잘못",
      "잠깐",
      "잠수함",
      "잠시",
      "잠옷",
      "잠자리",
      "잡지",
      "장관",
      "장군",
      "장기간",
      "장래",
      "장례",
      "장르",
      "장마",
      "장면",
      "장모",
      "장미",
      "장비",
      "장사",
      "장소",
      "장식",
      "장애인",
      "장인",
      "장점",
      "장차",
      "장학금",
      "재능",
      "재빨리",
      "재산",
      "재생",
      "재작년",
      "재정",
      "재채기",
      "재판",
      "재학",
      "재활용",
      "저것",
      "저고리",
      "저곳",
      "저녁",
      "저런",
      "저렇게",
      "저번",
      "저울",
      "저절로",
      "저축",
      "적극",
      "적당히",
      "적성",
      "적용",
      "적응",
      "전개",
      "전공",
      "전기",
      "전달",
      "전라도",
      "전망",
      "전문",
      "전반",
      "전부",
      "전세",
      "전시",
      "전용",
      "전자",
      "전쟁",
      "전주",
      "전철",
      "전체",
      "전통",
      "전혀",
      "전후",
      "절대",
      "절망",
      "절반",
      "절약",
      "절차",
      "점검",
      "점수",
      "점심",
      "점원",
      "점점",
      "점차",
      "접근",
      "접시",
      "접촉",
      "젓가락",
      "정거장",
      "정도",
      "정류장",
      "정리",
      "정말",
      "정면",
      "정문",
      "정반대",
      "정보",
      "정부",
      "정비",
      "정상",
      "정성",
      "정오",
      "정원",
      "정장",
      "정지",
      "정치",
      "정확히",
      "제공",
      "제과점",
      "제대로",
      "제목",
      "제발",
      "제법",
      "제삿날",
      "제안",
      "제일",
      "제작",
      "제주도",
      "제출",
      "제품",
      "제한",
      "조각",
      "조건",
      "조금",
      "조깅",
      "조명",
      "조미료",
      "조상",
      "조선",
      "조용히",
      "조절",
      "조정",
      "조직",
      "존댓말",
      "존재",
      "졸업",
      "졸음",
      "종교",
      "종로",
      "종류",
      "종소리",
      "종업원",
      "종종",
      "종합",
      "좌석",
      "죄인",
      "주관적",
      "주름",
      "주말",
      "주머니",
      "주먹",
      "주문",
      "주민",
      "주방",
      "주변",
      "주식",
      "주인",
      "주일",
      "주장",
      "주전자",
      "주택",
      "준비",
      "줄거리",
      "줄기",
      "줄무늬",
      "중간",
      "중계방송",
      "중국",
      "중년",
      "중단",
      "중독",
      "중반",
      "중부",
      "중세",
      "중소기업",
      "중순",
      "중앙",
      "중요",
      "중학교",
      "즉석",
      "즉시",
      "즐거움",
      "증가",
      "증거",
      "증권",
      "증상",
      "증세",
      "지각",
      "지갑",
      "지경",
      "지극히",
      "지금",
      "지급",
      "지능",
      "지름길",
      "지리산",
      "지방",
      "지붕",
      "지식",
      "지역",
      "지우개",
      "지원",
      "지적",
      "지점",
      "지진",
      "지출",
      "직선",
      "직업",
      "직원",
      "직장",
      "진급",
      "진동",
      "진로",
      "진료",
      "진리",
      "진짜",
      "진찰",
      "진출",
      "진통",
      "진행",
      "질문",
      "질병",
      "질서",
      "짐작",
      "집단",
      "집안",
      "집중",
      "짜증",
      "찌꺼기",
      "차남",
      "차라리",
      "차량",
      "차림",
      "차별",
      "차선",
      "차츰",
      "착각",
      "찬물",
      "찬성",
      "참가",
      "참기름",
      "참새",
      "참석",
      "참여",
      "참외",
      "참조",
      "찻잔",
      "창가",
      "창고",
      "창구",
      "창문",
      "창밖",
      "창작",
      "창조",
      "채널",
      "채점",
      "책가방",
      "책방",
      "책상",
      "책임",
      "챔피언",
      "처벌",
      "처음",
      "천국",
      "천둥",
      "천장",
      "천재",
      "천천히",
      "철도",
      "철저히",
      "철학",
      "첫날",
      "첫째",
      "청년",
      "청바지",
      "청소",
      "청춘",
      "체계",
      "체력",
      "체온",
      "체육",
      "체중",
      "체험",
      "초등학생",
      "초반",
      "초밥",
      "초상화",
      "초순",
      "초여름",
      "초원",
      "초저녁",
      "초점",
      "초청",
      "초콜릿",
      "촛불",
      "총각",
      "총리",
      "총장",
      "촬영",
      "최근",
      "최상",
      "최선",
      "최신",
      "최악",
      "최종",
      "추석",
      "추억",
      "추진",
      "추천",
      "추측",
      "축구",
      "축소",
      "축제",
      "축하",
      "출근",
      "출발",
      "출산",
      "출신",
      "출연",
      "출입",
      "출장",
      "출판",
      "충격",
      "충고",
      "충돌",
      "충분히",
      "충청도",
      "취업",
      "취직",
      "취향",
      "치약",
      "친구",
      "친척",
      "칠십",
      "칠월",
      "칠판",
      "침대",
      "침묵",
      "침실",
      "칫솔",
      "칭찬",
      "카메라",
      "카운터",
      "칼국수",
      "캐릭터",
      "캠퍼스",
      "캠페인",
      "커튼",
      "컨디션",
      "컬러",
      "컴퓨터",
      "코끼리",
      "코미디",
      "콘서트",
      "콜라",
      "콤플렉스",
      "콩나물",
      "쾌감",
      "쿠데타",
      "크림",
      "큰길",
      "큰딸",
      "큰소리",
      "큰아들",
      "큰어머니",
      "큰일",
      "큰절",
      "클래식",
      "클럽",
      "킬로",
      "타입",
      "타자기",
      "탁구",
      "탁자",
      "탄생",
      "태권도",
      "태양",
      "태풍",
      "택시",
      "탤런트",
      "터널",
      "터미널",
      "테니스",
      "테스트",
      "테이블",
      "텔레비전",
      "토론",
      "토마토",
      "토요일",
      "통계",
      "통과",
      "통로",
      "통신",
      "통역",
      "통일",
      "통장",
      "통제",
      "통증",
      "통합",
      "통화",
      "퇴근",
      "퇴원",
      "퇴직금",
      "튀김",
      "트럭",
      "특급",
      "특별",
      "특성",
      "특수",
      "특징",
      "특히",
      "튼튼히",
      "티셔츠",
      "파란색",
      "파일",
      "파출소",
      "판결",
      "판단",
      "판매",
      "판사",
      "팔십",
      "팔월",
      "팝송",
      "패션",
      "팩스",
      "팩시밀리",
      "팬티",
      "퍼센트",
      "페인트",
      "편견",
      "편의",
      "편지",
      "편히",
      "평가",
      "평균",
      "평생",
      "평소",
      "평양",
      "평일",
      "평화",
      "포스터",
      "포인트",
      "포장",
      "포함",
      "표면",
      "표정",
      "표준",
      "표현",
      "품목",
      "품질",
      "풍경",
      "풍속",
      "풍습",
      "프랑스",
      "프린터",
      "플라스틱",
      "피곤",
      "피망",
      "피아노",
      "필름",
      "필수",
      "필요",
      "필자",
      "필통",
      "핑계",
      "하느님",
      "하늘",
      "하드웨어",
      "하룻밤",
      "하반기",
      "하숙집",
      "하순",
      "하여튼",
      "하지만",
      "하천",
      "하품",
      "하필",
      "학과",
      "학교",
      "학급",
      "학기",
      "학년",
      "학력",
      "학번",
      "학부모",
      "학비",
      "학생",
      "학술",
      "학습",
      "학용품",
      "학원",
      "학위",
      "학자",
      "학점",
      "한계",
      "한글",
      "한꺼번에",
      "한낮",
      "한눈",
      "한동안",
      "한때",
      "한라산",
      "한마디",
      "한문",
      "한번",
      "한복",
      "한식",
      "한여름",
      "한쪽",
      "할머니",
      "할아버지",
      "할인",
      "함께",
      "함부로",
      "합격",
      "합리적",
      "항공",
      "항구",
      "항상",
      "항의",
      "해결",
      "해군",
      "해답",
      "해당",
      "해물",
      "해석",
      "해설",
      "해수욕장",
      "해안",
      "핵심",
      "핸드백",
      "햄버거",
      "햇볕",
      "햇살",
      "행동",
      "행복",
      "행사",
      "행운",
      "행위",
      "향기",
      "향상",
      "향수",
      "허락",
      "허용",
      "헬기",
      "현관",
      "현금",
      "현대",
      "현상",
      "현실",
      "현장",
      "현재",
      "현지",
      "혈액",
      "협력",
      "형부",
      "형사",
      "형수",
      "형식",
      "형제",
      "형태",
      "형편",
      "혜택",
      "호기심",
      "호남",
      "호랑이",
      "호박",
      "호텔",
      "호흡",
      "혹시",
      "홀로",
      "홈페이지",
      "홍보",
      "홍수",
      "홍차",
      "화면",
      "화분",
      "화살",
      "화요일",
      "화장",
      "화학",
      "확보",
      "확인",
      "확장",
      "확정",
      "환갑",
      "환경",
      "환영",
      "환율",
      "환자",
      "활기",
      "활동",
      "활발히",
      "활용",
      "활짝",
      "회견",
      "회관",
      "회복",
      "회색",
      "회원",
      "회장",
      "회전",
      "횟수",
      "횡단보도",
      "효율적",
      "후반",
      "후춧가루",
      "훈련",
      "훨씬",
      "휴식",
      "휴일",
      "흉내",
      "흐름",
      "흑백",
      "흑인",
      "흔적",
      "흔히",
      "흥미",
      "흥분",
      "희곡",
      "희망",
      "희생",
      "흰색",
      "힘껏"
    ];
  }
});

// node_modules/bip39/src/wordlists/french.json
var require_french = __commonJS({
  "node_modules/bip39/src/wordlists/french.json"(exports, module) {
    module.exports = [
      "abaisser",
      "abandon",
      "abdiquer",
      "abeille",
      "abolir",
      "aborder",
      "aboutir",
      "aboyer",
      "abrasif",
      "abreuver",
      "abriter",
      "abroger",
      "abrupt",
      "absence",
      "absolu",
      "absurde",
      "abusif",
      "abyssal",
      "académie",
      "acajou",
      "acarien",
      "accabler",
      "accepter",
      "acclamer",
      "accolade",
      "accroche",
      "accuser",
      "acerbe",
      "achat",
      "acheter",
      "aciduler",
      "acier",
      "acompte",
      "acquérir",
      "acronyme",
      "acteur",
      "actif",
      "actuel",
      "adepte",
      "adéquat",
      "adhésif",
      "adjectif",
      "adjuger",
      "admettre",
      "admirer",
      "adopter",
      "adorer",
      "adoucir",
      "adresse",
      "adroit",
      "adulte",
      "adverbe",
      "aérer",
      "aéronef",
      "affaire",
      "affecter",
      "affiche",
      "affreux",
      "affubler",
      "agacer",
      "agencer",
      "agile",
      "agiter",
      "agrafer",
      "agréable",
      "agrume",
      "aider",
      "aiguille",
      "ailier",
      "aimable",
      "aisance",
      "ajouter",
      "ajuster",
      "alarmer",
      "alchimie",
      "alerte",
      "algèbre",
      "algue",
      "aliéner",
      "aliment",
      "alléger",
      "alliage",
      "allouer",
      "allumer",
      "alourdir",
      "alpaga",
      "altesse",
      "alvéole",
      "amateur",
      "ambigu",
      "ambre",
      "aménager",
      "amertume",
      "amidon",
      "amiral",
      "amorcer",
      "amour",
      "amovible",
      "amphibie",
      "ampleur",
      "amusant",
      "analyse",
      "anaphore",
      "anarchie",
      "anatomie",
      "ancien",
      "anéantir",
      "angle",
      "angoisse",
      "anguleux",
      "animal",
      "annexer",
      "annonce",
      "annuel",
      "anodin",
      "anomalie",
      "anonyme",
      "anormal",
      "antenne",
      "antidote",
      "anxieux",
      "apaiser",
      "apéritif",
      "aplanir",
      "apologie",
      "appareil",
      "appeler",
      "apporter",
      "appuyer",
      "aquarium",
      "aqueduc",
      "arbitre",
      "arbuste",
      "ardeur",
      "ardoise",
      "argent",
      "arlequin",
      "armature",
      "armement",
      "armoire",
      "armure",
      "arpenter",
      "arracher",
      "arriver",
      "arroser",
      "arsenic",
      "artériel",
      "article",
      "aspect",
      "asphalte",
      "aspirer",
      "assaut",
      "asservir",
      "assiette",
      "associer",
      "assurer",
      "asticot",
      "astre",
      "astuce",
      "atelier",
      "atome",
      "atrium",
      "atroce",
      "attaque",
      "attentif",
      "attirer",
      "attraper",
      "aubaine",
      "auberge",
      "audace",
      "audible",
      "augurer",
      "aurore",
      "automne",
      "autruche",
      "avaler",
      "avancer",
      "avarice",
      "avenir",
      "averse",
      "aveugle",
      "aviateur",
      "avide",
      "avion",
      "aviser",
      "avoine",
      "avouer",
      "avril",
      "axial",
      "axiome",
      "badge",
      "bafouer",
      "bagage",
      "baguette",
      "baignade",
      "balancer",
      "balcon",
      "baleine",
      "balisage",
      "bambin",
      "bancaire",
      "bandage",
      "banlieue",
      "bannière",
      "banquier",
      "barbier",
      "baril",
      "baron",
      "barque",
      "barrage",
      "bassin",
      "bastion",
      "bataille",
      "bateau",
      "batterie",
      "baudrier",
      "bavarder",
      "belette",
      "bélier",
      "belote",
      "bénéfice",
      "berceau",
      "berger",
      "berline",
      "bermuda",
      "besace",
      "besogne",
      "bétail",
      "beurre",
      "biberon",
      "bicycle",
      "bidule",
      "bijou",
      "bilan",
      "bilingue",
      "billard",
      "binaire",
      "biologie",
      "biopsie",
      "biotype",
      "biscuit",
      "bison",
      "bistouri",
      "bitume",
      "bizarre",
      "blafard",
      "blague",
      "blanchir",
      "blessant",
      "blinder",
      "blond",
      "bloquer",
      "blouson",
      "bobard",
      "bobine",
      "boire",
      "boiser",
      "bolide",
      "bonbon",
      "bondir",
      "bonheur",
      "bonifier",
      "bonus",
      "bordure",
      "borne",
      "botte",
      "boucle",
      "boueux",
      "bougie",
      "boulon",
      "bouquin",
      "bourse",
      "boussole",
      "boutique",
      "boxeur",
      "branche",
      "brasier",
      "brave",
      "brebis",
      "brèche",
      "breuvage",
      "bricoler",
      "brigade",
      "brillant",
      "brioche",
      "brique",
      "brochure",
      "broder",
      "bronzer",
      "brousse",
      "broyeur",
      "brume",
      "brusque",
      "brutal",
      "bruyant",
      "buffle",
      "buisson",
      "bulletin",
      "bureau",
      "burin",
      "bustier",
      "butiner",
      "butoir",
      "buvable",
      "buvette",
      "cabanon",
      "cabine",
      "cachette",
      "cadeau",
      "cadre",
      "caféine",
      "caillou",
      "caisson",
      "calculer",
      "calepin",
      "calibre",
      "calmer",
      "calomnie",
      "calvaire",
      "camarade",
      "caméra",
      "camion",
      "campagne",
      "canal",
      "caneton",
      "canon",
      "cantine",
      "canular",
      "capable",
      "caporal",
      "caprice",
      "capsule",
      "capter",
      "capuche",
      "carabine",
      "carbone",
      "caresser",
      "caribou",
      "carnage",
      "carotte",
      "carreau",
      "carton",
      "cascade",
      "casier",
      "casque",
      "cassure",
      "causer",
      "caution",
      "cavalier",
      "caverne",
      "caviar",
      "cédille",
      "ceinture",
      "céleste",
      "cellule",
      "cendrier",
      "censurer",
      "central",
      "cercle",
      "cérébral",
      "cerise",
      "cerner",
      "cerveau",
      "cesser",
      "chagrin",
      "chaise",
      "chaleur",
      "chambre",
      "chance",
      "chapitre",
      "charbon",
      "chasseur",
      "chaton",
      "chausson",
      "chavirer",
      "chemise",
      "chenille",
      "chéquier",
      "chercher",
      "cheval",
      "chien",
      "chiffre",
      "chignon",
      "chimère",
      "chiot",
      "chlorure",
      "chocolat",
      "choisir",
      "chose",
      "chouette",
      "chrome",
      "chute",
      "cigare",
      "cigogne",
      "cimenter",
      "cinéma",
      "cintrer",
      "circuler",
      "cirer",
      "cirque",
      "citerne",
      "citoyen",
      "citron",
      "civil",
      "clairon",
      "clameur",
      "claquer",
      "classe",
      "clavier",
      "client",
      "cligner",
      "climat",
      "clivage",
      "cloche",
      "clonage",
      "cloporte",
      "cobalt",
      "cobra",
      "cocasse",
      "cocotier",
      "coder",
      "codifier",
      "coffre",
      "cogner",
      "cohésion",
      "coiffer",
      "coincer",
      "colère",
      "colibri",
      "colline",
      "colmater",
      "colonel",
      "combat",
      "comédie",
      "commande",
      "compact",
      "concert",
      "conduire",
      "confier",
      "congeler",
      "connoter",
      "consonne",
      "contact",
      "convexe",
      "copain",
      "copie",
      "corail",
      "corbeau",
      "cordage",
      "corniche",
      "corpus",
      "correct",
      "cortège",
      "cosmique",
      "costume",
      "coton",
      "coude",
      "coupure",
      "courage",
      "couteau",
      "couvrir",
      "coyote",
      "crabe",
      "crainte",
      "cravate",
      "crayon",
      "créature",
      "créditer",
      "crémeux",
      "creuser",
      "crevette",
      "cribler",
      "crier",
      "cristal",
      "critère",
      "croire",
      "croquer",
      "crotale",
      "crucial",
      "cruel",
      "crypter",
      "cubique",
      "cueillir",
      "cuillère",
      "cuisine",
      "cuivre",
      "culminer",
      "cultiver",
      "cumuler",
      "cupide",
      "curatif",
      "curseur",
      "cyanure",
      "cycle",
      "cylindre",
      "cynique",
      "daigner",
      "damier",
      "danger",
      "danseur",
      "dauphin",
      "débattre",
      "débiter",
      "déborder",
      "débrider",
      "débutant",
      "décaler",
      "décembre",
      "déchirer",
      "décider",
      "déclarer",
      "décorer",
      "décrire",
      "décupler",
      "dédale",
      "déductif",
      "déesse",
      "défensif",
      "défiler",
      "défrayer",
      "dégager",
      "dégivrer",
      "déglutir",
      "dégrafer",
      "déjeuner",
      "délice",
      "déloger",
      "demander",
      "demeurer",
      "démolir",
      "dénicher",
      "dénouer",
      "dentelle",
      "dénuder",
      "départ",
      "dépenser",
      "déphaser",
      "déplacer",
      "déposer",
      "déranger",
      "dérober",
      "désastre",
      "descente",
      "désert",
      "désigner",
      "désobéir",
      "dessiner",
      "destrier",
      "détacher",
      "détester",
      "détourer",
      "détresse",
      "devancer",
      "devenir",
      "deviner",
      "devoir",
      "diable",
      "dialogue",
      "diamant",
      "dicter",
      "différer",
      "digérer",
      "digital",
      "digne",
      "diluer",
      "dimanche",
      "diminuer",
      "dioxyde",
      "directif",
      "diriger",
      "discuter",
      "disposer",
      "dissiper",
      "distance",
      "divertir",
      "diviser",
      "docile",
      "docteur",
      "dogme",
      "doigt",
      "domaine",
      "domicile",
      "dompter",
      "donateur",
      "donjon",
      "donner",
      "dopamine",
      "dortoir",
      "dorure",
      "dosage",
      "doseur",
      "dossier",
      "dotation",
      "douanier",
      "double",
      "douceur",
      "douter",
      "doyen",
      "dragon",
      "draper",
      "dresser",
      "dribbler",
      "droiture",
      "duperie",
      "duplexe",
      "durable",
      "durcir",
      "dynastie",
      "éblouir",
      "écarter",
      "écharpe",
      "échelle",
      "éclairer",
      "éclipse",
      "éclore",
      "écluse",
      "école",
      "économie",
      "écorce",
      "écouter",
      "écraser",
      "écrémer",
      "écrivain",
      "écrou",
      "écume",
      "écureuil",
      "édifier",
      "éduquer",
      "effacer",
      "effectif",
      "effigie",
      "effort",
      "effrayer",
      "effusion",
      "égaliser",
      "égarer",
      "éjecter",
      "élaborer",
      "élargir",
      "électron",
      "élégant",
      "éléphant",
      "élève",
      "éligible",
      "élitisme",
      "éloge",
      "élucider",
      "éluder",
      "emballer",
      "embellir",
      "embryon",
      "émeraude",
      "émission",
      "emmener",
      "émotion",
      "émouvoir",
      "empereur",
      "employer",
      "emporter",
      "emprise",
      "émulsion",
      "encadrer",
      "enchère",
      "enclave",
      "encoche",
      "endiguer",
      "endosser",
      "endroit",
      "enduire",
      "énergie",
      "enfance",
      "enfermer",
      "enfouir",
      "engager",
      "engin",
      "englober",
      "énigme",
      "enjamber",
      "enjeu",
      "enlever",
      "ennemi",
      "ennuyeux",
      "enrichir",
      "enrobage",
      "enseigne",
      "entasser",
      "entendre",
      "entier",
      "entourer",
      "entraver",
      "énumérer",
      "envahir",
      "enviable",
      "envoyer",
      "enzyme",
      "éolien",
      "épaissir",
      "épargne",
      "épatant",
      "épaule",
      "épicerie",
      "épidémie",
      "épier",
      "épilogue",
      "épine",
      "épisode",
      "épitaphe",
      "époque",
      "épreuve",
      "éprouver",
      "épuisant",
      "équerre",
      "équipe",
      "ériger",
      "érosion",
      "erreur",
      "éruption",
      "escalier",
      "espadon",
      "espèce",
      "espiègle",
      "espoir",
      "esprit",
      "esquiver",
      "essayer",
      "essence",
      "essieu",
      "essorer",
      "estime",
      "estomac",
      "estrade",
      "étagère",
      "étaler",
      "étanche",
      "étatique",
      "éteindre",
      "étendoir",
      "éternel",
      "éthanol",
      "éthique",
      "ethnie",
      "étirer",
      "étoffer",
      "étoile",
      "étonnant",
      "étourdir",
      "étrange",
      "étroit",
      "étude",
      "euphorie",
      "évaluer",
      "évasion",
      "éventail",
      "évidence",
      "éviter",
      "évolutif",
      "évoquer",
      "exact",
      "exagérer",
      "exaucer",
      "exceller",
      "excitant",
      "exclusif",
      "excuse",
      "exécuter",
      "exemple",
      "exercer",
      "exhaler",
      "exhorter",
      "exigence",
      "exiler",
      "exister",
      "exotique",
      "expédier",
      "explorer",
      "exposer",
      "exprimer",
      "exquis",
      "extensif",
      "extraire",
      "exulter",
      "fable",
      "fabuleux",
      "facette",
      "facile",
      "facture",
      "faiblir",
      "falaise",
      "fameux",
      "famille",
      "farceur",
      "farfelu",
      "farine",
      "farouche",
      "fasciner",
      "fatal",
      "fatigue",
      "faucon",
      "fautif",
      "faveur",
      "favori",
      "fébrile",
      "féconder",
      "fédérer",
      "félin",
      "femme",
      "fémur",
      "fendoir",
      "féodal",
      "fermer",
      "féroce",
      "ferveur",
      "festival",
      "feuille",
      "feutre",
      "février",
      "fiasco",
      "ficeler",
      "fictif",
      "fidèle",
      "figure",
      "filature",
      "filetage",
      "filière",
      "filleul",
      "filmer",
      "filou",
      "filtrer",
      "financer",
      "finir",
      "fiole",
      "firme",
      "fissure",
      "fixer",
      "flairer",
      "flamme",
      "flasque",
      "flatteur",
      "fléau",
      "flèche",
      "fleur",
      "flexion",
      "flocon",
      "flore",
      "fluctuer",
      "fluide",
      "fluvial",
      "folie",
      "fonderie",
      "fongible",
      "fontaine",
      "forcer",
      "forgeron",
      "formuler",
      "fortune",
      "fossile",
      "foudre",
      "fougère",
      "fouiller",
      "foulure",
      "fourmi",
      "fragile",
      "fraise",
      "franchir",
      "frapper",
      "frayeur",
      "frégate",
      "freiner",
      "frelon",
      "frémir",
      "frénésie",
      "frère",
      "friable",
      "friction",
      "frisson",
      "frivole",
      "froid",
      "fromage",
      "frontal",
      "frotter",
      "fruit",
      "fugitif",
      "fuite",
      "fureur",
      "furieux",
      "furtif",
      "fusion",
      "futur",
      "gagner",
      "galaxie",
      "galerie",
      "gambader",
      "garantir",
      "gardien",
      "garnir",
      "garrigue",
      "gazelle",
      "gazon",
      "géant",
      "gélatine",
      "gélule",
      "gendarme",
      "général",
      "génie",
      "genou",
      "gentil",
      "géologie",
      "géomètre",
      "géranium",
      "germe",
      "gestuel",
      "geyser",
      "gibier",
      "gicler",
      "girafe",
      "givre",
      "glace",
      "glaive",
      "glisser",
      "globe",
      "gloire",
      "glorieux",
      "golfeur",
      "gomme",
      "gonfler",
      "gorge",
      "gorille",
      "goudron",
      "gouffre",
      "goulot",
      "goupille",
      "gourmand",
      "goutte",
      "graduel",
      "graffiti",
      "graine",
      "grand",
      "grappin",
      "gratuit",
      "gravir",
      "grenat",
      "griffure",
      "griller",
      "grimper",
      "grogner",
      "gronder",
      "grotte",
      "groupe",
      "gruger",
      "grutier",
      "gruyère",
      "guépard",
      "guerrier",
      "guide",
      "guimauve",
      "guitare",
      "gustatif",
      "gymnaste",
      "gyrostat",
      "habitude",
      "hachoir",
      "halte",
      "hameau",
      "hangar",
      "hanneton",
      "haricot",
      "harmonie",
      "harpon",
      "hasard",
      "hélium",
      "hématome",
      "herbe",
      "hérisson",
      "hermine",
      "héron",
      "hésiter",
      "heureux",
      "hiberner",
      "hibou",
      "hilarant",
      "histoire",
      "hiver",
      "homard",
      "hommage",
      "homogène",
      "honneur",
      "honorer",
      "honteux",
      "horde",
      "horizon",
      "horloge",
      "hormone",
      "horrible",
      "houleux",
      "housse",
      "hublot",
      "huileux",
      "humain",
      "humble",
      "humide",
      "humour",
      "hurler",
      "hydromel",
      "hygiène",
      "hymne",
      "hypnose",
      "idylle",
      "ignorer",
      "iguane",
      "illicite",
      "illusion",
      "image",
      "imbiber",
      "imiter",
      "immense",
      "immobile",
      "immuable",
      "impact",
      "impérial",
      "implorer",
      "imposer",
      "imprimer",
      "imputer",
      "incarner",
      "incendie",
      "incident",
      "incliner",
      "incolore",
      "indexer",
      "indice",
      "inductif",
      "inédit",
      "ineptie",
      "inexact",
      "infini",
      "infliger",
      "informer",
      "infusion",
      "ingérer",
      "inhaler",
      "inhiber",
      "injecter",
      "injure",
      "innocent",
      "inoculer",
      "inonder",
      "inscrire",
      "insecte",
      "insigne",
      "insolite",
      "inspirer",
      "instinct",
      "insulter",
      "intact",
      "intense",
      "intime",
      "intrigue",
      "intuitif",
      "inutile",
      "invasion",
      "inventer",
      "inviter",
      "invoquer",
      "ironique",
      "irradier",
      "irréel",
      "irriter",
      "isoler",
      "ivoire",
      "ivresse",
      "jaguar",
      "jaillir",
      "jambe",
      "janvier",
      "jardin",
      "jauger",
      "jaune",
      "javelot",
      "jetable",
      "jeton",
      "jeudi",
      "jeunesse",
      "joindre",
      "joncher",
      "jongler",
      "joueur",
      "jouissif",
      "journal",
      "jovial",
      "joyau",
      "joyeux",
      "jubiler",
      "jugement",
      "junior",
      "jupon",
      "juriste",
      "justice",
      "juteux",
      "juvénile",
      "kayak",
      "kimono",
      "kiosque",
      "label",
      "labial",
      "labourer",
      "lacérer",
      "lactose",
      "lagune",
      "laine",
      "laisser",
      "laitier",
      "lambeau",
      "lamelle",
      "lampe",
      "lanceur",
      "langage",
      "lanterne",
      "lapin",
      "largeur",
      "larme",
      "laurier",
      "lavabo",
      "lavoir",
      "lecture",
      "légal",
      "léger",
      "légume",
      "lessive",
      "lettre",
      "levier",
      "lexique",
      "lézard",
      "liasse",
      "libérer",
      "libre",
      "licence",
      "licorne",
      "liège",
      "lièvre",
      "ligature",
      "ligoter",
      "ligue",
      "limer",
      "limite",
      "limonade",
      "limpide",
      "linéaire",
      "lingot",
      "lionceau",
      "liquide",
      "lisière",
      "lister",
      "lithium",
      "litige",
      "littoral",
      "livreur",
      "logique",
      "lointain",
      "loisir",
      "lombric",
      "loterie",
      "louer",
      "lourd",
      "loutre",
      "louve",
      "loyal",
      "lubie",
      "lucide",
      "lucratif",
      "lueur",
      "lugubre",
      "luisant",
      "lumière",
      "lunaire",
      "lundi",
      "luron",
      "lutter",
      "luxueux",
      "machine",
      "magasin",
      "magenta",
      "magique",
      "maigre",
      "maillon",
      "maintien",
      "mairie",
      "maison",
      "majorer",
      "malaxer",
      "maléfice",
      "malheur",
      "malice",
      "mallette",
      "mammouth",
      "mandater",
      "maniable",
      "manquant",
      "manteau",
      "manuel",
      "marathon",
      "marbre",
      "marchand",
      "mardi",
      "maritime",
      "marqueur",
      "marron",
      "marteler",
      "mascotte",
      "massif",
      "matériel",
      "matière",
      "matraque",
      "maudire",
      "maussade",
      "mauve",
      "maximal",
      "méchant",
      "méconnu",
      "médaille",
      "médecin",
      "méditer",
      "méduse",
      "meilleur",
      "mélange",
      "mélodie",
      "membre",
      "mémoire",
      "menacer",
      "mener",
      "menhir",
      "mensonge",
      "mentor",
      "mercredi",
      "mérite",
      "merle",
      "messager",
      "mesure",
      "métal",
      "météore",
      "méthode",
      "métier",
      "meuble",
      "miauler",
      "microbe",
      "miette",
      "mignon",
      "migrer",
      "milieu",
      "million",
      "mimique",
      "mince",
      "minéral",
      "minimal",
      "minorer",
      "minute",
      "miracle",
      "miroiter",
      "missile",
      "mixte",
      "mobile",
      "moderne",
      "moelleux",
      "mondial",
      "moniteur",
      "monnaie",
      "monotone",
      "monstre",
      "montagne",
      "monument",
      "moqueur",
      "morceau",
      "morsure",
      "mortier",
      "moteur",
      "motif",
      "mouche",
      "moufle",
      "moulin",
      "mousson",
      "mouton",
      "mouvant",
      "multiple",
      "munition",
      "muraille",
      "murène",
      "murmure",
      "muscle",
      "muséum",
      "musicien",
      "mutation",
      "muter",
      "mutuel",
      "myriade",
      "myrtille",
      "mystère",
      "mythique",
      "nageur",
      "nappe",
      "narquois",
      "narrer",
      "natation",
      "nation",
      "nature",
      "naufrage",
      "nautique",
      "navire",
      "nébuleux",
      "nectar",
      "néfaste",
      "négation",
      "négliger",
      "négocier",
      "neige",
      "nerveux",
      "nettoyer",
      "neurone",
      "neutron",
      "neveu",
      "niche",
      "nickel",
      "nitrate",
      "niveau",
      "noble",
      "nocif",
      "nocturne",
      "noirceur",
      "noisette",
      "nomade",
      "nombreux",
      "nommer",
      "normatif",
      "notable",
      "notifier",
      "notoire",
      "nourrir",
      "nouveau",
      "novateur",
      "novembre",
      "novice",
      "nuage",
      "nuancer",
      "nuire",
      "nuisible",
      "numéro",
      "nuptial",
      "nuque",
      "nutritif",
      "obéir",
      "objectif",
      "obliger",
      "obscur",
      "observer",
      "obstacle",
      "obtenir",
      "obturer",
      "occasion",
      "occuper",
      "océan",
      "octobre",
      "octroyer",
      "octupler",
      "oculaire",
      "odeur",
      "odorant",
      "offenser",
      "officier",
      "offrir",
      "ogive",
      "oiseau",
      "oisillon",
      "olfactif",
      "olivier",
      "ombrage",
      "omettre",
      "onctueux",
      "onduler",
      "onéreux",
      "onirique",
      "opale",
      "opaque",
      "opérer",
      "opinion",
      "opportun",
      "opprimer",
      "opter",
      "optique",
      "orageux",
      "orange",
      "orbite",
      "ordonner",
      "oreille",
      "organe",
      "orgueil",
      "orifice",
      "ornement",
      "orque",
      "ortie",
      "osciller",
      "osmose",
      "ossature",
      "otarie",
      "ouragan",
      "ourson",
      "outil",
      "outrager",
      "ouvrage",
      "ovation",
      "oxyde",
      "oxygène",
      "ozone",
      "paisible",
      "palace",
      "palmarès",
      "palourde",
      "palper",
      "panache",
      "panda",
      "pangolin",
      "paniquer",
      "panneau",
      "panorama",
      "pantalon",
      "papaye",
      "papier",
      "papoter",
      "papyrus",
      "paradoxe",
      "parcelle",
      "paresse",
      "parfumer",
      "parler",
      "parole",
      "parrain",
      "parsemer",
      "partager",
      "parure",
      "parvenir",
      "passion",
      "pastèque",
      "paternel",
      "patience",
      "patron",
      "pavillon",
      "pavoiser",
      "payer",
      "paysage",
      "peigne",
      "peintre",
      "pelage",
      "pélican",
      "pelle",
      "pelouse",
      "peluche",
      "pendule",
      "pénétrer",
      "pénible",
      "pensif",
      "pénurie",
      "pépite",
      "péplum",
      "perdrix",
      "perforer",
      "période",
      "permuter",
      "perplexe",
      "persil",
      "perte",
      "peser",
      "pétale",
      "petit",
      "pétrir",
      "peuple",
      "pharaon",
      "phobie",
      "phoque",
      "photon",
      "phrase",
      "physique",
      "piano",
      "pictural",
      "pièce",
      "pierre",
      "pieuvre",
      "pilote",
      "pinceau",
      "pipette",
      "piquer",
      "pirogue",
      "piscine",
      "piston",
      "pivoter",
      "pixel",
      "pizza",
      "placard",
      "plafond",
      "plaisir",
      "planer",
      "plaque",
      "plastron",
      "plateau",
      "pleurer",
      "plexus",
      "pliage",
      "plomb",
      "plonger",
      "pluie",
      "plumage",
      "pochette",
      "poésie",
      "poète",
      "pointe",
      "poirier",
      "poisson",
      "poivre",
      "polaire",
      "policier",
      "pollen",
      "polygone",
      "pommade",
      "pompier",
      "ponctuel",
      "pondérer",
      "poney",
      "portique",
      "position",
      "posséder",
      "posture",
      "potager",
      "poteau",
      "potion",
      "pouce",
      "poulain",
      "poumon",
      "pourpre",
      "poussin",
      "pouvoir",
      "prairie",
      "pratique",
      "précieux",
      "prédire",
      "préfixe",
      "prélude",
      "prénom",
      "présence",
      "prétexte",
      "prévoir",
      "primitif",
      "prince",
      "prison",
      "priver",
      "problème",
      "procéder",
      "prodige",
      "profond",
      "progrès",
      "proie",
      "projeter",
      "prologue",
      "promener",
      "propre",
      "prospère",
      "protéger",
      "prouesse",
      "proverbe",
      "prudence",
      "pruneau",
      "psychose",
      "public",
      "puceron",
      "puiser",
      "pulpe",
      "pulsar",
      "punaise",
      "punitif",
      "pupitre",
      "purifier",
      "puzzle",
      "pyramide",
      "quasar",
      "querelle",
      "question",
      "quiétude",
      "quitter",
      "quotient",
      "racine",
      "raconter",
      "radieux",
      "ragondin",
      "raideur",
      "raisin",
      "ralentir",
      "rallonge",
      "ramasser",
      "rapide",
      "rasage",
      "ratisser",
      "ravager",
      "ravin",
      "rayonner",
      "réactif",
      "réagir",
      "réaliser",
      "réanimer",
      "recevoir",
      "réciter",
      "réclamer",
      "récolter",
      "recruter",
      "reculer",
      "recycler",
      "rédiger",
      "redouter",
      "refaire",
      "réflexe",
      "réformer",
      "refrain",
      "refuge",
      "régalien",
      "région",
      "réglage",
      "régulier",
      "réitérer",
      "rejeter",
      "rejouer",
      "relatif",
      "relever",
      "relief",
      "remarque",
      "remède",
      "remise",
      "remonter",
      "remplir",
      "remuer",
      "renard",
      "renfort",
      "renifler",
      "renoncer",
      "rentrer",
      "renvoi",
      "replier",
      "reporter",
      "reprise",
      "reptile",
      "requin",
      "réserve",
      "résineux",
      "résoudre",
      "respect",
      "rester",
      "résultat",
      "rétablir",
      "retenir",
      "réticule",
      "retomber",
      "retracer",
      "réunion",
      "réussir",
      "revanche",
      "revivre",
      "révolte",
      "révulsif",
      "richesse",
      "rideau",
      "rieur",
      "rigide",
      "rigoler",
      "rincer",
      "riposter",
      "risible",
      "risque",
      "rituel",
      "rival",
      "rivière",
      "rocheux",
      "romance",
      "rompre",
      "ronce",
      "rondin",
      "roseau",
      "rosier",
      "rotatif",
      "rotor",
      "rotule",
      "rouge",
      "rouille",
      "rouleau",
      "routine",
      "royaume",
      "ruban",
      "rubis",
      "ruche",
      "ruelle",
      "rugueux",
      "ruiner",
      "ruisseau",
      "ruser",
      "rustique",
      "rythme",
      "sabler",
      "saboter",
      "sabre",
      "sacoche",
      "safari",
      "sagesse",
      "saisir",
      "salade",
      "salive",
      "salon",
      "saluer",
      "samedi",
      "sanction",
      "sanglier",
      "sarcasme",
      "sardine",
      "saturer",
      "saugrenu",
      "saumon",
      "sauter",
      "sauvage",
      "savant",
      "savonner",
      "scalpel",
      "scandale",
      "scélérat",
      "scénario",
      "sceptre",
      "schéma",
      "science",
      "scinder",
      "score",
      "scrutin",
      "sculpter",
      "séance",
      "sécable",
      "sécher",
      "secouer",
      "sécréter",
      "sédatif",
      "séduire",
      "seigneur",
      "séjour",
      "sélectif",
      "semaine",
      "sembler",
      "semence",
      "séminal",
      "sénateur",
      "sensible",
      "sentence",
      "séparer",
      "séquence",
      "serein",
      "sergent",
      "sérieux",
      "serrure",
      "sérum",
      "service",
      "sésame",
      "sévir",
      "sevrage",
      "sextuple",
      "sidéral",
      "siècle",
      "siéger",
      "siffler",
      "sigle",
      "signal",
      "silence",
      "silicium",
      "simple",
      "sincère",
      "sinistre",
      "siphon",
      "sirop",
      "sismique",
      "situer",
      "skier",
      "social",
      "socle",
      "sodium",
      "soigneux",
      "soldat",
      "soleil",
      "solitude",
      "soluble",
      "sombre",
      "sommeil",
      "somnoler",
      "sonde",
      "songeur",
      "sonnette",
      "sonore",
      "sorcier",
      "sortir",
      "sosie",
      "sottise",
      "soucieux",
      "soudure",
      "souffle",
      "soulever",
      "soupape",
      "source",
      "soutirer",
      "souvenir",
      "spacieux",
      "spatial",
      "spécial",
      "sphère",
      "spiral",
      "stable",
      "station",
      "sternum",
      "stimulus",
      "stipuler",
      "strict",
      "studieux",
      "stupeur",
      "styliste",
      "sublime",
      "substrat",
      "subtil",
      "subvenir",
      "succès",
      "sucre",
      "suffixe",
      "suggérer",
      "suiveur",
      "sulfate",
      "superbe",
      "supplier",
      "surface",
      "suricate",
      "surmener",
      "surprise",
      "sursaut",
      "survie",
      "suspect",
      "syllabe",
      "symbole",
      "symétrie",
      "synapse",
      "syntaxe",
      "système",
      "tabac",
      "tablier",
      "tactile",
      "tailler",
      "talent",
      "talisman",
      "talonner",
      "tambour",
      "tamiser",
      "tangible",
      "tapis",
      "taquiner",
      "tarder",
      "tarif",
      "tartine",
      "tasse",
      "tatami",
      "tatouage",
      "taupe",
      "taureau",
      "taxer",
      "témoin",
      "temporel",
      "tenaille",
      "tendre",
      "teneur",
      "tenir",
      "tension",
      "terminer",
      "terne",
      "terrible",
      "tétine",
      "texte",
      "thème",
      "théorie",
      "thérapie",
      "thorax",
      "tibia",
      "tiède",
      "timide",
      "tirelire",
      "tiroir",
      "tissu",
      "titane",
      "titre",
      "tituber",
      "toboggan",
      "tolérant",
      "tomate",
      "tonique",
      "tonneau",
      "toponyme",
      "torche",
      "tordre",
      "tornade",
      "torpille",
      "torrent",
      "torse",
      "tortue",
      "totem",
      "toucher",
      "tournage",
      "tousser",
      "toxine",
      "traction",
      "trafic",
      "tragique",
      "trahir",
      "train",
      "trancher",
      "travail",
      "trèfle",
      "tremper",
      "trésor",
      "treuil",
      "triage",
      "tribunal",
      "tricoter",
      "trilogie",
      "triomphe",
      "tripler",
      "triturer",
      "trivial",
      "trombone",
      "tronc",
      "tropical",
      "troupeau",
      "tuile",
      "tulipe",
      "tumulte",
      "tunnel",
      "turbine",
      "tuteur",
      "tutoyer",
      "tuyau",
      "tympan",
      "typhon",
      "typique",
      "tyran",
      "ubuesque",
      "ultime",
      "ultrason",
      "unanime",
      "unifier",
      "union",
      "unique",
      "unitaire",
      "univers",
      "uranium",
      "urbain",
      "urticant",
      "usage",
      "usine",
      "usuel",
      "usure",
      "utile",
      "utopie",
      "vacarme",
      "vaccin",
      "vagabond",
      "vague",
      "vaillant",
      "vaincre",
      "vaisseau",
      "valable",
      "valise",
      "vallon",
      "valve",
      "vampire",
      "vanille",
      "vapeur",
      "varier",
      "vaseux",
      "vassal",
      "vaste",
      "vecteur",
      "vedette",
      "végétal",
      "véhicule",
      "veinard",
      "véloce",
      "vendredi",
      "vénérer",
      "venger",
      "venimeux",
      "ventouse",
      "verdure",
      "vérin",
      "vernir",
      "verrou",
      "verser",
      "vertu",
      "veston",
      "vétéran",
      "vétuste",
      "vexant",
      "vexer",
      "viaduc",
      "viande",
      "victoire",
      "vidange",
      "vidéo",
      "vignette",
      "vigueur",
      "vilain",
      "village",
      "vinaigre",
      "violon",
      "vipère",
      "virement",
      "virtuose",
      "virus",
      "visage",
      "viseur",
      "vision",
      "visqueux",
      "visuel",
      "vital",
      "vitesse",
      "viticole",
      "vitrine",
      "vivace",
      "vivipare",
      "vocation",
      "voguer",
      "voile",
      "voisin",
      "voiture",
      "volaille",
      "volcan",
      "voltiger",
      "volume",
      "vorace",
      "vortex",
      "voter",
      "vouloir",
      "voyage",
      "voyelle",
      "wagon",
      "xénon",
      "yacht",
      "zèbre",
      "zénith",
      "zeste",
      "zoologie"
    ];
  }
});

// node_modules/bip39/src/wordlists/italian.json
var require_italian = __commonJS({
  "node_modules/bip39/src/wordlists/italian.json"(exports, module) {
    module.exports = [
      "abaco",
      "abbaglio",
      "abbinato",
      "abete",
      "abisso",
      "abolire",
      "abrasivo",
      "abrogato",
      "accadere",
      "accenno",
      "accusato",
      "acetone",
      "achille",
      "acido",
      "acqua",
      "acre",
      "acrilico",
      "acrobata",
      "acuto",
      "adagio",
      "addebito",
      "addome",
      "adeguato",
      "aderire",
      "adipe",
      "adottare",
      "adulare",
      "affabile",
      "affetto",
      "affisso",
      "affranto",
      "aforisma",
      "afoso",
      "africano",
      "agave",
      "agente",
      "agevole",
      "aggancio",
      "agire",
      "agitare",
      "agonismo",
      "agricolo",
      "agrumeto",
      "aguzzo",
      "alabarda",
      "alato",
      "albatro",
      "alberato",
      "albo",
      "albume",
      "alce",
      "alcolico",
      "alettone",
      "alfa",
      "algebra",
      "aliante",
      "alibi",
      "alimento",
      "allagato",
      "allegro",
      "allievo",
      "allodola",
      "allusivo",
      "almeno",
      "alogeno",
      "alpaca",
      "alpestre",
      "altalena",
      "alterno",
      "alticcio",
      "altrove",
      "alunno",
      "alveolo",
      "alzare",
      "amalgama",
      "amanita",
      "amarena",
      "ambito",
      "ambrato",
      "ameba",
      "america",
      "ametista",
      "amico",
      "ammasso",
      "ammenda",
      "ammirare",
      "ammonito",
      "amore",
      "ampio",
      "ampliare",
      "amuleto",
      "anacardo",
      "anagrafe",
      "analista",
      "anarchia",
      "anatra",
      "anca",
      "ancella",
      "ancora",
      "andare",
      "andrea",
      "anello",
      "angelo",
      "angolare",
      "angusto",
      "anima",
      "annegare",
      "annidato",
      "anno",
      "annuncio",
      "anonimo",
      "anticipo",
      "anzi",
      "apatico",
      "apertura",
      "apode",
      "apparire",
      "appetito",
      "appoggio",
      "approdo",
      "appunto",
      "aprile",
      "arabica",
      "arachide",
      "aragosta",
      "araldica",
      "arancio",
      "aratura",
      "arazzo",
      "arbitro",
      "archivio",
      "ardito",
      "arenile",
      "argento",
      "argine",
      "arguto",
      "aria",
      "armonia",
      "arnese",
      "arredato",
      "arringa",
      "arrosto",
      "arsenico",
      "arso",
      "artefice",
      "arzillo",
      "asciutto",
      "ascolto",
      "asepsi",
      "asettico",
      "asfalto",
      "asino",
      "asola",
      "aspirato",
      "aspro",
      "assaggio",
      "asse",
      "assoluto",
      "assurdo",
      "asta",
      "astenuto",
      "astice",
      "astratto",
      "atavico",
      "ateismo",
      "atomico",
      "atono",
      "attesa",
      "attivare",
      "attorno",
      "attrito",
      "attuale",
      "ausilio",
      "austria",
      "autista",
      "autonomo",
      "autunno",
      "avanzato",
      "avere",
      "avvenire",
      "avviso",
      "avvolgere",
      "azione",
      "azoto",
      "azzimo",
      "azzurro",
      "babele",
      "baccano",
      "bacino",
      "baco",
      "badessa",
      "badilata",
      "bagnato",
      "baita",
      "balcone",
      "baldo",
      "balena",
      "ballata",
      "balzano",
      "bambino",
      "bandire",
      "baraonda",
      "barbaro",
      "barca",
      "baritono",
      "barlume",
      "barocco",
      "basilico",
      "basso",
      "batosta",
      "battuto",
      "baule",
      "bava",
      "bavosa",
      "becco",
      "beffa",
      "belgio",
      "belva",
      "benda",
      "benevole",
      "benigno",
      "benzina",
      "bere",
      "berlina",
      "beta",
      "bibita",
      "bici",
      "bidone",
      "bifido",
      "biga",
      "bilancia",
      "bimbo",
      "binocolo",
      "biologo",
      "bipede",
      "bipolare",
      "birbante",
      "birra",
      "biscotto",
      "bisesto",
      "bisnonno",
      "bisonte",
      "bisturi",
      "bizzarro",
      "blando",
      "blatta",
      "bollito",
      "bonifico",
      "bordo",
      "bosco",
      "botanico",
      "bottino",
      "bozzolo",
      "braccio",
      "bradipo",
      "brama",
      "branca",
      "bravura",
      "bretella",
      "brevetto",
      "brezza",
      "briglia",
      "brillante",
      "brindare",
      "broccolo",
      "brodo",
      "bronzina",
      "brullo",
      "bruno",
      "bubbone",
      "buca",
      "budino",
      "buffone",
      "buio",
      "bulbo",
      "buono",
      "burlone",
      "burrasca",
      "bussola",
      "busta",
      "cadetto",
      "caduco",
      "calamaro",
      "calcolo",
      "calesse",
      "calibro",
      "calmo",
      "caloria",
      "cambusa",
      "camerata",
      "camicia",
      "cammino",
      "camola",
      "campale",
      "canapa",
      "candela",
      "cane",
      "canino",
      "canotto",
      "cantina",
      "capace",
      "capello",
      "capitolo",
      "capogiro",
      "cappero",
      "capra",
      "capsula",
      "carapace",
      "carcassa",
      "cardo",
      "carisma",
      "carovana",
      "carretto",
      "cartolina",
      "casaccio",
      "cascata",
      "caserma",
      "caso",
      "cassone",
      "castello",
      "casuale",
      "catasta",
      "catena",
      "catrame",
      "cauto",
      "cavillo",
      "cedibile",
      "cedrata",
      "cefalo",
      "celebre",
      "cellulare",
      "cena",
      "cenone",
      "centesimo",
      "ceramica",
      "cercare",
      "certo",
      "cerume",
      "cervello",
      "cesoia",
      "cespo",
      "ceto",
      "chela",
      "chiaro",
      "chicca",
      "chiedere",
      "chimera",
      "china",
      "chirurgo",
      "chitarra",
      "ciao",
      "ciclismo",
      "cifrare",
      "cigno",
      "cilindro",
      "ciottolo",
      "circa",
      "cirrosi",
      "citrico",
      "cittadino",
      "ciuffo",
      "civetta",
      "civile",
      "classico",
      "clinica",
      "cloro",
      "cocco",
      "codardo",
      "codice",
      "coerente",
      "cognome",
      "collare",
      "colmato",
      "colore",
      "colposo",
      "coltivato",
      "colza",
      "coma",
      "cometa",
      "commando",
      "comodo",
      "computer",
      "comune",
      "conciso",
      "condurre",
      "conferma",
      "congelare",
      "coniuge",
      "connesso",
      "conoscere",
      "consumo",
      "continuo",
      "convegno",
      "coperto",
      "copione",
      "coppia",
      "copricapo",
      "corazza",
      "cordata",
      "coricato",
      "cornice",
      "corolla",
      "corpo",
      "corredo",
      "corsia",
      "cortese",
      "cosmico",
      "costante",
      "cottura",
      "covato",
      "cratere",
      "cravatta",
      "creato",
      "credere",
      "cremoso",
      "crescita",
      "creta",
      "criceto",
      "crinale",
      "crisi",
      "critico",
      "croce",
      "cronaca",
      "crostata",
      "cruciale",
      "crusca",
      "cucire",
      "cuculo",
      "cugino",
      "cullato",
      "cupola",
      "curatore",
      "cursore",
      "curvo",
      "cuscino",
      "custode",
      "dado",
      "daino",
      "dalmata",
      "damerino",
      "daniela",
      "dannoso",
      "danzare",
      "datato",
      "davanti",
      "davvero",
      "debutto",
      "decennio",
      "deciso",
      "declino",
      "decollo",
      "decreto",
      "dedicato",
      "definito",
      "deforme",
      "degno",
      "delegare",
      "delfino",
      "delirio",
      "delta",
      "demenza",
      "denotato",
      "dentro",
      "deposito",
      "derapata",
      "derivare",
      "deroga",
      "descritto",
      "deserto",
      "desiderio",
      "desumere",
      "detersivo",
      "devoto",
      "diametro",
      "dicembre",
      "diedro",
      "difeso",
      "diffuso",
      "digerire",
      "digitale",
      "diluvio",
      "dinamico",
      "dinnanzi",
      "dipinto",
      "diploma",
      "dipolo",
      "diradare",
      "dire",
      "dirotto",
      "dirupo",
      "disagio",
      "discreto",
      "disfare",
      "disgelo",
      "disposto",
      "distanza",
      "disumano",
      "dito",
      "divano",
      "divelto",
      "dividere",
      "divorato",
      "doblone",
      "docente",
      "doganale",
      "dogma",
      "dolce",
      "domato",
      "domenica",
      "dominare",
      "dondolo",
      "dono",
      "dormire",
      "dote",
      "dottore",
      "dovuto",
      "dozzina",
      "drago",
      "druido",
      "dubbio",
      "dubitare",
      "ducale",
      "duna",
      "duomo",
      "duplice",
      "duraturo",
      "ebano",
      "eccesso",
      "ecco",
      "eclissi",
      "economia",
      "edera",
      "edicola",
      "edile",
      "editoria",
      "educare",
      "egemonia",
      "egli",
      "egoismo",
      "egregio",
      "elaborato",
      "elargire",
      "elegante",
      "elencato",
      "eletto",
      "elevare",
      "elfico",
      "elica",
      "elmo",
      "elsa",
      "eluso",
      "emanato",
      "emblema",
      "emesso",
      "emiro",
      "emotivo",
      "emozione",
      "empirico",
      "emulo",
      "endemico",
      "enduro",
      "energia",
      "enfasi",
      "enoteca",
      "entrare",
      "enzima",
      "epatite",
      "epilogo",
      "episodio",
      "epocale",
      "eppure",
      "equatore",
      "erario",
      "erba",
      "erboso",
      "erede",
      "eremita",
      "erigere",
      "ermetico",
      "eroe",
      "erosivo",
      "errante",
      "esagono",
      "esame",
      "esanime",
      "esaudire",
      "esca",
      "esempio",
      "esercito",
      "esibito",
      "esigente",
      "esistere",
      "esito",
      "esofago",
      "esortato",
      "esoso",
      "espanso",
      "espresso",
      "essenza",
      "esso",
      "esteso",
      "estimare",
      "estonia",
      "estroso",
      "esultare",
      "etilico",
      "etnico",
      "etrusco",
      "etto",
      "euclideo",
      "europa",
      "evaso",
      "evidenza",
      "evitato",
      "evoluto",
      "evviva",
      "fabbrica",
      "faccenda",
      "fachiro",
      "falco",
      "famiglia",
      "fanale",
      "fanfara",
      "fango",
      "fantasma",
      "fare",
      "farfalla",
      "farinoso",
      "farmaco",
      "fascia",
      "fastoso",
      "fasullo",
      "faticare",
      "fato",
      "favoloso",
      "febbre",
      "fecola",
      "fede",
      "fegato",
      "felpa",
      "feltro",
      "femmina",
      "fendere",
      "fenomeno",
      "fermento",
      "ferro",
      "fertile",
      "fessura",
      "festivo",
      "fetta",
      "feudo",
      "fiaba",
      "fiducia",
      "fifa",
      "figurato",
      "filo",
      "finanza",
      "finestra",
      "finire",
      "fiore",
      "fiscale",
      "fisico",
      "fiume",
      "flacone",
      "flamenco",
      "flebo",
      "flemma",
      "florido",
      "fluente",
      "fluoro",
      "fobico",
      "focaccia",
      "focoso",
      "foderato",
      "foglio",
      "folata",
      "folclore",
      "folgore",
      "fondente",
      "fonetico",
      "fonia",
      "fontana",
      "forbito",
      "forchetta",
      "foresta",
      "formica",
      "fornaio",
      "foro",
      "fortezza",
      "forzare",
      "fosfato",
      "fosso",
      "fracasso",
      "frana",
      "frassino",
      "fratello",
      "freccetta",
      "frenata",
      "fresco",
      "frigo",
      "frollino",
      "fronde",
      "frugale",
      "frutta",
      "fucilata",
      "fucsia",
      "fuggente",
      "fulmine",
      "fulvo",
      "fumante",
      "fumetto",
      "fumoso",
      "fune",
      "funzione",
      "fuoco",
      "furbo",
      "furgone",
      "furore",
      "fuso",
      "futile",
      "gabbiano",
      "gaffe",
      "galateo",
      "gallina",
      "galoppo",
      "gambero",
      "gamma",
      "garanzia",
      "garbo",
      "garofano",
      "garzone",
      "gasdotto",
      "gasolio",
      "gastrico",
      "gatto",
      "gaudio",
      "gazebo",
      "gazzella",
      "geco",
      "gelatina",
      "gelso",
      "gemello",
      "gemmato",
      "gene",
      "genitore",
      "gennaio",
      "genotipo",
      "gergo",
      "ghepardo",
      "ghiaccio",
      "ghisa",
      "giallo",
      "gilda",
      "ginepro",
      "giocare",
      "gioiello",
      "giorno",
      "giove",
      "girato",
      "girone",
      "gittata",
      "giudizio",
      "giurato",
      "giusto",
      "globulo",
      "glutine",
      "gnomo",
      "gobba",
      "golf",
      "gomito",
      "gommone",
      "gonfio",
      "gonna",
      "governo",
      "gracile",
      "grado",
      "grafico",
      "grammo",
      "grande",
      "grattare",
      "gravoso",
      "grazia",
      "greca",
      "gregge",
      "grifone",
      "grigio",
      "grinza",
      "grotta",
      "gruppo",
      "guadagno",
      "guaio",
      "guanto",
      "guardare",
      "gufo",
      "guidare",
      "ibernato",
      "icona",
      "identico",
      "idillio",
      "idolo",
      "idra",
      "idrico",
      "idrogeno",
      "igiene",
      "ignaro",
      "ignorato",
      "ilare",
      "illeso",
      "illogico",
      "illudere",
      "imballo",
      "imbevuto",
      "imbocco",
      "imbuto",
      "immane",
      "immerso",
      "immolato",
      "impacco",
      "impeto",
      "impiego",
      "importo",
      "impronta",
      "inalare",
      "inarcare",
      "inattivo",
      "incanto",
      "incendio",
      "inchino",
      "incisivo",
      "incluso",
      "incontro",
      "incrocio",
      "incubo",
      "indagine",
      "india",
      "indole",
      "inedito",
      "infatti",
      "infilare",
      "inflitto",
      "ingaggio",
      "ingegno",
      "inglese",
      "ingordo",
      "ingrosso",
      "innesco",
      "inodore",
      "inoltrare",
      "inondato",
      "insano",
      "insetto",
      "insieme",
      "insonnia",
      "insulina",
      "intasato",
      "intero",
      "intonaco",
      "intuito",
      "inumidire",
      "invalido",
      "invece",
      "invito",
      "iperbole",
      "ipnotico",
      "ipotesi",
      "ippica",
      "iride",
      "irlanda",
      "ironico",
      "irrigato",
      "irrorare",
      "isolato",
      "isotopo",
      "isterico",
      "istituto",
      "istrice",
      "italia",
      "iterare",
      "labbro",
      "labirinto",
      "lacca",
      "lacerato",
      "lacrima",
      "lacuna",
      "laddove",
      "lago",
      "lampo",
      "lancetta",
      "lanterna",
      "lardoso",
      "larga",
      "laringe",
      "lastra",
      "latenza",
      "latino",
      "lattuga",
      "lavagna",
      "lavoro",
      "legale",
      "leggero",
      "lembo",
      "lentezza",
      "lenza",
      "leone",
      "lepre",
      "lesivo",
      "lessato",
      "lesto",
      "letterale",
      "leva",
      "levigato",
      "libero",
      "lido",
      "lievito",
      "lilla",
      "limatura",
      "limitare",
      "limpido",
      "lineare",
      "lingua",
      "liquido",
      "lira",
      "lirica",
      "lisca",
      "lite",
      "litigio",
      "livrea",
      "locanda",
      "lode",
      "logica",
      "lombare",
      "londra",
      "longevo",
      "loquace",
      "lorenzo",
      "loto",
      "lotteria",
      "luce",
      "lucidato",
      "lumaca",
      "luminoso",
      "lungo",
      "lupo",
      "luppolo",
      "lusinga",
      "lusso",
      "lutto",
      "macabro",
      "macchina",
      "macero",
      "macinato",
      "madama",
      "magico",
      "maglia",
      "magnete",
      "magro",
      "maiolica",
      "malafede",
      "malgrado",
      "malinteso",
      "malsano",
      "malto",
      "malumore",
      "mana",
      "mancia",
      "mandorla",
      "mangiare",
      "manifesto",
      "mannaro",
      "manovra",
      "mansarda",
      "mantide",
      "manubrio",
      "mappa",
      "maratona",
      "marcire",
      "maretta",
      "marmo",
      "marsupio",
      "maschera",
      "massaia",
      "mastino",
      "materasso",
      "matricola",
      "mattone",
      "maturo",
      "mazurca",
      "meandro",
      "meccanico",
      "mecenate",
      "medesimo",
      "meditare",
      "mega",
      "melassa",
      "melis",
      "melodia",
      "meninge",
      "meno",
      "mensola",
      "mercurio",
      "merenda",
      "merlo",
      "meschino",
      "mese",
      "messere",
      "mestolo",
      "metallo",
      "metodo",
      "mettere",
      "miagolare",
      "mica",
      "micelio",
      "michele",
      "microbo",
      "midollo",
      "miele",
      "migliore",
      "milano",
      "milite",
      "mimosa",
      "minerale",
      "mini",
      "minore",
      "mirino",
      "mirtillo",
      "miscela",
      "missiva",
      "misto",
      "misurare",
      "mitezza",
      "mitigare",
      "mitra",
      "mittente",
      "mnemonico",
      "modello",
      "modifica",
      "modulo",
      "mogano",
      "mogio",
      "mole",
      "molosso",
      "monastero",
      "monco",
      "mondina",
      "monetario",
      "monile",
      "monotono",
      "monsone",
      "montato",
      "monviso",
      "mora",
      "mordere",
      "morsicato",
      "mostro",
      "motivato",
      "motosega",
      "motto",
      "movenza",
      "movimento",
      "mozzo",
      "mucca",
      "mucosa",
      "muffa",
      "mughetto",
      "mugnaio",
      "mulatto",
      "mulinello",
      "multiplo",
      "mummia",
      "munto",
      "muovere",
      "murale",
      "musa",
      "muscolo",
      "musica",
      "mutevole",
      "muto",
      "nababbo",
      "nafta",
      "nanometro",
      "narciso",
      "narice",
      "narrato",
      "nascere",
      "nastrare",
      "naturale",
      "nautica",
      "naviglio",
      "nebulosa",
      "necrosi",
      "negativo",
      "negozio",
      "nemmeno",
      "neofita",
      "neretto",
      "nervo",
      "nessuno",
      "nettuno",
      "neutrale",
      "neve",
      "nevrotico",
      "nicchia",
      "ninfa",
      "nitido",
      "nobile",
      "nocivo",
      "nodo",
      "nome",
      "nomina",
      "nordico",
      "normale",
      "norvegese",
      "nostrano",
      "notare",
      "notizia",
      "notturno",
      "novella",
      "nucleo",
      "nulla",
      "numero",
      "nuovo",
      "nutrire",
      "nuvola",
      "nuziale",
      "oasi",
      "obbedire",
      "obbligo",
      "obelisco",
      "oblio",
      "obolo",
      "obsoleto",
      "occasione",
      "occhio",
      "occidente",
      "occorrere",
      "occultare",
      "ocra",
      "oculato",
      "odierno",
      "odorare",
      "offerta",
      "offrire",
      "offuscato",
      "oggetto",
      "oggi",
      "ognuno",
      "olandese",
      "olfatto",
      "oliato",
      "oliva",
      "ologramma",
      "oltre",
      "omaggio",
      "ombelico",
      "ombra",
      "omega",
      "omissione",
      "ondoso",
      "onere",
      "onice",
      "onnivoro",
      "onorevole",
      "onta",
      "operato",
      "opinione",
      "opposto",
      "oracolo",
      "orafo",
      "ordine",
      "orecchino",
      "orefice",
      "orfano",
      "organico",
      "origine",
      "orizzonte",
      "orma",
      "ormeggio",
      "ornativo",
      "orologio",
      "orrendo",
      "orribile",
      "ortensia",
      "ortica",
      "orzata",
      "orzo",
      "osare",
      "oscurare",
      "osmosi",
      "ospedale",
      "ospite",
      "ossa",
      "ossidare",
      "ostacolo",
      "oste",
      "otite",
      "otre",
      "ottagono",
      "ottimo",
      "ottobre",
      "ovale",
      "ovest",
      "ovino",
      "oviparo",
      "ovocito",
      "ovunque",
      "ovviare",
      "ozio",
      "pacchetto",
      "pace",
      "pacifico",
      "padella",
      "padrone",
      "paese",
      "paga",
      "pagina",
      "palazzina",
      "palesare",
      "pallido",
      "palo",
      "palude",
      "pandoro",
      "pannello",
      "paolo",
      "paonazzo",
      "paprica",
      "parabola",
      "parcella",
      "parere",
      "pargolo",
      "pari",
      "parlato",
      "parola",
      "partire",
      "parvenza",
      "parziale",
      "passivo",
      "pasticca",
      "patacca",
      "patologia",
      "pattume",
      "pavone",
      "peccato",
      "pedalare",
      "pedonale",
      "peggio",
      "peloso",
      "penare",
      "pendice",
      "penisola",
      "pennuto",
      "penombra",
      "pensare",
      "pentola",
      "pepe",
      "pepita",
      "perbene",
      "percorso",
      "perdonato",
      "perforare",
      "pergamena",
      "periodo",
      "permesso",
      "perno",
      "perplesso",
      "persuaso",
      "pertugio",
      "pervaso",
      "pesatore",
      "pesista",
      "peso",
      "pestifero",
      "petalo",
      "pettine",
      "petulante",
      "pezzo",
      "piacere",
      "pianta",
      "piattino",
      "piccino",
      "picozza",
      "piega",
      "pietra",
      "piffero",
      "pigiama",
      "pigolio",
      "pigro",
      "pila",
      "pilifero",
      "pillola",
      "pilota",
      "pimpante",
      "pineta",
      "pinna",
      "pinolo",
      "pioggia",
      "piombo",
      "piramide",
      "piretico",
      "pirite",
      "pirolisi",
      "pitone",
      "pizzico",
      "placebo",
      "planare",
      "plasma",
      "platano",
      "plenario",
      "pochezza",
      "poderoso",
      "podismo",
      "poesia",
      "poggiare",
      "polenta",
      "poligono",
      "pollice",
      "polmonite",
      "polpetta",
      "polso",
      "poltrona",
      "polvere",
      "pomice",
      "pomodoro",
      "ponte",
      "popoloso",
      "porfido",
      "poroso",
      "porpora",
      "porre",
      "portata",
      "posa",
      "positivo",
      "possesso",
      "postulato",
      "potassio",
      "potere",
      "pranzo",
      "prassi",
      "pratica",
      "precluso",
      "predica",
      "prefisso",
      "pregiato",
      "prelievo",
      "premere",
      "prenotare",
      "preparato",
      "presenza",
      "pretesto",
      "prevalso",
      "prima",
      "principe",
      "privato",
      "problema",
      "procura",
      "produrre",
      "profumo",
      "progetto",
      "prolunga",
      "promessa",
      "pronome",
      "proposta",
      "proroga",
      "proteso",
      "prova",
      "prudente",
      "prugna",
      "prurito",
      "psiche",
      "pubblico",
      "pudica",
      "pugilato",
      "pugno",
      "pulce",
      "pulito",
      "pulsante",
      "puntare",
      "pupazzo",
      "pupilla",
      "puro",
      "quadro",
      "qualcosa",
      "quasi",
      "querela",
      "quota",
      "raccolto",
      "raddoppio",
      "radicale",
      "radunato",
      "raffica",
      "ragazzo",
      "ragione",
      "ragno",
      "ramarro",
      "ramingo",
      "ramo",
      "randagio",
      "rantolare",
      "rapato",
      "rapina",
      "rappreso",
      "rasatura",
      "raschiato",
      "rasente",
      "rassegna",
      "rastrello",
      "rata",
      "ravveduto",
      "reale",
      "recepire",
      "recinto",
      "recluta",
      "recondito",
      "recupero",
      "reddito",
      "redimere",
      "regalato",
      "registro",
      "regola",
      "regresso",
      "relazione",
      "remare",
      "remoto",
      "renna",
      "replica",
      "reprimere",
      "reputare",
      "resa",
      "residente",
      "responso",
      "restauro",
      "rete",
      "retina",
      "retorica",
      "rettifica",
      "revocato",
      "riassunto",
      "ribadire",
      "ribelle",
      "ribrezzo",
      "ricarica",
      "ricco",
      "ricevere",
      "riciclato",
      "ricordo",
      "ricreduto",
      "ridicolo",
      "ridurre",
      "rifasare",
      "riflesso",
      "riforma",
      "rifugio",
      "rigare",
      "rigettato",
      "righello",
      "rilassato",
      "rilevato",
      "rimanere",
      "rimbalzo",
      "rimedio",
      "rimorchio",
      "rinascita",
      "rincaro",
      "rinforzo",
      "rinnovo",
      "rinomato",
      "rinsavito",
      "rintocco",
      "rinuncia",
      "rinvenire",
      "riparato",
      "ripetuto",
      "ripieno",
      "riportare",
      "ripresa",
      "ripulire",
      "risata",
      "rischio",
      "riserva",
      "risibile",
      "riso",
      "rispetto",
      "ristoro",
      "risultato",
      "risvolto",
      "ritardo",
      "ritegno",
      "ritmico",
      "ritrovo",
      "riunione",
      "riva",
      "riverso",
      "rivincita",
      "rivolto",
      "rizoma",
      "roba",
      "robotico",
      "robusto",
      "roccia",
      "roco",
      "rodaggio",
      "rodere",
      "roditore",
      "rogito",
      "rollio",
      "romantico",
      "rompere",
      "ronzio",
      "rosolare",
      "rospo",
      "rotante",
      "rotondo",
      "rotula",
      "rovescio",
      "rubizzo",
      "rubrica",
      "ruga",
      "rullino",
      "rumine",
      "rumoroso",
      "ruolo",
      "rupe",
      "russare",
      "rustico",
      "sabato",
      "sabbiare",
      "sabotato",
      "sagoma",
      "salasso",
      "saldatura",
      "salgemma",
      "salivare",
      "salmone",
      "salone",
      "saltare",
      "saluto",
      "salvo",
      "sapere",
      "sapido",
      "saporito",
      "saraceno",
      "sarcasmo",
      "sarto",
      "sassoso",
      "satellite",
      "satira",
      "satollo",
      "saturno",
      "savana",
      "savio",
      "saziato",
      "sbadiglio",
      "sbalzo",
      "sbancato",
      "sbarra",
      "sbattere",
      "sbavare",
      "sbendare",
      "sbirciare",
      "sbloccato",
      "sbocciato",
      "sbrinare",
      "sbruffone",
      "sbuffare",
      "scabroso",
      "scadenza",
      "scala",
      "scambiare",
      "scandalo",
      "scapola",
      "scarso",
      "scatenare",
      "scavato",
      "scelto",
      "scenico",
      "scettro",
      "scheda",
      "schiena",
      "sciarpa",
      "scienza",
      "scindere",
      "scippo",
      "sciroppo",
      "scivolo",
      "sclerare",
      "scodella",
      "scolpito",
      "scomparto",
      "sconforto",
      "scoprire",
      "scorta",
      "scossone",
      "scozzese",
      "scriba",
      "scrollare",
      "scrutinio",
      "scuderia",
      "scultore",
      "scuola",
      "scuro",
      "scusare",
      "sdebitare",
      "sdoganare",
      "seccatura",
      "secondo",
      "sedano",
      "seggiola",
      "segnalato",
      "segregato",
      "seguito",
      "selciato",
      "selettivo",
      "sella",
      "selvaggio",
      "semaforo",
      "sembrare",
      "seme",
      "seminato",
      "sempre",
      "senso",
      "sentire",
      "sepolto",
      "sequenza",
      "serata",
      "serbato",
      "sereno",
      "serio",
      "serpente",
      "serraglio",
      "servire",
      "sestina",
      "setola",
      "settimana",
      "sfacelo",
      "sfaldare",
      "sfamato",
      "sfarzoso",
      "sfaticato",
      "sfera",
      "sfida",
      "sfilato",
      "sfinge",
      "sfocato",
      "sfoderare",
      "sfogo",
      "sfoltire",
      "sforzato",
      "sfratto",
      "sfruttato",
      "sfuggito",
      "sfumare",
      "sfuso",
      "sgabello",
      "sgarbato",
      "sgonfiare",
      "sgorbio",
      "sgrassato",
      "sguardo",
      "sibilo",
      "siccome",
      "sierra",
      "sigla",
      "signore",
      "silenzio",
      "sillaba",
      "simbolo",
      "simpatico",
      "simulato",
      "sinfonia",
      "singolo",
      "sinistro",
      "sino",
      "sintesi",
      "sinusoide",
      "sipario",
      "sisma",
      "sistole",
      "situato",
      "slitta",
      "slogatura",
      "sloveno",
      "smarrito",
      "smemorato",
      "smentito",
      "smeraldo",
      "smilzo",
      "smontare",
      "smottato",
      "smussato",
      "snellire",
      "snervato",
      "snodo",
      "sobbalzo",
      "sobrio",
      "soccorso",
      "sociale",
      "sodale",
      "soffitto",
      "sogno",
      "soldato",
      "solenne",
      "solido",
      "sollazzo",
      "solo",
      "solubile",
      "solvente",
      "somatico",
      "somma",
      "sonda",
      "sonetto",
      "sonnifero",
      "sopire",
      "soppeso",
      "sopra",
      "sorgere",
      "sorpasso",
      "sorriso",
      "sorso",
      "sorteggio",
      "sorvolato",
      "sospiro",
      "sosta",
      "sottile",
      "spada",
      "spalla",
      "spargere",
      "spatola",
      "spavento",
      "spazzola",
      "specie",
      "spedire",
      "spegnere",
      "spelatura",
      "speranza",
      "spessore",
      "spettrale",
      "spezzato",
      "spia",
      "spigoloso",
      "spillato",
      "spinoso",
      "spirale",
      "splendido",
      "sportivo",
      "sposo",
      "spranga",
      "sprecare",
      "spronato",
      "spruzzo",
      "spuntino",
      "squillo",
      "sradicare",
      "srotolato",
      "stabile",
      "stacco",
      "staffa",
      "stagnare",
      "stampato",
      "stantio",
      "starnuto",
      "stasera",
      "statuto",
      "stelo",
      "steppa",
      "sterzo",
      "stiletto",
      "stima",
      "stirpe",
      "stivale",
      "stizzoso",
      "stonato",
      "storico",
      "strappo",
      "stregato",
      "stridulo",
      "strozzare",
      "strutto",
      "stuccare",
      "stufo",
      "stupendo",
      "subentro",
      "succoso",
      "sudore",
      "suggerito",
      "sugo",
      "sultano",
      "suonare",
      "superbo",
      "supporto",
      "surgelato",
      "surrogato",
      "sussurro",
      "sutura",
      "svagare",
      "svedese",
      "sveglio",
      "svelare",
      "svenuto",
      "svezia",
      "sviluppo",
      "svista",
      "svizzera",
      "svolta",
      "svuotare",
      "tabacco",
      "tabulato",
      "tacciare",
      "taciturno",
      "tale",
      "talismano",
      "tampone",
      "tannino",
      "tara",
      "tardivo",
      "targato",
      "tariffa",
      "tarpare",
      "tartaruga",
      "tasto",
      "tattico",
      "taverna",
      "tavolata",
      "tazza",
      "teca",
      "tecnico",
      "telefono",
      "temerario",
      "tempo",
      "temuto",
      "tendone",
      "tenero",
      "tensione",
      "tentacolo",
      "teorema",
      "terme",
      "terrazzo",
      "terzetto",
      "tesi",
      "tesserato",
      "testato",
      "tetro",
      "tettoia",
      "tifare",
      "tigella",
      "timbro",
      "tinto",
      "tipico",
      "tipografo",
      "tiraggio",
      "tiro",
      "titanio",
      "titolo",
      "titubante",
      "tizio",
      "tizzone",
      "toccare",
      "tollerare",
      "tolto",
      "tombola",
      "tomo",
      "tonfo",
      "tonsilla",
      "topazio",
      "topologia",
      "toppa",
      "torba",
      "tornare",
      "torrone",
      "tortora",
      "toscano",
      "tossire",
      "tostatura",
      "totano",
      "trabocco",
      "trachea",
      "trafila",
      "tragedia",
      "tralcio",
      "tramonto",
      "transito",
      "trapano",
      "trarre",
      "trasloco",
      "trattato",
      "trave",
      "treccia",
      "tremolio",
      "trespolo",
      "tributo",
      "tricheco",
      "trifoglio",
      "trillo",
      "trincea",
      "trio",
      "tristezza",
      "triturato",
      "trivella",
      "tromba",
      "trono",
      "troppo",
      "trottola",
      "trovare",
      "truccato",
      "tubatura",
      "tuffato",
      "tulipano",
      "tumulto",
      "tunisia",
      "turbare",
      "turchino",
      "tuta",
      "tutela",
      "ubicato",
      "uccello",
      "uccisore",
      "udire",
      "uditivo",
      "uffa",
      "ufficio",
      "uguale",
      "ulisse",
      "ultimato",
      "umano",
      "umile",
      "umorismo",
      "uncinetto",
      "ungere",
      "ungherese",
      "unicorno",
      "unificato",
      "unisono",
      "unitario",
      "unte",
      "uovo",
      "upupa",
      "uragano",
      "urgenza",
      "urlo",
      "usanza",
      "usato",
      "uscito",
      "usignolo",
      "usuraio",
      "utensile",
      "utilizzo",
      "utopia",
      "vacante",
      "vaccinato",
      "vagabondo",
      "vagliato",
      "valanga",
      "valgo",
      "valico",
      "valletta",
      "valoroso",
      "valutare",
      "valvola",
      "vampata",
      "vangare",
      "vanitoso",
      "vano",
      "vantaggio",
      "vanvera",
      "vapore",
      "varano",
      "varcato",
      "variante",
      "vasca",
      "vedetta",
      "vedova",
      "veduto",
      "vegetale",
      "veicolo",
      "velcro",
      "velina",
      "velluto",
      "veloce",
      "venato",
      "vendemmia",
      "vento",
      "verace",
      "verbale",
      "vergogna",
      "verifica",
      "vero",
      "verruca",
      "verticale",
      "vescica",
      "vessillo",
      "vestale",
      "veterano",
      "vetrina",
      "vetusto",
      "viandante",
      "vibrante",
      "vicenda",
      "vichingo",
      "vicinanza",
      "vidimare",
      "vigilia",
      "vigneto",
      "vigore",
      "vile",
      "villano",
      "vimini",
      "vincitore",
      "viola",
      "vipera",
      "virgola",
      "virologo",
      "virulento",
      "viscoso",
      "visione",
      "vispo",
      "vissuto",
      "visura",
      "vita",
      "vitello",
      "vittima",
      "vivanda",
      "vivido",
      "viziare",
      "voce",
      "voga",
      "volatile",
      "volere",
      "volpe",
      "voragine",
      "vulcano",
      "zampogna",
      "zanna",
      "zappato",
      "zattera",
      "zavorra",
      "zefiro",
      "zelante",
      "zelo",
      "zenzero",
      "zerbino",
      "zibetto",
      "zinco",
      "zircone",
      "zitto",
      "zolla",
      "zotico",
      "zucchero",
      "zufolo",
      "zulu",
      "zuppa"
    ];
  }
});

// node_modules/bip39/src/wordlists/spanish.json
var require_spanish = __commonJS({
  "node_modules/bip39/src/wordlists/spanish.json"(exports, module) {
    module.exports = [
      "ábaco",
      "abdomen",
      "abeja",
      "abierto",
      "abogado",
      "abono",
      "aborto",
      "abrazo",
      "abrir",
      "abuelo",
      "abuso",
      "acabar",
      "academia",
      "acceso",
      "acción",
      "aceite",
      "acelga",
      "acento",
      "aceptar",
      "ácido",
      "aclarar",
      "acné",
      "acoger",
      "acoso",
      "activo",
      "acto",
      "actriz",
      "actuar",
      "acudir",
      "acuerdo",
      "acusar",
      "adicto",
      "admitir",
      "adoptar",
      "adorno",
      "aduana",
      "adulto",
      "aéreo",
      "afectar",
      "afición",
      "afinar",
      "afirmar",
      "ágil",
      "agitar",
      "agonía",
      "agosto",
      "agotar",
      "agregar",
      "agrio",
      "agua",
      "agudo",
      "águila",
      "aguja",
      "ahogo",
      "ahorro",
      "aire",
      "aislar",
      "ajedrez",
      "ajeno",
      "ajuste",
      "alacrán",
      "alambre",
      "alarma",
      "alba",
      "álbum",
      "alcalde",
      "aldea",
      "alegre",
      "alejar",
      "alerta",
      "aleta",
      "alfiler",
      "alga",
      "algodón",
      "aliado",
      "aliento",
      "alivio",
      "alma",
      "almeja",
      "almíbar",
      "altar",
      "alteza",
      "altivo",
      "alto",
      "altura",
      "alumno",
      "alzar",
      "amable",
      "amante",
      "amapola",
      "amargo",
      "amasar",
      "ámbar",
      "ámbito",
      "ameno",
      "amigo",
      "amistad",
      "amor",
      "amparo",
      "amplio",
      "ancho",
      "anciano",
      "ancla",
      "andar",
      "andén",
      "anemia",
      "ángulo",
      "anillo",
      "ánimo",
      "anís",
      "anotar",
      "antena",
      "antiguo",
      "antojo",
      "anual",
      "anular",
      "anuncio",
      "añadir",
      "añejo",
      "año",
      "apagar",
      "aparato",
      "apetito",
      "apio",
      "aplicar",
      "apodo",
      "aporte",
      "apoyo",
      "aprender",
      "aprobar",
      "apuesta",
      "apuro",
      "arado",
      "araña",
      "arar",
      "árbitro",
      "árbol",
      "arbusto",
      "archivo",
      "arco",
      "arder",
      "ardilla",
      "arduo",
      "área",
      "árido",
      "aries",
      "armonía",
      "arnés",
      "aroma",
      "arpa",
      "arpón",
      "arreglo",
      "arroz",
      "arruga",
      "arte",
      "artista",
      "asa",
      "asado",
      "asalto",
      "ascenso",
      "asegurar",
      "aseo",
      "asesor",
      "asiento",
      "asilo",
      "asistir",
      "asno",
      "asombro",
      "áspero",
      "astilla",
      "astro",
      "astuto",
      "asumir",
      "asunto",
      "atajo",
      "ataque",
      "atar",
      "atento",
      "ateo",
      "ático",
      "atleta",
      "átomo",
      "atraer",
      "atroz",
      "atún",
      "audaz",
      "audio",
      "auge",
      "aula",
      "aumento",
      "ausente",
      "autor",
      "aval",
      "avance",
      "avaro",
      "ave",
      "avellana",
      "avena",
      "avestruz",
      "avión",
      "aviso",
      "ayer",
      "ayuda",
      "ayuno",
      "azafrán",
      "azar",
      "azote",
      "azúcar",
      "azufre",
      "azul",
      "baba",
      "babor",
      "bache",
      "bahía",
      "baile",
      "bajar",
      "balanza",
      "balcón",
      "balde",
      "bambú",
      "banco",
      "banda",
      "baño",
      "barba",
      "barco",
      "barniz",
      "barro",
      "báscula",
      "bastón",
      "basura",
      "batalla",
      "batería",
      "batir",
      "batuta",
      "baúl",
      "bazar",
      "bebé",
      "bebida",
      "bello",
      "besar",
      "beso",
      "bestia",
      "bicho",
      "bien",
      "bingo",
      "blanco",
      "bloque",
      "blusa",
      "boa",
      "bobina",
      "bobo",
      "boca",
      "bocina",
      "boda",
      "bodega",
      "boina",
      "bola",
      "bolero",
      "bolsa",
      "bomba",
      "bondad",
      "bonito",
      "bono",
      "bonsái",
      "borde",
      "borrar",
      "bosque",
      "bote",
      "botín",
      "bóveda",
      "bozal",
      "bravo",
      "brazo",
      "brecha",
      "breve",
      "brillo",
      "brinco",
      "brisa",
      "broca",
      "broma",
      "bronce",
      "brote",
      "bruja",
      "brusco",
      "bruto",
      "buceo",
      "bucle",
      "bueno",
      "buey",
      "bufanda",
      "bufón",
      "búho",
      "buitre",
      "bulto",
      "burbuja",
      "burla",
      "burro",
      "buscar",
      "butaca",
      "buzón",
      "caballo",
      "cabeza",
      "cabina",
      "cabra",
      "cacao",
      "cadáver",
      "cadena",
      "caer",
      "café",
      "caída",
      "caimán",
      "caja",
      "cajón",
      "cal",
      "calamar",
      "calcio",
      "caldo",
      "calidad",
      "calle",
      "calma",
      "calor",
      "calvo",
      "cama",
      "cambio",
      "camello",
      "camino",
      "campo",
      "cáncer",
      "candil",
      "canela",
      "canguro",
      "canica",
      "canto",
      "caña",
      "cañón",
      "caoba",
      "caos",
      "capaz",
      "capitán",
      "capote",
      "captar",
      "capucha",
      "cara",
      "carbón",
      "cárcel",
      "careta",
      "carga",
      "cariño",
      "carne",
      "carpeta",
      "carro",
      "carta",
      "casa",
      "casco",
      "casero",
      "caspa",
      "castor",
      "catorce",
      "catre",
      "caudal",
      "causa",
      "cazo",
      "cebolla",
      "ceder",
      "cedro",
      "celda",
      "célebre",
      "celoso",
      "célula",
      "cemento",
      "ceniza",
      "centro",
      "cerca",
      "cerdo",
      "cereza",
      "cero",
      "cerrar",
      "certeza",
      "césped",
      "cetro",
      "chacal",
      "chaleco",
      "champú",
      "chancla",
      "chapa",
      "charla",
      "chico",
      "chiste",
      "chivo",
      "choque",
      "choza",
      "chuleta",
      "chupar",
      "ciclón",
      "ciego",
      "cielo",
      "cien",
      "cierto",
      "cifra",
      "cigarro",
      "cima",
      "cinco",
      "cine",
      "cinta",
      "ciprés",
      "circo",
      "ciruela",
      "cisne",
      "cita",
      "ciudad",
      "clamor",
      "clan",
      "claro",
      "clase",
      "clave",
      "cliente",
      "clima",
      "clínica",
      "cobre",
      "cocción",
      "cochino",
      "cocina",
      "coco",
      "código",
      "codo",
      "cofre",
      "coger",
      "cohete",
      "cojín",
      "cojo",
      "cola",
      "colcha",
      "colegio",
      "colgar",
      "colina",
      "collar",
      "colmo",
      "columna",
      "combate",
      "comer",
      "comida",
      "cómodo",
      "compra",
      "conde",
      "conejo",
      "conga",
      "conocer",
      "consejo",
      "contar",
      "copa",
      "copia",
      "corazón",
      "corbata",
      "corcho",
      "cordón",
      "corona",
      "correr",
      "coser",
      "cosmos",
      "costa",
      "cráneo",
      "cráter",
      "crear",
      "crecer",
      "creído",
      "crema",
      "cría",
      "crimen",
      "cripta",
      "crisis",
      "cromo",
      "crónica",
      "croqueta",
      "crudo",
      "cruz",
      "cuadro",
      "cuarto",
      "cuatro",
      "cubo",
      "cubrir",
      "cuchara",
      "cuello",
      "cuento",
      "cuerda",
      "cuesta",
      "cueva",
      "cuidar",
      "culebra",
      "culpa",
      "culto",
      "cumbre",
      "cumplir",
      "cuna",
      "cuneta",
      "cuota",
      "cupón",
      "cúpula",
      "curar",
      "curioso",
      "curso",
      "curva",
      "cutis",
      "dama",
      "danza",
      "dar",
      "dardo",
      "dátil",
      "deber",
      "débil",
      "década",
      "decir",
      "dedo",
      "defensa",
      "definir",
      "dejar",
      "delfín",
      "delgado",
      "delito",
      "demora",
      "denso",
      "dental",
      "deporte",
      "derecho",
      "derrota",
      "desayuno",
      "deseo",
      "desfile",
      "desnudo",
      "destino",
      "desvío",
      "detalle",
      "detener",
      "deuda",
      "día",
      "diablo",
      "diadema",
      "diamante",
      "diana",
      "diario",
      "dibujo",
      "dictar",
      "diente",
      "dieta",
      "diez",
      "difícil",
      "digno",
      "dilema",
      "diluir",
      "dinero",
      "directo",
      "dirigir",
      "disco",
      "diseño",
      "disfraz",
      "diva",
      "divino",
      "doble",
      "doce",
      "dolor",
      "domingo",
      "don",
      "donar",
      "dorado",
      "dormir",
      "dorso",
      "dos",
      "dosis",
      "dragón",
      "droga",
      "ducha",
      "duda",
      "duelo",
      "dueño",
      "dulce",
      "dúo",
      "duque",
      "durar",
      "dureza",
      "duro",
      "ébano",
      "ebrio",
      "echar",
      "eco",
      "ecuador",
      "edad",
      "edición",
      "edificio",
      "editor",
      "educar",
      "efecto",
      "eficaz",
      "eje",
      "ejemplo",
      "elefante",
      "elegir",
      "elemento",
      "elevar",
      "elipse",
      "élite",
      "elixir",
      "elogio",
      "eludir",
      "embudo",
      "emitir",
      "emoción",
      "empate",
      "empeño",
      "empleo",
      "empresa",
      "enano",
      "encargo",
      "enchufe",
      "encía",
      "enemigo",
      "enero",
      "enfado",
      "enfermo",
      "engaño",
      "enigma",
      "enlace",
      "enorme",
      "enredo",
      "ensayo",
      "enseñar",
      "entero",
      "entrar",
      "envase",
      "envío",
      "época",
      "equipo",
      "erizo",
      "escala",
      "escena",
      "escolar",
      "escribir",
      "escudo",
      "esencia",
      "esfera",
      "esfuerzo",
      "espada",
      "espejo",
      "espía",
      "esposa",
      "espuma",
      "esquí",
      "estar",
      "este",
      "estilo",
      "estufa",
      "etapa",
      "eterno",
      "ética",
      "etnia",
      "evadir",
      "evaluar",
      "evento",
      "evitar",
      "exacto",
      "examen",
      "exceso",
      "excusa",
      "exento",
      "exigir",
      "exilio",
      "existir",
      "éxito",
      "experto",
      "explicar",
      "exponer",
      "extremo",
      "fábrica",
      "fábula",
      "fachada",
      "fácil",
      "factor",
      "faena",
      "faja",
      "falda",
      "fallo",
      "falso",
      "faltar",
      "fama",
      "familia",
      "famoso",
      "faraón",
      "farmacia",
      "farol",
      "farsa",
      "fase",
      "fatiga",
      "fauna",
      "favor",
      "fax",
      "febrero",
      "fecha",
      "feliz",
      "feo",
      "feria",
      "feroz",
      "fértil",
      "fervor",
      "festín",
      "fiable",
      "fianza",
      "fiar",
      "fibra",
      "ficción",
      "ficha",
      "fideo",
      "fiebre",
      "fiel",
      "fiera",
      "fiesta",
      "figura",
      "fijar",
      "fijo",
      "fila",
      "filete",
      "filial",
      "filtro",
      "fin",
      "finca",
      "fingir",
      "finito",
      "firma",
      "flaco",
      "flauta",
      "flecha",
      "flor",
      "flota",
      "fluir",
      "flujo",
      "flúor",
      "fobia",
      "foca",
      "fogata",
      "fogón",
      "folio",
      "folleto",
      "fondo",
      "forma",
      "forro",
      "fortuna",
      "forzar",
      "fosa",
      "foto",
      "fracaso",
      "frágil",
      "franja",
      "frase",
      "fraude",
      "freír",
      "freno",
      "fresa",
      "frío",
      "frito",
      "fruta",
      "fuego",
      "fuente",
      "fuerza",
      "fuga",
      "fumar",
      "función",
      "funda",
      "furgón",
      "furia",
      "fusil",
      "fútbol",
      "futuro",
      "gacela",
      "gafas",
      "gaita",
      "gajo",
      "gala",
      "galería",
      "gallo",
      "gamba",
      "ganar",
      "gancho",
      "ganga",
      "ganso",
      "garaje",
      "garza",
      "gasolina",
      "gastar",
      "gato",
      "gavilán",
      "gemelo",
      "gemir",
      "gen",
      "género",
      "genio",
      "gente",
      "geranio",
      "gerente",
      "germen",
      "gesto",
      "gigante",
      "gimnasio",
      "girar",
      "giro",
      "glaciar",
      "globo",
      "gloria",
      "gol",
      "golfo",
      "goloso",
      "golpe",
      "goma",
      "gordo",
      "gorila",
      "gorra",
      "gota",
      "goteo",
      "gozar",
      "grada",
      "gráfico",
      "grano",
      "grasa",
      "gratis",
      "grave",
      "grieta",
      "grillo",
      "gripe",
      "gris",
      "grito",
      "grosor",
      "grúa",
      "grueso",
      "grumo",
      "grupo",
      "guante",
      "guapo",
      "guardia",
      "guerra",
      "guía",
      "guiño",
      "guion",
      "guiso",
      "guitarra",
      "gusano",
      "gustar",
      "haber",
      "hábil",
      "hablar",
      "hacer",
      "hacha",
      "hada",
      "hallar",
      "hamaca",
      "harina",
      "haz",
      "hazaña",
      "hebilla",
      "hebra",
      "hecho",
      "helado",
      "helio",
      "hembra",
      "herir",
      "hermano",
      "héroe",
      "hervir",
      "hielo",
      "hierro",
      "hígado",
      "higiene",
      "hijo",
      "himno",
      "historia",
      "hocico",
      "hogar",
      "hoguera",
      "hoja",
      "hombre",
      "hongo",
      "honor",
      "honra",
      "hora",
      "hormiga",
      "horno",
      "hostil",
      "hoyo",
      "hueco",
      "huelga",
      "huerta",
      "hueso",
      "huevo",
      "huida",
      "huir",
      "humano",
      "húmedo",
      "humilde",
      "humo",
      "hundir",
      "huracán",
      "hurto",
      "icono",
      "ideal",
      "idioma",
      "ídolo",
      "iglesia",
      "iglú",
      "igual",
      "ilegal",
      "ilusión",
      "imagen",
      "imán",
      "imitar",
      "impar",
      "imperio",
      "imponer",
      "impulso",
      "incapaz",
      "índice",
      "inerte",
      "infiel",
      "informe",
      "ingenio",
      "inicio",
      "inmenso",
      "inmune",
      "innato",
      "insecto",
      "instante",
      "interés",
      "íntimo",
      "intuir",
      "inútil",
      "invierno",
      "ira",
      "iris",
      "ironía",
      "isla",
      "islote",
      "jabalí",
      "jabón",
      "jamón",
      "jarabe",
      "jardín",
      "jarra",
      "jaula",
      "jazmín",
      "jefe",
      "jeringa",
      "jinete",
      "jornada",
      "joroba",
      "joven",
      "joya",
      "juerga",
      "jueves",
      "juez",
      "jugador",
      "jugo",
      "juguete",
      "juicio",
      "junco",
      "jungla",
      "junio",
      "juntar",
      "júpiter",
      "jurar",
      "justo",
      "juvenil",
      "juzgar",
      "kilo",
      "koala",
      "labio",
      "lacio",
      "lacra",
      "lado",
      "ladrón",
      "lagarto",
      "lágrima",
      "laguna",
      "laico",
      "lamer",
      "lámina",
      "lámpara",
      "lana",
      "lancha",
      "langosta",
      "lanza",
      "lápiz",
      "largo",
      "larva",
      "lástima",
      "lata",
      "látex",
      "latir",
      "laurel",
      "lavar",
      "lazo",
      "leal",
      "lección",
      "leche",
      "lector",
      "leer",
      "legión",
      "legumbre",
      "lejano",
      "lengua",
      "lento",
      "leña",
      "león",
      "leopardo",
      "lesión",
      "letal",
      "letra",
      "leve",
      "leyenda",
      "libertad",
      "libro",
      "licor",
      "líder",
      "lidiar",
      "lienzo",
      "liga",
      "ligero",
      "lima",
      "límite",
      "limón",
      "limpio",
      "lince",
      "lindo",
      "línea",
      "lingote",
      "lino",
      "linterna",
      "líquido",
      "liso",
      "lista",
      "litera",
      "litio",
      "litro",
      "llaga",
      "llama",
      "llanto",
      "llave",
      "llegar",
      "llenar",
      "llevar",
      "llorar",
      "llover",
      "lluvia",
      "lobo",
      "loción",
      "loco",
      "locura",
      "lógica",
      "logro",
      "lombriz",
      "lomo",
      "lonja",
      "lote",
      "lucha",
      "lucir",
      "lugar",
      "lujo",
      "luna",
      "lunes",
      "lupa",
      "lustro",
      "luto",
      "luz",
      "maceta",
      "macho",
      "madera",
      "madre",
      "maduro",
      "maestro",
      "mafia",
      "magia",
      "mago",
      "maíz",
      "maldad",
      "maleta",
      "malla",
      "malo",
      "mamá",
      "mambo",
      "mamut",
      "manco",
      "mando",
      "manejar",
      "manga",
      "maniquí",
      "manjar",
      "mano",
      "manso",
      "manta",
      "mañana",
      "mapa",
      "máquina",
      "mar",
      "marco",
      "marea",
      "marfil",
      "margen",
      "marido",
      "mármol",
      "marrón",
      "martes",
      "marzo",
      "masa",
      "máscara",
      "masivo",
      "matar",
      "materia",
      "matiz",
      "matriz",
      "máximo",
      "mayor",
      "mazorca",
      "mecha",
      "medalla",
      "medio",
      "médula",
      "mejilla",
      "mejor",
      "melena",
      "melón",
      "memoria",
      "menor",
      "mensaje",
      "mente",
      "menú",
      "mercado",
      "merengue",
      "mérito",
      "mes",
      "mesón",
      "meta",
      "meter",
      "método",
      "metro",
      "mezcla",
      "miedo",
      "miel",
      "miembro",
      "miga",
      "mil",
      "milagro",
      "militar",
      "millón",
      "mimo",
      "mina",
      "minero",
      "mínimo",
      "minuto",
      "miope",
      "mirar",
      "misa",
      "miseria",
      "misil",
      "mismo",
      "mitad",
      "mito",
      "mochila",
      "moción",
      "moda",
      "modelo",
      "moho",
      "mojar",
      "molde",
      "moler",
      "molino",
      "momento",
      "momia",
      "monarca",
      "moneda",
      "monja",
      "monto",
      "moño",
      "morada",
      "morder",
      "moreno",
      "morir",
      "morro",
      "morsa",
      "mortal",
      "mosca",
      "mostrar",
      "motivo",
      "mover",
      "móvil",
      "mozo",
      "mucho",
      "mudar",
      "mueble",
      "muela",
      "muerte",
      "muestra",
      "mugre",
      "mujer",
      "mula",
      "muleta",
      "multa",
      "mundo",
      "muñeca",
      "mural",
      "muro",
      "músculo",
      "museo",
      "musgo",
      "música",
      "muslo",
      "nácar",
      "nación",
      "nadar",
      "naipe",
      "naranja",
      "nariz",
      "narrar",
      "nasal",
      "natal",
      "nativo",
      "natural",
      "náusea",
      "naval",
      "nave",
      "navidad",
      "necio",
      "néctar",
      "negar",
      "negocio",
      "negro",
      "neón",
      "nervio",
      "neto",
      "neutro",
      "nevar",
      "nevera",
      "nicho",
      "nido",
      "niebla",
      "nieto",
      "niñez",
      "niño",
      "nítido",
      "nivel",
      "nobleza",
      "noche",
      "nómina",
      "noria",
      "norma",
      "norte",
      "nota",
      "noticia",
      "novato",
      "novela",
      "novio",
      "nube",
      "nuca",
      "núcleo",
      "nudillo",
      "nudo",
      "nuera",
      "nueve",
      "nuez",
      "nulo",
      "número",
      "nutria",
      "oasis",
      "obeso",
      "obispo",
      "objeto",
      "obra",
      "obrero",
      "observar",
      "obtener",
      "obvio",
      "oca",
      "ocaso",
      "océano",
      "ochenta",
      "ocho",
      "ocio",
      "ocre",
      "octavo",
      "octubre",
      "oculto",
      "ocupar",
      "ocurrir",
      "odiar",
      "odio",
      "odisea",
      "oeste",
      "ofensa",
      "oferta",
      "oficio",
      "ofrecer",
      "ogro",
      "oído",
      "oír",
      "ojo",
      "ola",
      "oleada",
      "olfato",
      "olivo",
      "olla",
      "olmo",
      "olor",
      "olvido",
      "ombligo",
      "onda",
      "onza",
      "opaco",
      "opción",
      "ópera",
      "opinar",
      "oponer",
      "optar",
      "óptica",
      "opuesto",
      "oración",
      "orador",
      "oral",
      "órbita",
      "orca",
      "orden",
      "oreja",
      "órgano",
      "orgía",
      "orgullo",
      "oriente",
      "origen",
      "orilla",
      "oro",
      "orquesta",
      "oruga",
      "osadía",
      "oscuro",
      "osezno",
      "oso",
      "ostra",
      "otoño",
      "otro",
      "oveja",
      "óvulo",
      "óxido",
      "oxígeno",
      "oyente",
      "ozono",
      "pacto",
      "padre",
      "paella",
      "página",
      "pago",
      "país",
      "pájaro",
      "palabra",
      "palco",
      "paleta",
      "pálido",
      "palma",
      "paloma",
      "palpar",
      "pan",
      "panal",
      "pánico",
      "pantera",
      "pañuelo",
      "papá",
      "papel",
      "papilla",
      "paquete",
      "parar",
      "parcela",
      "pared",
      "parir",
      "paro",
      "párpado",
      "parque",
      "párrafo",
      "parte",
      "pasar",
      "paseo",
      "pasión",
      "paso",
      "pasta",
      "pata",
      "patio",
      "patria",
      "pausa",
      "pauta",
      "pavo",
      "payaso",
      "peatón",
      "pecado",
      "pecera",
      "pecho",
      "pedal",
      "pedir",
      "pegar",
      "peine",
      "pelar",
      "peldaño",
      "pelea",
      "peligro",
      "pellejo",
      "pelo",
      "peluca",
      "pena",
      "pensar",
      "peñón",
      "peón",
      "peor",
      "pepino",
      "pequeño",
      "pera",
      "percha",
      "perder",
      "pereza",
      "perfil",
      "perico",
      "perla",
      "permiso",
      "perro",
      "persona",
      "pesa",
      "pesca",
      "pésimo",
      "pestaña",
      "pétalo",
      "petróleo",
      "pez",
      "pezuña",
      "picar",
      "pichón",
      "pie",
      "piedra",
      "pierna",
      "pieza",
      "pijama",
      "pilar",
      "piloto",
      "pimienta",
      "pino",
      "pintor",
      "pinza",
      "piña",
      "piojo",
      "pipa",
      "pirata",
      "pisar",
      "piscina",
      "piso",
      "pista",
      "pitón",
      "pizca",
      "placa",
      "plan",
      "plata",
      "playa",
      "plaza",
      "pleito",
      "pleno",
      "plomo",
      "pluma",
      "plural",
      "pobre",
      "poco",
      "poder",
      "podio",
      "poema",
      "poesía",
      "poeta",
      "polen",
      "policía",
      "pollo",
      "polvo",
      "pomada",
      "pomelo",
      "pomo",
      "pompa",
      "poner",
      "porción",
      "portal",
      "posada",
      "poseer",
      "posible",
      "poste",
      "potencia",
      "potro",
      "pozo",
      "prado",
      "precoz",
      "pregunta",
      "premio",
      "prensa",
      "preso",
      "previo",
      "primo",
      "príncipe",
      "prisión",
      "privar",
      "proa",
      "probar",
      "proceso",
      "producto",
      "proeza",
      "profesor",
      "programa",
      "prole",
      "promesa",
      "pronto",
      "propio",
      "próximo",
      "prueba",
      "público",
      "puchero",
      "pudor",
      "pueblo",
      "puerta",
      "puesto",
      "pulga",
      "pulir",
      "pulmón",
      "pulpo",
      "pulso",
      "puma",
      "punto",
      "puñal",
      "puño",
      "pupa",
      "pupila",
      "puré",
      "quedar",
      "queja",
      "quemar",
      "querer",
      "queso",
      "quieto",
      "química",
      "quince",
      "quitar",
      "rábano",
      "rabia",
      "rabo",
      "ración",
      "radical",
      "raíz",
      "rama",
      "rampa",
      "rancho",
      "rango",
      "rapaz",
      "rápido",
      "rapto",
      "rasgo",
      "raspa",
      "rato",
      "rayo",
      "raza",
      "razón",
      "reacción",
      "realidad",
      "rebaño",
      "rebote",
      "recaer",
      "receta",
      "rechazo",
      "recoger",
      "recreo",
      "recto",
      "recurso",
      "red",
      "redondo",
      "reducir",
      "reflejo",
      "reforma",
      "refrán",
      "refugio",
      "regalo",
      "regir",
      "regla",
      "regreso",
      "rehén",
      "reino",
      "reír",
      "reja",
      "relato",
      "relevo",
      "relieve",
      "relleno",
      "reloj",
      "remar",
      "remedio",
      "remo",
      "rencor",
      "rendir",
      "renta",
      "reparto",
      "repetir",
      "reposo",
      "reptil",
      "res",
      "rescate",
      "resina",
      "respeto",
      "resto",
      "resumen",
      "retiro",
      "retorno",
      "retrato",
      "reunir",
      "revés",
      "revista",
      "rey",
      "rezar",
      "rico",
      "riego",
      "rienda",
      "riesgo",
      "rifa",
      "rígido",
      "rigor",
      "rincón",
      "riñón",
      "río",
      "riqueza",
      "risa",
      "ritmo",
      "rito",
      "rizo",
      "roble",
      "roce",
      "rociar",
      "rodar",
      "rodeo",
      "rodilla",
      "roer",
      "rojizo",
      "rojo",
      "romero",
      "romper",
      "ron",
      "ronco",
      "ronda",
      "ropa",
      "ropero",
      "rosa",
      "rosca",
      "rostro",
      "rotar",
      "rubí",
      "rubor",
      "rudo",
      "rueda",
      "rugir",
      "ruido",
      "ruina",
      "ruleta",
      "rulo",
      "rumbo",
      "rumor",
      "ruptura",
      "ruta",
      "rutina",
      "sábado",
      "saber",
      "sabio",
      "sable",
      "sacar",
      "sagaz",
      "sagrado",
      "sala",
      "saldo",
      "salero",
      "salir",
      "salmón",
      "salón",
      "salsa",
      "salto",
      "salud",
      "salvar",
      "samba",
      "sanción",
      "sandía",
      "sanear",
      "sangre",
      "sanidad",
      "sano",
      "santo",
      "sapo",
      "saque",
      "sardina",
      "sartén",
      "sastre",
      "satán",
      "sauna",
      "saxofón",
      "sección",
      "seco",
      "secreto",
      "secta",
      "sed",
      "seguir",
      "seis",
      "sello",
      "selva",
      "semana",
      "semilla",
      "senda",
      "sensor",
      "señal",
      "señor",
      "separar",
      "sepia",
      "sequía",
      "ser",
      "serie",
      "sermón",
      "servir",
      "sesenta",
      "sesión",
      "seta",
      "setenta",
      "severo",
      "sexo",
      "sexto",
      "sidra",
      "siesta",
      "siete",
      "siglo",
      "signo",
      "sílaba",
      "silbar",
      "silencio",
      "silla",
      "símbolo",
      "simio",
      "sirena",
      "sistema",
      "sitio",
      "situar",
      "sobre",
      "socio",
      "sodio",
      "sol",
      "solapa",
      "soldado",
      "soledad",
      "sólido",
      "soltar",
      "solución",
      "sombra",
      "sondeo",
      "sonido",
      "sonoro",
      "sonrisa",
      "sopa",
      "soplar",
      "soporte",
      "sordo",
      "sorpresa",
      "sorteo",
      "sostén",
      "sótano",
      "suave",
      "subir",
      "suceso",
      "sudor",
      "suegra",
      "suelo",
      "sueño",
      "suerte",
      "sufrir",
      "sujeto",
      "sultán",
      "sumar",
      "superar",
      "suplir",
      "suponer",
      "supremo",
      "sur",
      "surco",
      "sureño",
      "surgir",
      "susto",
      "sutil",
      "tabaco",
      "tabique",
      "tabla",
      "tabú",
      "taco",
      "tacto",
      "tajo",
      "talar",
      "talco",
      "talento",
      "talla",
      "talón",
      "tamaño",
      "tambor",
      "tango",
      "tanque",
      "tapa",
      "tapete",
      "tapia",
      "tapón",
      "taquilla",
      "tarde",
      "tarea",
      "tarifa",
      "tarjeta",
      "tarot",
      "tarro",
      "tarta",
      "tatuaje",
      "tauro",
      "taza",
      "tazón",
      "teatro",
      "techo",
      "tecla",
      "técnica",
      "tejado",
      "tejer",
      "tejido",
      "tela",
      "teléfono",
      "tema",
      "temor",
      "templo",
      "tenaz",
      "tender",
      "tener",
      "tenis",
      "tenso",
      "teoría",
      "terapia",
      "terco",
      "término",
      "ternura",
      "terror",
      "tesis",
      "tesoro",
      "testigo",
      "tetera",
      "texto",
      "tez",
      "tibio",
      "tiburón",
      "tiempo",
      "tienda",
      "tierra",
      "tieso",
      "tigre",
      "tijera",
      "tilde",
      "timbre",
      "tímido",
      "timo",
      "tinta",
      "tío",
      "típico",
      "tipo",
      "tira",
      "tirón",
      "titán",
      "títere",
      "título",
      "tiza",
      "toalla",
      "tobillo",
      "tocar",
      "tocino",
      "todo",
      "toga",
      "toldo",
      "tomar",
      "tono",
      "tonto",
      "topar",
      "tope",
      "toque",
      "tórax",
      "torero",
      "tormenta",
      "torneo",
      "toro",
      "torpedo",
      "torre",
      "torso",
      "tortuga",
      "tos",
      "tosco",
      "toser",
      "tóxico",
      "trabajo",
      "tractor",
      "traer",
      "tráfico",
      "trago",
      "traje",
      "tramo",
      "trance",
      "trato",
      "trauma",
      "trazar",
      "trébol",
      "tregua",
      "treinta",
      "tren",
      "trepar",
      "tres",
      "tribu",
      "trigo",
      "tripa",
      "triste",
      "triunfo",
      "trofeo",
      "trompa",
      "tronco",
      "tropa",
      "trote",
      "trozo",
      "truco",
      "trueno",
      "trufa",
      "tubería",
      "tubo",
      "tuerto",
      "tumba",
      "tumor",
      "túnel",
      "túnica",
      "turbina",
      "turismo",
      "turno",
      "tutor",
      "ubicar",
      "úlcera",
      "umbral",
      "unidad",
      "unir",
      "universo",
      "uno",
      "untar",
      "uña",
      "urbano",
      "urbe",
      "urgente",
      "urna",
      "usar",
      "usuario",
      "útil",
      "utopía",
      "uva",
      "vaca",
      "vacío",
      "vacuna",
      "vagar",
      "vago",
      "vaina",
      "vajilla",
      "vale",
      "válido",
      "valle",
      "valor",
      "válvula",
      "vampiro",
      "vara",
      "variar",
      "varón",
      "vaso",
      "vecino",
      "vector",
      "vehículo",
      "veinte",
      "vejez",
      "vela",
      "velero",
      "veloz",
      "vena",
      "vencer",
      "venda",
      "veneno",
      "vengar",
      "venir",
      "venta",
      "venus",
      "ver",
      "verano",
      "verbo",
      "verde",
      "vereda",
      "verja",
      "verso",
      "verter",
      "vía",
      "viaje",
      "vibrar",
      "vicio",
      "víctima",
      "vida",
      "vídeo",
      "vidrio",
      "viejo",
      "viernes",
      "vigor",
      "vil",
      "villa",
      "vinagre",
      "vino",
      "viñedo",
      "violín",
      "viral",
      "virgo",
      "virtud",
      "visor",
      "víspera",
      "vista",
      "vitamina",
      "viudo",
      "vivaz",
      "vivero",
      "vivir",
      "vivo",
      "volcán",
      "volumen",
      "volver",
      "voraz",
      "votar",
      "voto",
      "voz",
      "vuelo",
      "vulgar",
      "yacer",
      "yate",
      "yegua",
      "yema",
      "yerno",
      "yeso",
      "yodo",
      "yoga",
      "yogur",
      "zafiro",
      "zanja",
      "zapato",
      "zarza",
      "zona",
      "zorro",
      "zumo",
      "zurdo"
    ];
  }
});

// node_modules/bip39/src/wordlists/japanese.json
var require_japanese = __commonJS({
  "node_modules/bip39/src/wordlists/japanese.json"(exports, module) {
    module.exports = [
      "あいこくしん",
      "あいさつ",
      "あいだ",
      "あおぞら",
      "あかちゃん",
      "あきる",
      "あけがた",
      "あける",
      "あこがれる",
      "あさい",
      "あさひ",
      "あしあと",
      "あじわう",
      "あずかる",
      "あずき",
      "あそぶ",
      "あたえる",
      "あたためる",
      "あたりまえ",
      "あたる",
      "あつい",
      "あつかう",
      "あっしゅく",
      "あつまり",
      "あつめる",
      "あてな",
      "あてはまる",
      "あひる",
      "あぶら",
      "あぶる",
      "あふれる",
      "あまい",
      "あまど",
      "あまやかす",
      "あまり",
      "あみもの",
      "あめりか",
      "あやまる",
      "あゆむ",
      "あらいぐま",
      "あらし",
      "あらすじ",
      "あらためる",
      "あらゆる",
      "あらわす",
      "ありがとう",
      "あわせる",
      "あわてる",
      "あんい",
      "あんがい",
      "あんこ",
      "あんぜん",
      "あんてい",
      "あんない",
      "あんまり",
      "いいだす",
      "いおん",
      "いがい",
      "いがく",
      "いきおい",
      "いきなり",
      "いきもの",
      "いきる",
      "いくじ",
      "いくぶん",
      "いけばな",
      "いけん",
      "いこう",
      "いこく",
      "いこつ",
      "いさましい",
      "いさん",
      "いしき",
      "いじゅう",
      "いじょう",
      "いじわる",
      "いずみ",
      "いずれ",
      "いせい",
      "いせえび",
      "いせかい",
      "いせき",
      "いぜん",
      "いそうろう",
      "いそがしい",
      "いだい",
      "いだく",
      "いたずら",
      "いたみ",
      "いたりあ",
      "いちおう",
      "いちじ",
      "いちど",
      "いちば",
      "いちぶ",
      "いちりゅう",
      "いつか",
      "いっしゅん",
      "いっせい",
      "いっそう",
      "いったん",
      "いっち",
      "いってい",
      "いっぽう",
      "いてざ",
      "いてん",
      "いどう",
      "いとこ",
      "いない",
      "いなか",
      "いねむり",
      "いのち",
      "いのる",
      "いはつ",
      "いばる",
      "いはん",
      "いびき",
      "いひん",
      "いふく",
      "いへん",
      "いほう",
      "いみん",
      "いもうと",
      "いもたれ",
      "いもり",
      "いやがる",
      "いやす",
      "いよかん",
      "いよく",
      "いらい",
      "いらすと",
      "いりぐち",
      "いりょう",
      "いれい",
      "いれもの",
      "いれる",
      "いろえんぴつ",
      "いわい",
      "いわう",
      "いわかん",
      "いわば",
      "いわゆる",
      "いんげんまめ",
      "いんさつ",
      "いんしょう",
      "いんよう",
      "うえき",
      "うえる",
      "うおざ",
      "うがい",
      "うかぶ",
      "うかべる",
      "うきわ",
      "うくらいな",
      "うくれれ",
      "うけたまわる",
      "うけつけ",
      "うけとる",
      "うけもつ",
      "うける",
      "うごかす",
      "うごく",
      "うこん",
      "うさぎ",
      "うしなう",
      "うしろがみ",
      "うすい",
      "うすぎ",
      "うすぐらい",
      "うすめる",
      "うせつ",
      "うちあわせ",
      "うちがわ",
      "うちき",
      "うちゅう",
      "うっかり",
      "うつくしい",
      "うったえる",
      "うつる",
      "うどん",
      "うなぎ",
      "うなじ",
      "うなずく",
      "うなる",
      "うねる",
      "うのう",
      "うぶげ",
      "うぶごえ",
      "うまれる",
      "うめる",
      "うもう",
      "うやまう",
      "うよく",
      "うらがえす",
      "うらぐち",
      "うらない",
      "うりあげ",
      "うりきれ",
      "うるさい",
      "うれしい",
      "うれゆき",
      "うれる",
      "うろこ",
      "うわき",
      "うわさ",
      "うんこう",
      "うんちん",
      "うんてん",
      "うんどう",
      "えいえん",
      "えいが",
      "えいきょう",
      "えいご",
      "えいせい",
      "えいぶん",
      "えいよう",
      "えいわ",
      "えおり",
      "えがお",
      "えがく",
      "えきたい",
      "えくせる",
      "えしゃく",
      "えすて",
      "えつらん",
      "えのぐ",
      "えほうまき",
      "えほん",
      "えまき",
      "えもじ",
      "えもの",
      "えらい",
      "えらぶ",
      "えりあ",
      "えんえん",
      "えんかい",
      "えんぎ",
      "えんげき",
      "えんしゅう",
      "えんぜつ",
      "えんそく",
      "えんちょう",
      "えんとつ",
      "おいかける",
      "おいこす",
      "おいしい",
      "おいつく",
      "おうえん",
      "おうさま",
      "おうじ",
      "おうせつ",
      "おうたい",
      "おうふく",
      "おうべい",
      "おうよう",
      "おえる",
      "おおい",
      "おおう",
      "おおどおり",
      "おおや",
      "おおよそ",
      "おかえり",
      "おかず",
      "おがむ",
      "おかわり",
      "おぎなう",
      "おきる",
      "おくさま",
      "おくじょう",
      "おくりがな",
      "おくる",
      "おくれる",
      "おこす",
      "おこなう",
      "おこる",
      "おさえる",
      "おさない",
      "おさめる",
      "おしいれ",
      "おしえる",
      "おじぎ",
      "おじさん",
      "おしゃれ",
      "おそらく",
      "おそわる",
      "おたがい",
      "おたく",
      "おだやか",
      "おちつく",
      "おっと",
      "おつり",
      "おでかけ",
      "おとしもの",
      "おとなしい",
      "おどり",
      "おどろかす",
      "おばさん",
      "おまいり",
      "おめでとう",
      "おもいで",
      "おもう",
      "おもたい",
      "おもちゃ",
      "おやつ",
      "おやゆび",
      "およぼす",
      "おらんだ",
      "おろす",
      "おんがく",
      "おんけい",
      "おんしゃ",
      "おんせん",
      "おんだん",
      "おんちゅう",
      "おんどけい",
      "かあつ",
      "かいが",
      "がいき",
      "がいけん",
      "がいこう",
      "かいさつ",
      "かいしゃ",
      "かいすいよく",
      "かいぜん",
      "かいぞうど",
      "かいつう",
      "かいてん",
      "かいとう",
      "かいふく",
      "がいへき",
      "かいほう",
      "かいよう",
      "がいらい",
      "かいわ",
      "かえる",
      "かおり",
      "かかえる",
      "かがく",
      "かがし",
      "かがみ",
      "かくご",
      "かくとく",
      "かざる",
      "がぞう",
      "かたい",
      "かたち",
      "がちょう",
      "がっきゅう",
      "がっこう",
      "がっさん",
      "がっしょう",
      "かなざわし",
      "かのう",
      "がはく",
      "かぶか",
      "かほう",
      "かほご",
      "かまう",
      "かまぼこ",
      "かめれおん",
      "かゆい",
      "かようび",
      "からい",
      "かるい",
      "かろう",
      "かわく",
      "かわら",
      "がんか",
      "かんけい",
      "かんこう",
      "かんしゃ",
      "かんそう",
      "かんたん",
      "かんち",
      "がんばる",
      "きあい",
      "きあつ",
      "きいろ",
      "ぎいん",
      "きうい",
      "きうん",
      "きえる",
      "きおう",
      "きおく",
      "きおち",
      "きおん",
      "きかい",
      "きかく",
      "きかんしゃ",
      "ききて",
      "きくばり",
      "きくらげ",
      "きけんせい",
      "きこう",
      "きこえる",
      "きこく",
      "きさい",
      "きさく",
      "きさま",
      "きさらぎ",
      "ぎじかがく",
      "ぎしき",
      "ぎじたいけん",
      "ぎじにってい",
      "ぎじゅつしゃ",
      "きすう",
      "きせい",
      "きせき",
      "きせつ",
      "きそう",
      "きぞく",
      "きぞん",
      "きたえる",
      "きちょう",
      "きつえん",
      "ぎっちり",
      "きつつき",
      "きつね",
      "きてい",
      "きどう",
      "きどく",
      "きない",
      "きなが",
      "きなこ",
      "きぬごし",
      "きねん",
      "きのう",
      "きのした",
      "きはく",
      "きびしい",
      "きひん",
      "きふく",
      "きぶん",
      "きぼう",
      "きほん",
      "きまる",
      "きみつ",
      "きむずかしい",
      "きめる",
      "きもだめし",
      "きもち",
      "きもの",
      "きゃく",
      "きやく",
      "ぎゅうにく",
      "きよう",
      "きょうりゅう",
      "きらい",
      "きらく",
      "きりん",
      "きれい",
      "きれつ",
      "きろく",
      "ぎろん",
      "きわめる",
      "ぎんいろ",
      "きんかくじ",
      "きんじょ",
      "きんようび",
      "ぐあい",
      "くいず",
      "くうかん",
      "くうき",
      "くうぐん",
      "くうこう",
      "ぐうせい",
      "くうそう",
      "ぐうたら",
      "くうふく",
      "くうぼ",
      "くかん",
      "くきょう",
      "くげん",
      "ぐこう",
      "くさい",
      "くさき",
      "くさばな",
      "くさる",
      "くしゃみ",
      "くしょう",
      "くすのき",
      "くすりゆび",
      "くせげ",
      "くせん",
      "ぐたいてき",
      "くださる",
      "くたびれる",
      "くちこみ",
      "くちさき",
      "くつした",
      "ぐっすり",
      "くつろぐ",
      "くとうてん",
      "くどく",
      "くなん",
      "くねくね",
      "くのう",
      "くふう",
      "くみあわせ",
      "くみたてる",
      "くめる",
      "くやくしょ",
      "くらす",
      "くらべる",
      "くるま",
      "くれる",
      "くろう",
      "くわしい",
      "ぐんかん",
      "ぐんしょく",
      "ぐんたい",
      "ぐんて",
      "けあな",
      "けいかく",
      "けいけん",
      "けいこ",
      "けいさつ",
      "げいじゅつ",
      "けいたい",
      "げいのうじん",
      "けいれき",
      "けいろ",
      "けおとす",
      "けおりもの",
      "げきか",
      "げきげん",
      "げきだん",
      "げきちん",
      "げきとつ",
      "げきは",
      "げきやく",
      "げこう",
      "げこくじょう",
      "げざい",
      "けさき",
      "げざん",
      "けしき",
      "けしごむ",
      "けしょう",
      "げすと",
      "けたば",
      "けちゃっぷ",
      "けちらす",
      "けつあつ",
      "けつい",
      "けつえき",
      "けっこん",
      "けつじょ",
      "けっせき",
      "けってい",
      "けつまつ",
      "げつようび",
      "げつれい",
      "けつろん",
      "げどく",
      "けとばす",
      "けとる",
      "けなげ",
      "けなす",
      "けなみ",
      "けぬき",
      "げねつ",
      "けねん",
      "けはい",
      "げひん",
      "けぶかい",
      "げぼく",
      "けまり",
      "けみかる",
      "けむし",
      "けむり",
      "けもの",
      "けらい",
      "けろけろ",
      "けわしい",
      "けんい",
      "けんえつ",
      "けんお",
      "けんか",
      "げんき",
      "けんげん",
      "けんこう",
      "けんさく",
      "けんしゅう",
      "けんすう",
      "げんそう",
      "けんちく",
      "けんてい",
      "けんとう",
      "けんない",
      "けんにん",
      "げんぶつ",
      "けんま",
      "けんみん",
      "けんめい",
      "けんらん",
      "けんり",
      "こあくま",
      "こいぬ",
      "こいびと",
      "ごうい",
      "こうえん",
      "こうおん",
      "こうかん",
      "ごうきゅう",
      "ごうけい",
      "こうこう",
      "こうさい",
      "こうじ",
      "こうすい",
      "ごうせい",
      "こうそく",
      "こうたい",
      "こうちゃ",
      "こうつう",
      "こうてい",
      "こうどう",
      "こうない",
      "こうはい",
      "ごうほう",
      "ごうまん",
      "こうもく",
      "こうりつ",
      "こえる",
      "こおり",
      "ごかい",
      "ごがつ",
      "ごかん",
      "こくご",
      "こくさい",
      "こくとう",
      "こくない",
      "こくはく",
      "こぐま",
      "こけい",
      "こける",
      "ここのか",
      "こころ",
      "こさめ",
      "こしつ",
      "こすう",
      "こせい",
      "こせき",
      "こぜん",
      "こそだて",
      "こたい",
      "こたえる",
      "こたつ",
      "こちょう",
      "こっか",
      "こつこつ",
      "こつばん",
      "こつぶ",
      "こてい",
      "こてん",
      "ことがら",
      "ことし",
      "ことば",
      "ことり",
      "こなごな",
      "こねこね",
      "このまま",
      "このみ",
      "このよ",
      "ごはん",
      "こひつじ",
      "こふう",
      "こふん",
      "こぼれる",
      "ごまあぶら",
      "こまかい",
      "ごますり",
      "こまつな",
      "こまる",
      "こむぎこ",
      "こもじ",
      "こもち",
      "こもの",
      "こもん",
      "こやく",
      "こやま",
      "こゆう",
      "こゆび",
      "こよい",
      "こよう",
      "こりる",
      "これくしょん",
      "ころっけ",
      "こわもて",
      "こわれる",
      "こんいん",
      "こんかい",
      "こんき",
      "こんしゅう",
      "こんすい",
      "こんだて",
      "こんとん",
      "こんなん",
      "こんびに",
      "こんぽん",
      "こんまけ",
      "こんや",
      "こんれい",
      "こんわく",
      "ざいえき",
      "さいかい",
      "さいきん",
      "ざいげん",
      "ざいこ",
      "さいしょ",
      "さいせい",
      "ざいたく",
      "ざいちゅう",
      "さいてき",
      "ざいりょう",
      "さうな",
      "さかいし",
      "さがす",
      "さかな",
      "さかみち",
      "さがる",
      "さぎょう",
      "さくし",
      "さくひん",
      "さくら",
      "さこく",
      "さこつ",
      "さずかる",
      "ざせき",
      "さたん",
      "さつえい",
      "ざつおん",
      "ざっか",
      "ざつがく",
      "さっきょく",
      "ざっし",
      "さつじん",
      "ざっそう",
      "さつたば",
      "さつまいも",
      "さてい",
      "さといも",
      "さとう",
      "さとおや",
      "さとし",
      "さとる",
      "さのう",
      "さばく",
      "さびしい",
      "さべつ",
      "さほう",
      "さほど",
      "さます",
      "さみしい",
      "さみだれ",
      "さむけ",
      "さめる",
      "さやえんどう",
      "さゆう",
      "さよう",
      "さよく",
      "さらだ",
      "ざるそば",
      "さわやか",
      "さわる",
      "さんいん",
      "さんか",
      "さんきゃく",
      "さんこう",
      "さんさい",
      "ざんしょ",
      "さんすう",
      "さんせい",
      "さんそ",
      "さんち",
      "さんま",
      "さんみ",
      "さんらん",
      "しあい",
      "しあげ",
      "しあさって",
      "しあわせ",
      "しいく",
      "しいん",
      "しうち",
      "しえい",
      "しおけ",
      "しかい",
      "しかく",
      "じかん",
      "しごと",
      "しすう",
      "じだい",
      "したうけ",
      "したぎ",
      "したて",
      "したみ",
      "しちょう",
      "しちりん",
      "しっかり",
      "しつじ",
      "しつもん",
      "してい",
      "してき",
      "してつ",
      "じてん",
      "じどう",
      "しなぎれ",
      "しなもの",
      "しなん",
      "しねま",
      "しねん",
      "しのぐ",
      "しのぶ",
      "しはい",
      "しばかり",
      "しはつ",
      "しはらい",
      "しはん",
      "しひょう",
      "しふく",
      "じぶん",
      "しへい",
      "しほう",
      "しほん",
      "しまう",
      "しまる",
      "しみん",
      "しむける",
      "じむしょ",
      "しめい",
      "しめる",
      "しもん",
      "しゃいん",
      "しゃうん",
      "しゃおん",
      "じゃがいも",
      "しやくしょ",
      "しゃくほう",
      "しゃけん",
      "しゃこ",
      "しゃざい",
      "しゃしん",
      "しゃせん",
      "しゃそう",
      "しゃたい",
      "しゃちょう",
      "しゃっきん",
      "じゃま",
      "しゃりん",
      "しゃれい",
      "じゆう",
      "じゅうしょ",
      "しゅくはく",
      "じゅしん",
      "しゅっせき",
      "しゅみ",
      "しゅらば",
      "じゅんばん",
      "しょうかい",
      "しょくたく",
      "しょっけん",
      "しょどう",
      "しょもつ",
      "しらせる",
      "しらべる",
      "しんか",
      "しんこう",
      "じんじゃ",
      "しんせいじ",
      "しんちく",
      "しんりん",
      "すあげ",
      "すあし",
      "すあな",
      "ずあん",
      "すいえい",
      "すいか",
      "すいとう",
      "ずいぶん",
      "すいようび",
      "すうがく",
      "すうじつ",
      "すうせん",
      "すおどり",
      "すきま",
      "すくう",
      "すくない",
      "すける",
      "すごい",
      "すこし",
      "ずさん",
      "すずしい",
      "すすむ",
      "すすめる",
      "すっかり",
      "ずっしり",
      "ずっと",
      "すてき",
      "すてる",
      "すねる",
      "すのこ",
      "すはだ",
      "すばらしい",
      "ずひょう",
      "ずぶぬれ",
      "すぶり",
      "すふれ",
      "すべて",
      "すべる",
      "ずほう",
      "すぼん",
      "すまい",
      "すめし",
      "すもう",
      "すやき",
      "すらすら",
      "するめ",
      "すれちがう",
      "すろっと",
      "すわる",
      "すんぜん",
      "すんぽう",
      "せあぶら",
      "せいかつ",
      "せいげん",
      "せいじ",
      "せいよう",
      "せおう",
      "せかいかん",
      "せきにん",
      "せきむ",
      "せきゆ",
      "せきらんうん",
      "せけん",
      "せこう",
      "せすじ",
      "せたい",
      "せたけ",
      "せっかく",
      "せっきゃく",
      "ぜっく",
      "せっけん",
      "せっこつ",
      "せっさたくま",
      "せつぞく",
      "せつだん",
      "せつでん",
      "せっぱん",
      "せつび",
      "せつぶん",
      "せつめい",
      "せつりつ",
      "せなか",
      "せのび",
      "せはば",
      "せびろ",
      "せぼね",
      "せまい",
      "せまる",
      "せめる",
      "せもたれ",
      "せりふ",
      "ぜんあく",
      "せんい",
      "せんえい",
      "せんか",
      "せんきょ",
      "せんく",
      "せんげん",
      "ぜんご",
      "せんさい",
      "せんしゅ",
      "せんすい",
      "せんせい",
      "せんぞ",
      "せんたく",
      "せんちょう",
      "せんてい",
      "せんとう",
      "せんぬき",
      "せんねん",
      "せんぱい",
      "ぜんぶ",
      "ぜんぽう",
      "せんむ",
      "せんめんじょ",
      "せんもん",
      "せんやく",
      "せんゆう",
      "せんよう",
      "ぜんら",
      "ぜんりゃく",
      "せんれい",
      "せんろ",
      "そあく",
      "そいとげる",
      "そいね",
      "そうがんきょう",
      "そうき",
      "そうご",
      "そうしん",
      "そうだん",
      "そうなん",
      "そうび",
      "そうめん",
      "そうり",
      "そえもの",
      "そえん",
      "そがい",
      "そげき",
      "そこう",
      "そこそこ",
      "そざい",
      "そしな",
      "そせい",
      "そせん",
      "そそぐ",
      "そだてる",
      "そつう",
      "そつえん",
      "そっかん",
      "そつぎょう",
      "そっけつ",
      "そっこう",
      "そっせん",
      "そっと",
      "そとがわ",
      "そとづら",
      "そなえる",
      "そなた",
      "そふぼ",
      "そぼく",
      "そぼろ",
      "そまつ",
      "そまる",
      "そむく",
      "そむりえ",
      "そめる",
      "そもそも",
      "そよかぜ",
      "そらまめ",
      "そろう",
      "そんかい",
      "そんけい",
      "そんざい",
      "そんしつ",
      "そんぞく",
      "そんちょう",
      "ぞんび",
      "ぞんぶん",
      "そんみん",
      "たあい",
      "たいいん",
      "たいうん",
      "たいえき",
      "たいおう",
      "だいがく",
      "たいき",
      "たいぐう",
      "たいけん",
      "たいこ",
      "たいざい",
      "だいじょうぶ",
      "だいすき",
      "たいせつ",
      "たいそう",
      "だいたい",
      "たいちょう",
      "たいてい",
      "だいどころ",
      "たいない",
      "たいねつ",
      "たいのう",
      "たいはん",
      "だいひょう",
      "たいふう",
      "たいへん",
      "たいほ",
      "たいまつばな",
      "たいみんぐ",
      "たいむ",
      "たいめん",
      "たいやき",
      "たいよう",
      "たいら",
      "たいりょく",
      "たいる",
      "たいわん",
      "たうえ",
      "たえる",
      "たおす",
      "たおる",
      "たおれる",
      "たかい",
      "たかね",
      "たきび",
      "たくさん",
      "たこく",
      "たこやき",
      "たさい",
      "たしざん",
      "だじゃれ",
      "たすける",
      "たずさわる",
      "たそがれ",
      "たたかう",
      "たたく",
      "ただしい",
      "たたみ",
      "たちばな",
      "だっかい",
      "だっきゃく",
      "だっこ",
      "だっしゅつ",
      "だったい",
      "たてる",
      "たとえる",
      "たなばた",
      "たにん",
      "たぬき",
      "たのしみ",
      "たはつ",
      "たぶん",
      "たべる",
      "たぼう",
      "たまご",
      "たまる",
      "だむる",
      "ためいき",
      "ためす",
      "ためる",
      "たもつ",
      "たやすい",
      "たよる",
      "たらす",
      "たりきほんがん",
      "たりょう",
      "たりる",
      "たると",
      "たれる",
      "たれんと",
      "たろっと",
      "たわむれる",
      "だんあつ",
      "たんい",
      "たんおん",
      "たんか",
      "たんき",
      "たんけん",
      "たんご",
      "たんさん",
      "たんじょうび",
      "だんせい",
      "たんそく",
      "たんたい",
      "だんち",
      "たんてい",
      "たんとう",
      "だんな",
      "たんにん",
      "だんねつ",
      "たんのう",
      "たんぴん",
      "だんぼう",
      "たんまつ",
      "たんめい",
      "だんれつ",
      "だんろ",
      "だんわ",
      "ちあい",
      "ちあん",
      "ちいき",
      "ちいさい",
      "ちえん",
      "ちかい",
      "ちから",
      "ちきゅう",
      "ちきん",
      "ちけいず",
      "ちけん",
      "ちこく",
      "ちさい",
      "ちしき",
      "ちしりょう",
      "ちせい",
      "ちそう",
      "ちたい",
      "ちたん",
      "ちちおや",
      "ちつじょ",
      "ちてき",
      "ちてん",
      "ちぬき",
      "ちぬり",
      "ちのう",
      "ちひょう",
      "ちへいせん",
      "ちほう",
      "ちまた",
      "ちみつ",
      "ちみどろ",
      "ちめいど",
      "ちゃんこなべ",
      "ちゅうい",
      "ちゆりょく",
      "ちょうし",
      "ちょさくけん",
      "ちらし",
      "ちらみ",
      "ちりがみ",
      "ちりょう",
      "ちるど",
      "ちわわ",
      "ちんたい",
      "ちんもく",
      "ついか",
      "ついたち",
      "つうか",
      "つうじょう",
      "つうはん",
      "つうわ",
      "つかう",
      "つかれる",
      "つくね",
      "つくる",
      "つけね",
      "つける",
      "つごう",
      "つたえる",
      "つづく",
      "つつじ",
      "つつむ",
      "つとめる",
      "つながる",
      "つなみ",
      "つねづね",
      "つのる",
      "つぶす",
      "つまらない",
      "つまる",
      "つみき",
      "つめたい",
      "つもり",
      "つもる",
      "つよい",
      "つるぼ",
      "つるみく",
      "つわもの",
      "つわり",
      "てあし",
      "てあて",
      "てあみ",
      "ていおん",
      "ていか",
      "ていき",
      "ていけい",
      "ていこく",
      "ていさつ",
      "ていし",
      "ていせい",
      "ていたい",
      "ていど",
      "ていねい",
      "ていひょう",
      "ていへん",
      "ていぼう",
      "てうち",
      "ておくれ",
      "てきとう",
      "てくび",
      "でこぼこ",
      "てさぎょう",
      "てさげ",
      "てすり",
      "てそう",
      "てちがい",
      "てちょう",
      "てつがく",
      "てつづき",
      "でっぱ",
      "てつぼう",
      "てつや",
      "でぬかえ",
      "てぬき",
      "てぬぐい",
      "てのひら",
      "てはい",
      "てぶくろ",
      "てふだ",
      "てほどき",
      "てほん",
      "てまえ",
      "てまきずし",
      "てみじか",
      "てみやげ",
      "てらす",
      "てれび",
      "てわけ",
      "てわたし",
      "でんあつ",
      "てんいん",
      "てんかい",
      "てんき",
      "てんぐ",
      "てんけん",
      "てんごく",
      "てんさい",
      "てんし",
      "てんすう",
      "でんち",
      "てんてき",
      "てんとう",
      "てんない",
      "てんぷら",
      "てんぼうだい",
      "てんめつ",
      "てんらんかい",
      "でんりょく",
      "でんわ",
      "どあい",
      "といれ",
      "どうかん",
      "とうきゅう",
      "どうぐ",
      "とうし",
      "とうむぎ",
      "とおい",
      "とおか",
      "とおく",
      "とおす",
      "とおる",
      "とかい",
      "とかす",
      "ときおり",
      "ときどき",
      "とくい",
      "とくしゅう",
      "とくてん",
      "とくに",
      "とくべつ",
      "とけい",
      "とける",
      "とこや",
      "とさか",
      "としょかん",
      "とそう",
      "とたん",
      "とちゅう",
      "とっきゅう",
      "とっくん",
      "とつぜん",
      "とつにゅう",
      "とどける",
      "ととのえる",
      "とない",
      "となえる",
      "となり",
      "とのさま",
      "とばす",
      "どぶがわ",
      "とほう",
      "とまる",
      "とめる",
      "ともだち",
      "ともる",
      "どようび",
      "とらえる",
      "とんかつ",
      "どんぶり",
      "ないかく",
      "ないこう",
      "ないしょ",
      "ないす",
      "ないせん",
      "ないそう",
      "なおす",
      "ながい",
      "なくす",
      "なげる",
      "なこうど",
      "なさけ",
      "なたでここ",
      "なっとう",
      "なつやすみ",
      "ななおし",
      "なにごと",
      "なにもの",
      "なにわ",
      "なのか",
      "なふだ",
      "なまいき",
      "なまえ",
      "なまみ",
      "なみだ",
      "なめらか",
      "なめる",
      "なやむ",
      "ならう",
      "ならび",
      "ならぶ",
      "なれる",
      "なわとび",
      "なわばり",
      "にあう",
      "にいがた",
      "にうけ",
      "におい",
      "にかい",
      "にがて",
      "にきび",
      "にくしみ",
      "にくまん",
      "にげる",
      "にさんかたんそ",
      "にしき",
      "にせもの",
      "にちじょう",
      "にちようび",
      "にっか",
      "にっき",
      "にっけい",
      "にっこう",
      "にっさん",
      "にっしょく",
      "にっすう",
      "にっせき",
      "にってい",
      "になう",
      "にほん",
      "にまめ",
      "にもつ",
      "にやり",
      "にゅういん",
      "にりんしゃ",
      "にわとり",
      "にんい",
      "にんか",
      "にんき",
      "にんげん",
      "にんしき",
      "にんずう",
      "にんそう",
      "にんたい",
      "にんち",
      "にんてい",
      "にんにく",
      "にんぷ",
      "にんまり",
      "にんむ",
      "にんめい",
      "にんよう",
      "ぬいくぎ",
      "ぬかす",
      "ぬぐいとる",
      "ぬぐう",
      "ぬくもり",
      "ぬすむ",
      "ぬまえび",
      "ぬめり",
      "ぬらす",
      "ぬんちゃく",
      "ねあげ",
      "ねいき",
      "ねいる",
      "ねいろ",
      "ねぐせ",
      "ねくたい",
      "ねくら",
      "ねこぜ",
      "ねこむ",
      "ねさげ",
      "ねすごす",
      "ねそべる",
      "ねだん",
      "ねつい",
      "ねっしん",
      "ねつぞう",
      "ねったいぎょ",
      "ねぶそく",
      "ねふだ",
      "ねぼう",
      "ねほりはほり",
      "ねまき",
      "ねまわし",
      "ねみみ",
      "ねむい",
      "ねむたい",
      "ねもと",
      "ねらう",
      "ねわざ",
      "ねんいり",
      "ねんおし",
      "ねんかん",
      "ねんきん",
      "ねんぐ",
      "ねんざ",
      "ねんし",
      "ねんちゃく",
      "ねんど",
      "ねんぴ",
      "ねんぶつ",
      "ねんまつ",
      "ねんりょう",
      "ねんれい",
      "のいず",
      "のおづま",
      "のがす",
      "のきなみ",
      "のこぎり",
      "のこす",
      "のこる",
      "のせる",
      "のぞく",
      "のぞむ",
      "のたまう",
      "のちほど",
      "のっく",
      "のばす",
      "のはら",
      "のべる",
      "のぼる",
      "のみもの",
      "のやま",
      "のらいぬ",
      "のらねこ",
      "のりもの",
      "のりゆき",
      "のれん",
      "のんき",
      "ばあい",
      "はあく",
      "ばあさん",
      "ばいか",
      "ばいく",
      "はいけん",
      "はいご",
      "はいしん",
      "はいすい",
      "はいせん",
      "はいそう",
      "はいち",
      "ばいばい",
      "はいれつ",
      "はえる",
      "はおる",
      "はかい",
      "ばかり",
      "はかる",
      "はくしゅ",
      "はけん",
      "はこぶ",
      "はさみ",
      "はさん",
      "はしご",
      "ばしょ",
      "はしる",
      "はせる",
      "ぱそこん",
      "はそん",
      "はたん",
      "はちみつ",
      "はつおん",
      "はっかく",
      "はづき",
      "はっきり",
      "はっくつ",
      "はっけん",
      "はっこう",
      "はっさん",
      "はっしん",
      "はったつ",
      "はっちゅう",
      "はってん",
      "はっぴょう",
      "はっぽう",
      "はなす",
      "はなび",
      "はにかむ",
      "はぶらし",
      "はみがき",
      "はむかう",
      "はめつ",
      "はやい",
      "はやし",
      "はらう",
      "はろうぃん",
      "はわい",
      "はんい",
      "はんえい",
      "はんおん",
      "はんかく",
      "はんきょう",
      "ばんぐみ",
      "はんこ",
      "はんしゃ",
      "はんすう",
      "はんだん",
      "ぱんち",
      "ぱんつ",
      "はんてい",
      "はんとし",
      "はんのう",
      "はんぱ",
      "はんぶん",
      "はんぺん",
      "はんぼうき",
      "はんめい",
      "はんらん",
      "はんろん",
      "ひいき",
      "ひうん",
      "ひえる",
      "ひかく",
      "ひかり",
      "ひかる",
      "ひかん",
      "ひくい",
      "ひけつ",
      "ひこうき",
      "ひこく",
      "ひさい",
      "ひさしぶり",
      "ひさん",
      "びじゅつかん",
      "ひしょ",
      "ひそか",
      "ひそむ",
      "ひたむき",
      "ひだり",
      "ひたる",
      "ひつぎ",
      "ひっこし",
      "ひっし",
      "ひつじゅひん",
      "ひっす",
      "ひつぜん",
      "ぴったり",
      "ぴっちり",
      "ひつよう",
      "ひてい",
      "ひとごみ",
      "ひなまつり",
      "ひなん",
      "ひねる",
      "ひはん",
      "ひびく",
      "ひひょう",
      "ひほう",
      "ひまわり",
      "ひまん",
      "ひみつ",
      "ひめい",
      "ひめじし",
      "ひやけ",
      "ひやす",
      "ひよう",
      "びょうき",
      "ひらがな",
      "ひらく",
      "ひりつ",
      "ひりょう",
      "ひるま",
      "ひるやすみ",
      "ひれい",
      "ひろい",
      "ひろう",
      "ひろき",
      "ひろゆき",
      "ひんかく",
      "ひんけつ",
      "ひんこん",
      "ひんしゅ",
      "ひんそう",
      "ぴんち",
      "ひんぱん",
      "びんぼう",
      "ふあん",
      "ふいうち",
      "ふうけい",
      "ふうせん",
      "ぷうたろう",
      "ふうとう",
      "ふうふ",
      "ふえる",
      "ふおん",
      "ふかい",
      "ふきん",
      "ふくざつ",
      "ふくぶくろ",
      "ふこう",
      "ふさい",
      "ふしぎ",
      "ふじみ",
      "ふすま",
      "ふせい",
      "ふせぐ",
      "ふそく",
      "ぶたにく",
      "ふたん",
      "ふちょう",
      "ふつう",
      "ふつか",
      "ふっかつ",
      "ふっき",
      "ふっこく",
      "ぶどう",
      "ふとる",
      "ふとん",
      "ふのう",
      "ふはい",
      "ふひょう",
      "ふへん",
      "ふまん",
      "ふみん",
      "ふめつ",
      "ふめん",
      "ふよう",
      "ふりこ",
      "ふりる",
      "ふるい",
      "ふんいき",
      "ぶんがく",
      "ぶんぐ",
      "ふんしつ",
      "ぶんせき",
      "ふんそう",
      "ぶんぽう",
      "へいあん",
      "へいおん",
      "へいがい",
      "へいき",
      "へいげん",
      "へいこう",
      "へいさ",
      "へいしゃ",
      "へいせつ",
      "へいそ",
      "へいたく",
      "へいてん",
      "へいねつ",
      "へいわ",
      "へきが",
      "へこむ",
      "べにいろ",
      "べにしょうが",
      "へらす",
      "へんかん",
      "べんきょう",
      "べんごし",
      "へんさい",
      "へんたい",
      "べんり",
      "ほあん",
      "ほいく",
      "ぼうぎょ",
      "ほうこく",
      "ほうそう",
      "ほうほう",
      "ほうもん",
      "ほうりつ",
      "ほえる",
      "ほおん",
      "ほかん",
      "ほきょう",
      "ぼきん",
      "ほくろ",
      "ほけつ",
      "ほけん",
      "ほこう",
      "ほこる",
      "ほしい",
      "ほしつ",
      "ほしゅ",
      "ほしょう",
      "ほせい",
      "ほそい",
      "ほそく",
      "ほたて",
      "ほたる",
      "ぽちぶくろ",
      "ほっきょく",
      "ほっさ",
      "ほったん",
      "ほとんど",
      "ほめる",
      "ほんい",
      "ほんき",
      "ほんけ",
      "ほんしつ",
      "ほんやく",
      "まいにち",
      "まかい",
      "まかせる",
      "まがる",
      "まける",
      "まこと",
      "まさつ",
      "まじめ",
      "ますく",
      "まぜる",
      "まつり",
      "まとめ",
      "まなぶ",
      "まぬけ",
      "まねく",
      "まほう",
      "まもる",
      "まゆげ",
      "まよう",
      "まろやか",
      "まわす",
      "まわり",
      "まわる",
      "まんが",
      "まんきつ",
      "まんぞく",
      "まんなか",
      "みいら",
      "みうち",
      "みえる",
      "みがく",
      "みかた",
      "みかん",
      "みけん",
      "みこん",
      "みじかい",
      "みすい",
      "みすえる",
      "みせる",
      "みっか",
      "みつかる",
      "みつける",
      "みてい",
      "みとめる",
      "みなと",
      "みなみかさい",
      "みねらる",
      "みのう",
      "みのがす",
      "みほん",
      "みもと",
      "みやげ",
      "みらい",
      "みりょく",
      "みわく",
      "みんか",
      "みんぞく",
      "むいか",
      "むえき",
      "むえん",
      "むかい",
      "むかう",
      "むかえ",
      "むかし",
      "むぎちゃ",
      "むける",
      "むげん",
      "むさぼる",
      "むしあつい",
      "むしば",
      "むじゅん",
      "むしろ",
      "むすう",
      "むすこ",
      "むすぶ",
      "むすめ",
      "むせる",
      "むせん",
      "むちゅう",
      "むなしい",
      "むのう",
      "むやみ",
      "むよう",
      "むらさき",
      "むりょう",
      "むろん",
      "めいあん",
      "めいうん",
      "めいえん",
      "めいかく",
      "めいきょく",
      "めいさい",
      "めいし",
      "めいそう",
      "めいぶつ",
      "めいれい",
      "めいわく",
      "めぐまれる",
      "めざす",
      "めした",
      "めずらしい",
      "めだつ",
      "めまい",
      "めやす",
      "めんきょ",
      "めんせき",
      "めんどう",
      "もうしあげる",
      "もうどうけん",
      "もえる",
      "もくし",
      "もくてき",
      "もくようび",
      "もちろん",
      "もどる",
      "もらう",
      "もんく",
      "もんだい",
      "やおや",
      "やける",
      "やさい",
      "やさしい",
      "やすい",
      "やすたろう",
      "やすみ",
      "やせる",
      "やそう",
      "やたい",
      "やちん",
      "やっと",
      "やっぱり",
      "やぶる",
      "やめる",
      "ややこしい",
      "やよい",
      "やわらかい",
      "ゆうき",
      "ゆうびんきょく",
      "ゆうべ",
      "ゆうめい",
      "ゆけつ",
      "ゆしゅつ",
      "ゆせん",
      "ゆそう",
      "ゆたか",
      "ゆちゃく",
      "ゆでる",
      "ゆにゅう",
      "ゆびわ",
      "ゆらい",
      "ゆれる",
      "ようい",
      "ようか",
      "ようきゅう",
      "ようじ",
      "ようす",
      "ようちえん",
      "よかぜ",
      "よかん",
      "よきん",
      "よくせい",
      "よくぼう",
      "よけい",
      "よごれる",
      "よさん",
      "よしゅう",
      "よそう",
      "よそく",
      "よっか",
      "よてい",
      "よどがわく",
      "よねつ",
      "よやく",
      "よゆう",
      "よろこぶ",
      "よろしい",
      "らいう",
      "らくがき",
      "らくご",
      "らくさつ",
      "らくだ",
      "らしんばん",
      "らせん",
      "らぞく",
      "らたい",
      "らっか",
      "られつ",
      "りえき",
      "りかい",
      "りきさく",
      "りきせつ",
      "りくぐん",
      "りくつ",
      "りけん",
      "りこう",
      "りせい",
      "りそう",
      "りそく",
      "りてん",
      "りねん",
      "りゆう",
      "りゅうがく",
      "りよう",
      "りょうり",
      "りょかん",
      "りょくちゃ",
      "りょこう",
      "りりく",
      "りれき",
      "りろん",
      "りんご",
      "るいけい",
      "るいさい",
      "るいじ",
      "るいせき",
      "るすばん",
      "るりがわら",
      "れいかん",
      "れいぎ",
      "れいせい",
      "れいぞうこ",
      "れいとう",
      "れいぼう",
      "れきし",
      "れきだい",
      "れんあい",
      "れんけい",
      "れんこん",
      "れんさい",
      "れんしゅう",
      "れんぞく",
      "れんらく",
      "ろうか",
      "ろうご",
      "ろうじん",
      "ろうそく",
      "ろくが",
      "ろこつ",
      "ろじうら",
      "ろしゅつ",
      "ろせん",
      "ろてん",
      "ろめん",
      "ろれつ",
      "ろんぎ",
      "ろんぱ",
      "ろんぶん",
      "ろんり",
      "わかす",
      "わかめ",
      "わかやま",
      "わかれる",
      "わしつ",
      "わじまし",
      "わすれもの",
      "わらう",
      "われる"
    ];
  }
});

// node_modules/bip39/src/wordlists/portuguese.json
var require_portuguese = __commonJS({
  "node_modules/bip39/src/wordlists/portuguese.json"(exports, module) {
    module.exports = [
      "abacate",
      "abaixo",
      "abalar",
      "abater",
      "abduzir",
      "abelha",
      "aberto",
      "abismo",
      "abotoar",
      "abranger",
      "abreviar",
      "abrigar",
      "abrupto",
      "absinto",
      "absoluto",
      "absurdo",
      "abutre",
      "acabado",
      "acalmar",
      "acampar",
      "acanhar",
      "acaso",
      "aceitar",
      "acelerar",
      "acenar",
      "acervo",
      "acessar",
      "acetona",
      "achatar",
      "acidez",
      "acima",
      "acionado",
      "acirrar",
      "aclamar",
      "aclive",
      "acolhida",
      "acomodar",
      "acoplar",
      "acordar",
      "acumular",
      "acusador",
      "adaptar",
      "adega",
      "adentro",
      "adepto",
      "adequar",
      "aderente",
      "adesivo",
      "adeus",
      "adiante",
      "aditivo",
      "adjetivo",
      "adjunto",
      "admirar",
      "adorar",
      "adquirir",
      "adubo",
      "adverso",
      "advogado",
      "aeronave",
      "afastar",
      "aferir",
      "afetivo",
      "afinador",
      "afivelar",
      "aflito",
      "afluente",
      "afrontar",
      "agachar",
      "agarrar",
      "agasalho",
      "agenciar",
      "agilizar",
      "agiota",
      "agitado",
      "agora",
      "agradar",
      "agreste",
      "agrupar",
      "aguardar",
      "agulha",
      "ajoelhar",
      "ajudar",
      "ajustar",
      "alameda",
      "alarme",
      "alastrar",
      "alavanca",
      "albergue",
      "albino",
      "alcatra",
      "aldeia",
      "alecrim",
      "alegria",
      "alertar",
      "alface",
      "alfinete",
      "algum",
      "alheio",
      "aliar",
      "alicate",
      "alienar",
      "alinhar",
      "aliviar",
      "almofada",
      "alocar",
      "alpiste",
      "alterar",
      "altitude",
      "alucinar",
      "alugar",
      "aluno",
      "alusivo",
      "alvo",
      "amaciar",
      "amador",
      "amarelo",
      "amassar",
      "ambas",
      "ambiente",
      "ameixa",
      "amenizar",
      "amido",
      "amistoso",
      "amizade",
      "amolador",
      "amontoar",
      "amoroso",
      "amostra",
      "amparar",
      "ampliar",
      "ampola",
      "anagrama",
      "analisar",
      "anarquia",
      "anatomia",
      "andaime",
      "anel",
      "anexo",
      "angular",
      "animar",
      "anjo",
      "anomalia",
      "anotado",
      "ansioso",
      "anterior",
      "anuidade",
      "anunciar",
      "anzol",
      "apagador",
      "apalpar",
      "apanhado",
      "apego",
      "apelido",
      "apertada",
      "apesar",
      "apetite",
      "apito",
      "aplauso",
      "aplicada",
      "apoio",
      "apontar",
      "aposta",
      "aprendiz",
      "aprovar",
      "aquecer",
      "arame",
      "aranha",
      "arara",
      "arcada",
      "ardente",
      "areia",
      "arejar",
      "arenito",
      "aresta",
      "argiloso",
      "argola",
      "arma",
      "arquivo",
      "arraial",
      "arrebate",
      "arriscar",
      "arroba",
      "arrumar",
      "arsenal",
      "arterial",
      "artigo",
      "arvoredo",
      "asfaltar",
      "asilado",
      "aspirar",
      "assador",
      "assinar",
      "assoalho",
      "assunto",
      "astral",
      "atacado",
      "atadura",
      "atalho",
      "atarefar",
      "atear",
      "atender",
      "aterro",
      "ateu",
      "atingir",
      "atirador",
      "ativo",
      "atoleiro",
      "atracar",
      "atrevido",
      "atriz",
      "atual",
      "atum",
      "auditor",
      "aumentar",
      "aura",
      "aurora",
      "autismo",
      "autoria",
      "autuar",
      "avaliar",
      "avante",
      "avaria",
      "avental",
      "avesso",
      "aviador",
      "avisar",
      "avulso",
      "axila",
      "azarar",
      "azedo",
      "azeite",
      "azulejo",
      "babar",
      "babosa",
      "bacalhau",
      "bacharel",
      "bacia",
      "bagagem",
      "baiano",
      "bailar",
      "baioneta",
      "bairro",
      "baixista",
      "bajular",
      "baleia",
      "baliza",
      "balsa",
      "banal",
      "bandeira",
      "banho",
      "banir",
      "banquete",
      "barato",
      "barbado",
      "baronesa",
      "barraca",
      "barulho",
      "baseado",
      "bastante",
      "batata",
      "batedor",
      "batida",
      "batom",
      "batucar",
      "baunilha",
      "beber",
      "beijo",
      "beirada",
      "beisebol",
      "beldade",
      "beleza",
      "belga",
      "beliscar",
      "bendito",
      "bengala",
      "benzer",
      "berimbau",
      "berlinda",
      "berro",
      "besouro",
      "bexiga",
      "bezerro",
      "bico",
      "bicudo",
      "bienal",
      "bifocal",
      "bifurcar",
      "bigorna",
      "bilhete",
      "bimestre",
      "bimotor",
      "biologia",
      "biombo",
      "biosfera",
      "bipolar",
      "birrento",
      "biscoito",
      "bisneto",
      "bispo",
      "bissexto",
      "bitola",
      "bizarro",
      "blindado",
      "bloco",
      "bloquear",
      "boato",
      "bobagem",
      "bocado",
      "bocejo",
      "bochecha",
      "boicotar",
      "bolada",
      "boletim",
      "bolha",
      "bolo",
      "bombeiro",
      "bonde",
      "boneco",
      "bonita",
      "borbulha",
      "borda",
      "boreal",
      "borracha",
      "bovino",
      "boxeador",
      "branco",
      "brasa",
      "braveza",
      "breu",
      "briga",
      "brilho",
      "brincar",
      "broa",
      "brochura",
      "bronzear",
      "broto",
      "bruxo",
      "bucha",
      "budismo",
      "bufar",
      "bule",
      "buraco",
      "busca",
      "busto",
      "buzina",
      "cabana",
      "cabelo",
      "cabide",
      "cabo",
      "cabrito",
      "cacau",
      "cacetada",
      "cachorro",
      "cacique",
      "cadastro",
      "cadeado",
      "cafezal",
      "caiaque",
      "caipira",
      "caixote",
      "cajado",
      "caju",
      "calafrio",
      "calcular",
      "caldeira",
      "calibrar",
      "calmante",
      "calota",
      "camada",
      "cambista",
      "camisa",
      "camomila",
      "campanha",
      "camuflar",
      "canavial",
      "cancelar",
      "caneta",
      "canguru",
      "canhoto",
      "canivete",
      "canoa",
      "cansado",
      "cantar",
      "canudo",
      "capacho",
      "capela",
      "capinar",
      "capotar",
      "capricho",
      "captador",
      "capuz",
      "caracol",
      "carbono",
      "cardeal",
      "careca",
      "carimbar",
      "carneiro",
      "carpete",
      "carreira",
      "cartaz",
      "carvalho",
      "casaco",
      "casca",
      "casebre",
      "castelo",
      "casulo",
      "catarata",
      "cativar",
      "caule",
      "causador",
      "cautelar",
      "cavalo",
      "caverna",
      "cebola",
      "cedilha",
      "cegonha",
      "celebrar",
      "celular",
      "cenoura",
      "censo",
      "centeio",
      "cercar",
      "cerrado",
      "certeiro",
      "cerveja",
      "cetim",
      "cevada",
      "chacota",
      "chaleira",
      "chamado",
      "chapada",
      "charme",
      "chatice",
      "chave",
      "chefe",
      "chegada",
      "cheiro",
      "cheque",
      "chicote",
      "chifre",
      "chinelo",
      "chocalho",
      "chover",
      "chumbo",
      "chutar",
      "chuva",
      "cicatriz",
      "ciclone",
      "cidade",
      "cidreira",
      "ciente",
      "cigana",
      "cimento",
      "cinto",
      "cinza",
      "ciranda",
      "circuito",
      "cirurgia",
      "citar",
      "clareza",
      "clero",
      "clicar",
      "clone",
      "clube",
      "coado",
      "coagir",
      "cobaia",
      "cobertor",
      "cobrar",
      "cocada",
      "coelho",
      "coentro",
      "coeso",
      "cogumelo",
      "coibir",
      "coifa",
      "coiote",
      "colar",
      "coleira",
      "colher",
      "colidir",
      "colmeia",
      "colono",
      "coluna",
      "comando",
      "combinar",
      "comentar",
      "comitiva",
      "comover",
      "complexo",
      "comum",
      "concha",
      "condor",
      "conectar",
      "confuso",
      "congelar",
      "conhecer",
      "conjugar",
      "consumir",
      "contrato",
      "convite",
      "cooperar",
      "copeiro",
      "copiador",
      "copo",
      "coquetel",
      "coragem",
      "cordial",
      "corneta",
      "coronha",
      "corporal",
      "correio",
      "cortejo",
      "coruja",
      "corvo",
      "cosseno",
      "costela",
      "cotonete",
      "couro",
      "couve",
      "covil",
      "cozinha",
      "cratera",
      "cravo",
      "creche",
      "credor",
      "creme",
      "crer",
      "crespo",
      "criada",
      "criminal",
      "crioulo",
      "crise",
      "criticar",
      "crosta",
      "crua",
      "cruzeiro",
      "cubano",
      "cueca",
      "cuidado",
      "cujo",
      "culatra",
      "culminar",
      "culpar",
      "cultura",
      "cumprir",
      "cunhado",
      "cupido",
      "curativo",
      "curral",
      "cursar",
      "curto",
      "cuspir",
      "custear",
      "cutelo",
      "damasco",
      "datar",
      "debater",
      "debitar",
      "deboche",
      "debulhar",
      "decalque",
      "decimal",
      "declive",
      "decote",
      "decretar",
      "dedal",
      "dedicado",
      "deduzir",
      "defesa",
      "defumar",
      "degelo",
      "degrau",
      "degustar",
      "deitado",
      "deixar",
      "delator",
      "delegado",
      "delinear",
      "delonga",
      "demanda",
      "demitir",
      "demolido",
      "dentista",
      "depenado",
      "depilar",
      "depois",
      "depressa",
      "depurar",
      "deriva",
      "derramar",
      "desafio",
      "desbotar",
      "descanso",
      "desenho",
      "desfiado",
      "desgaste",
      "desigual",
      "deslize",
      "desmamar",
      "desova",
      "despesa",
      "destaque",
      "desviar",
      "detalhar",
      "detentor",
      "detonar",
      "detrito",
      "deusa",
      "dever",
      "devido",
      "devotado",
      "dezena",
      "diagrama",
      "dialeto",
      "didata",
      "difuso",
      "digitar",
      "dilatado",
      "diluente",
      "diminuir",
      "dinastia",
      "dinheiro",
      "diocese",
      "direto",
      "discreta",
      "disfarce",
      "disparo",
      "disquete",
      "dissipar",
      "distante",
      "ditador",
      "diurno",
      "diverso",
      "divisor",
      "divulgar",
      "dizer",
      "dobrador",
      "dolorido",
      "domador",
      "dominado",
      "donativo",
      "donzela",
      "dormente",
      "dorsal",
      "dosagem",
      "dourado",
      "doutor",
      "drenagem",
      "drible",
      "drogaria",
      "duelar",
      "duende",
      "dueto",
      "duplo",
      "duquesa",
      "durante",
      "duvidoso",
      "eclodir",
      "ecoar",
      "ecologia",
      "edificar",
      "edital",
      "educado",
      "efeito",
      "efetivar",
      "ejetar",
      "elaborar",
      "eleger",
      "eleitor",
      "elenco",
      "elevador",
      "eliminar",
      "elogiar",
      "embargo",
      "embolado",
      "embrulho",
      "embutido",
      "emenda",
      "emergir",
      "emissor",
      "empatia",
      "empenho",
      "empinado",
      "empolgar",
      "emprego",
      "empurrar",
      "emulador",
      "encaixe",
      "encenado",
      "enchente",
      "encontro",
      "endeusar",
      "endossar",
      "enfaixar",
      "enfeite",
      "enfim",
      "engajado",
      "engenho",
      "englobar",
      "engomado",
      "engraxar",
      "enguia",
      "enjoar",
      "enlatar",
      "enquanto",
      "enraizar",
      "enrolado",
      "enrugar",
      "ensaio",
      "enseada",
      "ensino",
      "ensopado",
      "entanto",
      "enteado",
      "entidade",
      "entortar",
      "entrada",
      "entulho",
      "envergar",
      "enviado",
      "envolver",
      "enxame",
      "enxerto",
      "enxofre",
      "enxuto",
      "epiderme",
      "equipar",
      "ereto",
      "erguido",
      "errata",
      "erva",
      "ervilha",
      "esbanjar",
      "esbelto",
      "escama",
      "escola",
      "escrita",
      "escuta",
      "esfinge",
      "esfolar",
      "esfregar",
      "esfumado",
      "esgrima",
      "esmalte",
      "espanto",
      "espelho",
      "espiga",
      "esponja",
      "espreita",
      "espumar",
      "esquerda",
      "estaca",
      "esteira",
      "esticar",
      "estofado",
      "estrela",
      "estudo",
      "esvaziar",
      "etanol",
      "etiqueta",
      "euforia",
      "europeu",
      "evacuar",
      "evaporar",
      "evasivo",
      "eventual",
      "evidente",
      "evoluir",
      "exagero",
      "exalar",
      "examinar",
      "exato",
      "exausto",
      "excesso",
      "excitar",
      "exclamar",
      "executar",
      "exemplo",
      "exibir",
      "exigente",
      "exonerar",
      "expandir",
      "expelir",
      "expirar",
      "explanar",
      "exposto",
      "expresso",
      "expulsar",
      "externo",
      "extinto",
      "extrato",
      "fabricar",
      "fabuloso",
      "faceta",
      "facial",
      "fada",
      "fadiga",
      "faixa",
      "falar",
      "falta",
      "familiar",
      "fandango",
      "fanfarra",
      "fantoche",
      "fardado",
      "farelo",
      "farinha",
      "farofa",
      "farpa",
      "fartura",
      "fatia",
      "fator",
      "favorita",
      "faxina",
      "fazenda",
      "fechado",
      "feijoada",
      "feirante",
      "felino",
      "feminino",
      "fenda",
      "feno",
      "fera",
      "feriado",
      "ferrugem",
      "ferver",
      "festejar",
      "fetal",
      "feudal",
      "fiapo",
      "fibrose",
      "ficar",
      "ficheiro",
      "figurado",
      "fileira",
      "filho",
      "filme",
      "filtrar",
      "firmeza",
      "fisgada",
      "fissura",
      "fita",
      "fivela",
      "fixador",
      "fixo",
      "flacidez",
      "flamingo",
      "flanela",
      "flechada",
      "flora",
      "flutuar",
      "fluxo",
      "focal",
      "focinho",
      "fofocar",
      "fogo",
      "foguete",
      "foice",
      "folgado",
      "folheto",
      "forjar",
      "formiga",
      "forno",
      "forte",
      "fosco",
      "fossa",
      "fragata",
      "fralda",
      "frango",
      "frasco",
      "fraterno",
      "freira",
      "frente",
      "fretar",
      "frieza",
      "friso",
      "fritura",
      "fronha",
      "frustrar",
      "fruteira",
      "fugir",
      "fulano",
      "fuligem",
      "fundar",
      "fungo",
      "funil",
      "furador",
      "furioso",
      "futebol",
      "gabarito",
      "gabinete",
      "gado",
      "gaiato",
      "gaiola",
      "gaivota",
      "galega",
      "galho",
      "galinha",
      "galocha",
      "ganhar",
      "garagem",
      "garfo",
      "gargalo",
      "garimpo",
      "garoupa",
      "garrafa",
      "gasoduto",
      "gasto",
      "gata",
      "gatilho",
      "gaveta",
      "gazela",
      "gelado",
      "geleia",
      "gelo",
      "gemada",
      "gemer",
      "gemido",
      "generoso",
      "gengiva",
      "genial",
      "genoma",
      "genro",
      "geologia",
      "gerador",
      "germinar",
      "gesso",
      "gestor",
      "ginasta",
      "gincana",
      "gingado",
      "girafa",
      "girino",
      "glacial",
      "glicose",
      "global",
      "glorioso",
      "goela",
      "goiaba",
      "golfe",
      "golpear",
      "gordura",
      "gorjeta",
      "gorro",
      "gostoso",
      "goteira",
      "governar",
      "gracejo",
      "gradual",
      "grafite",
      "gralha",
      "grampo",
      "granada",
      "gratuito",
      "graveto",
      "graxa",
      "grego",
      "grelhar",
      "greve",
      "grilo",
      "grisalho",
      "gritaria",
      "grosso",
      "grotesco",
      "grudado",
      "grunhido",
      "gruta",
      "guache",
      "guarani",
      "guaxinim",
      "guerrear",
      "guiar",
      "guincho",
      "guisado",
      "gula",
      "guloso",
      "guru",
      "habitar",
      "harmonia",
      "haste",
      "haver",
      "hectare",
      "herdar",
      "heresia",
      "hesitar",
      "hiato",
      "hibernar",
      "hidratar",
      "hiena",
      "hino",
      "hipismo",
      "hipnose",
      "hipoteca",
      "hoje",
      "holofote",
      "homem",
      "honesto",
      "honrado",
      "hormonal",
      "hospedar",
      "humorado",
      "iate",
      "ideia",
      "idoso",
      "ignorado",
      "igreja",
      "iguana",
      "ileso",
      "ilha",
      "iludido",
      "iluminar",
      "ilustrar",
      "imagem",
      "imediato",
      "imenso",
      "imersivo",
      "iminente",
      "imitador",
      "imortal",
      "impacto",
      "impedir",
      "implante",
      "impor",
      "imprensa",
      "impune",
      "imunizar",
      "inalador",
      "inapto",
      "inativo",
      "incenso",
      "inchar",
      "incidir",
      "incluir",
      "incolor",
      "indeciso",
      "indireto",
      "indutor",
      "ineficaz",
      "inerente",
      "infantil",
      "infestar",
      "infinito",
      "inflamar",
      "informal",
      "infrator",
      "ingerir",
      "inibido",
      "inicial",
      "inimigo",
      "injetar",
      "inocente",
      "inodoro",
      "inovador",
      "inox",
      "inquieto",
      "inscrito",
      "inseto",
      "insistir",
      "inspetor",
      "instalar",
      "insulto",
      "intacto",
      "integral",
      "intimar",
      "intocado",
      "intriga",
      "invasor",
      "inverno",
      "invicto",
      "invocar",
      "iogurte",
      "iraniano",
      "ironizar",
      "irreal",
      "irritado",
      "isca",
      "isento",
      "isolado",
      "isqueiro",
      "italiano",
      "janeiro",
      "jangada",
      "janta",
      "jararaca",
      "jardim",
      "jarro",
      "jasmim",
      "jato",
      "javali",
      "jazida",
      "jejum",
      "joaninha",
      "joelhada",
      "jogador",
      "joia",
      "jornal",
      "jorrar",
      "jovem",
      "juba",
      "judeu",
      "judoca",
      "juiz",
      "julgador",
      "julho",
      "jurado",
      "jurista",
      "juro",
      "justa",
      "labareda",
      "laboral",
      "lacre",
      "lactante",
      "ladrilho",
      "lagarta",
      "lagoa",
      "laje",
      "lamber",
      "lamentar",
      "laminar",
      "lampejo",
      "lanche",
      "lapidar",
      "lapso",
      "laranja",
      "lareira",
      "largura",
      "lasanha",
      "lastro",
      "lateral",
      "latido",
      "lavanda",
      "lavoura",
      "lavrador",
      "laxante",
      "lazer",
      "lealdade",
      "lebre",
      "legado",
      "legendar",
      "legista",
      "leigo",
      "leiloar",
      "leitura",
      "lembrete",
      "leme",
      "lenhador",
      "lentilha",
      "leoa",
      "lesma",
      "leste",
      "letivo",
      "letreiro",
      "levar",
      "leveza",
      "levitar",
      "liberal",
      "libido",
      "liderar",
      "ligar",
      "ligeiro",
      "limitar",
      "limoeiro",
      "limpador",
      "linda",
      "linear",
      "linhagem",
      "liquidez",
      "listagem",
      "lisura",
      "litoral",
      "livro",
      "lixa",
      "lixeira",
      "locador",
      "locutor",
      "lojista",
      "lombo",
      "lona",
      "longe",
      "lontra",
      "lorde",
      "lotado",
      "loteria",
      "loucura",
      "lousa",
      "louvar",
      "luar",
      "lucidez",
      "lucro",
      "luneta",
      "lustre",
      "lutador",
      "luva",
      "macaco",
      "macete",
      "machado",
      "macio",
      "madeira",
      "madrinha",
      "magnata",
      "magreza",
      "maior",
      "mais",
      "malandro",
      "malha",
      "malote",
      "maluco",
      "mamilo",
      "mamoeiro",
      "mamute",
      "manada",
      "mancha",
      "mandato",
      "manequim",
      "manhoso",
      "manivela",
      "manobrar",
      "mansa",
      "manter",
      "manusear",
      "mapeado",
      "maquinar",
      "marcador",
      "maresia",
      "marfim",
      "margem",
      "marinho",
      "marmita",
      "maroto",
      "marquise",
      "marreco",
      "martelo",
      "marujo",
      "mascote",
      "masmorra",
      "massagem",
      "mastigar",
      "matagal",
      "materno",
      "matinal",
      "matutar",
      "maxilar",
      "medalha",
      "medida",
      "medusa",
      "megafone",
      "meiga",
      "melancia",
      "melhor",
      "membro",
      "memorial",
      "menino",
      "menos",
      "mensagem",
      "mental",
      "merecer",
      "mergulho",
      "mesada",
      "mesclar",
      "mesmo",
      "mesquita",
      "mestre",
      "metade",
      "meteoro",
      "metragem",
      "mexer",
      "mexicano",
      "micro",
      "migalha",
      "migrar",
      "milagre",
      "milenar",
      "milhar",
      "mimado",
      "minerar",
      "minhoca",
      "ministro",
      "minoria",
      "miolo",
      "mirante",
      "mirtilo",
      "misturar",
      "mocidade",
      "moderno",
      "modular",
      "moeda",
      "moer",
      "moinho",
      "moita",
      "moldura",
      "moleza",
      "molho",
      "molinete",
      "molusco",
      "montanha",
      "moqueca",
      "morango",
      "morcego",
      "mordomo",
      "morena",
      "mosaico",
      "mosquete",
      "mostarda",
      "motel",
      "motim",
      "moto",
      "motriz",
      "muda",
      "muito",
      "mulata",
      "mulher",
      "multar",
      "mundial",
      "munido",
      "muralha",
      "murcho",
      "muscular",
      "museu",
      "musical",
      "nacional",
      "nadador",
      "naja",
      "namoro",
      "narina",
      "narrado",
      "nascer",
      "nativa",
      "natureza",
      "navalha",
      "navegar",
      "navio",
      "neblina",
      "nebuloso",
      "negativa",
      "negociar",
      "negrito",
      "nervoso",
      "neta",
      "neural",
      "nevasca",
      "nevoeiro",
      "ninar",
      "ninho",
      "nitidez",
      "nivelar",
      "nobreza",
      "noite",
      "noiva",
      "nomear",
      "nominal",
      "nordeste",
      "nortear",
      "notar",
      "noticiar",
      "noturno",
      "novelo",
      "novilho",
      "novo",
      "nublado",
      "nudez",
      "numeral",
      "nupcial",
      "nutrir",
      "nuvem",
      "obcecado",
      "obedecer",
      "objetivo",
      "obrigado",
      "obscuro",
      "obstetra",
      "obter",
      "obturar",
      "ocidente",
      "ocioso",
      "ocorrer",
      "oculista",
      "ocupado",
      "ofegante",
      "ofensiva",
      "oferenda",
      "oficina",
      "ofuscado",
      "ogiva",
      "olaria",
      "oleoso",
      "olhar",
      "oliveira",
      "ombro",
      "omelete",
      "omisso",
      "omitir",
      "ondulado",
      "oneroso",
      "ontem",
      "opcional",
      "operador",
      "oponente",
      "oportuno",
      "oposto",
      "orar",
      "orbitar",
      "ordem",
      "ordinal",
      "orfanato",
      "orgasmo",
      "orgulho",
      "oriental",
      "origem",
      "oriundo",
      "orla",
      "ortodoxo",
      "orvalho",
      "oscilar",
      "ossada",
      "osso",
      "ostentar",
      "otimismo",
      "ousadia",
      "outono",
      "outubro",
      "ouvido",
      "ovelha",
      "ovular",
      "oxidar",
      "oxigenar",
      "pacato",
      "paciente",
      "pacote",
      "pactuar",
      "padaria",
      "padrinho",
      "pagar",
      "pagode",
      "painel",
      "pairar",
      "paisagem",
      "palavra",
      "palestra",
      "palheta",
      "palito",
      "palmada",
      "palpitar",
      "pancada",
      "panela",
      "panfleto",
      "panqueca",
      "pantanal",
      "papagaio",
      "papelada",
      "papiro",
      "parafina",
      "parcial",
      "pardal",
      "parede",
      "partida",
      "pasmo",
      "passado",
      "pastel",
      "patamar",
      "patente",
      "patinar",
      "patrono",
      "paulada",
      "pausar",
      "peculiar",
      "pedalar",
      "pedestre",
      "pediatra",
      "pedra",
      "pegada",
      "peitoral",
      "peixe",
      "pele",
      "pelicano",
      "penca",
      "pendurar",
      "peneira",
      "penhasco",
      "pensador",
      "pente",
      "perceber",
      "perfeito",
      "pergunta",
      "perito",
      "permitir",
      "perna",
      "perplexo",
      "persiana",
      "pertence",
      "peruca",
      "pescado",
      "pesquisa",
      "pessoa",
      "petiscar",
      "piada",
      "picado",
      "piedade",
      "pigmento",
      "pilastra",
      "pilhado",
      "pilotar",
      "pimenta",
      "pincel",
      "pinguim",
      "pinha",
      "pinote",
      "pintar",
      "pioneiro",
      "pipoca",
      "piquete",
      "piranha",
      "pires",
      "pirueta",
      "piscar",
      "pistola",
      "pitanga",
      "pivete",
      "planta",
      "plaqueta",
      "platina",
      "plebeu",
      "plumagem",
      "pluvial",
      "pneu",
      "poda",
      "poeira",
      "poetisa",
      "polegada",
      "policiar",
      "poluente",
      "polvilho",
      "pomar",
      "pomba",
      "ponderar",
      "pontaria",
      "populoso",
      "porta",
      "possuir",
      "postal",
      "pote",
      "poupar",
      "pouso",
      "povoar",
      "praia",
      "prancha",
      "prato",
      "praxe",
      "prece",
      "predador",
      "prefeito",
      "premiar",
      "prensar",
      "preparar",
      "presilha",
      "pretexto",
      "prevenir",
      "prezar",
      "primata",
      "princesa",
      "prisma",
      "privado",
      "processo",
      "produto",
      "profeta",
      "proibido",
      "projeto",
      "prometer",
      "propagar",
      "prosa",
      "protetor",
      "provador",
      "publicar",
      "pudim",
      "pular",
      "pulmonar",
      "pulseira",
      "punhal",
      "punir",
      "pupilo",
      "pureza",
      "puxador",
      "quadra",
      "quantia",
      "quarto",
      "quase",
      "quebrar",
      "queda",
      "queijo",
      "quente",
      "querido",
      "quimono",
      "quina",
      "quiosque",
      "rabanada",
      "rabisco",
      "rachar",
      "racionar",
      "radial",
      "raiar",
      "rainha",
      "raio",
      "raiva",
      "rajada",
      "ralado",
      "ramal",
      "ranger",
      "ranhura",
      "rapadura",
      "rapel",
      "rapidez",
      "raposa",
      "raquete",
      "raridade",
      "rasante",
      "rascunho",
      "rasgar",
      "raspador",
      "rasteira",
      "rasurar",
      "ratazana",
      "ratoeira",
      "realeza",
      "reanimar",
      "reaver",
      "rebaixar",
      "rebelde",
      "rebolar",
      "recado",
      "recente",
      "recheio",
      "recibo",
      "recordar",
      "recrutar",
      "recuar",
      "rede",
      "redimir",
      "redonda",
      "reduzida",
      "reenvio",
      "refinar",
      "refletir",
      "refogar",
      "refresco",
      "refugiar",
      "regalia",
      "regime",
      "regra",
      "reinado",
      "reitor",
      "rejeitar",
      "relativo",
      "remador",
      "remendo",
      "remorso",
      "renovado",
      "reparo",
      "repelir",
      "repleto",
      "repolho",
      "represa",
      "repudiar",
      "requerer",
      "resenha",
      "resfriar",
      "resgatar",
      "residir",
      "resolver",
      "respeito",
      "ressaca",
      "restante",
      "resumir",
      "retalho",
      "reter",
      "retirar",
      "retomada",
      "retratar",
      "revelar",
      "revisor",
      "revolta",
      "riacho",
      "rica",
      "rigidez",
      "rigoroso",
      "rimar",
      "ringue",
      "risada",
      "risco",
      "risonho",
      "robalo",
      "rochedo",
      "rodada",
      "rodeio",
      "rodovia",
      "roedor",
      "roleta",
      "romano",
      "roncar",
      "rosado",
      "roseira",
      "rosto",
      "rota",
      "roteiro",
      "rotina",
      "rotular",
      "rouco",
      "roupa",
      "roxo",
      "rubro",
      "rugido",
      "rugoso",
      "ruivo",
      "rumo",
      "rupestre",
      "russo",
      "sabor",
      "saciar",
      "sacola",
      "sacudir",
      "sadio",
      "safira",
      "saga",
      "sagrada",
      "saibro",
      "salada",
      "saleiro",
      "salgado",
      "saliva",
      "salpicar",
      "salsicha",
      "saltar",
      "salvador",
      "sambar",
      "samurai",
      "sanar",
      "sanfona",
      "sangue",
      "sanidade",
      "sapato",
      "sarda",
      "sargento",
      "sarjeta",
      "saturar",
      "saudade",
      "saxofone",
      "sazonal",
      "secar",
      "secular",
      "seda",
      "sedento",
      "sediado",
      "sedoso",
      "sedutor",
      "segmento",
      "segredo",
      "segundo",
      "seiva",
      "seleto",
      "selvagem",
      "semanal",
      "semente",
      "senador",
      "senhor",
      "sensual",
      "sentado",
      "separado",
      "sereia",
      "seringa",
      "serra",
      "servo",
      "setembro",
      "setor",
      "sigilo",
      "silhueta",
      "silicone",
      "simetria",
      "simpatia",
      "simular",
      "sinal",
      "sincero",
      "singular",
      "sinopse",
      "sintonia",
      "sirene",
      "siri",
      "situado",
      "soberano",
      "sobra",
      "socorro",
      "sogro",
      "soja",
      "solda",
      "soletrar",
      "solteiro",
      "sombrio",
      "sonata",
      "sondar",
      "sonegar",
      "sonhador",
      "sono",
      "soprano",
      "soquete",
      "sorrir",
      "sorteio",
      "sossego",
      "sotaque",
      "soterrar",
      "sovado",
      "sozinho",
      "suavizar",
      "subida",
      "submerso",
      "subsolo",
      "subtrair",
      "sucata",
      "sucesso",
      "suco",
      "sudeste",
      "sufixo",
      "sugador",
      "sugerir",
      "sujeito",
      "sulfato",
      "sumir",
      "suor",
      "superior",
      "suplicar",
      "suposto",
      "suprimir",
      "surdina",
      "surfista",
      "surpresa",
      "surreal",
      "surtir",
      "suspiro",
      "sustento",
      "tabela",
      "tablete",
      "tabuada",
      "tacho",
      "tagarela",
      "talher",
      "talo",
      "talvez",
      "tamanho",
      "tamborim",
      "tampa",
      "tangente",
      "tanto",
      "tapar",
      "tapioca",
      "tardio",
      "tarefa",
      "tarja",
      "tarraxa",
      "tatuagem",
      "taurino",
      "taxativo",
      "taxista",
      "teatral",
      "tecer",
      "tecido",
      "teclado",
      "tedioso",
      "teia",
      "teimar",
      "telefone",
      "telhado",
      "tempero",
      "tenente",
      "tensor",
      "tentar",
      "termal",
      "terno",
      "terreno",
      "tese",
      "tesoura",
      "testado",
      "teto",
      "textura",
      "texugo",
      "tiara",
      "tigela",
      "tijolo",
      "timbrar",
      "timidez",
      "tingido",
      "tinteiro",
      "tiragem",
      "titular",
      "toalha",
      "tocha",
      "tolerar",
      "tolice",
      "tomada",
      "tomilho",
      "tonel",
      "tontura",
      "topete",
      "tora",
      "torcido",
      "torneio",
      "torque",
      "torrada",
      "torto",
      "tostar",
      "touca",
      "toupeira",
      "toxina",
      "trabalho",
      "tracejar",
      "tradutor",
      "trafegar",
      "trajeto",
      "trama",
      "trancar",
      "trapo",
      "traseiro",
      "tratador",
      "travar",
      "treino",
      "tremer",
      "trepidar",
      "trevo",
      "triagem",
      "tribo",
      "triciclo",
      "tridente",
      "trilogia",
      "trindade",
      "triplo",
      "triturar",
      "triunfal",
      "trocar",
      "trombeta",
      "trova",
      "trunfo",
      "truque",
      "tubular",
      "tucano",
      "tudo",
      "tulipa",
      "tupi",
      "turbo",
      "turma",
      "turquesa",
      "tutelar",
      "tutorial",
      "uivar",
      "umbigo",
      "unha",
      "unidade",
      "uniforme",
      "urologia",
      "urso",
      "urtiga",
      "urubu",
      "usado",
      "usina",
      "usufruir",
      "vacina",
      "vadiar",
      "vagaroso",
      "vaidoso",
      "vala",
      "valente",
      "validade",
      "valores",
      "vantagem",
      "vaqueiro",
      "varanda",
      "vareta",
      "varrer",
      "vascular",
      "vasilha",
      "vassoura",
      "vazar",
      "vazio",
      "veado",
      "vedar",
      "vegetar",
      "veicular",
      "veleiro",
      "velhice",
      "veludo",
      "vencedor",
      "vendaval",
      "venerar",
      "ventre",
      "verbal",
      "verdade",
      "vereador",
      "vergonha",
      "vermelho",
      "verniz",
      "versar",
      "vertente",
      "vespa",
      "vestido",
      "vetorial",
      "viaduto",
      "viagem",
      "viajar",
      "viatura",
      "vibrador",
      "videira",
      "vidraria",
      "viela",
      "viga",
      "vigente",
      "vigiar",
      "vigorar",
      "vilarejo",
      "vinco",
      "vinheta",
      "vinil",
      "violeta",
      "virada",
      "virtude",
      "visitar",
      "visto",
      "vitral",
      "viveiro",
      "vizinho",
      "voador",
      "voar",
      "vogal",
      "volante",
      "voleibol",
      "voltagem",
      "volumoso",
      "vontade",
      "vulto",
      "vuvuzela",
      "xadrez",
      "xarope",
      "xeque",
      "xeretar",
      "xerife",
      "xingar",
      "zangado",
      "zarpar",
      "zebu",
      "zelador",
      "zombar",
      "zoologia",
      "zumbido"
    ];
  }
});

// node_modules/bip39/src/wordlists/english.json
var require_english = __commonJS({
  "node_modules/bip39/src/wordlists/english.json"(exports, module) {
    module.exports = [
      "abandon",
      "ability",
      "able",
      "about",
      "above",
      "absent",
      "absorb",
      "abstract",
      "absurd",
      "abuse",
      "access",
      "accident",
      "account",
      "accuse",
      "achieve",
      "acid",
      "acoustic",
      "acquire",
      "across",
      "act",
      "action",
      "actor",
      "actress",
      "actual",
      "adapt",
      "add",
      "addict",
      "address",
      "adjust",
      "admit",
      "adult",
      "advance",
      "advice",
      "aerobic",
      "affair",
      "afford",
      "afraid",
      "again",
      "age",
      "agent",
      "agree",
      "ahead",
      "aim",
      "air",
      "airport",
      "aisle",
      "alarm",
      "album",
      "alcohol",
      "alert",
      "alien",
      "all",
      "alley",
      "allow",
      "almost",
      "alone",
      "alpha",
      "already",
      "also",
      "alter",
      "always",
      "amateur",
      "amazing",
      "among",
      "amount",
      "amused",
      "analyst",
      "anchor",
      "ancient",
      "anger",
      "angle",
      "angry",
      "animal",
      "ankle",
      "announce",
      "annual",
      "another",
      "answer",
      "antenna",
      "antique",
      "anxiety",
      "any",
      "apart",
      "apology",
      "appear",
      "apple",
      "approve",
      "april",
      "arch",
      "arctic",
      "area",
      "arena",
      "argue",
      "arm",
      "armed",
      "armor",
      "army",
      "around",
      "arrange",
      "arrest",
      "arrive",
      "arrow",
      "art",
      "artefact",
      "artist",
      "artwork",
      "ask",
      "aspect",
      "assault",
      "asset",
      "assist",
      "assume",
      "asthma",
      "athlete",
      "atom",
      "attack",
      "attend",
      "attitude",
      "attract",
      "auction",
      "audit",
      "august",
      "aunt",
      "author",
      "auto",
      "autumn",
      "average",
      "avocado",
      "avoid",
      "awake",
      "aware",
      "away",
      "awesome",
      "awful",
      "awkward",
      "axis",
      "baby",
      "bachelor",
      "bacon",
      "badge",
      "bag",
      "balance",
      "balcony",
      "ball",
      "bamboo",
      "banana",
      "banner",
      "bar",
      "barely",
      "bargain",
      "barrel",
      "base",
      "basic",
      "basket",
      "battle",
      "beach",
      "bean",
      "beauty",
      "because",
      "become",
      "beef",
      "before",
      "begin",
      "behave",
      "behind",
      "believe",
      "below",
      "belt",
      "bench",
      "benefit",
      "best",
      "betray",
      "better",
      "between",
      "beyond",
      "bicycle",
      "bid",
      "bike",
      "bind",
      "biology",
      "bird",
      "birth",
      "bitter",
      "black",
      "blade",
      "blame",
      "blanket",
      "blast",
      "bleak",
      "bless",
      "blind",
      "blood",
      "blossom",
      "blouse",
      "blue",
      "blur",
      "blush",
      "board",
      "boat",
      "body",
      "boil",
      "bomb",
      "bone",
      "bonus",
      "book",
      "boost",
      "border",
      "boring",
      "borrow",
      "boss",
      "bottom",
      "bounce",
      "box",
      "boy",
      "bracket",
      "brain",
      "brand",
      "brass",
      "brave",
      "bread",
      "breeze",
      "brick",
      "bridge",
      "brief",
      "bright",
      "bring",
      "brisk",
      "broccoli",
      "broken",
      "bronze",
      "broom",
      "brother",
      "brown",
      "brush",
      "bubble",
      "buddy",
      "budget",
      "buffalo",
      "build",
      "bulb",
      "bulk",
      "bullet",
      "bundle",
      "bunker",
      "burden",
      "burger",
      "burst",
      "bus",
      "business",
      "busy",
      "butter",
      "buyer",
      "buzz",
      "cabbage",
      "cabin",
      "cable",
      "cactus",
      "cage",
      "cake",
      "call",
      "calm",
      "camera",
      "camp",
      "can",
      "canal",
      "cancel",
      "candy",
      "cannon",
      "canoe",
      "canvas",
      "canyon",
      "capable",
      "capital",
      "captain",
      "car",
      "carbon",
      "card",
      "cargo",
      "carpet",
      "carry",
      "cart",
      "case",
      "cash",
      "casino",
      "castle",
      "casual",
      "cat",
      "catalog",
      "catch",
      "category",
      "cattle",
      "caught",
      "cause",
      "caution",
      "cave",
      "ceiling",
      "celery",
      "cement",
      "census",
      "century",
      "cereal",
      "certain",
      "chair",
      "chalk",
      "champion",
      "change",
      "chaos",
      "chapter",
      "charge",
      "chase",
      "chat",
      "cheap",
      "check",
      "cheese",
      "chef",
      "cherry",
      "chest",
      "chicken",
      "chief",
      "child",
      "chimney",
      "choice",
      "choose",
      "chronic",
      "chuckle",
      "chunk",
      "churn",
      "cigar",
      "cinnamon",
      "circle",
      "citizen",
      "city",
      "civil",
      "claim",
      "clap",
      "clarify",
      "claw",
      "clay",
      "clean",
      "clerk",
      "clever",
      "click",
      "client",
      "cliff",
      "climb",
      "clinic",
      "clip",
      "clock",
      "clog",
      "close",
      "cloth",
      "cloud",
      "clown",
      "club",
      "clump",
      "cluster",
      "clutch",
      "coach",
      "coast",
      "coconut",
      "code",
      "coffee",
      "coil",
      "coin",
      "collect",
      "color",
      "column",
      "combine",
      "come",
      "comfort",
      "comic",
      "common",
      "company",
      "concert",
      "conduct",
      "confirm",
      "congress",
      "connect",
      "consider",
      "control",
      "convince",
      "cook",
      "cool",
      "copper",
      "copy",
      "coral",
      "core",
      "corn",
      "correct",
      "cost",
      "cotton",
      "couch",
      "country",
      "couple",
      "course",
      "cousin",
      "cover",
      "coyote",
      "crack",
      "cradle",
      "craft",
      "cram",
      "crane",
      "crash",
      "crater",
      "crawl",
      "crazy",
      "cream",
      "credit",
      "creek",
      "crew",
      "cricket",
      "crime",
      "crisp",
      "critic",
      "crop",
      "cross",
      "crouch",
      "crowd",
      "crucial",
      "cruel",
      "cruise",
      "crumble",
      "crunch",
      "crush",
      "cry",
      "crystal",
      "cube",
      "culture",
      "cup",
      "cupboard",
      "curious",
      "current",
      "curtain",
      "curve",
      "cushion",
      "custom",
      "cute",
      "cycle",
      "dad",
      "damage",
      "damp",
      "dance",
      "danger",
      "daring",
      "dash",
      "daughter",
      "dawn",
      "day",
      "deal",
      "debate",
      "debris",
      "decade",
      "december",
      "decide",
      "decline",
      "decorate",
      "decrease",
      "deer",
      "defense",
      "define",
      "defy",
      "degree",
      "delay",
      "deliver",
      "demand",
      "demise",
      "denial",
      "dentist",
      "deny",
      "depart",
      "depend",
      "deposit",
      "depth",
      "deputy",
      "derive",
      "describe",
      "desert",
      "design",
      "desk",
      "despair",
      "destroy",
      "detail",
      "detect",
      "develop",
      "device",
      "devote",
      "diagram",
      "dial",
      "diamond",
      "diary",
      "dice",
      "diesel",
      "diet",
      "differ",
      "digital",
      "dignity",
      "dilemma",
      "dinner",
      "dinosaur",
      "direct",
      "dirt",
      "disagree",
      "discover",
      "disease",
      "dish",
      "dismiss",
      "disorder",
      "display",
      "distance",
      "divert",
      "divide",
      "divorce",
      "dizzy",
      "doctor",
      "document",
      "dog",
      "doll",
      "dolphin",
      "domain",
      "donate",
      "donkey",
      "donor",
      "door",
      "dose",
      "double",
      "dove",
      "draft",
      "dragon",
      "drama",
      "drastic",
      "draw",
      "dream",
      "dress",
      "drift",
      "drill",
      "drink",
      "drip",
      "drive",
      "drop",
      "drum",
      "dry",
      "duck",
      "dumb",
      "dune",
      "during",
      "dust",
      "dutch",
      "duty",
      "dwarf",
      "dynamic",
      "eager",
      "eagle",
      "early",
      "earn",
      "earth",
      "easily",
      "east",
      "easy",
      "echo",
      "ecology",
      "economy",
      "edge",
      "edit",
      "educate",
      "effort",
      "egg",
      "eight",
      "either",
      "elbow",
      "elder",
      "electric",
      "elegant",
      "element",
      "elephant",
      "elevator",
      "elite",
      "else",
      "embark",
      "embody",
      "embrace",
      "emerge",
      "emotion",
      "employ",
      "empower",
      "empty",
      "enable",
      "enact",
      "end",
      "endless",
      "endorse",
      "enemy",
      "energy",
      "enforce",
      "engage",
      "engine",
      "enhance",
      "enjoy",
      "enlist",
      "enough",
      "enrich",
      "enroll",
      "ensure",
      "enter",
      "entire",
      "entry",
      "envelope",
      "episode",
      "equal",
      "equip",
      "era",
      "erase",
      "erode",
      "erosion",
      "error",
      "erupt",
      "escape",
      "essay",
      "essence",
      "estate",
      "eternal",
      "ethics",
      "evidence",
      "evil",
      "evoke",
      "evolve",
      "exact",
      "example",
      "excess",
      "exchange",
      "excite",
      "exclude",
      "excuse",
      "execute",
      "exercise",
      "exhaust",
      "exhibit",
      "exile",
      "exist",
      "exit",
      "exotic",
      "expand",
      "expect",
      "expire",
      "explain",
      "expose",
      "express",
      "extend",
      "extra",
      "eye",
      "eyebrow",
      "fabric",
      "face",
      "faculty",
      "fade",
      "faint",
      "faith",
      "fall",
      "false",
      "fame",
      "family",
      "famous",
      "fan",
      "fancy",
      "fantasy",
      "farm",
      "fashion",
      "fat",
      "fatal",
      "father",
      "fatigue",
      "fault",
      "favorite",
      "feature",
      "february",
      "federal",
      "fee",
      "feed",
      "feel",
      "female",
      "fence",
      "festival",
      "fetch",
      "fever",
      "few",
      "fiber",
      "fiction",
      "field",
      "figure",
      "file",
      "film",
      "filter",
      "final",
      "find",
      "fine",
      "finger",
      "finish",
      "fire",
      "firm",
      "first",
      "fiscal",
      "fish",
      "fit",
      "fitness",
      "fix",
      "flag",
      "flame",
      "flash",
      "flat",
      "flavor",
      "flee",
      "flight",
      "flip",
      "float",
      "flock",
      "floor",
      "flower",
      "fluid",
      "flush",
      "fly",
      "foam",
      "focus",
      "fog",
      "foil",
      "fold",
      "follow",
      "food",
      "foot",
      "force",
      "forest",
      "forget",
      "fork",
      "fortune",
      "forum",
      "forward",
      "fossil",
      "foster",
      "found",
      "fox",
      "fragile",
      "frame",
      "frequent",
      "fresh",
      "friend",
      "fringe",
      "frog",
      "front",
      "frost",
      "frown",
      "frozen",
      "fruit",
      "fuel",
      "fun",
      "funny",
      "furnace",
      "fury",
      "future",
      "gadget",
      "gain",
      "galaxy",
      "gallery",
      "game",
      "gap",
      "garage",
      "garbage",
      "garden",
      "garlic",
      "garment",
      "gas",
      "gasp",
      "gate",
      "gather",
      "gauge",
      "gaze",
      "general",
      "genius",
      "genre",
      "gentle",
      "genuine",
      "gesture",
      "ghost",
      "giant",
      "gift",
      "giggle",
      "ginger",
      "giraffe",
      "girl",
      "give",
      "glad",
      "glance",
      "glare",
      "glass",
      "glide",
      "glimpse",
      "globe",
      "gloom",
      "glory",
      "glove",
      "glow",
      "glue",
      "goat",
      "goddess",
      "gold",
      "good",
      "goose",
      "gorilla",
      "gospel",
      "gossip",
      "govern",
      "gown",
      "grab",
      "grace",
      "grain",
      "grant",
      "grape",
      "grass",
      "gravity",
      "great",
      "green",
      "grid",
      "grief",
      "grit",
      "grocery",
      "group",
      "grow",
      "grunt",
      "guard",
      "guess",
      "guide",
      "guilt",
      "guitar",
      "gun",
      "gym",
      "habit",
      "hair",
      "half",
      "hammer",
      "hamster",
      "hand",
      "happy",
      "harbor",
      "hard",
      "harsh",
      "harvest",
      "hat",
      "have",
      "hawk",
      "hazard",
      "head",
      "health",
      "heart",
      "heavy",
      "hedgehog",
      "height",
      "hello",
      "helmet",
      "help",
      "hen",
      "hero",
      "hidden",
      "high",
      "hill",
      "hint",
      "hip",
      "hire",
      "history",
      "hobby",
      "hockey",
      "hold",
      "hole",
      "holiday",
      "hollow",
      "home",
      "honey",
      "hood",
      "hope",
      "horn",
      "horror",
      "horse",
      "hospital",
      "host",
      "hotel",
      "hour",
      "hover",
      "hub",
      "huge",
      "human",
      "humble",
      "humor",
      "hundred",
      "hungry",
      "hunt",
      "hurdle",
      "hurry",
      "hurt",
      "husband",
      "hybrid",
      "ice",
      "icon",
      "idea",
      "identify",
      "idle",
      "ignore",
      "ill",
      "illegal",
      "illness",
      "image",
      "imitate",
      "immense",
      "immune",
      "impact",
      "impose",
      "improve",
      "impulse",
      "inch",
      "include",
      "income",
      "increase",
      "index",
      "indicate",
      "indoor",
      "industry",
      "infant",
      "inflict",
      "inform",
      "inhale",
      "inherit",
      "initial",
      "inject",
      "injury",
      "inmate",
      "inner",
      "innocent",
      "input",
      "inquiry",
      "insane",
      "insect",
      "inside",
      "inspire",
      "install",
      "intact",
      "interest",
      "into",
      "invest",
      "invite",
      "involve",
      "iron",
      "island",
      "isolate",
      "issue",
      "item",
      "ivory",
      "jacket",
      "jaguar",
      "jar",
      "jazz",
      "jealous",
      "jeans",
      "jelly",
      "jewel",
      "job",
      "join",
      "joke",
      "journey",
      "joy",
      "judge",
      "juice",
      "jump",
      "jungle",
      "junior",
      "junk",
      "just",
      "kangaroo",
      "keen",
      "keep",
      "ketchup",
      "key",
      "kick",
      "kid",
      "kidney",
      "kind",
      "kingdom",
      "kiss",
      "kit",
      "kitchen",
      "kite",
      "kitten",
      "kiwi",
      "knee",
      "knife",
      "knock",
      "know",
      "lab",
      "label",
      "labor",
      "ladder",
      "lady",
      "lake",
      "lamp",
      "language",
      "laptop",
      "large",
      "later",
      "latin",
      "laugh",
      "laundry",
      "lava",
      "law",
      "lawn",
      "lawsuit",
      "layer",
      "lazy",
      "leader",
      "leaf",
      "learn",
      "leave",
      "lecture",
      "left",
      "leg",
      "legal",
      "legend",
      "leisure",
      "lemon",
      "lend",
      "length",
      "lens",
      "leopard",
      "lesson",
      "letter",
      "level",
      "liar",
      "liberty",
      "library",
      "license",
      "life",
      "lift",
      "light",
      "like",
      "limb",
      "limit",
      "link",
      "lion",
      "liquid",
      "list",
      "little",
      "live",
      "lizard",
      "load",
      "loan",
      "lobster",
      "local",
      "lock",
      "logic",
      "lonely",
      "long",
      "loop",
      "lottery",
      "loud",
      "lounge",
      "love",
      "loyal",
      "lucky",
      "luggage",
      "lumber",
      "lunar",
      "lunch",
      "luxury",
      "lyrics",
      "machine",
      "mad",
      "magic",
      "magnet",
      "maid",
      "mail",
      "main",
      "major",
      "make",
      "mammal",
      "man",
      "manage",
      "mandate",
      "mango",
      "mansion",
      "manual",
      "maple",
      "marble",
      "march",
      "margin",
      "marine",
      "market",
      "marriage",
      "mask",
      "mass",
      "master",
      "match",
      "material",
      "math",
      "matrix",
      "matter",
      "maximum",
      "maze",
      "meadow",
      "mean",
      "measure",
      "meat",
      "mechanic",
      "medal",
      "media",
      "melody",
      "melt",
      "member",
      "memory",
      "mention",
      "menu",
      "mercy",
      "merge",
      "merit",
      "merry",
      "mesh",
      "message",
      "metal",
      "method",
      "middle",
      "midnight",
      "milk",
      "million",
      "mimic",
      "mind",
      "minimum",
      "minor",
      "minute",
      "miracle",
      "mirror",
      "misery",
      "miss",
      "mistake",
      "mix",
      "mixed",
      "mixture",
      "mobile",
      "model",
      "modify",
      "mom",
      "moment",
      "monitor",
      "monkey",
      "monster",
      "month",
      "moon",
      "moral",
      "more",
      "morning",
      "mosquito",
      "mother",
      "motion",
      "motor",
      "mountain",
      "mouse",
      "move",
      "movie",
      "much",
      "muffin",
      "mule",
      "multiply",
      "muscle",
      "museum",
      "mushroom",
      "music",
      "must",
      "mutual",
      "myself",
      "mystery",
      "myth",
      "naive",
      "name",
      "napkin",
      "narrow",
      "nasty",
      "nation",
      "nature",
      "near",
      "neck",
      "need",
      "negative",
      "neglect",
      "neither",
      "nephew",
      "nerve",
      "nest",
      "net",
      "network",
      "neutral",
      "never",
      "news",
      "next",
      "nice",
      "night",
      "noble",
      "noise",
      "nominee",
      "noodle",
      "normal",
      "north",
      "nose",
      "notable",
      "note",
      "nothing",
      "notice",
      "novel",
      "now",
      "nuclear",
      "number",
      "nurse",
      "nut",
      "oak",
      "obey",
      "object",
      "oblige",
      "obscure",
      "observe",
      "obtain",
      "obvious",
      "occur",
      "ocean",
      "october",
      "odor",
      "off",
      "offer",
      "office",
      "often",
      "oil",
      "okay",
      "old",
      "olive",
      "olympic",
      "omit",
      "once",
      "one",
      "onion",
      "online",
      "only",
      "open",
      "opera",
      "opinion",
      "oppose",
      "option",
      "orange",
      "orbit",
      "orchard",
      "order",
      "ordinary",
      "organ",
      "orient",
      "original",
      "orphan",
      "ostrich",
      "other",
      "outdoor",
      "outer",
      "output",
      "outside",
      "oval",
      "oven",
      "over",
      "own",
      "owner",
      "oxygen",
      "oyster",
      "ozone",
      "pact",
      "paddle",
      "page",
      "pair",
      "palace",
      "palm",
      "panda",
      "panel",
      "panic",
      "panther",
      "paper",
      "parade",
      "parent",
      "park",
      "parrot",
      "party",
      "pass",
      "patch",
      "path",
      "patient",
      "patrol",
      "pattern",
      "pause",
      "pave",
      "payment",
      "peace",
      "peanut",
      "pear",
      "peasant",
      "pelican",
      "pen",
      "penalty",
      "pencil",
      "people",
      "pepper",
      "perfect",
      "permit",
      "person",
      "pet",
      "phone",
      "photo",
      "phrase",
      "physical",
      "piano",
      "picnic",
      "picture",
      "piece",
      "pig",
      "pigeon",
      "pill",
      "pilot",
      "pink",
      "pioneer",
      "pipe",
      "pistol",
      "pitch",
      "pizza",
      "place",
      "planet",
      "plastic",
      "plate",
      "play",
      "please",
      "pledge",
      "pluck",
      "plug",
      "plunge",
      "poem",
      "poet",
      "point",
      "polar",
      "pole",
      "police",
      "pond",
      "pony",
      "pool",
      "popular",
      "portion",
      "position",
      "possible",
      "post",
      "potato",
      "pottery",
      "poverty",
      "powder",
      "power",
      "practice",
      "praise",
      "predict",
      "prefer",
      "prepare",
      "present",
      "pretty",
      "prevent",
      "price",
      "pride",
      "primary",
      "print",
      "priority",
      "prison",
      "private",
      "prize",
      "problem",
      "process",
      "produce",
      "profit",
      "program",
      "project",
      "promote",
      "proof",
      "property",
      "prosper",
      "protect",
      "proud",
      "provide",
      "public",
      "pudding",
      "pull",
      "pulp",
      "pulse",
      "pumpkin",
      "punch",
      "pupil",
      "puppy",
      "purchase",
      "purity",
      "purpose",
      "purse",
      "push",
      "put",
      "puzzle",
      "pyramid",
      "quality",
      "quantum",
      "quarter",
      "question",
      "quick",
      "quit",
      "quiz",
      "quote",
      "rabbit",
      "raccoon",
      "race",
      "rack",
      "radar",
      "radio",
      "rail",
      "rain",
      "raise",
      "rally",
      "ramp",
      "ranch",
      "random",
      "range",
      "rapid",
      "rare",
      "rate",
      "rather",
      "raven",
      "raw",
      "razor",
      "ready",
      "real",
      "reason",
      "rebel",
      "rebuild",
      "recall",
      "receive",
      "recipe",
      "record",
      "recycle",
      "reduce",
      "reflect",
      "reform",
      "refuse",
      "region",
      "regret",
      "regular",
      "reject",
      "relax",
      "release",
      "relief",
      "rely",
      "remain",
      "remember",
      "remind",
      "remove",
      "render",
      "renew",
      "rent",
      "reopen",
      "repair",
      "repeat",
      "replace",
      "report",
      "require",
      "rescue",
      "resemble",
      "resist",
      "resource",
      "response",
      "result",
      "retire",
      "retreat",
      "return",
      "reunion",
      "reveal",
      "review",
      "reward",
      "rhythm",
      "rib",
      "ribbon",
      "rice",
      "rich",
      "ride",
      "ridge",
      "rifle",
      "right",
      "rigid",
      "ring",
      "riot",
      "ripple",
      "risk",
      "ritual",
      "rival",
      "river",
      "road",
      "roast",
      "robot",
      "robust",
      "rocket",
      "romance",
      "roof",
      "rookie",
      "room",
      "rose",
      "rotate",
      "rough",
      "round",
      "route",
      "royal",
      "rubber",
      "rude",
      "rug",
      "rule",
      "run",
      "runway",
      "rural",
      "sad",
      "saddle",
      "sadness",
      "safe",
      "sail",
      "salad",
      "salmon",
      "salon",
      "salt",
      "salute",
      "same",
      "sample",
      "sand",
      "satisfy",
      "satoshi",
      "sauce",
      "sausage",
      "save",
      "say",
      "scale",
      "scan",
      "scare",
      "scatter",
      "scene",
      "scheme",
      "school",
      "science",
      "scissors",
      "scorpion",
      "scout",
      "scrap",
      "screen",
      "script",
      "scrub",
      "sea",
      "search",
      "season",
      "seat",
      "second",
      "secret",
      "section",
      "security",
      "seed",
      "seek",
      "segment",
      "select",
      "sell",
      "seminar",
      "senior",
      "sense",
      "sentence",
      "series",
      "service",
      "session",
      "settle",
      "setup",
      "seven",
      "shadow",
      "shaft",
      "shallow",
      "share",
      "shed",
      "shell",
      "sheriff",
      "shield",
      "shift",
      "shine",
      "ship",
      "shiver",
      "shock",
      "shoe",
      "shoot",
      "shop",
      "short",
      "shoulder",
      "shove",
      "shrimp",
      "shrug",
      "shuffle",
      "shy",
      "sibling",
      "sick",
      "side",
      "siege",
      "sight",
      "sign",
      "silent",
      "silk",
      "silly",
      "silver",
      "similar",
      "simple",
      "since",
      "sing",
      "siren",
      "sister",
      "situate",
      "six",
      "size",
      "skate",
      "sketch",
      "ski",
      "skill",
      "skin",
      "skirt",
      "skull",
      "slab",
      "slam",
      "sleep",
      "slender",
      "slice",
      "slide",
      "slight",
      "slim",
      "slogan",
      "slot",
      "slow",
      "slush",
      "small",
      "smart",
      "smile",
      "smoke",
      "smooth",
      "snack",
      "snake",
      "snap",
      "sniff",
      "snow",
      "soap",
      "soccer",
      "social",
      "sock",
      "soda",
      "soft",
      "solar",
      "soldier",
      "solid",
      "solution",
      "solve",
      "someone",
      "song",
      "soon",
      "sorry",
      "sort",
      "soul",
      "sound",
      "soup",
      "source",
      "south",
      "space",
      "spare",
      "spatial",
      "spawn",
      "speak",
      "special",
      "speed",
      "spell",
      "spend",
      "sphere",
      "spice",
      "spider",
      "spike",
      "spin",
      "spirit",
      "split",
      "spoil",
      "sponsor",
      "spoon",
      "sport",
      "spot",
      "spray",
      "spread",
      "spring",
      "spy",
      "square",
      "squeeze",
      "squirrel",
      "stable",
      "stadium",
      "staff",
      "stage",
      "stairs",
      "stamp",
      "stand",
      "start",
      "state",
      "stay",
      "steak",
      "steel",
      "stem",
      "step",
      "stereo",
      "stick",
      "still",
      "sting",
      "stock",
      "stomach",
      "stone",
      "stool",
      "story",
      "stove",
      "strategy",
      "street",
      "strike",
      "strong",
      "struggle",
      "student",
      "stuff",
      "stumble",
      "style",
      "subject",
      "submit",
      "subway",
      "success",
      "such",
      "sudden",
      "suffer",
      "sugar",
      "suggest",
      "suit",
      "summer",
      "sun",
      "sunny",
      "sunset",
      "super",
      "supply",
      "supreme",
      "sure",
      "surface",
      "surge",
      "surprise",
      "surround",
      "survey",
      "suspect",
      "sustain",
      "swallow",
      "swamp",
      "swap",
      "swarm",
      "swear",
      "sweet",
      "swift",
      "swim",
      "swing",
      "switch",
      "sword",
      "symbol",
      "symptom",
      "syrup",
      "system",
      "table",
      "tackle",
      "tag",
      "tail",
      "talent",
      "talk",
      "tank",
      "tape",
      "target",
      "task",
      "taste",
      "tattoo",
      "taxi",
      "teach",
      "team",
      "tell",
      "ten",
      "tenant",
      "tennis",
      "tent",
      "term",
      "test",
      "text",
      "thank",
      "that",
      "theme",
      "then",
      "theory",
      "there",
      "they",
      "thing",
      "this",
      "thought",
      "three",
      "thrive",
      "throw",
      "thumb",
      "thunder",
      "ticket",
      "tide",
      "tiger",
      "tilt",
      "timber",
      "time",
      "tiny",
      "tip",
      "tired",
      "tissue",
      "title",
      "toast",
      "tobacco",
      "today",
      "toddler",
      "toe",
      "together",
      "toilet",
      "token",
      "tomato",
      "tomorrow",
      "tone",
      "tongue",
      "tonight",
      "tool",
      "tooth",
      "top",
      "topic",
      "topple",
      "torch",
      "tornado",
      "tortoise",
      "toss",
      "total",
      "tourist",
      "toward",
      "tower",
      "town",
      "toy",
      "track",
      "trade",
      "traffic",
      "tragic",
      "train",
      "transfer",
      "trap",
      "trash",
      "travel",
      "tray",
      "treat",
      "tree",
      "trend",
      "trial",
      "tribe",
      "trick",
      "trigger",
      "trim",
      "trip",
      "trophy",
      "trouble",
      "truck",
      "true",
      "truly",
      "trumpet",
      "trust",
      "truth",
      "try",
      "tube",
      "tuition",
      "tumble",
      "tuna",
      "tunnel",
      "turkey",
      "turn",
      "turtle",
      "twelve",
      "twenty",
      "twice",
      "twin",
      "twist",
      "two",
      "type",
      "typical",
      "ugly",
      "umbrella",
      "unable",
      "unaware",
      "uncle",
      "uncover",
      "under",
      "undo",
      "unfair",
      "unfold",
      "unhappy",
      "uniform",
      "unique",
      "unit",
      "universe",
      "unknown",
      "unlock",
      "until",
      "unusual",
      "unveil",
      "update",
      "upgrade",
      "uphold",
      "upon",
      "upper",
      "upset",
      "urban",
      "urge",
      "usage",
      "use",
      "used",
      "useful",
      "useless",
      "usual",
      "utility",
      "vacant",
      "vacuum",
      "vague",
      "valid",
      "valley",
      "valve",
      "van",
      "vanish",
      "vapor",
      "various",
      "vast",
      "vault",
      "vehicle",
      "velvet",
      "vendor",
      "venture",
      "venue",
      "verb",
      "verify",
      "version",
      "very",
      "vessel",
      "veteran",
      "viable",
      "vibrant",
      "vicious",
      "victory",
      "video",
      "view",
      "village",
      "vintage",
      "violin",
      "virtual",
      "virus",
      "visa",
      "visit",
      "visual",
      "vital",
      "vivid",
      "vocal",
      "voice",
      "void",
      "volcano",
      "volume",
      "vote",
      "voyage",
      "wage",
      "wagon",
      "wait",
      "walk",
      "wall",
      "walnut",
      "want",
      "warfare",
      "warm",
      "warrior",
      "wash",
      "wasp",
      "waste",
      "water",
      "wave",
      "way",
      "wealth",
      "weapon",
      "wear",
      "weasel",
      "weather",
      "web",
      "wedding",
      "weekend",
      "weird",
      "welcome",
      "west",
      "wet",
      "whale",
      "what",
      "wheat",
      "wheel",
      "when",
      "where",
      "whip",
      "whisper",
      "wide",
      "width",
      "wife",
      "wild",
      "will",
      "win",
      "window",
      "wine",
      "wing",
      "wink",
      "winner",
      "winter",
      "wire",
      "wisdom",
      "wise",
      "wish",
      "witness",
      "wolf",
      "woman",
      "wonder",
      "wood",
      "wool",
      "word",
      "work",
      "world",
      "worry",
      "worth",
      "wrap",
      "wreck",
      "wrestle",
      "wrist",
      "write",
      "wrong",
      "yard",
      "year",
      "yellow",
      "you",
      "young",
      "youth",
      "zebra",
      "zero",
      "zone",
      "zoo"
    ];
  }
});

// node_modules/bip39/src/_wordlists.js
var require_wordlists = __commonJS({
  "node_modules/bip39/src/_wordlists.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var wordlists = {};
    exports.wordlists = wordlists;
    var _default;
    exports._default = _default;
    try {
      exports._default = _default = require_czech();
      wordlists.czech = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_chinese_simplified();
      wordlists.chinese_simplified = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_chinese_traditional();
      wordlists.chinese_traditional = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_korean();
      wordlists.korean = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_french();
      wordlists.french = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_italian();
      wordlists.italian = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_spanish();
      wordlists.spanish = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_japanese();
      wordlists.japanese = _default;
      wordlists.JA = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_portuguese();
      wordlists.portuguese = _default;
    } catch (err) {
    }
    try {
      exports._default = _default = require_english();
      wordlists.english = _default;
      wordlists.EN = _default;
    } catch (err) {
    }
  }
});

// node_modules/bip39/src/index.js
var require_src = __commonJS({
  "node_modules/bip39/src/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var pbkdf2_1 = require_pbkdf2();
    var utils_1 = require_utils();
    var _wordlists_1 = require_wordlists();
    var DEFAULT_WORDLIST = _wordlists_1._default;
    var INVALID_MNEMONIC = "Invalid mnemonic";
    var INVALID_ENTROPY = "Invalid entropy";
    var INVALID_CHECKSUM = "Invalid mnemonic checksum";
    var WORDLIST_REQUIRED = "A wordlist is required but a default could not be found.\nPlease pass a 2048 word array explicitly.";
    function normalize(str) {
      return (str || "").normalize("NFKD");
    }
    function lpad(str, padString, length) {
      while (str.length < length) {
        str = padString + str;
      }
      return str;
    }
    function binaryToByte(bin) {
      return parseInt(bin, 2);
    }
    function bytesToBinary(bytes) {
      return bytes.map((x15) => lpad(x15.toString(2), "0", 8)).join("");
    }
    function deriveChecksumBits(entropyBuffer) {
      const ENT = entropyBuffer.length * 8;
      const CS = ENT / 32;
      const hash = sha256_1.sha256(Uint8Array.from(entropyBuffer));
      return bytesToBinary(Array.from(hash)).slice(0, CS);
    }
    function salt(password) {
      return "mnemonic" + (password || "");
    }
    function mnemonicToSeedSync3(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      const res = pbkdf2_1.pbkdf2(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      });
      return Buffer.from(res);
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync3;
    function mnemonicToSeed(mnemonic, password) {
      const mnemonicBuffer = Uint8Array.from(Buffer.from(normalize(mnemonic), "utf8"));
      const saltBuffer = Uint8Array.from(Buffer.from(salt(normalize(password)), "utf8"));
      return pbkdf2_1.pbkdf2Async(sha512_1.sha512, mnemonicBuffer, saltBuffer, {
        c: 2048,
        dkLen: 64
      }).then((res) => Buffer.from(res));
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToEntropy(mnemonic, wordlist) {
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      const words = normalize(mnemonic).split(" ");
      if (words.length % 3 !== 0) {
        throw new Error(INVALID_MNEMONIC);
      }
      const bits = words.map((word) => {
        const index = wordlist.indexOf(word);
        if (index === -1) {
          throw new Error(INVALID_MNEMONIC);
        }
        return lpad(index.toString(2), "0", 11);
      }).join("");
      const dividerIndex = Math.floor(bits.length / 33) * 32;
      const entropyBits = bits.slice(0, dividerIndex);
      const checksumBits = bits.slice(dividerIndex);
      const entropyBytes = entropyBits.match(/(.{1,8})/g).map(binaryToByte);
      if (entropyBytes.length < 16) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length > 32) {
        throw new Error(INVALID_ENTROPY);
      }
      if (entropyBytes.length % 4 !== 0) {
        throw new Error(INVALID_ENTROPY);
      }
      const entropy = Buffer.from(entropyBytes);
      const newChecksum = deriveChecksumBits(entropy);
      if (newChecksum !== checksumBits) {
        throw new Error(INVALID_CHECKSUM);
      }
      return entropy.toString("hex");
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      if (!Buffer.isBuffer(entropy)) {
        entropy = Buffer.from(entropy, "hex");
      }
      wordlist = wordlist || DEFAULT_WORDLIST;
      if (!wordlist) {
        throw new Error(WORDLIST_REQUIRED);
      }
      if (entropy.length < 16) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length > 32) {
        throw new TypeError(INVALID_ENTROPY);
      }
      if (entropy.length % 4 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      const entropyBits = bytesToBinary(Array.from(entropy));
      const checksumBits = deriveChecksumBits(entropy);
      const bits = entropyBits + checksumBits;
      const chunks = bits.match(/(.{1,11})/g);
      const words = chunks.map((binary) => {
        const index = binaryToByte(binary);
        return wordlist[index];
      });
      return wordlist[0] === "あいこくしん" ? words.join("　") : words.join(" ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function generateMnemonic(strength, rng, wordlist) {
      strength = strength || 128;
      if (strength % 32 !== 0) {
        throw new TypeError(INVALID_ENTROPY);
      }
      rng = rng || ((size2) => Buffer.from(utils_1.randomBytes(size2)));
      return entropyToMnemonic(rng(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    function validateMnemonic2(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e17) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic2;
    function setDefaultWordlist(language) {
      const result = _wordlists_1.wordlists[language];
      if (result) {
        DEFAULT_WORDLIST = result;
      } else {
        throw new Error('Could not find wordlist for language "' + language + '"');
      }
    }
    exports.setDefaultWordlist = setDefaultWordlist;
    function getDefaultWordlist() {
      if (!DEFAULT_WORDLIST) {
        throw new Error("No Default Wordlist set");
      }
      return Object.keys(_wordlists_1.wordlists).filter((lang) => {
        if (lang === "JA" || lang === "EN") {
          return false;
        }
        return _wordlists_1.wordlists[lang].every((word, index) => word === DEFAULT_WORDLIST[index]);
      })[0];
    }
    exports.getDefaultWordlist = getDefaultWordlist;
    var _wordlists_2 = require_wordlists();
    exports.wordlists = _wordlists_2.wordlists;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/_assert.js
var require_assert2 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number2(n13) {
      if (!Number.isSafeInteger(n13) || n13 < 0)
        throw new Error(`positive integer expected, not ${n13}`);
    }
    exports.number = number2;
    function bool(b10) {
      if (typeof b10 !== "boolean")
        throw new Error(`boolean expected, not ${b10}`);
    }
    exports.bool = bool;
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    function bytes(b10, ...lengths) {
      if (!isBytes2(b10))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b10.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b10.length}`);
    }
    exports.bytes = bytes;
    function hash(h11) {
      if (typeof h11 !== "function" || typeof h11.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(h11.outputLen);
      number2(h11.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number: number2, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/utils.js
var require_utils2 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto2();
    var _assert_js_1 = require_assert2();
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u82;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n13) => n13 : (n13) => (0, exports.byteSwap)(n13);
    function byteSwap32(arr) {
      for (let i18 = 0; i18 < arr.length; i18++) {
        arr[i18] = (0, exports.byteSwap)(arr[i18]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_10, i18) => i18.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i18 = 0; i18 < bytes.length; i18++) {
        hex += hexes[bytes[i18]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes2;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i18 = 0; i18 < iters; i18++) {
        cb(i18);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i18 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        (0, _assert_js_1.bytes)(a24);
        sum += a24.length;
      }
      const res = new Uint8Array(sum);
      for (let i18 = 0, pad2 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        res.set(a24, pad2);
        pad2 += a24.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes2;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils2();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad2 = new Uint8Array(blockLen);
        pad2.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i18 = 0; i18 < pad2.length; i18++)
          pad2[i18] ^= 54;
        this.iHash.update(pad2);
        this.oHash = hash.create();
        for (let i18 = 0; i18 < pad2.length; i18++)
          pad2[i18] ^= 54 ^ 92;
        this.oHash.update(pad2);
        pad2.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/bip32/node_modules/@noble/hashes/_md.js
var require_md2 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert2();
    var utils_js_1 = require_utils2();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h11 = isLE ? 4 : 0;
      const l23 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h11, wh, isLE);
      view.setUint32(byteOffset + l23, wl, isLE);
    }
    var Chi = (a24, b10, c10) => a24 & b10 ^ ~a24 & c10;
    exports.Chi = Chi;
    var Maj = (a24, b10, c10) => a24 & b10 ^ a24 & c10 ^ b10 & c10;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i18 = pos; i18 < blockLen; i18++)
          buffer[i18] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i18 = 0; i18 < outLen; i18++)
          oview.setUint32(4 * i18, state[i18], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _md_js_1 = require_md2();
    var utils_js_1 = require_utils2();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = new Uint8Array(new Array(16).fill(0).map((_10, i18) => i18));
    var Pi = Id.map((i18) => (9 * i18 + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i18 = 0; i18 < 4; i18++)
      for (let j6 of [idxL, idxR])
        j6.push(j6[i18].map((k9) => Rho[k9]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i18) => new Uint8Array(i18));
    var shiftsL = idxL.map((idx, i18) => idx.map((j6) => shifts[i18][j6]));
    var shiftsR = idxR.map((idx, i18) => idx.map((j6) => shifts[i18][j6]));
    var Kl = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function f17(group, x15, y13, z10) {
      if (group === 0)
        return x15 ^ y13 ^ z10;
      else if (group === 1)
        return x15 & y13 | ~x15 & z10;
      else if (group === 2)
        return (x15 | ~y13) ^ z10;
      else if (group === 3)
        return x15 & z10 | y13 & ~z10;
      else
        return x15 ^ (y13 | ~z10);
    }
    var R_BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
        return [h0, h1, h22, h32, h42];
      }
      set(h0, h1, h22, h32, h42) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h22 | 0;
        this.h3 = h32 | 0;
        this.h4 = h42 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          R_BUF[i18] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i18 = 0; i18 < 16; i18++) {
            const tl = (0, utils_js_1.rotl)(al + f17(group, bl, cl, dl) + R_BUF[rl[i18]] + hbl, sl[i18]) + el | 0;
            al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i18 = 0; i18 < 16; i18++) {
            const tr = (0, utils_js_1.rotl)(ar + f17(rGroup, br, cr, dr) + R_BUF[rr[i18]] + hbr, sr[i18]) + er | 0;
            ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        R_BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/bip32/node_modules/@noble/hashes/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md2();
    var utils_js_1 = require_utils2();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        return [A13, B12, C7, D7, E14, F11, G6, H7];
      }
      // prettier-ignore
      set(A13, B12, C7, D7, E14, F11, G6, H7) {
        this.A = A13 | 0;
        this.B = B12 | 0;
        this.C = C7 | 0;
        this.D = D7 | 0;
        this.E = E14 | 0;
        this.F = F11 | 0;
        this.G = G6 | 0;
        this.H = H7 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          SHA256_W[i18] = view.getUint32(offset, false);
        for (let i18 = 16; i18 < 64; i18++) {
          const W15 = SHA256_W[i18 - 15];
          const W2 = SHA256_W[i18 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i18] = s1 + SHA256_W[i18 - 7] + s0 + SHA256_W[i18 - 16] | 0;
        }
        let { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        for (let i18 = 0; i18 < 64; i18++) {
          const sigma1 = (0, utils_js_1.rotr)(E14, 6) ^ (0, utils_js_1.rotr)(E14, 11) ^ (0, utils_js_1.rotr)(E14, 25);
          const T1 = H7 + sigma1 + (0, _md_js_1.Chi)(E14, F11, G6) + SHA256_K[i18] + SHA256_W[i18] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A13, 2) ^ (0, utils_js_1.rotr)(A13, 13) ^ (0, utils_js_1.rotr)(A13, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A13, B12, C7) | 0;
          H7 = G6;
          G6 = F11;
          F11 = E14;
          E14 = D7 + T1 | 0;
          D7 = C7;
          C7 = B12;
          B12 = A13;
          A13 = T1 + T22 | 0;
        }
        A13 = A13 + this.A | 0;
        B12 = B12 + this.B | 0;
        C7 = C7 + this.C | 0;
        D7 = D7 + this.D | 0;
        E14 = E14 + this.E | 0;
        F11 = F11 + this.F | 0;
        G6 = G6 + this.G | 0;
        H7 = H7 + this.H | 0;
        this.set(A13, B12, C7, D7, E14, F11, G6, H7);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/bip32/node_modules/@noble/hashes/_u64.js
var require_u642 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n13, le = false) {
      if (le)
        return { h: Number(n13 & U32_MASK64), l: Number(n13 >> _32n & U32_MASK64) };
      return { h: Number(n13 >> _32n & U32_MASK64) | 0, l: Number(n13 & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split2(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i18 = 0; i18 < lst.length; i18++) {
        const { h: h11, l: l23 } = fromBig(lst[i18], le);
        [Ah[i18], Al[i18]] = [h11, l23];
      }
      return [Ah, Al];
    }
    exports.split = split2;
    var toBig = (h11, l23) => BigInt(h11 >>> 0) << _32n | BigInt(l23 >>> 0);
    exports.toBig = toBig;
    var shrSH = (h11, _l, s15) => h11 >>> s15;
    exports.shrSH = shrSH;
    var shrSL = (h11, l23, s15) => h11 << 32 - s15 | l23 >>> s15;
    exports.shrSL = shrSL;
    var rotrSH = (h11, l23, s15) => h11 >>> s15 | l23 << 32 - s15;
    exports.rotrSH = rotrSH;
    var rotrSL = (h11, l23, s15) => h11 << 32 - s15 | l23 >>> s15;
    exports.rotrSL = rotrSL;
    var rotrBH = (h11, l23, s15) => h11 << 64 - s15 | l23 >>> s15 - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h11, l23, s15) => h11 >>> s15 - 32 | l23 << 64 - s15;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l23) => l23;
    exports.rotr32H = rotr32H;
    var rotr32L = (h11, _l) => h11;
    exports.rotr32L = rotr32L;
    var rotlSH = (h11, l23, s15) => h11 << s15 | l23 >>> 32 - s15;
    exports.rotlSH = rotlSH;
    var rotlSL = (h11, l23, s15) => l23 << s15 | h11 >>> 32 - s15;
    exports.rotlSL = rotlSL;
    var rotlBH = (h11, l23, s15) => l23 << s15 - 32 | h11 >>> 64 - s15;
    exports.rotlBH = rotlBH;
    var rotlBL = (h11, l23, s15) => h11 << s15 - 32 | l23 >>> 64 - s15;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l23 = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l23 / 2 ** 32 | 0) | 0, l: l23 | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split: split2,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/bip32/node_modules/@noble/hashes/sha512.js
var require_sha5122 = __commonJS({
  "node_modules/bip32/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _md_js_1 = require_md2();
    var _u64_js_1 = require_u642();
    var utils_js_1 = require_utils2();
    var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n13) => BigInt(n13))))();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_js_1.HashMD {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4) {
          SHA512_W_H[i18] = view.getUint32(offset);
          SHA512_W_L[i18] = view.getUint32(offset += 4);
        }
        for (let i18 = 16; i18 < 80; i18++) {
          const W15h = SHA512_W_H[i18 - 15] | 0;
          const W15l = SHA512_W_L[i18 - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i18 - 2] | 0;
          const W2l = SHA512_W_L[i18 - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i18 - 7], SHA512_W_L[i18 - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i18 - 7], SHA512_W_H[i18 - 16]);
          SHA512_W_H[i18] = SUMh | 0;
          SHA512_W_L[i18] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i18 = 0; i18 < 80; i18++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i18], SHA512_W_L[i18]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i18], SHA512_W_H[i18]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/bip32/src/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/bip32/src/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmacSHA512 = exports.hash160 = void 0;
    var hmac_1 = require_hmac2();
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha2562();
    var sha512_1 = require_sha5122();
    function hash160(buffer) {
      const sha256Hash = (0, sha256_1.sha256)(Uint8Array.from(buffer));
      return Buffer.from((0, ripemd160_1.ripemd160)(sha256Hash));
    }
    exports.hash160 = hash160;
    function hmacSHA512(key, data) {
      return Buffer.from((0, hmac_1.hmac)(sha512_1.sha512, key, data));
    }
    exports.hmacSHA512 = hmacSHA512;
  }
});

// node_modules/bip32/src/testecc.js
var require_testecc = __commonJS({
  "node_modules/bip32/src/testecc.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testEcc = void 0;
    var h11 = (hex) => Buffer.from(hex, "hex");
    function testEcc(ecc) {
      assert(ecc.isPoint(h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
      assert(!ecc.isPoint(h11("030000000000000000000000000000000000000000000000000000000000000005")));
      assert(ecc.isPrivate(h11("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")));
      assert(ecc.isPrivate(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
      assert(!ecc.isPrivate(h11("0000000000000000000000000000000000000000000000000000000000000000")));
      assert(!ecc.isPrivate(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")));
      assert(!ecc.isPrivate(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")));
      assert(Buffer.from(ecc.pointFromScalar(h11("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h11("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")));
      if (ecc.xOnlyPointAddTweak) {
        assert(ecc.xOnlyPointAddTweak(h11("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")) === null);
        let xOnlyRes = ecc.xOnlyPointAddTweak(h11("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"), h11("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac"));
        assert(Buffer.from(xOnlyRes.xOnlyPubkey).equals(h11("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")) && xOnlyRes.parity === 1);
        xOnlyRes = ecc.xOnlyPointAddTweak(h11("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"), h11("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47"));
      }
      assert(Buffer.from(ecc.pointAddScalar(h11("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h11("0000000000000000000000000000000000000000000000000000000000000003"))).equals(h11("02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5")));
      assert(Buffer.from(ecc.privateAdd(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"), h11("0000000000000000000000000000000000000000000000000000000000000002"))).equals(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
      if (ecc.privateNegate) {
        assert(Buffer.from(ecc.privateNegate(h11("0000000000000000000000000000000000000000000000000000000000000001"))).equals(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")));
        assert(Buffer.from(ecc.privateNegate(h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"))).equals(h11("0000000000000000000000000000000000000000000000000000000000000003")));
        assert(Buffer.from(ecc.privateNegate(h11("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af"))).equals(h11("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")));
      }
      assert(Buffer.from(ecc.sign(h11("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140"))).equals(h11("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));
      assert(ecc.verify(h11("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"), h11("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"), h11("54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5")));
      if (ecc.signSchnorr) {
        assert(Buffer.from(ecc.signSchnorr(h11("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h11("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"), h11("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906"))).equals(h11("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
      }
      if (ecc.verifySchnorr) {
        assert(ecc.verifySchnorr(h11("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"), h11("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"), h11("5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7")));
      }
    }
    exports.testEcc = testEcc;
    function assert(bool) {
      if (!bool)
        throw new Error("ecc library invalid");
    }
  }
});

// node_modules/@scure/base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@scure/base/lib/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bytes = exports.stringToBytes = exports.str = exports.bytesToString = exports.hex = exports.utf8 = exports.bech32m = exports.bech32 = exports.base58check = exports.createBase58check = exports.base58xmr = exports.base58xrp = exports.base58flickr = exports.base58 = exports.base64urlnopad = exports.base64url = exports.base64nopad = exports.base64 = exports.base32crockford = exports.base32hexnopad = exports.base32hex = exports.base32nopad = exports.base32 = exports.base16 = exports.utils = exports.assertNumber = void 0;
    function assertNumber(n13) {
      if (!Number.isSafeInteger(n13))
        throw new Error(`Wrong integer: ${n13}`);
    }
    exports.assertNumber = assertNumber;
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    function chain(...args) {
      const id = (a24) => a24;
      const wrap = (a24, b10) => (c10) => a24(b10(c10));
      const encode = args.map((x15) => x15.encode).reduceRight(wrap, id);
      const decode = args.map((x15) => x15.decode).reduce(wrap, id);
      return { encode, decode };
    }
    function alphabet(alphabet2) {
      return {
        encode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("alphabet.encode input should be an array of numbers");
          return digits.map((i18) => {
            assertNumber(i18);
            if (i18 < 0 || i18 >= alphabet2.length)
              throw new Error(`Digit index outside alphabet: ${i18} (alphabet: ${alphabet2.length})`);
            return alphabet2[i18];
          });
        },
        decode: (input) => {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("alphabet.decode input should be array of strings");
          return input.map((letter) => {
            if (typeof letter !== "string")
              throw new Error(`alphabet.decode: not string element=${letter}`);
            const index = alphabet2.indexOf(letter);
            if (index === -1)
              throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
            return index;
          });
        }
      };
    }
    function join2(separator = "") {
      if (typeof separator !== "string")
        throw new Error("join separator should be string");
      return {
        encode: (from) => {
          if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
            throw new Error("join.encode input should be array of strings");
          for (let i18 of from)
            if (typeof i18 !== "string")
              throw new Error(`join.encode: non-string input=${i18}`);
          return from.join(separator);
        },
        decode: (to) => {
          if (typeof to !== "string")
            throw new Error("join.decode input should be string");
          return to.split(separator);
        }
      };
    }
    function padding(bits, chr = "=") {
      assertNumber(bits);
      if (typeof chr !== "string")
        throw new Error("padding chr should be string");
      return {
        encode(data) {
          if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i18 of data)
            if (typeof i18 !== "string")
              throw new Error(`padding.encode: non-string input=${i18}`);
          while (data.length * bits % 8)
            data.push(chr);
          return data;
        },
        decode(input) {
          if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
            throw new Error("padding.encode input should be array of strings");
          for (let i18 of input)
            if (typeof i18 !== "string")
              throw new Error(`padding.decode: non-string input=${i18}`);
          let end = input.length;
          if (end * bits % 8)
            throw new Error("Invalid padding: string should have whole number of bytes");
          for (; end > 0 && input[end - 1] === chr; end--) {
            if (!((end - 1) * bits % 8))
              throw new Error("Invalid padding: string has too much padding");
          }
          return input.slice(0, end);
        }
      };
    }
    function normalize(fn) {
      if (typeof fn !== "function")
        throw new Error("normalize fn should be function");
      return { encode: (from) => from, decode: (to) => fn(to) };
    }
    function convertRadix(data, from, to) {
      if (from < 2)
        throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
      if (to < 2)
        throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
      if (!Array.isArray(data))
        throw new Error("convertRadix: data should be array");
      if (!data.length)
        return [];
      let pos = 0;
      const res = [];
      const digits = Array.from(data);
      digits.forEach((d20) => {
        assertNumber(d20);
        if (d20 < 0 || d20 >= from)
          throw new Error(`Wrong integer: ${d20}`);
      });
      while (true) {
        let carry = 0;
        let done = true;
        for (let i18 = pos; i18 < digits.length; i18++) {
          const digit = digits[i18];
          const digitBase = from * carry + digit;
          if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
            throw new Error("convertRadix: carry overflow");
          }
          carry = digitBase % to;
          const rounded = Math.floor(digitBase / to);
          digits[i18] = rounded;
          if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
            throw new Error("convertRadix: carry overflow");
          if (!done)
            continue;
          else if (!rounded)
            pos = i18;
          else
            done = false;
        }
        res.push(carry);
        if (done)
          break;
      }
      for (let i18 = 0; i18 < data.length - 1 && data[i18] === 0; i18++)
        res.push(0);
      return res.reverse();
    }
    var gcd = (a24, b10) => !b10 ? a24 : gcd(b10, a24 % b10);
    var radix2carry = (from, to) => from + (to - gcd(from, to));
    function convertRadix2(data, from, to, padding2) {
      if (!Array.isArray(data))
        throw new Error("convertRadix2: data should be array");
      if (from <= 0 || from > 32)
        throw new Error(`convertRadix2: wrong from=${from}`);
      if (to <= 0 || to > 32)
        throw new Error(`convertRadix2: wrong to=${to}`);
      if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
      }
      let carry = 0;
      let pos = 0;
      const mask = 2 ** to - 1;
      const res = [];
      for (const n13 of data) {
        assertNumber(n13);
        if (n13 >= 2 ** from)
          throw new Error(`convertRadix2: invalid data word=${n13} from=${from}`);
        carry = carry << from | n13;
        if (pos + from > 32)
          throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for (; pos >= to; pos -= to)
          res.push((carry >> pos - to & mask) >>> 0);
        carry &= 2 ** pos - 1;
      }
      carry = carry << to - pos & mask;
      if (!padding2 && pos >= from)
        throw new Error("Excess padding");
      if (!padding2 && carry)
        throw new Error(`Non-zero padding: ${carry}`);
      if (padding2 && pos > 0)
        res.push(carry >>> 0);
      return res;
    }
    function radix(num) {
      assertNumber(num);
      return {
        encode: (bytes) => {
          if (!isBytes2(bytes))
            throw new Error("radix.encode input should be Uint8Array");
          return convertRadix(Array.from(bytes), 2 ** 8, num);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix.decode input should be array of numbers");
          return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
        }
      };
    }
    function radix2(bits, revPadding = false) {
      assertNumber(bits);
      if (bits <= 0 || bits > 32)
        throw new Error("radix2: bits should be in (0..32]");
      if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
        throw new Error("radix2: carry overflow");
      return {
        encode: (bytes) => {
          if (!isBytes2(bytes))
            throw new Error("radix2.encode input should be Uint8Array");
          return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits) => {
          if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
            throw new Error("radix2.decode input should be array of numbers");
          return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
      };
    }
    function unsafeWrapper(fn) {
      if (typeof fn !== "function")
        throw new Error("unsafeWrapper fn should be function");
      return function(...args) {
        try {
          return fn.apply(null, args);
        } catch (e17) {
        }
      };
    }
    function checksum(len, fn) {
      assertNumber(len);
      if (typeof fn !== "function")
        throw new Error("checksum fn should be function");
      return {
        encode(data) {
          if (!isBytes2(data))
            throw new Error("checksum.encode: input should be Uint8Array");
          const checksum2 = fn(data).slice(0, len);
          const res = new Uint8Array(data.length + len);
          res.set(data);
          res.set(checksum2, data.length);
          return res;
        },
        decode(data) {
          if (!isBytes2(data))
            throw new Error("checksum.decode: input should be Uint8Array");
          const payload = data.slice(0, -len);
          const newChecksum = fn(payload).slice(0, len);
          const oldChecksum = data.slice(-len);
          for (let i18 = 0; i18 < len; i18++)
            if (newChecksum[i18] !== oldChecksum[i18])
              throw new Error("Invalid checksum");
          return payload;
        }
      };
    }
    exports.utils = {
      alphabet,
      chain,
      checksum,
      convertRadix,
      convertRadix2,
      radix,
      radix2,
      join: join2,
      padding
    };
    exports.base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join2(""));
    exports.base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join2(""));
    exports.base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join2(""));
    exports.base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join2(""));
    exports.base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join2(""));
    exports.base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join2(""), normalize((s15) => s15.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
    exports.base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join2(""));
    exports.base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join2(""));
    exports.base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join2(""));
    exports.base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join2(""));
    var genBase58 = (abc) => chain(radix(58), alphabet(abc), join2(""));
    exports.base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    exports.base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
    exports.base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
    var XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];
    exports.base58xmr = {
      encode(data) {
        let res = "";
        for (let i18 = 0; i18 < data.length; i18 += 8) {
          const block = data.subarray(i18, i18 + 8);
          res += exports.base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], "1");
        }
        return res;
      },
      decode(str) {
        let res = [];
        for (let i18 = 0; i18 < str.length; i18 += 11) {
          const slice2 = str.slice(i18, i18 + 11);
          const blockLen = XMR_BLOCK_LEN.indexOf(slice2.length);
          const block = exports.base58.decode(slice2);
          for (let j6 = 0; j6 < block.length - blockLen; j6++) {
            if (block[j6] !== 0)
              throw new Error("base58xmr: wrong padding");
          }
          res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
      }
    };
    var createBase58check = (sha2563) => chain(checksum(4, (data) => sha2563(sha2563(data))), exports.base58);
    exports.createBase58check = createBase58check;
    exports.base58check = exports.createBase58check;
    var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join2(""));
    var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
    function bech32Polymod(pre) {
      const b10 = pre >> 25;
      let chk = (pre & 33554431) << 5;
      for (let i18 = 0; i18 < POLYMOD_GENERATORS.length; i18++) {
        if ((b10 >> i18 & 1) === 1)
          chk ^= POLYMOD_GENERATORS[i18];
      }
      return chk;
    }
    function bechChecksum(prefix, words, encodingConst = 1) {
      const len = prefix.length;
      let chk = 1;
      for (let i18 = 0; i18 < len; i18++) {
        const c10 = prefix.charCodeAt(i18);
        if (c10 < 33 || c10 > 126)
          throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c10 >> 5;
      }
      chk = bech32Polymod(chk);
      for (let i18 = 0; i18 < len; i18++)
        chk = bech32Polymod(chk) ^ prefix.charCodeAt(i18) & 31;
      for (let v8 of words)
        chk = bech32Polymod(chk) ^ v8;
      for (let i18 = 0; i18 < 6; i18++)
        chk = bech32Polymod(chk);
      chk ^= encodingConst;
      return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
    }
    function genBech32(encoding) {
      const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
      const _words = radix2(5);
      const fromWords = _words.decode;
      const toWords = _words.encode;
      const fromWordsUnsafe = unsafeWrapper(fromWords);
      function encode(prefix, words, limit = 90) {
        if (typeof prefix !== "string")
          throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
        if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
          throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
        if (prefix.length === 0)
          throw new TypeError(`Invalid prefix length ${prefix.length}`);
        const actualLength = prefix.length + 7 + words.length;
        if (limit !== false && actualLength > limit)
          throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
      }
      function decode(str, limit = 90) {
        if (typeof str !== "string")
          throw new Error(`bech32.decode input should be string, not ${typeof str}`);
        if (str.length < 8 || limit !== false && str.length > limit)
          throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase())
          throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf("1");
        if (sepIndex === 0 || sepIndex === -1)
          throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6)
          throw new Error("Data must be at least 6 characters long");
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum))
          throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return { prefix, words };
      }
      const decodeUnsafe = unsafeWrapper(decode);
      function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return { prefix, words, bytes: fromWords(words) };
      }
      return { encode, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
    }
    exports.bech32 = genBech32("bech32");
    exports.bech32m = genBech32("bech32m");
    exports.utf8 = {
      encode: (data) => new TextDecoder().decode(data),
      decode: (str) => new TextEncoder().encode(str)
    };
    exports.hex = chain(radix2(4), alphabet("0123456789abcdef"), join2(""), normalize((s15) => {
      if (typeof s15 !== "string" || s15.length % 2)
        throw new TypeError(`hex.decode: expected string, got ${typeof s15} with length ${s15.length}`);
      return s15.toLowerCase();
    }));
    var CODERS = {
      utf8: exports.utf8,
      hex: exports.hex,
      base16: exports.base16,
      base32: exports.base32,
      base64: exports.base64,
      base64url: exports.base64url,
      base58: exports.base58,
      base58xmr: exports.base58xmr
    };
    var coderTypeError = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
    var bytesToString2 = (type, bytes) => {
      if (typeof type !== "string" || !CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (!isBytes2(bytes))
        throw new TypeError("bytesToString() expects Uint8Array");
      return CODERS[type].encode(bytes);
    };
    exports.bytesToString = bytesToString2;
    exports.str = exports.bytesToString;
    var stringToBytes2 = (type, str) => {
      if (!CODERS.hasOwnProperty(type))
        throw new TypeError(coderTypeError);
      if (typeof str !== "string")
        throw new TypeError("stringToBytes() expects string");
      return CODERS[type].decode(str);
    };
    exports.stringToBytes = stringToBytes2;
    exports.bytes = exports.stringToBytes;
  }
});

// node_modules/typeforce/native.js
var require_native = __commonJS({
  "node_modules/typeforce/native.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var types = {
      Array: function(value) {
        return value !== null && value !== void 0 && value.constructor === Array;
      },
      Boolean: function(value) {
        return typeof value === "boolean";
      },
      Function: function(value) {
        return typeof value === "function";
      },
      Nil: function(value) {
        return value === void 0 || value === null;
      },
      Number: function(value) {
        return typeof value === "number";
      },
      Object: function(value) {
        return typeof value === "object";
      },
      String: function(value) {
        return typeof value === "string";
      },
      "": function() {
        return true;
      }
    };
    types.Null = types.Nil;
    for (typeName in types) {
      types[typeName].toJSON = function(t12) {
        return t12;
      }.bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// node_modules/typeforce/errors.js
var require_errors = __commonJS({
  "node_modules/typeforce/errors.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var native = require_native();
    function getTypeName(fn) {
      return fn.name || fn.toString().match(/function (.*?)\s*\(/)[1];
    }
    function getValueTypeName(value) {
      return native.Nil(value) ? "" : getTypeName(value.constructor);
    }
    function getValue(value) {
      if (native.Function(value)) return "";
      if (native.String(value)) return JSON.stringify(value);
      if (value && native.Object(value)) return "";
      return value;
    }
    function captureStackTrace(e17, t12) {
      if (Error.captureStackTrace) {
        Error.captureStackTrace(e17, t12);
      }
    }
    function tfJSON(type) {
      if (native.Function(type)) return type.toJSON ? type.toJSON() : getTypeName(type);
      if (native.Array(type)) return "Array";
      if (type && native.Object(type)) return "Object";
      return type !== void 0 ? type : "";
    }
    function tfErrorString(type, value, valueTypeName) {
      var valueJson = getValue(value);
      return "Expected " + tfJSON(type) + ", got" + (valueTypeName !== "" ? " " + valueTypeName : "") + (valueJson !== "" ? " " + valueJson : "");
    }
    function TfTypeError(type, value, valueTypeName) {
      valueTypeName = valueTypeName || getValueTypeName(value);
      this.message = tfErrorString(type, value, valueTypeName);
      captureStackTrace(this, TfTypeError);
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfTypeError.prototype = Object.create(Error.prototype);
    TfTypeError.prototype.constructor = TfTypeError;
    function tfPropertyErrorString(type, label, name, value, valueTypeName) {
      var description = '" of type ';
      if (label === "key") description = '" with key type ';
      return tfErrorString('property "' + tfJSON(name) + description + tfJSON(type), value, valueTypeName);
    }
    function TfPropertyTypeError(type, property, label, value, valueTypeName) {
      if (type) {
        valueTypeName = valueTypeName || getValueTypeName(value);
        this.message = tfPropertyErrorString(type, label, property, value, valueTypeName);
      } else {
        this.message = 'Unexpected property "' + property + '"';
      }
      captureStackTrace(this, TfTypeError);
      this.__label = label;
      this.__property = property;
      this.__type = type;
      this.__value = value;
      this.__valueTypeName = valueTypeName;
    }
    TfPropertyTypeError.prototype = Object.create(Error.prototype);
    TfPropertyTypeError.prototype.constructor = TfTypeError;
    function tfCustomError(expected, actual) {
      return new TfTypeError(expected, {}, actual);
    }
    function tfSubError(e17, property, label) {
      if (e17 instanceof TfPropertyTypeError) {
        property = property + "." + e17.__property;
        e17 = new TfPropertyTypeError(
          e17.__type,
          property,
          e17.__label,
          e17.__value,
          e17.__valueTypeName
        );
      } else if (e17 instanceof TfTypeError) {
        e17 = new TfPropertyTypeError(
          e17.__type,
          property,
          label,
          e17.__value,
          e17.__valueTypeName
        );
      }
      captureStackTrace(e17);
      return e17;
    }
    module.exports = {
      TfTypeError,
      TfPropertyTypeError,
      tfCustomError,
      tfSubError,
      tfJSON,
      getValueTypeName
    };
  }
});

// node_modules/typeforce/extra.js
var require_extra = __commonJS({
  "node_modules/typeforce/extra.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var NATIVE = require_native();
    var ERRORS = require_errors();
    function _Buffer(value) {
      return Buffer.isBuffer(value);
    }
    function Hex(value) {
      return typeof value === "string" && /^([0-9a-f]{2})+$/i.test(value);
    }
    function _LengthN(type, length) {
      var name = type.toJSON();
      function Length(value) {
        if (!type(value)) return false;
        if (value.length === length) return true;
        throw ERRORS.tfCustomError(name + "(Length: " + length + ")", name + "(Length: " + value.length + ")");
      }
      Length.toJSON = function() {
        return name;
      };
      return Length;
    }
    var _ArrayN = _LengthN.bind(null, NATIVE.Array);
    var _BufferN = _LengthN.bind(null, _Buffer);
    var _HexN = _LengthN.bind(null, Hex);
    var _StringN = _LengthN.bind(null, NATIVE.String);
    function Range(a24, b10, f17) {
      f17 = f17 || NATIVE.Number;
      function _range(value, strict) {
        return f17(value, strict) && value > a24 && value < b10;
      }
      _range.toJSON = function() {
        return `${f17.toJSON()} between [${a24}, ${b10}]`;
      };
      return _range;
    }
    var INT53_MAX = Math.pow(2, 53) - 1;
    function Finite(value) {
      return typeof value === "number" && isFinite(value);
    }
    function Int8(value) {
      return value << 24 >> 24 === value;
    }
    function Int16(value) {
      return value << 16 >> 16 === value;
    }
    function Int32(value) {
      return (value | 0) === value;
    }
    function Int53(value) {
      return typeof value === "number" && value >= -INT53_MAX && value <= INT53_MAX && Math.floor(value) === value;
    }
    function UInt8(value) {
      return (value & 255) === value;
    }
    function UInt16(value) {
      return (value & 65535) === value;
    }
    function UInt32(value) {
      return value >>> 0 === value;
    }
    function UInt53(value) {
      return typeof value === "number" && value >= 0 && value <= INT53_MAX && Math.floor(value) === value;
    }
    var types = {
      ArrayN: _ArrayN,
      Buffer: _Buffer,
      BufferN: _BufferN,
      Finite,
      Hex,
      HexN: _HexN,
      Int8,
      Int16,
      Int32,
      Int53,
      Range,
      StringN: _StringN,
      UInt8,
      UInt16,
      UInt32,
      UInt53
    };
    for (typeName in types) {
      types[typeName].toJSON = function(t12) {
        return t12;
      }.bind(null, typeName);
    }
    var typeName;
    module.exports = types;
  }
});

// node_modules/typeforce/index.js
var require_typeforce = __commonJS({
  "node_modules/typeforce/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var ERRORS = require_errors();
    var NATIVE = require_native();
    var tfJSON = ERRORS.tfJSON;
    var TfTypeError = ERRORS.TfTypeError;
    var TfPropertyTypeError = ERRORS.TfPropertyTypeError;
    var tfSubError = ERRORS.tfSubError;
    var getValueTypeName = ERRORS.getValueTypeName;
    var TYPES = {
      arrayOf: function arrayOf(type, options) {
        type = compile(type);
        options = options || {};
        function _arrayOf(array2, strict) {
          if (!NATIVE.Array(array2)) return false;
          if (NATIVE.Nil(array2)) return false;
          if (options.minLength !== void 0 && array2.length < options.minLength) return false;
          if (options.maxLength !== void 0 && array2.length > options.maxLength) return false;
          if (options.length !== void 0 && array2.length !== options.length) return false;
          return array2.every(function(value, i18) {
            try {
              return typeforce(type, value, strict);
            } catch (e17) {
              throw tfSubError(e17, i18);
            }
          });
        }
        _arrayOf.toJSON = function() {
          var str = "[" + tfJSON(type) + "]";
          if (options.length !== void 0) {
            str += "{" + options.length + "}";
          } else if (options.minLength !== void 0 || options.maxLength !== void 0) {
            str += "{" + (options.minLength === void 0 ? 0 : options.minLength) + "," + (options.maxLength === void 0 ? Infinity : options.maxLength) + "}";
          }
          return str;
        };
        return _arrayOf;
      },
      maybe: function maybe(type) {
        type = compile(type);
        function _maybe(value, strict) {
          return NATIVE.Nil(value) || type(value, strict, maybe);
        }
        _maybe.toJSON = function() {
          return "?" + tfJSON(type);
        };
        return _maybe;
      },
      map: function map(propertyType, propertyKeyType) {
        propertyType = compile(propertyType);
        if (propertyKeyType) propertyKeyType = compile(propertyKeyType);
        function _map(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          for (var propertyName in value) {
            try {
              if (propertyKeyType) {
                typeforce(propertyKeyType, propertyName, strict);
              }
            } catch (e17) {
              throw tfSubError(e17, propertyName, "key");
            }
            try {
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            } catch (e17) {
              throw tfSubError(e17, propertyName);
            }
          }
          return true;
        }
        if (propertyKeyType) {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyKeyType) + ": " + tfJSON(propertyType) + "}";
          };
        } else {
          _map.toJSON = function() {
            return "{" + tfJSON(propertyType) + "}";
          };
        }
        return _map;
      },
      object: function object2(uncompiled) {
        var type = {};
        for (var typePropertyName in uncompiled) {
          type[typePropertyName] = compile(uncompiled[typePropertyName]);
        }
        function _object(value, strict) {
          if (!NATIVE.Object(value)) return false;
          if (NATIVE.Nil(value)) return false;
          var propertyName;
          try {
            for (propertyName in type) {
              var propertyType = type[propertyName];
              var propertyValue = value[propertyName];
              typeforce(propertyType, propertyValue, strict);
            }
          } catch (e17) {
            throw tfSubError(e17, propertyName);
          }
          if (strict) {
            for (propertyName in value) {
              if (type[propertyName]) continue;
              throw new TfPropertyTypeError(void 0, propertyName);
            }
          }
          return true;
        }
        _object.toJSON = function() {
          return tfJSON(type);
        };
        return _object;
      },
      anyOf: function anyOf() {
        var types = [].slice.call(arguments).map(compile);
        function _anyOf(value, strict) {
          return types.some(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e17) {
              return false;
            }
          });
        }
        _anyOf.toJSON = function() {
          return types.map(tfJSON).join("|");
        };
        return _anyOf;
      },
      allOf: function allOf() {
        var types = [].slice.call(arguments).map(compile);
        function _allOf(value, strict) {
          return types.every(function(type) {
            try {
              return typeforce(type, value, strict);
            } catch (e17) {
              return false;
            }
          });
        }
        _allOf.toJSON = function() {
          return types.map(tfJSON).join(" & ");
        };
        return _allOf;
      },
      quacksLike: function quacksLike(type) {
        function _quacksLike(value) {
          return type === getValueTypeName(value);
        }
        _quacksLike.toJSON = function() {
          return type;
        };
        return _quacksLike;
      },
      tuple: function tuple2() {
        var types = [].slice.call(arguments).map(compile);
        function _tuple(values, strict) {
          if (NATIVE.Nil(values)) return false;
          if (NATIVE.Nil(values.length)) return false;
          if (strict && values.length !== types.length) return false;
          return types.every(function(type, i18) {
            try {
              return typeforce(type, values[i18], strict);
            } catch (e17) {
              throw tfSubError(e17, i18);
            }
          });
        }
        _tuple.toJSON = function() {
          return "(" + types.map(tfJSON).join(", ") + ")";
        };
        return _tuple;
      },
      value: function value(expected) {
        function _value(actual) {
          return actual === expected;
        }
        _value.toJSON = function() {
          return expected;
        };
        return _value;
      }
    };
    TYPES.oneOf = TYPES.anyOf;
    function compile(type) {
      if (NATIVE.String(type)) {
        if (type[0] === "?") return TYPES.maybe(type.slice(1));
        return NATIVE[type] || TYPES.quacksLike(type);
      } else if (type && NATIVE.Object(type)) {
        if (NATIVE.Array(type)) {
          if (type.length !== 1) throw new TypeError("Expected compile() parameter of type Array of length 1");
          return TYPES.arrayOf(type[0]);
        }
        return TYPES.object(type);
      } else if (NATIVE.Function(type)) {
        return type;
      }
      return TYPES.value(type);
    }
    function typeforce(type, value, strict, surrogate) {
      if (NATIVE.Function(type)) {
        if (type(value, strict)) return true;
        throw new TfTypeError(surrogate || type, value);
      }
      return typeforce(compile(type), value, strict);
    }
    for (typeName in NATIVE) {
      typeforce[typeName] = NATIVE[typeName];
    }
    var typeName;
    for (typeName in TYPES) {
      typeforce[typeName] = TYPES[typeName];
    }
    var EXTRA = require_extra();
    for (typeName in EXTRA) {
      typeforce[typeName] = EXTRA[typeName];
    }
    typeforce.compile = compile;
    typeforce.TfTypeError = TfTypeError;
    typeforce.TfPropertyTypeError = TfPropertyTypeError;
    module.exports = typeforce;
  }
});

// node_modules/wif/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js
var require_src2 = __commonJS({
  "node_modules/wif/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var _Buffer = require_safe_buffer().Buffer;
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j6 = 0; j6 < BASE_MAP.length; j6++) {
        BASE_MAP[j6] = 255;
      }
      for (var i18 = 0; i18 < ALPHABET.length; i18++) {
        var x15 = ALPHABET.charAt(i18);
        var xc = x15.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x15 + " is ambiguous");
        }
        BASE_MAP[xc] = i18;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (Array.isArray(source) || source instanceof Uint8Array) {
          source = _Buffer.from(source);
        }
        if (!_Buffer.isBuffer(source)) {
          throw new TypeError("Expected Buffer");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size2);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i19 = 0;
          for (var it1 = size2 - 1; (carry !== 0 || i19 < length) && it1 !== -1; it1--, i19++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i19;
          pbegin++;
        }
        var it2 = size2 - length;
        while (it2 !== size2 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size2; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return _Buffer.alloc(0);
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size2);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i19 = 0;
          for (var it3 = size2 - 1; (carry !== 0 || i19 < length) && it3 !== -1; it3--, i19++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i19;
          psz++;
        }
        var it4 = size2 - length;
        while (it4 !== size2 && b256[it4] === 0) {
          it4++;
        }
        var vch = _Buffer.allocUnsafe(zeroes + (size2 - it4));
        vch.fill(0, 0, zeroes);
        var j7 = zeroes;
        while (it4 !== size2) {
          vch[j7++] = b256[it4++];
        }
        return vch;
      }
      function decode(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/wif/node_modules/bs58check/node_modules/bs58/index.js
var require_bs58 = __commonJS({
  "node_modules/wif/node_modules/bs58check/node_modules/bs58/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var basex = require_src2();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/wif/node_modules/bs58check/base.js
var require_base = __commonJS({
  "node_modules/wif/node_modules/bs58check/base.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var base58 = require_bs58();
    var Buffer2 = require_safe_buffer().Buffer;
    module.exports = function(checksumFn) {
      function encode(payload) {
        var checksum = checksumFn(payload);
        return base58.encode(Buffer2.concat([
          payload,
          checksum
        ], payload.length + 4));
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string2) {
        var buffer = base58.decodeUnsafe(string2);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode(string2) {
        var buffer = base58.decode(string2);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode,
        decode,
        decodeUnsafe
      };
    };
  }
});

// node_modules/wif/node_modules/bs58check/index.js
var require_bs58check = __commonJS({
  "node_modules/wif/node_modules/bs58check/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var createHash = require_browser();
    var bs58checkBase = require_base();
    function sha256x2(buffer) {
      var tmp = createHash("sha256").update(buffer).digest();
      return createHash("sha256").update(tmp).digest();
    }
    module.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/wif/index.js
var require_wif = __commonJS({
  "node_modules/wif/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var bs58check = require_bs58check();
    function decodeRaw(buffer, version) {
      if (version !== void 0 && buffer[0] !== version) throw new Error("Invalid network version");
      if (buffer.length === 33) {
        return {
          version: buffer[0],
          privateKey: buffer.slice(1, 33),
          compressed: false
        };
      }
      if (buffer.length !== 34) throw new Error("Invalid WIF length");
      if (buffer[33] !== 1) throw new Error("Invalid compression flag");
      return {
        version: buffer[0],
        privateKey: buffer.slice(1, 33),
        compressed: true
      };
    }
    function encodeRaw(version, privateKey, compressed) {
      var result = new Buffer(compressed ? 34 : 33);
      result.writeUInt8(version, 0);
      privateKey.copy(result, 1);
      if (compressed) {
        result[33] = 1;
      }
      return result;
    }
    function decode(string2, version) {
      return decodeRaw(bs58check.decode(string2), version);
    }
    function encode(version, privateKey, compressed) {
      if (typeof version === "number") return bs58check.encode(encodeRaw(version, privateKey, compressed));
      return bs58check.encode(
        encodeRaw(
          version.version,
          version.privateKey,
          version.compressed
        )
      );
    }
    module.exports = {
      decode,
      decodeRaw,
      encode,
      encodeRaw
    };
  }
});

// node_modules/bip32/src/bip32.js
var require_bip32 = __commonJS({
  "node_modules/bip32/src/bip32.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BIP32Factory = void 0;
    var crypto = require_crypto3();
    var testecc_1 = require_testecc();
    var base_1 = require_lib();
    var sha256_1 = require_sha2562();
    var typeforce = require_typeforce();
    var wif = require_wif();
    var _bs58check = (0, base_1.base58check)(sha256_1.sha256);
    var bs58check = {
      encode: (data) => _bs58check.encode(Uint8Array.from(data)),
      decode: (str) => Buffer.from(_bs58check.decode(str))
    };
    function BIP32Factory(ecc) {
      (0, testecc_1.testEcc)(ecc);
      const UINT256_TYPE = typeforce.BufferN(32);
      const NETWORK_TYPE = typeforce.compile({
        wif: typeforce.UInt8,
        bip32: {
          public: typeforce.UInt32,
          private: typeforce.UInt32
        }
      });
      const BITCOIN = {
        messagePrefix: "Bitcoin Signed Message:\n",
        bech32: "bc",
        bip32: {
          public: 76067358,
          private: 76066276
        },
        pubKeyHash: 0,
        scriptHash: 5,
        wif: 128
      };
      const HIGHEST_BIT = 2147483648;
      const UINT31_MAX = Math.pow(2, 31) - 1;
      function BIP32Path(value) {
        return typeforce.String(value) && value.match(/^(m\/)?(\d+'?\/)*\d+'?$/) !== null;
      }
      function UInt31(value) {
        return typeforce.UInt32(value) && value <= UINT31_MAX;
      }
      function toXOnly(pubKey) {
        return pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
      }
      class Bip32Signer {
        constructor(__D, __Q) {
          this.__D = __D;
          this.__Q = __Q;
          this.lowR = false;
        }
        get publicKey() {
          if (this.__Q === void 0)
            this.__Q = Buffer.from(ecc.pointFromScalar(this.__D, true));
          return this.__Q;
        }
        get privateKey() {
          return this.__D;
        }
        sign(hash, lowR) {
          if (!this.privateKey)
            throw new Error("Missing private key");
          if (lowR === void 0)
            lowR = this.lowR;
          if (lowR === false) {
            return Buffer.from(ecc.sign(hash, this.privateKey));
          } else {
            let sig = Buffer.from(ecc.sign(hash, this.privateKey));
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            while (sig[0] > 127) {
              counter++;
              extraData.writeUIntLE(counter, 0, 6);
              sig = Buffer.from(ecc.sign(hash, this.privateKey, extraData));
            }
            return sig;
          }
        }
        signSchnorr(hash) {
          if (!this.privateKey)
            throw new Error("Missing private key");
          if (!ecc.signSchnorr)
            throw new Error("signSchnorr not supported by ecc library");
          return Buffer.from(ecc.signSchnorr(hash, this.privateKey));
        }
        verify(hash, signature) {
          return ecc.verify(hash, this.publicKey, signature);
        }
        verifySchnorr(hash, signature) {
          if (!ecc.verifySchnorr)
            throw new Error("verifySchnorr not supported by ecc library");
          return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
        }
      }
      class BIP32 extends Bip32Signer {
        constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0) {
          super(__D, __Q);
          this.chainCode = chainCode;
          this.network = network;
          this.__DEPTH = __DEPTH;
          this.__INDEX = __INDEX;
          this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;
          typeforce(NETWORK_TYPE, network);
        }
        get depth() {
          return this.__DEPTH;
        }
        get index() {
          return this.__INDEX;
        }
        get parentFingerprint() {
          return this.__PARENT_FINGERPRINT;
        }
        get identifier() {
          return crypto.hash160(this.publicKey);
        }
        get fingerprint() {
          return this.identifier.slice(0, 4);
        }
        get compressed() {
          return true;
        }
        // Private === not neutered
        // Public === neutered
        isNeutered() {
          return this.__D === void 0;
        }
        neutered() {
          return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);
        }
        toBase58() {
          const network = this.network;
          const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;
          const buffer = Buffer.allocUnsafe(78);
          buffer.writeUInt32BE(version, 0);
          buffer.writeUInt8(this.depth, 4);
          buffer.writeUInt32BE(this.parentFingerprint, 5);
          buffer.writeUInt32BE(this.index, 9);
          this.chainCode.copy(buffer, 13);
          if (!this.isNeutered()) {
            buffer.writeUInt8(0, 45);
            this.privateKey.copy(buffer, 46);
          } else {
            this.publicKey.copy(buffer, 45);
          }
          return bs58check.encode(buffer);
        }
        toWIF() {
          if (!this.privateKey)
            throw new TypeError("Missing private key");
          return wif.encode(this.network.wif, this.privateKey, true);
        }
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions
        derive(index) {
          typeforce(typeforce.UInt32, index);
          const isHardened = index >= HIGHEST_BIT;
          const data = Buffer.allocUnsafe(37);
          if (isHardened) {
            if (this.isNeutered())
              throw new TypeError("Missing private key for hardened child key");
            data[0] = 0;
            this.privateKey.copy(data, 1);
            data.writeUInt32BE(index, 33);
          } else {
            this.publicKey.copy(data, 0);
            data.writeUInt32BE(index, 33);
          }
          const I10 = crypto.hmacSHA512(this.chainCode, data);
          const IL = I10.slice(0, 32);
          const IR = I10.slice(32);
          if (!ecc.isPrivate(IL))
            return this.derive(index + 1);
          let hd;
          if (!this.isNeutered()) {
            const ki = Buffer.from(ecc.privateAdd(this.privateKey, IL));
            if (ki == null)
              return this.derive(index + 1);
            hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
          } else {
            const Ki = Buffer.from(ecc.pointAddScalar(this.publicKey, IL, true));
            if (Ki === null)
              return this.derive(index + 1);
            hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));
          }
          return hd;
        }
        deriveHardened(index) {
          typeforce(UInt31, index);
          return this.derive(index + HIGHEST_BIT);
        }
        derivePath(path) {
          typeforce(BIP32Path, path);
          let splitPath = path.split("/");
          if (splitPath[0] === "m") {
            if (this.parentFingerprint)
              throw new TypeError("Expected master, got child");
            splitPath = splitPath.slice(1);
          }
          return splitPath.reduce((prevHd, indexStr) => {
            let index;
            if (indexStr.slice(-1) === `'`) {
              index = parseInt(indexStr.slice(0, -1), 10);
              return prevHd.deriveHardened(index);
            } else {
              index = parseInt(indexStr, 10);
              return prevHd.derive(index);
            }
          }, this);
        }
        tweak(t12) {
          if (this.privateKey)
            return this.tweakFromPrivateKey(t12);
          return this.tweakFromPublicKey(t12);
        }
        tweakFromPublicKey(t12) {
          const xOnlyPubKey = toXOnly(this.publicKey);
          if (!ecc.xOnlyPointAddTweak)
            throw new Error("xOnlyPointAddTweak not supported by ecc library");
          const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t12);
          if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
            throw new Error("Cannot tweak public key!");
          const parityByte = Buffer.from([
            tweakedPublicKey.parity === 0 ? 2 : 3
          ]);
          const tweakedPublicKeyCompresed = Buffer.concat([
            parityByte,
            tweakedPublicKey.xOnlyPubkey
          ]);
          return new Bip32Signer(void 0, tweakedPublicKeyCompresed);
        }
        tweakFromPrivateKey(t12) {
          const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
          const privateKey = (() => {
            if (!hasOddY)
              return this.privateKey;
            else if (!ecc.privateNegate)
              throw new Error("privateNegate not supported by ecc library");
            else
              return ecc.privateNegate(this.privateKey);
          })();
          const tweakedPrivateKey = ecc.privateAdd(privateKey, t12);
          if (!tweakedPrivateKey)
            throw new Error("Invalid tweaked private key!");
          return new Bip32Signer(Buffer.from(tweakedPrivateKey), void 0);
        }
      }
      function fromBase58(inString, network) {
        const buffer = bs58check.decode(inString);
        if (buffer.length !== 78)
          throw new TypeError("Invalid buffer length");
        network = network || BITCOIN;
        const version = buffer.readUInt32BE(0);
        if (version !== network.bip32.private && version !== network.bip32.public)
          throw new TypeError("Invalid network version");
        const depth = buffer[4];
        const parentFingerprint = buffer.readUInt32BE(5);
        if (depth === 0) {
          if (parentFingerprint !== 0)
            throw new TypeError("Invalid parent fingerprint");
        }
        const index = buffer.readUInt32BE(9);
        if (depth === 0 && index !== 0)
          throw new TypeError("Invalid index");
        const chainCode = buffer.slice(13, 45);
        let hd;
        if (version === network.bip32.private) {
          if (buffer.readUInt8(45) !== 0)
            throw new TypeError("Invalid private key");
          const k9 = buffer.slice(46, 78);
          hd = fromPrivateKeyLocal(k9, chainCode, network, depth, index, parentFingerprint);
        } else {
          const X = buffer.slice(45, 78);
          hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);
        }
        return hd;
      }
      function fromPrivateKey(privateKey, chainCode, network) {
        return fromPrivateKeyLocal(privateKey, chainCode, network);
      }
      function fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {
        typeforce({
          privateKey: UINT256_TYPE,
          chainCode: UINT256_TYPE
        }, { privateKey, chainCode });
        network = network || BITCOIN;
        if (!ecc.isPrivate(privateKey))
          throw new TypeError("Private key not in range [1, n)");
        return new BIP32(privateKey, void 0, chainCode, network, depth, index, parentFingerprint);
      }
      function fromPublicKey(publicKey, chainCode, network) {
        return fromPublicKeyLocal(publicKey, chainCode, network);
      }
      function fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {
        typeforce({
          publicKey: typeforce.BufferN(33),
          chainCode: UINT256_TYPE
        }, { publicKey, chainCode });
        network = network || BITCOIN;
        if (!ecc.isPoint(publicKey))
          throw new TypeError("Point is not on the curve");
        return new BIP32(void 0, publicKey, chainCode, network, depth, index, parentFingerprint);
      }
      function fromSeed(seed, network) {
        typeforce(typeforce.Buffer, seed);
        if (seed.length < 16)
          throw new TypeError("Seed should be at least 128 bits");
        if (seed.length > 64)
          throw new TypeError("Seed should be at most 512 bits");
        network = network || BITCOIN;
        const I10 = crypto.hmacSHA512(Buffer.from("Bitcoin seed", "utf8"), seed);
        const IL = I10.slice(0, 32);
        const IR = I10.slice(32);
        return fromPrivateKey(IL, IR, network);
      }
      return {
        fromSeed,
        fromBase58,
        fromPublicKey,
        fromPrivateKey
      };
    }
    exports.BIP32Factory = BIP32Factory;
  }
});

// node_modules/bip32/src/index.js
var require_src3 = __commonJS({
  "node_modules/bip32/src/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BIP32Factory = exports.default = void 0;
    var bip32_1 = require_bip32();
    Object.defineProperty(exports, "default", { enumerable: true, get: function() {
      return bip32_1.BIP32Factory;
    } });
    Object.defineProperty(exports, "BIP32Factory", { enumerable: true, get: function() {
      return bip32_1.BIP32Factory;
    } });
  }
});

// node_modules/bitcoinjs-lib/src/networks.js
var require_networks = __commonJS({
  "node_modules/bitcoinjs-lib/src/networks.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testnet = exports.regtest = exports.bitcoin = void 0;
    exports.bitcoin = {
      /**
       * The message prefix used for signing Bitcoin messages.
       */
      messagePrefix: "Bitcoin Signed Message:\n",
      /**
       * The Bech32 prefix used for Bitcoin addresses.
       */
      bech32: "bc",
      /**
       * The BIP32 key prefixes for Bitcoin.
       */
      bip32: {
        /**
         * The public key prefix for BIP32 extended public keys.
         */
        public: 76067358,
        /**
         * The private key prefix for BIP32 extended private keys.
         */
        private: 76066276
      },
      /**
       * The prefix for Bitcoin public key hashes.
       */
      pubKeyHash: 0,
      /**
       * The prefix for Bitcoin script hashes.
       */
      scriptHash: 5,
      /**
       * The prefix for Bitcoin Wallet Import Format (WIF) private keys.
       */
      wif: 128
    };
    exports.regtest = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bcrt",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
    exports.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/bitcoinjs-lib/src/bip66.js
var require_bip66 = __commonJS({
  "node_modules/bitcoinjs-lib/src/bip66.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = exports.check = void 0;
    function check(buffer) {
      if (buffer.length < 8) return false;
      if (buffer.length > 72) return false;
      if (buffer[0] !== 48) return false;
      if (buffer[1] !== buffer.length - 2) return false;
      if (buffer[2] !== 2) return false;
      const lenR = buffer[3];
      if (lenR === 0) return false;
      if (5 + lenR >= buffer.length) return false;
      if (buffer[4 + lenR] !== 2) return false;
      const lenS = buffer[5 + lenR];
      if (lenS === 0) return false;
      if (6 + lenR + lenS !== buffer.length) return false;
      if (buffer[4] & 128) return false;
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128)) return false;
      if (buffer[lenR + 6] & 128) return false;
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        return false;
      return true;
    }
    exports.check = check;
    function decode(buffer) {
      if (buffer.length < 8) throw new Error("DER sequence length is too short");
      if (buffer.length > 72) throw new Error("DER sequence length is too long");
      if (buffer[0] !== 48) throw new Error("Expected DER sequence");
      if (buffer[1] !== buffer.length - 2)
        throw new Error("DER sequence length is invalid");
      if (buffer[2] !== 2) throw new Error("Expected DER integer");
      const lenR = buffer[3];
      if (lenR === 0) throw new Error("R length is zero");
      if (5 + lenR >= buffer.length) throw new Error("R length is too long");
      if (buffer[4 + lenR] !== 2) throw new Error("Expected DER integer (2)");
      const lenS = buffer[5 + lenR];
      if (lenS === 0) throw new Error("S length is zero");
      if (6 + lenR + lenS !== buffer.length) throw new Error("S length is invalid");
      if (buffer[4] & 128) throw new Error("R value is negative");
      if (lenR > 1 && buffer[4] === 0 && !(buffer[5] & 128))
        throw new Error("R value excessively padded");
      if (buffer[lenR + 6] & 128) throw new Error("S value is negative");
      if (lenS > 1 && buffer[lenR + 6] === 0 && !(buffer[lenR + 7] & 128))
        throw new Error("S value excessively padded");
      return {
        r: buffer.slice(4, 4 + lenR),
        s: buffer.slice(6 + lenR)
      };
    }
    exports.decode = decode;
    function encode(r13, s15) {
      const lenR = r13.length;
      const lenS = s15.length;
      if (lenR === 0) throw new Error("R length is zero");
      if (lenS === 0) throw new Error("S length is zero");
      if (lenR > 33) throw new Error("R length is too long");
      if (lenS > 33) throw new Error("S length is too long");
      if (r13[0] & 128) throw new Error("R value is negative");
      if (s15[0] & 128) throw new Error("S value is negative");
      if (lenR > 1 && r13[0] === 0 && !(r13[1] & 128))
        throw new Error("R value excessively padded");
      if (lenS > 1 && s15[0] === 0 && !(s15[1] & 128))
        throw new Error("S value excessively padded");
      const signature = Buffer.allocUnsafe(6 + lenR + lenS);
      signature[0] = 48;
      signature[1] = signature.length - 2;
      signature[2] = 2;
      signature[3] = r13.length;
      r13.copy(signature, 4);
      signature[4 + lenR] = 2;
      signature[5 + lenR] = s15.length;
      s15.copy(signature, 6 + lenR);
      return signature;
    }
    exports.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/ops.js
var require_ops = __commonJS({
  "node_modules/bitcoinjs-lib/src/ops.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.REVERSE_OPS = exports.OPS = void 0;
    var OPS = {
      OP_FALSE: 0,
      OP_0: 0,
      OP_PUSHDATA1: 76,
      OP_PUSHDATA2: 77,
      OP_PUSHDATA4: 78,
      OP_1NEGATE: 79,
      OP_RESERVED: 80,
      OP_TRUE: 81,
      OP_1: 81,
      OP_2: 82,
      OP_3: 83,
      OP_4: 84,
      OP_5: 85,
      OP_6: 86,
      OP_7: 87,
      OP_8: 88,
      OP_9: 89,
      OP_10: 90,
      OP_11: 91,
      OP_12: 92,
      OP_13: 93,
      OP_14: 94,
      OP_15: 95,
      OP_16: 96,
      OP_NOP: 97,
      OP_VER: 98,
      OP_IF: 99,
      OP_NOTIF: 100,
      OP_VERIF: 101,
      OP_VERNOTIF: 102,
      OP_ELSE: 103,
      OP_ENDIF: 104,
      OP_VERIFY: 105,
      OP_RETURN: 106,
      OP_TOALTSTACK: 107,
      OP_FROMALTSTACK: 108,
      OP_2DROP: 109,
      OP_2DUP: 110,
      OP_3DUP: 111,
      OP_2OVER: 112,
      OP_2ROT: 113,
      OP_2SWAP: 114,
      OP_IFDUP: 115,
      OP_DEPTH: 116,
      OP_DROP: 117,
      OP_DUP: 118,
      OP_NIP: 119,
      OP_OVER: 120,
      OP_PICK: 121,
      OP_ROLL: 122,
      OP_ROT: 123,
      OP_SWAP: 124,
      OP_TUCK: 125,
      OP_CAT: 126,
      OP_SUBSTR: 127,
      OP_LEFT: 128,
      OP_RIGHT: 129,
      OP_SIZE: 130,
      OP_INVERT: 131,
      OP_AND: 132,
      OP_OR: 133,
      OP_XOR: 134,
      OP_EQUAL: 135,
      OP_EQUALVERIFY: 136,
      OP_RESERVED1: 137,
      OP_RESERVED2: 138,
      OP_1ADD: 139,
      OP_1SUB: 140,
      OP_2MUL: 141,
      OP_2DIV: 142,
      OP_NEGATE: 143,
      OP_ABS: 144,
      OP_NOT: 145,
      OP_0NOTEQUAL: 146,
      OP_ADD: 147,
      OP_SUB: 148,
      OP_MUL: 149,
      OP_DIV: 150,
      OP_MOD: 151,
      OP_LSHIFT: 152,
      OP_RSHIFT: 153,
      OP_BOOLAND: 154,
      OP_BOOLOR: 155,
      OP_NUMEQUAL: 156,
      OP_NUMEQUALVERIFY: 157,
      OP_NUMNOTEQUAL: 158,
      OP_LESSTHAN: 159,
      OP_GREATERTHAN: 160,
      OP_LESSTHANOREQUAL: 161,
      OP_GREATERTHANOREQUAL: 162,
      OP_MIN: 163,
      OP_MAX: 164,
      OP_WITHIN: 165,
      OP_RIPEMD160: 166,
      OP_SHA1: 167,
      OP_SHA256: 168,
      OP_HASH160: 169,
      OP_HASH256: 170,
      OP_CODESEPARATOR: 171,
      OP_CHECKSIG: 172,
      OP_CHECKSIGVERIFY: 173,
      OP_CHECKMULTISIG: 174,
      OP_CHECKMULTISIGVERIFY: 175,
      OP_NOP1: 176,
      OP_NOP2: 177,
      OP_CHECKLOCKTIMEVERIFY: 177,
      OP_NOP3: 178,
      OP_CHECKSEQUENCEVERIFY: 178,
      OP_NOP4: 179,
      OP_NOP5: 180,
      OP_NOP6: 181,
      OP_NOP7: 182,
      OP_NOP8: 183,
      OP_NOP9: 184,
      OP_NOP10: 185,
      OP_CHECKSIGADD: 186,
      OP_PUBKEYHASH: 253,
      OP_PUBKEY: 254,
      OP_INVALIDOPCODE: 255
    };
    exports.OPS = OPS;
    var REVERSE_OPS = {};
    exports.REVERSE_OPS = REVERSE_OPS;
    for (const op of Object.keys(OPS)) {
      const code = OPS[op];
      REVERSE_OPS[code] = op;
    }
  }
});

// node_modules/bitcoinjs-lib/src/push_data.js
var require_push_data = __commonJS({
  "node_modules/bitcoinjs-lib/src/push_data.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decode = exports.encode = exports.encodingLength = void 0;
    var ops_1 = require_ops();
    function encodingLength(i18) {
      return i18 < ops_1.OPS.OP_PUSHDATA1 ? 1 : i18 <= 255 ? 2 : i18 <= 65535 ? 3 : 5;
    }
    exports.encodingLength = encodingLength;
    function encode(buffer, num, offset) {
      const size2 = encodingLength(num);
      if (size2 === 1) {
        buffer.writeUInt8(num, offset);
      } else if (size2 === 2) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);
        buffer.writeUInt8(num, offset + 1);
      } else if (size2 === 3) {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);
        buffer.writeUInt16LE(num, offset + 1);
      } else {
        buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);
        buffer.writeUInt32LE(num, offset + 1);
      }
      return size2;
    }
    exports.encode = encode;
    function decode(buffer, offset) {
      const opcode = buffer.readUInt8(offset);
      let num;
      let size2;
      if (opcode < ops_1.OPS.OP_PUSHDATA1) {
        num = opcode;
        size2 = 1;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {
        if (offset + 2 > buffer.length) return null;
        num = buffer.readUInt8(offset + 1);
        size2 = 2;
      } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {
        if (offset + 3 > buffer.length) return null;
        num = buffer.readUInt16LE(offset + 1);
        size2 = 3;
      } else {
        if (offset + 5 > buffer.length) return null;
        if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error("Unexpected opcode");
        num = buffer.readUInt32LE(offset + 1);
        size2 = 5;
      }
      return {
        opcode,
        number: num,
        size: size2
      };
    }
    exports.decode = decode;
  }
});

// node_modules/bitcoinjs-lib/src/script_number.js
var require_script_number = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_number.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    function decode(buffer, maxLength, minimal) {
      maxLength = maxLength || 4;
      minimal = minimal === void 0 ? true : minimal;
      const length = buffer.length;
      if (length === 0) return 0;
      if (length > maxLength) throw new TypeError("Script number overflow");
      if (minimal) {
        if ((buffer[length - 1] & 127) === 0) {
          if (length <= 1 || (buffer[length - 2] & 128) === 0)
            throw new Error("Non-minimally encoded script number");
        }
      }
      if (length === 5) {
        const a24 = buffer.readUInt32LE(0);
        const b10 = buffer.readUInt8(4);
        if (b10 & 128) return -((b10 & ~128) * 4294967296 + a24);
        return b10 * 4294967296 + a24;
      }
      let result = 0;
      for (let i18 = 0; i18 < length; ++i18) {
        result |= buffer[i18] << 8 * i18;
      }
      if (buffer[length - 1] & 128)
        return -(result & ~(128 << 8 * (length - 1)));
      return result;
    }
    exports.decode = decode;
    function scriptNumSize(i18) {
      return i18 > 2147483647 ? 5 : i18 > 8388607 ? 4 : i18 > 32767 ? 3 : i18 > 127 ? 2 : i18 > 0 ? 1 : 0;
    }
    function encode(_number) {
      let value = Math.abs(_number);
      const size2 = scriptNumSize(value);
      const buffer = Buffer.allocUnsafe(size2);
      const negative = _number < 0;
      for (let i18 = 0; i18 < size2; ++i18) {
        buffer.writeUInt8(value & 255, i18);
        value >>= 8;
      }
      if (buffer[size2 - 1] & 128) {
        buffer.writeUInt8(negative ? 128 : 0, size2 - 1);
      } else if (negative) {
        buffer[size2 - 1] |= 128;
      }
      return buffer;
    }
    exports.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/types.js
var require_types = __commonJS({
  "node_modules/bitcoinjs-lib/src/types.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.oneOf = exports.Null = exports.BufferN = exports.Function = exports.UInt32 = exports.UInt8 = exports.tuple = exports.maybe = exports.Hex = exports.Buffer = exports.String = exports.Boolean = exports.Array = exports.Number = exports.Hash256bit = exports.Hash160bit = exports.Buffer256bit = exports.isTaptree = exports.isTapleaf = exports.TAPLEAF_VERSION_MASK = exports.Satoshi = exports.isPoint = exports.stacksEqual = exports.typeforce = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    exports.typeforce = require_typeforce();
    var ZERO32 = buffer_1.Buffer.alloc(32, 0);
    var EC_P = buffer_1.Buffer.from(
      "fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
      "hex"
    );
    function stacksEqual(a24, b10) {
      if (a24.length !== b10.length) return false;
      return a24.every((x15, i18) => {
        return x15.equals(b10[i18]);
      });
    }
    exports.stacksEqual = stacksEqual;
    function isPoint(p20) {
      if (!buffer_1.Buffer.isBuffer(p20)) return false;
      if (p20.length < 33) return false;
      const t12 = p20[0];
      const x15 = p20.slice(1, 33);
      if (x15.compare(ZERO32) === 0) return false;
      if (x15.compare(EC_P) >= 0) return false;
      if ((t12 === 2 || t12 === 3) && p20.length === 33) {
        return true;
      }
      const y13 = p20.slice(33);
      if (y13.compare(ZERO32) === 0) return false;
      if (y13.compare(EC_P) >= 0) return false;
      if (t12 === 4 && p20.length === 65) return true;
      return false;
    }
    exports.isPoint = isPoint;
    var SATOSHI_MAX = 21 * 1e14;
    function Satoshi(value) {
      return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;
    }
    exports.Satoshi = Satoshi;
    exports.TAPLEAF_VERSION_MASK = 254;
    function isTapleaf(o13) {
      if (!o13 || !("output" in o13)) return false;
      if (!buffer_1.Buffer.isBuffer(o13.output)) return false;
      if (o13.version !== void 0)
        return (o13.version & exports.TAPLEAF_VERSION_MASK) === o13.version;
      return true;
    }
    exports.isTapleaf = isTapleaf;
    function isTaptree(scriptTree) {
      if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);
      if (scriptTree.length !== 2) return false;
      return scriptTree.every((t12) => isTaptree(t12));
    }
    exports.isTaptree = isTaptree;
    exports.Buffer256bit = exports.typeforce.BufferN(32);
    exports.Hash160bit = exports.typeforce.BufferN(20);
    exports.Hash256bit = exports.typeforce.BufferN(32);
    exports.Number = exports.typeforce.Number;
    exports.Array = exports.typeforce.Array;
    exports.Boolean = exports.typeforce.Boolean;
    exports.String = exports.typeforce.String;
    exports.Buffer = exports.typeforce.Buffer;
    exports.Hex = exports.typeforce.Hex;
    exports.maybe = exports.typeforce.maybe;
    exports.tuple = exports.typeforce.tuple;
    exports.UInt8 = exports.typeforce.UInt8;
    exports.UInt32 = exports.typeforce.UInt32;
    exports.Function = exports.typeforce.Function;
    exports.BufferN = exports.typeforce.BufferN;
    exports.Null = exports.typeforce.Null;
    exports.oneOf = exports.typeforce.oneOf;
  }
});

// node_modules/bitcoinjs-lib/src/script_signature.js
var require_script_signature = __commonJS({
  "node_modules/bitcoinjs-lib/src/script_signature.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = exports.decode = void 0;
    var bip66 = require_bip66();
    var script_1 = require_script();
    var types = require_types();
    var { typeforce } = types;
    var ZERO = Buffer.alloc(1, 0);
    function toDER(x15) {
      let i18 = 0;
      while (x15[i18] === 0) ++i18;
      if (i18 === x15.length) return ZERO;
      x15 = x15.slice(i18);
      if (x15[0] & 128) return Buffer.concat([ZERO, x15], 1 + x15.length);
      return x15;
    }
    function fromDER(x15) {
      if (x15[0] === 0) x15 = x15.slice(1);
      const buffer = Buffer.alloc(32, 0);
      const bstart = Math.max(0, 32 - x15.length);
      x15.copy(buffer, bstart);
      return buffer;
    }
    function decode(buffer) {
      const hashType = buffer.readUInt8(buffer.length - 1);
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const decoded = bip66.decode(buffer.slice(0, -1));
      const r13 = fromDER(decoded.r);
      const s15 = fromDER(decoded.s);
      const signature = Buffer.concat([r13, s15], 64);
      return { signature, hashType };
    }
    exports.decode = decode;
    function encode(signature, hashType) {
      typeforce(
        {
          signature: types.BufferN(64),
          hashType: types.UInt8
        },
        { signature, hashType }
      );
      if (!(0, script_1.isDefinedHashType)(hashType)) {
        throw new Error("Invalid hashType " + hashType);
      }
      const hashTypeBuffer = Buffer.allocUnsafe(1);
      hashTypeBuffer.writeUInt8(hashType, 0);
      const r13 = toDER(signature.slice(0, 32));
      const s15 = toDER(signature.slice(32, 64));
      return Buffer.concat([bip66.encode(r13, s15), hashTypeBuffer]);
    }
    exports.encode = encode;
  }
});

// node_modules/bitcoinjs-lib/src/script.js
var require_script = __commonJS({
  "node_modules/bitcoinjs-lib/src/script.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signature = exports.number = exports.isCanonicalScriptSignature = exports.isDefinedHashType = exports.isCanonicalPubKey = exports.toStack = exports.fromASM = exports.toASM = exports.decompile = exports.compile = exports.countNonPushOnlyOPs = exports.isPushOnly = exports.OPS = void 0;
    var bip66 = require_bip66();
    var ops_1 = require_ops();
    Object.defineProperty(exports, "OPS", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var pushdata = require_push_data();
    var scriptNumber = require_script_number();
    var scriptSignature = require_script_signature();
    var types = require_types();
    var { typeforce } = types;
    var OP_INT_BASE = ops_1.OPS.OP_RESERVED;
    function isOPInt(value) {
      return types.Number(value) && (value === ops_1.OPS.OP_0 || value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16 || value === ops_1.OPS.OP_1NEGATE);
    }
    function isPushOnlyChunk(value) {
      return types.Buffer(value) || isOPInt(value);
    }
    function isPushOnly(value) {
      return types.Array(value) && value.every(isPushOnlyChunk);
    }
    exports.isPushOnly = isPushOnly;
    function countNonPushOnlyOPs(value) {
      return value.length - value.filter(isPushOnlyChunk).length;
    }
    exports.countNonPushOnlyOPs = countNonPushOnlyOPs;
    function asMinimalOP(buffer) {
      if (buffer.length === 0) return ops_1.OPS.OP_0;
      if (buffer.length !== 1) return;
      if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];
      if (buffer[0] === 129) return ops_1.OPS.OP_1NEGATE;
    }
    function chunksIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function chunksIsArray(buf) {
      return types.Array(buf);
    }
    function singleChunkIsBuffer(buf) {
      return Buffer.isBuffer(buf);
    }
    function compile(chunks) {
      if (chunksIsBuffer(chunks)) return chunks;
      typeforce(types.Array, chunks);
      const bufferSize = chunks.reduce((accum, chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          if (chunk.length === 1 && asMinimalOP(chunk) !== void 0) {
            return accum + 1;
          }
          return accum + pushdata.encodingLength(chunk.length) + chunk.length;
        }
        return accum + 1;
      }, 0);
      const buffer = Buffer.allocUnsafe(bufferSize);
      let offset = 0;
      chunks.forEach((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const opcode = asMinimalOP(chunk);
          if (opcode !== void 0) {
            buffer.writeUInt8(opcode, offset);
            offset += 1;
            return;
          }
          offset += pushdata.encode(buffer, chunk.length, offset);
          chunk.copy(buffer, offset);
          offset += chunk.length;
        } else {
          buffer.writeUInt8(chunk, offset);
          offset += 1;
        }
      });
      if (offset !== buffer.length) throw new Error("Could not decode chunks");
      return buffer;
    }
    exports.compile = compile;
    function decompile(buffer) {
      if (chunksIsArray(buffer)) return buffer;
      typeforce(types.Buffer, buffer);
      const chunks = [];
      let i18 = 0;
      while (i18 < buffer.length) {
        const opcode = buffer[i18];
        if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {
          const d20 = pushdata.decode(buffer, i18);
          if (d20 === null) return null;
          i18 += d20.size;
          if (i18 + d20.number > buffer.length) return null;
          const data = buffer.slice(i18, i18 + d20.number);
          i18 += d20.number;
          const op = asMinimalOP(data);
          if (op !== void 0) {
            chunks.push(op);
          } else {
            chunks.push(data);
          }
        } else {
          chunks.push(opcode);
          i18 += 1;
        }
      }
      return chunks;
    }
    exports.decompile = decompile;
    function toASM(chunks) {
      if (chunksIsBuffer(chunks)) {
        chunks = decompile(chunks);
      }
      if (!chunks) {
        throw new Error("Could not convert invalid chunks to ASM");
      }
      return chunks.map((chunk) => {
        if (singleChunkIsBuffer(chunk)) {
          const op = asMinimalOP(chunk);
          if (op === void 0) return chunk.toString("hex");
          chunk = op;
        }
        return ops_1.REVERSE_OPS[chunk];
      }).join(" ");
    }
    exports.toASM = toASM;
    function fromASM(asm) {
      typeforce(types.String, asm);
      return compile(
        asm.split(" ").map((chunkStr) => {
          if (ops_1.OPS[chunkStr] !== void 0) return ops_1.OPS[chunkStr];
          typeforce(types.Hex, chunkStr);
          return Buffer.from(chunkStr, "hex");
        })
      );
    }
    exports.fromASM = fromASM;
    function toStack(chunks) {
      chunks = decompile(chunks);
      typeforce(isPushOnly, chunks);
      return chunks.map((op) => {
        if (singleChunkIsBuffer(op)) return op;
        if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);
        return scriptNumber.encode(op - OP_INT_BASE);
      });
    }
    exports.toStack = toStack;
    function isCanonicalPubKey(buffer) {
      return types.isPoint(buffer);
    }
    exports.isCanonicalPubKey = isCanonicalPubKey;
    function isDefinedHashType(hashType) {
      const hashTypeMod = hashType & ~128;
      return hashTypeMod > 0 && hashTypeMod < 4;
    }
    exports.isDefinedHashType = isDefinedHashType;
    function isCanonicalScriptSignature(buffer) {
      if (!Buffer.isBuffer(buffer)) return false;
      if (!isDefinedHashType(buffer[buffer.length - 1])) return false;
      return bip66.check(buffer.slice(0, -1));
    }
    exports.isCanonicalScriptSignature = isCanonicalScriptSignature;
    exports.number = scriptNumber;
    exports.signature = scriptSignature;
  }
});

// node_modules/bitcoinjs-lib/src/payments/lazy.js
var require_lazy = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/lazy.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.value = exports.prop = void 0;
    function prop(object2, name, f17) {
      Object.defineProperty(object2, name, {
        configurable: true,
        enumerable: true,
        get() {
          const _value = f17.call(this);
          this[name] = _value;
          return _value;
        },
        set(_value) {
          Object.defineProperty(this, name, {
            configurable: true,
            enumerable: true,
            value: _value,
            writable: true
          });
        }
      });
    }
    exports.prop = prop;
    function value(f17) {
      let _value;
      return () => {
        if (_value !== void 0) return _value;
        _value = f17();
        return _value;
      };
    }
    exports.value = value;
  }
});

// node_modules/bitcoinjs-lib/src/payments/embed.js
var require_embed = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/embed.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2data = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function p2data(a24, opts) {
      if (!a24.data && !a24.output) throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          data: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a24
      );
      const network = a24.network || networks_1.bitcoin;
      const o13 = { name: "embed", network };
      lazy.prop(o13, "output", () => {
        if (!a24.data) return;
        return bscript.compile([OPS.OP_RETURN].concat(a24.data));
      });
      lazy.prop(o13, "data", () => {
        if (!a24.output) return;
        return bscript.decompile(a24.output).slice(1);
      });
      if (opts.validate) {
        if (a24.output) {
          const chunks = bscript.decompile(a24.output);
          if (chunks[0] !== OPS.OP_RETURN) throw new TypeError("Output is invalid");
          if (!chunks.slice(1).every(types_1.typeforce.Buffer))
            throw new TypeError("Output is invalid");
          if (a24.data && !(0, types_1.stacksEqual)(a24.data, o13.data))
            throw new TypeError("Data mismatch");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2data = p2data;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2ms.js
var require_p2ms = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2ms.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2ms = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    var OP_INT_BASE = OPS.OP_RESERVED;
    function p2ms(a24, opts) {
      if (!a24.input && !a24.output && !(a24.pubkeys && a24.m !== void 0) && !a24.signatures)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      function isAcceptableSignature(x15) {
        return bscript.isCanonicalScriptSignature(x15) || (opts.allowIncomplete && x15 === OPS.OP_0) !== void 0;
      }
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          m: types_1.typeforce.maybe(types_1.typeforce.Number),
          n: types_1.typeforce.maybe(types_1.typeforce.Number),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkeys: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.isPoint)
          ),
          signatures: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(isAcceptableSignature)
          ),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a24
      );
      const network = a24.network || networks_1.bitcoin;
      const o13 = { network };
      let chunks = [];
      let decoded = false;
      function decode(output) {
        if (decoded) return;
        decoded = true;
        chunks = bscript.decompile(output);
        o13.m = chunks[0] - OP_INT_BASE;
        o13.n = chunks[chunks.length - 2] - OP_INT_BASE;
        o13.pubkeys = chunks.slice(1, -2);
      }
      lazy.prop(o13, "output", () => {
        if (!a24.m) return;
        if (!o13.n) return;
        if (!a24.pubkeys) return;
        return bscript.compile(
          [].concat(
            OP_INT_BASE + a24.m,
            a24.pubkeys,
            OP_INT_BASE + o13.n,
            OPS.OP_CHECKMULTISIG
          )
        );
      });
      lazy.prop(o13, "m", () => {
        if (!o13.output) return;
        decode(o13.output);
        return o13.m;
      });
      lazy.prop(o13, "n", () => {
        if (!o13.pubkeys) return;
        return o13.pubkeys.length;
      });
      lazy.prop(o13, "pubkeys", () => {
        if (!a24.output) return;
        decode(a24.output);
        return o13.pubkeys;
      });
      lazy.prop(o13, "signatures", () => {
        if (!a24.input) return;
        return bscript.decompile(a24.input).slice(1);
      });
      lazy.prop(o13, "input", () => {
        if (!a24.signatures) return;
        return bscript.compile([OPS.OP_0].concat(a24.signatures));
      });
      lazy.prop(o13, "witness", () => {
        if (!o13.input) return;
        return [];
      });
      lazy.prop(o13, "name", () => {
        if (!o13.m || !o13.n) return;
        return `p2ms(${o13.m} of ${o13.n})`;
      });
      if (opts.validate) {
        if (a24.output) {
          decode(a24.output);
          if (!types_1.typeforce.Number(chunks[0]))
            throw new TypeError("Output is invalid");
          if (!types_1.typeforce.Number(chunks[chunks.length - 2]))
            throw new TypeError("Output is invalid");
          if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)
            throw new TypeError("Output is invalid");
          if (o13.m <= 0 || o13.n > 16 || o13.m > o13.n || o13.n !== chunks.length - 3)
            throw new TypeError("Output is invalid");
          if (!o13.pubkeys.every((x15) => (0, types_1.isPoint)(x15)))
            throw new TypeError("Output is invalid");
          if (a24.m !== void 0 && a24.m !== o13.m) throw new TypeError("m mismatch");
          if (a24.n !== void 0 && a24.n !== o13.n) throw new TypeError("n mismatch");
          if (a24.pubkeys && !(0, types_1.stacksEqual)(a24.pubkeys, o13.pubkeys))
            throw new TypeError("Pubkeys mismatch");
        }
        if (a24.pubkeys) {
          if (a24.n !== void 0 && a24.n !== a24.pubkeys.length)
            throw new TypeError("Pubkey count mismatch");
          o13.n = a24.pubkeys.length;
          if (o13.n < o13.m) throw new TypeError("Pubkey count cannot be less than m");
        }
        if (a24.signatures) {
          if (a24.signatures.length < o13.m)
            throw new TypeError("Not enough signatures provided");
          if (a24.signatures.length > o13.m)
            throw new TypeError("Too many signatures provided");
        }
        if (a24.input) {
          if (a24.input[0] !== OPS.OP_0) throw new TypeError("Input is invalid");
          if (o13.signatures.length === 0 || !o13.signatures.every(isAcceptableSignature))
            throw new TypeError("Input has invalid signature(s)");
          if (a24.signatures && !(0, types_1.stacksEqual)(a24.signatures, o13.signatures))
            throw new TypeError("Signature mismatch");
          if (a24.m !== void 0 && a24.m !== a24.signatures.length)
            throw new TypeError("Signature count mismatch");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2ms = p2ms;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pk.js
var require_p2pk = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pk.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2pk = void 0;
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var OPS = bscript.OPS;
    function p2pk(a24, opts) {
      if (!a24.input && !a24.output && !a24.pubkey && !a24.input && !a24.signature)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a24
      );
      const _chunks = lazy.value(() => {
        return bscript.decompile(a24.input);
      });
      const network = a24.network || networks_1.bitcoin;
      const o13 = { name: "p2pk", network };
      lazy.prop(o13, "output", () => {
        if (!a24.pubkey) return;
        return bscript.compile([a24.pubkey, OPS.OP_CHECKSIG]);
      });
      lazy.prop(o13, "pubkey", () => {
        if (!a24.output) return;
        return a24.output.slice(1, -1);
      });
      lazy.prop(o13, "signature", () => {
        if (!a24.input) return;
        return _chunks()[0];
      });
      lazy.prop(o13, "input", () => {
        if (!a24.signature) return;
        return bscript.compile([a24.signature]);
      });
      lazy.prop(o13, "witness", () => {
        if (!o13.input) return;
        return [];
      });
      if (opts.validate) {
        if (a24.output) {
          if (a24.output[a24.output.length - 1] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          if (!(0, types_1.isPoint)(o13.pubkey))
            throw new TypeError("Output pubkey is invalid");
          if (a24.pubkey && !a24.pubkey.equals(o13.pubkey))
            throw new TypeError("Pubkey mismatch");
        }
        if (a24.signature) {
          if (a24.input && !a24.input.equals(o13.input))
            throw new TypeError("Signature mismatch");
        }
        if (a24.input) {
          if (_chunks().length !== 1) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(o13.signature))
            throw new TypeError("Input has invalid signature");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2pk = p2pk;
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/_assert.js
var require_assert3 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number2(n13) {
      if (!Number.isSafeInteger(n13) || n13 < 0)
        throw new Error(`positive integer expected, not ${n13}`);
    }
    exports.number = number2;
    function bool(b10) {
      if (typeof b10 !== "boolean")
        throw new Error(`boolean expected, not ${b10}`);
    }
    exports.bool = bool;
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    function bytes(b10, ...lengths) {
      if (!isBytes2(b10))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b10.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b10.length}`);
    }
    exports.bytes = bytes;
    function hash(h11) {
      if (typeof h11 !== "function" || typeof h11.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(h11.outputLen);
      number2(h11.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number: number2, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/crypto.js
var require_crypto4 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/utils.js
var require_utils3 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto4();
    var _assert_js_1 = require_assert3();
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u82;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n13) => n13 : (n13) => (0, exports.byteSwap)(n13);
    function byteSwap32(arr) {
      for (let i18 = 0; i18 < arr.length; i18++) {
        arr[i18] = (0, exports.byteSwap)(arr[i18]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_10, i18) => i18.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i18 = 0; i18 < bytes.length; i18++) {
        hex += hexes[bytes[i18]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes2;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i18 = 0; i18 < iters; i18++) {
        cb(i18);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i18 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        (0, _assert_js_1.bytes)(a24);
        sum += a24.length;
      }
      const res = new Uint8Array(sum);
      for (let i18 = 0, pad2 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        res.set(a24, pad2);
        pad2 += a24.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes2;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/_md.js
var require_md3 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert3();
    var utils_js_1 = require_utils3();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h11 = isLE ? 4 : 0;
      const l23 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h11, wh, isLE);
      view.setUint32(byteOffset + l23, wl, isLE);
    }
    var Chi = (a24, b10, c10) => a24 & b10 ^ ~a24 & c10;
    exports.Chi = Chi;
    var Maj = (a24, b10, c10) => a24 & b10 ^ a24 & c10 ^ b10 & c10;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i18 = pos; i18 < blockLen; i18++)
          buffer[i18] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i18 = 0; i18 < outLen; i18++)
          oview.setUint32(4 * i18, state[i18], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/ripemd160.js
var require_ripemd1602 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _md_js_1 = require_md3();
    var utils_js_1 = require_utils3();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = new Uint8Array(new Array(16).fill(0).map((_10, i18) => i18));
    var Pi = Id.map((i18) => (9 * i18 + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i18 = 0; i18 < 4; i18++)
      for (let j6 of [idxL, idxR])
        j6.push(j6[i18].map((k9) => Rho[k9]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i18) => new Uint8Array(i18));
    var shiftsL = idxL.map((idx, i18) => idx.map((j6) => shifts[i18][j6]));
    var shiftsR = idxR.map((idx, i18) => idx.map((j6) => shifts[i18][j6]));
    var Kl = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function f17(group, x15, y13, z10) {
      if (group === 0)
        return x15 ^ y13 ^ z10;
      else if (group === 1)
        return x15 & y13 | ~x15 & z10;
      else if (group === 2)
        return (x15 | ~y13) ^ z10;
      else if (group === 3)
        return x15 & z10 | y13 & ~z10;
      else
        return x15 ^ (y13 | ~z10);
    }
    var R_BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
        return [h0, h1, h22, h32, h42];
      }
      set(h0, h1, h22, h32, h42) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h22 | 0;
        this.h3 = h32 | 0;
        this.h4 = h42 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          R_BUF[i18] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i18 = 0; i18 < 16; i18++) {
            const tl = (0, utils_js_1.rotl)(al + f17(group, bl, cl, dl) + R_BUF[rl[i18]] + hbl, sl[i18]) + el | 0;
            al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i18 = 0; i18 < 16; i18++) {
            const tr = (0, utils_js_1.rotl)(ar + f17(rGroup, br, cr, dr) + R_BUF[rr[i18]] + hbr, sr[i18]) + er | 0;
            ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        R_BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/sha1.js
var require_sha1 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/sha1.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha1 = void 0;
    var _md_js_1 = require_md3();
    var utils_js_1 = require_utils3();
    var SHA1_IV = new Uint32Array([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
    var SHA1_W = new Uint32Array(80);
    var SHA1 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, false);
        this.A = SHA1_IV[0] | 0;
        this.B = SHA1_IV[1] | 0;
        this.C = SHA1_IV[2] | 0;
        this.D = SHA1_IV[3] | 0;
        this.E = SHA1_IV[4] | 0;
      }
      get() {
        const { A: A13, B: B12, C: C7, D: D7, E: E14 } = this;
        return [A13, B12, C7, D7, E14];
      }
      set(A13, B12, C7, D7, E14) {
        this.A = A13 | 0;
        this.B = B12 | 0;
        this.C = C7 | 0;
        this.D = D7 | 0;
        this.E = E14 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          SHA1_W[i18] = view.getUint32(offset, false);
        for (let i18 = 16; i18 < 80; i18++)
          SHA1_W[i18] = (0, utils_js_1.rotl)(SHA1_W[i18 - 3] ^ SHA1_W[i18 - 8] ^ SHA1_W[i18 - 14] ^ SHA1_W[i18 - 16], 1);
        let { A: A13, B: B12, C: C7, D: D7, E: E14 } = this;
        for (let i18 = 0; i18 < 80; i18++) {
          let F11, K7;
          if (i18 < 20) {
            F11 = (0, _md_js_1.Chi)(B12, C7, D7);
            K7 = 1518500249;
          } else if (i18 < 40) {
            F11 = B12 ^ C7 ^ D7;
            K7 = 1859775393;
          } else if (i18 < 60) {
            F11 = (0, _md_js_1.Maj)(B12, C7, D7);
            K7 = 2400959708;
          } else {
            F11 = B12 ^ C7 ^ D7;
            K7 = 3395469782;
          }
          const T14 = (0, utils_js_1.rotl)(A13, 5) + F11 + E14 + K7 + SHA1_W[i18] | 0;
          E14 = D7;
          D7 = C7;
          C7 = (0, utils_js_1.rotl)(B12, 30);
          B12 = A13;
          A13 = T14;
        }
        A13 = A13 + this.A | 0;
        B12 = B12 + this.B | 0;
        C7 = C7 + this.C | 0;
        D7 = D7 + this.D | 0;
        E14 = E14 + this.E | 0;
        this.set(A13, B12, C7, D7, E14);
      }
      roundClean() {
        SHA1_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    exports.sha1 = (0, utils_js_1.wrapConstructor)(() => new SHA1());
  }
});

// node_modules/bitcoinjs-lib/node_modules/@noble/hashes/sha256.js
var require_sha2563 = __commonJS({
  "node_modules/bitcoinjs-lib/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md3();
    var utils_js_1 = require_utils3();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        return [A13, B12, C7, D7, E14, F11, G6, H7];
      }
      // prettier-ignore
      set(A13, B12, C7, D7, E14, F11, G6, H7) {
        this.A = A13 | 0;
        this.B = B12 | 0;
        this.C = C7 | 0;
        this.D = D7 | 0;
        this.E = E14 | 0;
        this.F = F11 | 0;
        this.G = G6 | 0;
        this.H = H7 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          SHA256_W[i18] = view.getUint32(offset, false);
        for (let i18 = 16; i18 < 64; i18++) {
          const W15 = SHA256_W[i18 - 15];
          const W2 = SHA256_W[i18 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i18] = s1 + SHA256_W[i18 - 7] + s0 + SHA256_W[i18 - 16] | 0;
        }
        let { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        for (let i18 = 0; i18 < 64; i18++) {
          const sigma1 = (0, utils_js_1.rotr)(E14, 6) ^ (0, utils_js_1.rotr)(E14, 11) ^ (0, utils_js_1.rotr)(E14, 25);
          const T1 = H7 + sigma1 + (0, _md_js_1.Chi)(E14, F11, G6) + SHA256_K[i18] + SHA256_W[i18] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A13, 2) ^ (0, utils_js_1.rotr)(A13, 13) ^ (0, utils_js_1.rotr)(A13, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A13, B12, C7) | 0;
          H7 = G6;
          G6 = F11;
          F11 = E14;
          E14 = D7 + T1 | 0;
          D7 = C7;
          C7 = B12;
          B12 = A13;
          A13 = T1 + T22 | 0;
        }
        A13 = A13 + this.A | 0;
        B12 = B12 + this.B | 0;
        C7 = C7 + this.C | 0;
        D7 = D7 + this.D | 0;
        E14 = E14 + this.E | 0;
        F11 = F11 + this.F | 0;
        G6 = G6 + this.G | 0;
        H7 = H7 + this.H | 0;
        this.set(A13, B12, C7, D7, E14, F11, G6, H7);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/bitcoinjs-lib/src/crypto.js
var require_crypto5 = __commonJS({
  "node_modules/bitcoinjs-lib/src/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.taggedHash = exports.TAGGED_HASH_PREFIXES = exports.TAGS = exports.hash256 = exports.hash160 = exports.sha256 = exports.sha1 = exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd1602();
    var sha1_1 = require_sha1();
    var sha256_1 = require_sha2563();
    function ripemd1603(buffer) {
      return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));
    }
    exports.ripemd160 = ripemd1603;
    function sha1(buffer) {
      return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));
    }
    exports.sha1 = sha1;
    function sha2563(buffer) {
      return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));
    }
    exports.sha256 = sha2563;
    function hash160(buffer) {
      return Buffer.from(
        (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports.hash160 = hash160;
    function hash256(buffer) {
      return Buffer.from(
        (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer)))
      );
    }
    exports.hash256 = hash256;
    exports.TAGS = [
      "BIP0340/challenge",
      "BIP0340/aux",
      "BIP0340/nonce",
      "TapLeaf",
      "TapBranch",
      "TapSighash",
      "TapTweak",
      "KeyAgg list",
      "KeyAgg coefficient"
    ];
    exports.TAGGED_HASH_PREFIXES = {
      "BIP0340/challenge": Buffer.from([
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124,
        123,
        181,
        45,
        122,
        159,
        239,
        88,
        50,
        62,
        177,
        191,
        122,
        64,
        125,
        179,
        130,
        210,
        243,
        242,
        216,
        27,
        177,
        34,
        79,
        73,
        254,
        81,
        143,
        109,
        72,
        211,
        124
      ]),
      "BIP0340/aux": Buffer.from([
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144,
        241,
        239,
        78,
        94,
        192,
        99,
        202,
        218,
        109,
        148,
        202,
        250,
        157,
        152,
        126,
        160,
        105,
        38,
        88,
        57,
        236,
        193,
        31,
        151,
        45,
        119,
        165,
        46,
        216,
        193,
        204,
        144
      ]),
      "BIP0340/nonce": Buffer.from([
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47,
        7,
        73,
        119,
        52,
        167,
        155,
        203,
        53,
        91,
        155,
        140,
        125,
        3,
        79,
        18,
        28,
        244,
        52,
        215,
        62,
        247,
        45,
        218,
        25,
        135,
        0,
        97,
        251,
        82,
        191,
        235,
        47
      ]),
      TapLeaf: Buffer.from([
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238,
        174,
        234,
        143,
        220,
        66,
        8,
        152,
        49,
        5,
        115,
        75,
        88,
        8,
        29,
        30,
        38,
        56,
        211,
        95,
        28,
        181,
        64,
        8,
        212,
        211,
        87,
        202,
        3,
        190,
        120,
        233,
        238
      ]),
      TapBranch: Buffer.from([
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21,
        25,
        65,
        161,
        242,
        229,
        110,
        185,
        95,
        162,
        169,
        241,
        148,
        190,
        92,
        1,
        247,
        33,
        111,
        51,
        237,
        130,
        176,
        145,
        70,
        52,
        144,
        208,
        91,
        245,
        22,
        160,
        21
      ]),
      TapSighash: Buffer.from([
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49,
        244,
        10,
        72,
        223,
        75,
        42,
        112,
        200,
        180,
        146,
        75,
        242,
        101,
        70,
        97,
        237,
        61,
        149,
        253,
        102,
        163,
        19,
        235,
        135,
        35,
        117,
        151,
        198,
        40,
        228,
        160,
        49
      ]),
      TapTweak: Buffer.from([
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233,
        232,
        15,
        225,
        99,
        156,
        156,
        160,
        80,
        227,
        175,
        27,
        57,
        193,
        67,
        198,
        62,
        66,
        156,
        188,
        235,
        21,
        217,
        64,
        251,
        181,
        197,
        161,
        244,
        175,
        87,
        197,
        233
      ]),
      "KeyAgg list": Buffer.from([
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240,
        72,
        28,
        151,
        28,
        60,
        11,
        70,
        215,
        240,
        178,
        117,
        174,
        89,
        141,
        78,
        44,
        126,
        215,
        49,
        156,
        89,
        74,
        92,
        110,
        199,
        158,
        160,
        212,
        153,
        2,
        148,
        240
      ]),
      "KeyAgg coefficient": Buffer.from([
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129,
        191,
        201,
        4,
        3,
        77,
        28,
        136,
        232,
        200,
        14,
        34,
        229,
        61,
        36,
        86,
        109,
        100,
        130,
        78,
        214,
        66,
        114,
        129,
        192,
        145,
        0,
        249,
        77,
        205,
        82,
        201,
        129
      ])
    };
    function taggedHash(prefix, data) {
      return sha2563(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));
    }
    exports.taggedHash = taggedHash;
  }
});

// node_modules/bs58check/node_modules/@noble/hashes/_assert.js
var require_assert4 = __commonJS({
  "node_modules/bs58check/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number2(n13) {
      if (!Number.isSafeInteger(n13) || n13 < 0)
        throw new Error(`positive integer expected, not ${n13}`);
    }
    exports.number = number2;
    function bool(b10) {
      if (typeof b10 !== "boolean")
        throw new Error(`boolean expected, not ${b10}`);
    }
    exports.bool = bool;
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    function bytes(b10, ...lengths) {
      if (!isBytes2(b10))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b10.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b10.length}`);
    }
    exports.bytes = bytes;
    function hash(h11) {
      if (typeof h11 !== "function" || typeof h11.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(h11.outputLen);
      number2(h11.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number: number2, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/bs58check/node_modules/@noble/hashes/crypto.js
var require_crypto6 = __commonJS({
  "node_modules/bs58check/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/bs58check/node_modules/@noble/hashes/utils.js
var require_utils4 = __commonJS({
  "node_modules/bs58check/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto6();
    var _assert_js_1 = require_assert4();
    function isBytes2(a24) {
      return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes2;
    var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u82;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n13) => n13 : (n13) => (0, exports.byteSwap)(n13);
    function byteSwap32(arr) {
      for (let i18 = 0; i18 < arr.length; i18++) {
        arr[i18] = (0, exports.byteSwap)(arr[i18]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_10, i18) => i18.toString(16).padStart(2, "0"));
    function bytesToHex2(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i18 = 0; i18 < bytes.length; i18++) {
        hex += hexes[bytes[i18]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex2;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes2(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array2 = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n22 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array2[ai] = n1 * 16 + n22;
      }
      return array2;
    }
    exports.hexToBytes = hexToBytes2;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i18 = 0; i18 < iters; i18++) {
        cb(i18);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes2(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes2;
    function concatBytes2(...arrays) {
      let sum = 0;
      for (let i18 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        (0, _assert_js_1.bytes)(a24);
        sum += a24.length;
      }
      const res = new Uint8Array(sum);
      for (let i18 = 0, pad2 = 0; i18 < arrays.length; i18++) {
        const a24 = arrays[i18];
        res.set(a24, pad2);
        pad2 += a24.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes2;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/bs58check/node_modules/@noble/hashes/_md.js
var require_md4 = __commonJS({
  "node_modules/bs58check/node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert4();
    var utils_js_1 = require_utils4();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h11 = isLE ? 4 : 0;
      const l23 = isLE ? 0 : 4;
      view.setUint32(byteOffset + h11, wh, isLE);
      view.setUint32(byteOffset + l23, wl, isLE);
    }
    var Chi = (a24, b10, c10) => a24 & b10 ^ ~a24 & c10;
    exports.Chi = Chi;
    var Maj = (a24, b10, c10) => a24 & b10 ^ a24 & c10 ^ b10 & c10;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i18 = pos; i18 < blockLen; i18++)
          buffer[i18] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i18 = 0; i18 < outLen; i18++)
          oview.setUint32(4 * i18, state[i18], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/bs58check/node_modules/@noble/hashes/sha256.js
var require_sha2564 = __commonJS({
  "node_modules/bs58check/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md4();
    var utils_js_1 = require_utils4();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        return [A13, B12, C7, D7, E14, F11, G6, H7];
      }
      // prettier-ignore
      set(A13, B12, C7, D7, E14, F11, G6, H7) {
        this.A = A13 | 0;
        this.B = B12 | 0;
        this.C = C7 | 0;
        this.D = D7 | 0;
        this.E = E14 | 0;
        this.F = F11 | 0;
        this.G = G6 | 0;
        this.H = H7 | 0;
      }
      process(view, offset) {
        for (let i18 = 0; i18 < 16; i18++, offset += 4)
          SHA256_W[i18] = view.getUint32(offset, false);
        for (let i18 = 16; i18 < 64; i18++) {
          const W15 = SHA256_W[i18 - 15];
          const W2 = SHA256_W[i18 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i18] = s1 + SHA256_W[i18 - 7] + s0 + SHA256_W[i18 - 16] | 0;
        }
        let { A: A13, B: B12, C: C7, D: D7, E: E14, F: F11, G: G6, H: H7 } = this;
        for (let i18 = 0; i18 < 64; i18++) {
          const sigma1 = (0, utils_js_1.rotr)(E14, 6) ^ (0, utils_js_1.rotr)(E14, 11) ^ (0, utils_js_1.rotr)(E14, 25);
          const T1 = H7 + sigma1 + (0, _md_js_1.Chi)(E14, F11, G6) + SHA256_K[i18] + SHA256_W[i18] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A13, 2) ^ (0, utils_js_1.rotr)(A13, 13) ^ (0, utils_js_1.rotr)(A13, 22);
          const T22 = sigma0 + (0, _md_js_1.Maj)(A13, B12, C7) | 0;
          H7 = G6;
          G6 = F11;
          F11 = E14;
          E14 = D7 + T1 | 0;
          D7 = C7;
          C7 = B12;
          B12 = A13;
          A13 = T1 + T22 | 0;
        }
        A13 = A13 + this.A | 0;
        B12 = B12 + this.B | 0;
        C7 = C7 + this.C | 0;
        D7 = D7 + this.D | 0;
        E14 = E14 + this.E | 0;
        F11 = F11 + this.F | 0;
        G6 = G6 + this.G | 0;
        H7 = H7 + this.H | 0;
        this.set(A13, B12, C7, D7, E14, F11, G6, H7);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/base-x/src/index.js
var require_src4 = __commonJS({
  "node_modules/base-x/src/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    function base(ALPHABET) {
      if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
      }
      var BASE_MAP = new Uint8Array(256);
      for (var j6 = 0; j6 < BASE_MAP.length; j6++) {
        BASE_MAP[j6] = 255;
      }
      for (var i18 = 0; i18 < ALPHABET.length; i18++) {
        var x15 = ALPHABET.charAt(i18);
        var xc = x15.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
          throw new TypeError(x15 + " is ambiguous");
        }
        BASE_MAP[xc] = i18;
      }
      var BASE = ALPHABET.length;
      var LEADER = ALPHABET.charAt(0);
      var FACTOR = Math.log(BASE) / Math.log(256);
      var iFACTOR = Math.log(256) / Math.log(BASE);
      function encode(source) {
        if (source instanceof Uint8Array) {
        } else if (ArrayBuffer.isView(source)) {
          source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
          source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
          throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
          return "";
        }
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while (pbegin !== pend && source[pbegin] === 0) {
          pbegin++;
          zeroes++;
        }
        var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size2);
        while (pbegin !== pend) {
          var carry = source[pbegin];
          var i19 = 0;
          for (var it1 = size2 - 1; (carry !== 0 || i19 < length) && it1 !== -1; it1--, i19++) {
            carry += 256 * b58[it1] >>> 0;
            b58[it1] = carry % BASE >>> 0;
            carry = carry / BASE >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i19;
          pbegin++;
        }
        var it2 = size2 - length;
        while (it2 !== size2 && b58[it2] === 0) {
          it2++;
        }
        var str = LEADER.repeat(zeroes);
        for (; it2 < size2; ++it2) {
          str += ALPHABET.charAt(b58[it2]);
        }
        return str;
      }
      function decodeUnsafe(source) {
        if (typeof source !== "string") {
          throw new TypeError("Expected String");
        }
        if (source.length === 0) {
          return new Uint8Array();
        }
        var psz = 0;
        var zeroes = 0;
        var length = 0;
        while (source[psz] === LEADER) {
          zeroes++;
          psz++;
        }
        var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size2);
        while (source[psz]) {
          var carry = BASE_MAP[source.charCodeAt(psz)];
          if (carry === 255) {
            return;
          }
          var i19 = 0;
          for (var it3 = size2 - 1; (carry !== 0 || i19 < length) && it3 !== -1; it3--, i19++) {
            carry += BASE * b256[it3] >>> 0;
            b256[it3] = carry % 256 >>> 0;
            carry = carry / 256 >>> 0;
          }
          if (carry !== 0) {
            throw new Error("Non-zero carry");
          }
          length = i19;
          psz++;
        }
        var it4 = size2 - length;
        while (it4 !== size2 && b256[it4] === 0) {
          it4++;
        }
        var vch = new Uint8Array(zeroes + (size2 - it4));
        var j7 = zeroes;
        while (it4 !== size2) {
          vch[j7++] = b256[it4++];
        }
        return vch;
      }
      function decode(string2) {
        var buffer = decodeUnsafe(string2);
        if (buffer) {
          return buffer;
        }
        throw new Error("Non-base" + BASE + " character");
      }
      return {
        encode,
        decodeUnsafe,
        decode
      };
    }
    module.exports = base;
  }
});

// node_modules/bs58/index.js
var require_bs582 = __commonJS({
  "node_modules/bs58/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var basex = require_src4();
    var ALPHABET = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    module.exports = basex(ALPHABET);
  }
});

// node_modules/bs58check/base.js
var require_base2 = __commonJS({
  "node_modules/bs58check/base.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var base58 = require_bs582();
    module.exports = function(checksumFn) {
      function encode(payload) {
        var payloadU8 = Uint8Array.from(payload);
        var checksum = checksumFn(payloadU8);
        var length = payloadU8.length + 4;
        var both = new Uint8Array(length);
        both.set(payloadU8, 0);
        both.set(checksum.subarray(0, 4), payloadU8.length);
        return base58.encode(both, length);
      }
      function decodeRaw(buffer) {
        var payload = buffer.slice(0, -4);
        var checksum = buffer.slice(-4);
        var newChecksum = checksumFn(payload);
        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;
        return payload;
      }
      function decodeUnsafe(string2) {
        var buffer = base58.decodeUnsafe(string2);
        if (!buffer) return;
        return decodeRaw(buffer);
      }
      function decode(string2) {
        var buffer = base58.decode(string2);
        var payload = decodeRaw(buffer, checksumFn);
        if (!payload) throw new Error("Invalid checksum");
        return payload;
      }
      return {
        encode,
        decode,
        decodeUnsafe
      };
    };
  }
});

// node_modules/bs58check/index.js
var require_bs58check2 = __commonJS({
  "node_modules/bs58check/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var { sha256: sha2563 } = require_sha2564();
    var bs58checkBase = require_base2();
    function sha256x2(buffer) {
      return sha2563(sha2563(buffer));
    }
    module.exports = bs58checkBase(sha256x2);
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2pkh.js
var require_p2pkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2pkh.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2pkh = void 0;
    var bcrypto = require_crypto5();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check2();
    var OPS = bscript.OPS;
    function p2pkh(a24, opts) {
      if (!a24.address && !a24.hash && !a24.output && !a24.pubkey && !a24.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer)
        },
        a24
      );
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a24.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a24.input);
      });
      const network = a24.network || networks_1.bitcoin;
      const o13 = { name: "p2pkh", network };
      lazy.prop(o13, "address", () => {
        if (!o13.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(network.pubKeyHash, 0);
        o13.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o13, "hash", () => {
        if (a24.output) return a24.output.slice(3, 23);
        if (a24.address) return _address().hash;
        if (a24.pubkey || o13.pubkey) return bcrypto.hash160(a24.pubkey || o13.pubkey);
      });
      lazy.prop(o13, "output", () => {
        if (!o13.hash) return;
        return bscript.compile([
          OPS.OP_DUP,
          OPS.OP_HASH160,
          o13.hash,
          OPS.OP_EQUALVERIFY,
          OPS.OP_CHECKSIG
        ]);
      });
      lazy.prop(o13, "pubkey", () => {
        if (!a24.input) return;
        return _chunks()[1];
      });
      lazy.prop(o13, "signature", () => {
        if (!a24.input) return;
        return _chunks()[0];
      });
      lazy.prop(o13, "input", () => {
        if (!a24.pubkey) return;
        if (!a24.signature) return;
        return bscript.compile([a24.signature, a24.pubkey]);
      });
      lazy.prop(o13, "witness", () => {
        if (!o13.input) return;
        return [];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a24.address) {
          if (_address().version !== network.pubKeyHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a24.hash) {
          if (hash.length > 0 && !hash.equals(a24.hash))
            throw new TypeError("Hash mismatch");
          else hash = a24.hash;
        }
        if (a24.output) {
          if (a24.output.length !== 25 || a24.output[0] !== OPS.OP_DUP || a24.output[1] !== OPS.OP_HASH160 || a24.output[2] !== 20 || a24.output[23] !== OPS.OP_EQUALVERIFY || a24.output[24] !== OPS.OP_CHECKSIG)
            throw new TypeError("Output is invalid");
          const hash2 = a24.output.slice(3, 23);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a24.pubkey) {
          const pkh = bcrypto.hash160(a24.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
        }
        if (a24.input) {
          const chunks = _chunks();
          if (chunks.length !== 2) throw new TypeError("Input is invalid");
          if (!bscript.isCanonicalScriptSignature(chunks[0]))
            throw new TypeError("Input has invalid signature");
          if (!(0, types_1.isPoint)(chunks[1]))
            throw new TypeError("Input has invalid pubkey");
          if (a24.signature && !a24.signature.equals(chunks[0]))
            throw new TypeError("Signature mismatch");
          if (a24.pubkey && !a24.pubkey.equals(chunks[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(chunks[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2pkh = p2pkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2sh.js
var require_p2sh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2sh.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2sh = void 0;
    var bcrypto = require_crypto5();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bs58check = require_bs58check2();
    var OPS = bscript.OPS;
    function p2sh(a24, opts) {
      if (!a24.address && !a24.hash && !a24.output && !a24.redeem && !a24.input)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),
          redeem: types_1.typeforce.maybe({
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a24
      );
      let network = a24.network;
      if (!network) {
        network = a24.redeem && a24.redeem.network || networks_1.bitcoin;
      }
      const o13 = { network };
      const _address = lazy.value(() => {
        const payload = Buffer.from(bs58check.decode(a24.address));
        const version = payload.readUInt8(0);
        const hash = payload.slice(1);
        return { version, hash };
      });
      const _chunks = lazy.value(() => {
        return bscript.decompile(a24.input);
      });
      const _redeem = lazy.value(() => {
        const chunks = _chunks();
        const lastChunk = chunks[chunks.length - 1];
        return {
          network,
          output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,
          input: bscript.compile(chunks.slice(0, -1)),
          witness: a24.witness || []
        };
      });
      lazy.prop(o13, "address", () => {
        if (!o13.hash) return;
        const payload = Buffer.allocUnsafe(21);
        payload.writeUInt8(o13.network.scriptHash, 0);
        o13.hash.copy(payload, 1);
        return bs58check.encode(payload);
      });
      lazy.prop(o13, "hash", () => {
        if (a24.output) return a24.output.slice(2, 22);
        if (a24.address) return _address().hash;
        if (o13.redeem && o13.redeem.output) return bcrypto.hash160(o13.redeem.output);
      });
      lazy.prop(o13, "output", () => {
        if (!o13.hash) return;
        return bscript.compile([OPS.OP_HASH160, o13.hash, OPS.OP_EQUAL]);
      });
      lazy.prop(o13, "redeem", () => {
        if (!a24.input) return;
        return _redeem();
      });
      lazy.prop(o13, "input", () => {
        if (!a24.redeem || !a24.redeem.input || !a24.redeem.output) return;
        return bscript.compile(
          [].concat(bscript.decompile(a24.redeem.input), a24.redeem.output)
        );
      });
      lazy.prop(o13, "witness", () => {
        if (o13.redeem && o13.redeem.witness) return o13.redeem.witness;
        if (o13.input) return [];
      });
      lazy.prop(o13, "name", () => {
        const nameParts = ["p2sh"];
        if (o13.redeem !== void 0 && o13.redeem.name !== void 0)
          nameParts.push(o13.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a24.address) {
          if (_address().version !== network.scriptHash)
            throw new TypeError("Invalid version or Network mismatch");
          if (_address().hash.length !== 20) throw new TypeError("Invalid address");
          hash = _address().hash;
        }
        if (a24.hash) {
          if (hash.length > 0 && !hash.equals(a24.hash))
            throw new TypeError("Hash mismatch");
          else hash = a24.hash;
        }
        if (a24.output) {
          if (a24.output.length !== 23 || a24.output[0] !== OPS.OP_HASH160 || a24.output[1] !== 20 || a24.output[22] !== OPS.OP_EQUAL)
            throw new TypeError("Output is invalid");
          const hash2 = a24.output.slice(2, 22);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        const checkRedeem = (redeem) => {
          if (redeem.output) {
            const decompile = bscript.decompile(redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output too short");
            if (redeem.output.byteLength > 520)
              throw new TypeError(
                "Redeem.output unspendable if larger than 520 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.hash160(redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (redeem.input) {
            const hasInput = redeem.input.length > 0;
            const hasWitness = redeem.witness && redeem.witness.length > 0;
            if (!hasInput && !hasWitness) throw new TypeError("Empty input");
            if (hasInput && hasWitness)
              throw new TypeError("Input and witness provided");
            if (hasInput) {
              const richunks = bscript.decompile(redeem.input);
              if (!bscript.isPushOnly(richunks))
                throw new TypeError("Non push-only scriptSig");
            }
          }
        };
        if (a24.input) {
          const chunks = _chunks();
          if (!chunks || chunks.length < 1) throw new TypeError("Input too short");
          if (!Buffer.isBuffer(_redeem().output))
            throw new TypeError("Input is invalid");
          checkRedeem(_redeem());
        }
        if (a24.redeem) {
          if (a24.redeem.network && a24.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a24.input) {
            const redeem = _redeem();
            if (a24.redeem.output && !a24.redeem.output.equals(redeem.output))
              throw new TypeError("Redeem.output mismatch");
            if (a24.redeem.input && !a24.redeem.input.equals(redeem.input))
              throw new TypeError("Redeem.input mismatch");
          }
          checkRedeem(a24.redeem);
        }
        if (a24.witness) {
          if (a24.redeem && a24.redeem.witness && !(0, types_1.stacksEqual)(a24.redeem.witness, a24.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2sh = p2sh;
  }
});

// node_modules/bech32/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/bech32/dist/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bech32m = exports.bech32 = void 0;
    var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
    var ALPHABET_MAP = {};
    for (let z10 = 0; z10 < ALPHABET.length; z10++) {
      const x15 = ALPHABET.charAt(z10);
      ALPHABET_MAP[x15] = z10;
    }
    function polymodStep(pre) {
      const b10 = pre >> 25;
      return (pre & 33554431) << 5 ^ -(b10 >> 0 & 1) & 996825010 ^ -(b10 >> 1 & 1) & 642813549 ^ -(b10 >> 2 & 1) & 513874426 ^ -(b10 >> 3 & 1) & 1027748829 ^ -(b10 >> 4 & 1) & 705979059;
    }
    function prefixChk(prefix) {
      let chk = 1;
      for (let i18 = 0; i18 < prefix.length; ++i18) {
        const c10 = prefix.charCodeAt(i18);
        if (c10 < 33 || c10 > 126)
          return "Invalid prefix (" + prefix + ")";
        chk = polymodStep(chk) ^ c10 >> 5;
      }
      chk = polymodStep(chk);
      for (let i18 = 0; i18 < prefix.length; ++i18) {
        const v8 = prefix.charCodeAt(i18);
        chk = polymodStep(chk) ^ v8 & 31;
      }
      return chk;
    }
    function convert(data, inBits, outBits, pad2) {
      let value = 0;
      let bits = 0;
      const maxV = (1 << outBits) - 1;
      const result = [];
      for (let i18 = 0; i18 < data.length; ++i18) {
        value = value << inBits | data[i18];
        bits += inBits;
        while (bits >= outBits) {
          bits -= outBits;
          result.push(value >> bits & maxV);
        }
      }
      if (pad2) {
        if (bits > 0) {
          result.push(value << outBits - bits & maxV);
        }
      } else {
        if (bits >= inBits)
          return "Excess padding";
        if (value << outBits - bits & maxV)
          return "Non-zero padding";
      }
      return result;
    }
    function toWords(bytes) {
      return convert(bytes, 8, 5, true);
    }
    function fromWordsUnsafe(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
    }
    function fromWords(words) {
      const res = convert(words, 5, 8, false);
      if (Array.isArray(res))
        return res;
      throw new Error(res);
    }
    function getLibraryFromEncoding(encoding) {
      let ENCODING_CONST;
      if (encoding === "bech32") {
        ENCODING_CONST = 1;
      } else {
        ENCODING_CONST = 734539939;
      }
      function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT)
          throw new TypeError("Exceeds length limit");
        prefix = prefix.toLowerCase();
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          throw new Error(chk);
        let result = prefix + "1";
        for (let i18 = 0; i18 < words.length; ++i18) {
          const x15 = words[i18];
          if (x15 >> 5 !== 0)
            throw new Error("Non 5-bit word");
          chk = polymodStep(chk) ^ x15;
          result += ALPHABET.charAt(x15);
        }
        for (let i18 = 0; i18 < 6; ++i18) {
          chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for (let i18 = 0; i18 < 6; ++i18) {
          const v8 = chk >> (5 - i18) * 5 & 31;
          result += ALPHABET.charAt(v8);
        }
        return result;
      }
      function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8)
          return str + " too short";
        if (str.length > LIMIT)
          return "Exceeds length limit";
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered)
          return "Mixed-case string " + str;
        str = lowered;
        const split2 = str.lastIndexOf("1");
        if (split2 === -1)
          return "No separator character for " + str;
        if (split2 === 0)
          return "Missing prefix for " + str;
        const prefix = str.slice(0, split2);
        const wordChars = str.slice(split2 + 1);
        if (wordChars.length < 6)
          return "Data too short";
        let chk = prefixChk(prefix);
        if (typeof chk === "string")
          return chk;
        const words = [];
        for (let i18 = 0; i18 < wordChars.length; ++i18) {
          const c10 = wordChars.charAt(i18);
          const v8 = ALPHABET_MAP[c10];
          if (v8 === void 0)
            return "Unknown character " + c10;
          chk = polymodStep(chk) ^ v8;
          if (i18 + 6 >= wordChars.length)
            continue;
          words.push(v8);
        }
        if (chk !== ENCODING_CONST)
          return "Invalid checksum for " + str;
        return { prefix, words };
      }
      function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
      }
      function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === "object")
          return res;
        throw new Error(res);
      }
      return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
      };
    }
    exports.bech32 = getLibraryFromEncoding("bech32");
    exports.bech32m = getLibraryFromEncoding("bech32m");
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wpkh.js
var require_p2wpkh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wpkh.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2wpkh = void 0;
    var bcrypto = require_crypto5();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist4();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function p2wpkh(a24, opts) {
      if (!a24.address && !a24.hash && !a24.output && !a24.pubkey && !a24.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),
          pubkey: types_1.typeforce.maybe(types_1.isPoint),
          signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a24
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a24.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const network = a24.network || networks_1.bitcoin;
      const o13 = { name: "p2wpkh", network };
      lazy.prop(o13, "address", () => {
        if (!o13.hash) return;
        const words = bech32_1.bech32.toWords(o13.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o13, "hash", () => {
        if (a24.output) return a24.output.slice(2, 22);
        if (a24.address) return _address().data;
        if (a24.pubkey || o13.pubkey) return bcrypto.hash160(a24.pubkey || o13.pubkey);
      });
      lazy.prop(o13, "output", () => {
        if (!o13.hash) return;
        return bscript.compile([OPS.OP_0, o13.hash]);
      });
      lazy.prop(o13, "pubkey", () => {
        if (a24.pubkey) return a24.pubkey;
        if (!a24.witness) return;
        return a24.witness[1];
      });
      lazy.prop(o13, "signature", () => {
        if (!a24.witness) return;
        return a24.witness[0];
      });
      lazy.prop(o13, "input", () => {
        if (!o13.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o13, "witness", () => {
        if (!a24.pubkey) return;
        if (!a24.signature) return;
        return [a24.signature, a24.pubkey];
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a24.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 20)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a24.hash) {
          if (hash.length > 0 && !hash.equals(a24.hash))
            throw new TypeError("Hash mismatch");
          else hash = a24.hash;
        }
        if (a24.output) {
          if (a24.output.length !== 22 || a24.output[0] !== OPS.OP_0 || a24.output[1] !== 20)
            throw new TypeError("Output is invalid");
          if (hash.length > 0 && !hash.equals(a24.output.slice(2)))
            throw new TypeError("Hash mismatch");
          else hash = a24.output.slice(2);
        }
        if (a24.pubkey) {
          const pkh = bcrypto.hash160(a24.pubkey);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
          else hash = pkh;
          if (!(0, types_1.isPoint)(a24.pubkey) || a24.pubkey.length !== 33)
            throw new TypeError("Invalid pubkey for p2wpkh");
        }
        if (a24.witness) {
          if (a24.witness.length !== 2) throw new TypeError("Witness is invalid");
          if (!bscript.isCanonicalScriptSignature(a24.witness[0]))
            throw new TypeError("Witness has invalid signature");
          if (!(0, types_1.isPoint)(a24.witness[1]) || a24.witness[1].length !== 33)
            throw new TypeError("Witness has invalid pubkey");
          if (a24.signature && !a24.signature.equals(a24.witness[0]))
            throw new TypeError("Signature mismatch");
          if (a24.pubkey && !a24.pubkey.equals(a24.witness[1]))
            throw new TypeError("Pubkey mismatch");
          const pkh = bcrypto.hash160(a24.witness[1]);
          if (hash.length > 0 && !hash.equals(pkh))
            throw new TypeError("Hash mismatch");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2wpkh = p2wpkh;
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2wsh.js
var require_p2wsh = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2wsh.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2wsh = void 0;
    var bcrypto = require_crypto5();
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var lazy = require_lazy();
    var bech32_1 = require_dist4();
    var OPS = bscript.OPS;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function chunkHasUncompressedPubkey(chunk) {
      if (Buffer.isBuffer(chunk) && chunk.length === 65 && chunk[0] === 4 && (0, types_1.isPoint)(chunk)) {
        return true;
      } else {
        return false;
      }
    }
    function p2wsh(a24, opts) {
      if (!a24.address && !a24.hash && !a24.output && !a24.redeem && !a24.witness)
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          redeem: types_1.typeforce.maybe({
            input: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            network: types_1.typeforce.maybe(types_1.typeforce.Object),
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          )
        },
        a24
      );
      const _address = lazy.value(() => {
        const result = bech32_1.bech32.decode(a24.address);
        const version = result.words.shift();
        const data = bech32_1.bech32.fromWords(result.words);
        return {
          version,
          prefix: result.prefix,
          data: Buffer.from(data)
        };
      });
      const _rchunks = lazy.value(() => {
        return bscript.decompile(a24.redeem.input);
      });
      let network = a24.network;
      if (!network) {
        network = a24.redeem && a24.redeem.network || networks_1.bitcoin;
      }
      const o13 = { network };
      lazy.prop(o13, "address", () => {
        if (!o13.hash) return;
        const words = bech32_1.bech32.toWords(o13.hash);
        words.unshift(0);
        return bech32_1.bech32.encode(network.bech32, words);
      });
      lazy.prop(o13, "hash", () => {
        if (a24.output) return a24.output.slice(2);
        if (a24.address) return _address().data;
        if (o13.redeem && o13.redeem.output) return bcrypto.sha256(o13.redeem.output);
      });
      lazy.prop(o13, "output", () => {
        if (!o13.hash) return;
        return bscript.compile([OPS.OP_0, o13.hash]);
      });
      lazy.prop(o13, "redeem", () => {
        if (!a24.witness) return;
        return {
          output: a24.witness[a24.witness.length - 1],
          input: EMPTY_BUFFER,
          witness: a24.witness.slice(0, -1)
        };
      });
      lazy.prop(o13, "input", () => {
        if (!o13.witness) return;
        return EMPTY_BUFFER;
      });
      lazy.prop(o13, "witness", () => {
        if (a24.redeem && a24.redeem.input && a24.redeem.input.length > 0 && a24.redeem.output && a24.redeem.output.length > 0) {
          const stack = bscript.toStack(_rchunks());
          o13.redeem = Object.assign({ witness: stack }, a24.redeem);
          o13.redeem.input = EMPTY_BUFFER;
          return [].concat(stack, a24.redeem.output);
        }
        if (!a24.redeem) return;
        if (!a24.redeem.output) return;
        if (!a24.redeem.witness) return;
        return [].concat(a24.redeem.witness, a24.redeem.output);
      });
      lazy.prop(o13, "name", () => {
        const nameParts = ["p2wsh"];
        if (o13.redeem !== void 0 && o13.redeem.name !== void 0)
          nameParts.push(o13.redeem.name);
        return nameParts.join("-");
      });
      if (opts.validate) {
        let hash = Buffer.from([]);
        if (a24.address) {
          if (_address().prefix !== network.bech32)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== 0)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          hash = _address().data;
        }
        if (a24.hash) {
          if (hash.length > 0 && !hash.equals(a24.hash))
            throw new TypeError("Hash mismatch");
          else hash = a24.hash;
        }
        if (a24.output) {
          if (a24.output.length !== 34 || a24.output[0] !== OPS.OP_0 || a24.output[1] !== 32)
            throw new TypeError("Output is invalid");
          const hash2 = a24.output.slice(2);
          if (hash.length > 0 && !hash.equals(hash2))
            throw new TypeError("Hash mismatch");
          else hash = hash2;
        }
        if (a24.redeem) {
          if (a24.redeem.network && a24.redeem.network !== network)
            throw new TypeError("Network mismatch");
          if (a24.redeem.input && a24.redeem.input.length > 0 && a24.redeem.witness && a24.redeem.witness.length > 0)
            throw new TypeError("Ambiguous witness source");
          if (a24.redeem.output) {
            const decompile = bscript.decompile(a24.redeem.output);
            if (!decompile || decompile.length < 1)
              throw new TypeError("Redeem.output is invalid");
            if (a24.redeem.output.byteLength > 3600)
              throw new TypeError(
                "Redeem.output unspendable if larger than 3600 bytes"
              );
            if (bscript.countNonPushOnlyOPs(decompile) > 201)
              throw new TypeError(
                "Redeem.output unspendable with more than 201 non-push ops"
              );
            const hash2 = bcrypto.sha256(a24.redeem.output);
            if (hash.length > 0 && !hash.equals(hash2))
              throw new TypeError("Hash mismatch");
            else hash = hash2;
          }
          if (a24.redeem.input && !bscript.isPushOnly(_rchunks()))
            throw new TypeError("Non push-only scriptSig");
          if (a24.witness && a24.redeem.witness && !(0, types_1.stacksEqual)(a24.witness, a24.redeem.witness))
            throw new TypeError("Witness and redeem.witness mismatch");
          if (a24.redeem.input && _rchunks().some(chunkHasUncompressedPubkey) || a24.redeem.output && (bscript.decompile(a24.redeem.output) || []).some(
            chunkHasUncompressedPubkey
          )) {
            throw new TypeError(
              "redeem.input or redeem.output contains uncompressed pubkey"
            );
          }
        }
        if (a24.witness && a24.witness.length > 0) {
          const wScript = a24.witness[a24.witness.length - 1];
          if (a24.redeem && a24.redeem.output && !a24.redeem.output.equals(wScript))
            throw new TypeError("Witness and redeem.output mismatch");
          if (a24.witness.some(chunkHasUncompressedPubkey) || (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey))
            throw new TypeError("Witness contains uncompressed pubkey");
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2wsh = p2wsh;
  }
});

// node_modules/bitcoinjs-lib/src/ecc_lib.js
var require_ecc_lib = __commonJS({
  "node_modules/bitcoinjs-lib/src/ecc_lib.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEccLib = exports.initEccLib = void 0;
    var _ECCLIB_CACHE = {};
    function initEccLib(eccLib) {
      if (!eccLib) {
        _ECCLIB_CACHE.eccLib = eccLib;
      } else if (eccLib !== _ECCLIB_CACHE.eccLib) {
        verifyEcc(eccLib);
        _ECCLIB_CACHE.eccLib = eccLib;
      }
    }
    exports.initEccLib = initEccLib;
    function getEccLib() {
      if (!_ECCLIB_CACHE.eccLib)
        throw new Error(
          "No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance"
        );
      return _ECCLIB_CACHE.eccLib;
    }
    exports.getEccLib = getEccLib;
    var h11 = (hex) => Buffer.from(hex, "hex");
    function verifyEcc(ecc) {
      assert(typeof ecc.isXOnlyPoint === "function");
      assert(
        ecc.isXOnlyPoint(
          h11("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h11("fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h11("f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9")
        )
      );
      assert(
        ecc.isXOnlyPoint(
          h11("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h11("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert(
        !ecc.isXOnlyPoint(
          h11("fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
        )
      );
      assert(typeof ecc.xOnlyPointAddTweak === "function");
      tweakAddVectors.forEach((t12) => {
        const r13 = ecc.xOnlyPointAddTweak(h11(t12.pubkey), h11(t12.tweak));
        if (t12.result === null) {
          assert(r13 === null);
        } else {
          assert(r13 !== null);
          assert(r13.parity === t12.parity);
          assert(Buffer.from(r13.xOnlyPubkey).equals(h11(t12.result)));
        }
      });
    }
    function assert(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
    var tweakAddVectors = [
      {
        pubkey: "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        tweak: "fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140",
        parity: -1,
        result: null
      },
      {
        pubkey: "1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b",
        tweak: "a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac",
        parity: 1,
        result: "e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf"
      },
      {
        pubkey: "2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991",
        tweak: "823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47",
        parity: 0,
        result: "9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c"
      }
    ];
  }
});

// node_modules/varuint-bitcoin/index.js
var require_varuint_bitcoin = __commonJS({
  "node_modules/varuint-bitcoin/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n13) {
      if (n13 < 0 || n13 > MAX_SAFE_INTEGER || n13 % 1 !== 0) throw new RangeError("value out of range");
    }
    function encode(number2, buffer, offset) {
      checkUInt53(number2);
      if (!buffer) buffer = Buffer2.allocUnsafe(encodingLength(number2));
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (number2 < 253) {
        buffer.writeUInt8(number2, offset);
        encode.bytes = 1;
      } else if (number2 <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(number2, offset + 1);
        encode.bytes = 3;
      } else if (number2 <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(number2, offset + 1);
        encode.bytes = 5;
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(number2 >>> 0, offset + 1);
        buffer.writeUInt32LE(number2 / 4294967296 | 0, offset + 5);
        encode.bytes = 9;
      }
      return buffer;
    }
    function decode(buffer, offset) {
      if (!Buffer2.isBuffer(buffer)) throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      var first = buffer.readUInt8(offset);
      if (first < 253) {
        decode.bytes = 1;
        return first;
      } else if (first === 253) {
        decode.bytes = 3;
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        decode.bytes = 5;
        return buffer.readUInt32LE(offset + 1);
      } else {
        decode.bytes = 9;
        var lo = buffer.readUInt32LE(offset + 1);
        var hi = buffer.readUInt32LE(offset + 5);
        var number2 = hi * 4294967296 + lo;
        checkUInt53(number2);
        return number2;
      }
    }
    function encodingLength(number2) {
      checkUInt53(number2);
      return number2 < 253 ? 1 : number2 <= 65535 ? 3 : number2 <= 4294967295 ? 5 : 9;
    }
    module.exports = { encode, decode, encodingLength };
  }
});

// node_modules/bitcoinjs-lib/src/bufferutils.js
var require_bufferutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/bufferutils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BufferReader = exports.BufferWriter = exports.cloneBuffer = exports.reverseBuffer = exports.writeUInt64LE = exports.readUInt64LE = exports.varuint = void 0;
    var types = require_types();
    var { typeforce } = types;
    var varuint = require_varuint_bitcoin();
    exports.varuint = varuint;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a24 = buffer.readUInt32LE(offset);
      let b10 = buffer.readUInt32LE(offset + 4);
      b10 *= 4294967296;
      verifuint(b10 + a24, 9007199254740991);
      return b10 + a24;
    }
    exports.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports.writeUInt64LE = writeUInt64LE;
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j6 = buffer.length - 1;
      let tmp = 0;
      for (let i18 = 0; i18 < buffer.length / 2; i18++) {
        tmp = buffer[i18];
        buffer[i18] = buffer[j6];
        buffer[j6] = tmp;
        j6--;
      }
      return buffer;
    }
    exports.reverseBuffer = reverseBuffer;
    function cloneBuffer(buffer) {
      const clone2 = Buffer.allocUnsafe(buffer.length);
      buffer.copy(clone2);
      return clone2;
    }
    exports.cloneBuffer = cloneBuffer;
    var BufferWriter = class _BufferWriter {
      static withCapacity(size2) {
        return new _BufferWriter(Buffer.alloc(size2));
      }
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      writeUInt8(i18) {
        this.offset = this.buffer.writeUInt8(i18, this.offset);
      }
      writeInt32(i18) {
        this.offset = this.buffer.writeInt32LE(i18, this.offset);
      }
      writeUInt32(i18) {
        this.offset = this.buffer.writeUInt32LE(i18, this.offset);
      }
      writeUInt64(i18) {
        this.offset = writeUInt64LE(this.buffer, i18, this.offset);
      }
      writeVarInt(i18) {
        varuint.encode(i18, this.buffer, this.offset);
        this.offset += varuint.encode.bytes;
      }
      writeSlice(slice2) {
        if (this.buffer.length < this.offset + slice2.length) {
          throw new Error("Cannot write slice out of bounds");
        }
        this.offset += slice2.copy(this.buffer, this.offset);
      }
      writeVarSlice(slice2) {
        this.writeVarInt(slice2.length);
        this.writeSlice(slice2);
      }
      writeVector(vector) {
        this.writeVarInt(vector.length);
        vector.forEach((buf) => this.writeVarSlice(buf));
      }
      end() {
        if (this.buffer.length === this.offset) {
          return this.buffer;
        }
        throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);
      }
    };
    exports.BufferWriter = BufferWriter;
    var BufferReader = class {
      constructor(buffer, offset = 0) {
        this.buffer = buffer;
        this.offset = offset;
        typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);
      }
      readUInt8() {
        const result = this.buffer.readUInt8(this.offset);
        this.offset++;
        return result;
      }
      readInt32() {
        const result = this.buffer.readInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt32() {
        const result = this.buffer.readUInt32LE(this.offset);
        this.offset += 4;
        return result;
      }
      readUInt64() {
        const result = readUInt64LE(this.buffer, this.offset);
        this.offset += 8;
        return result;
      }
      readVarInt() {
        const vi = varuint.decode(this.buffer, this.offset);
        this.offset += varuint.decode.bytes;
        return vi;
      }
      readSlice(n13) {
        if (this.buffer.length < this.offset + n13) {
          throw new Error("Cannot read slice out of bounds");
        }
        const result = this.buffer.slice(this.offset, this.offset + n13);
        this.offset += n13;
        return result;
      }
      readVarSlice() {
        return this.readSlice(this.readVarInt());
      }
      readVector() {
        const count = this.readVarInt();
        const vector = [];
        for (let i18 = 0; i18 < count; i18++) vector.push(this.readVarSlice());
        return vector;
      }
    };
    exports.BufferReader = BufferReader;
  }
});

// node_modules/bitcoinjs-lib/src/payments/bip341.js
var require_bip341 = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/bip341.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.tweakKey = exports.tapTweakHash = exports.tapleafHash = exports.findScriptPath = exports.toHashTree = exports.rootHashFromPath = exports.MAX_TAPTREE_DEPTH = exports.LEAF_VERSION_TAPSCRIPT = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    var ecc_lib_1 = require_ecc_lib();
    var bcrypto = require_crypto5();
    var bufferutils_1 = require_bufferutils();
    var types_1 = require_types();
    exports.LEAF_VERSION_TAPSCRIPT = 192;
    exports.MAX_TAPTREE_DEPTH = 128;
    var isHashBranch = (ht3) => "left" in ht3 && "right" in ht3;
    function rootHashFromPath(controlBlock, leafHash) {
      if (controlBlock.length < 33)
        throw new TypeError(
          `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
        );
      const m17 = (controlBlock.length - 33) / 32;
      let kj = leafHash;
      for (let j6 = 0; j6 < m17; j6++) {
        const ej = controlBlock.slice(33 + 32 * j6, 65 + 32 * j6);
        if (kj.compare(ej) < 0) {
          kj = tapBranchHash(kj, ej);
        } else {
          kj = tapBranchHash(ej, kj);
        }
      }
      return kj;
    }
    exports.rootHashFromPath = rootHashFromPath;
    function toHashTree(scriptTree) {
      if ((0, types_1.isTapleaf)(scriptTree))
        return { hash: tapleafHash(scriptTree) };
      const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];
      hashes.sort((a24, b10) => a24.hash.compare(b10.hash));
      const [left, right] = hashes;
      return {
        hash: tapBranchHash(left.hash, right.hash),
        left,
        right
      };
    }
    exports.toHashTree = toHashTree;
    function findScriptPath(node, hash) {
      if (isHashBranch(node)) {
        const leftPath = findScriptPath(node.left, hash);
        if (leftPath !== void 0) return [...leftPath, node.right.hash];
        const rightPath = findScriptPath(node.right, hash);
        if (rightPath !== void 0) return [...rightPath, node.left.hash];
      } else if (node.hash.equals(hash)) {
        return [];
      }
      return void 0;
    }
    exports.findScriptPath = findScriptPath;
    function tapleafHash(leaf) {
      const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;
      return bcrypto.taggedHash(
        "TapLeaf",
        buffer_1.Buffer.concat([
          buffer_1.Buffer.from([version]),
          serializeScript(leaf.output)
        ])
      );
    }
    exports.tapleafHash = tapleafHash;
    function tapTweakHash(pubKey, h11) {
      return bcrypto.taggedHash(
        "TapTweak",
        buffer_1.Buffer.concat(h11 ? [pubKey, h11] : [pubKey])
      );
    }
    exports.tapTweakHash = tapTweakHash;
    function tweakKey(pubKey, h11) {
      if (!buffer_1.Buffer.isBuffer(pubKey)) return null;
      if (pubKey.length !== 32) return null;
      if (h11 && h11.length !== 32) return null;
      const tweakHash = tapTweakHash(pubKey, h11);
      const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);
      if (!res || res.xOnlyPubkey === null) return null;
      return {
        parity: res.parity,
        x: buffer_1.Buffer.from(res.xOnlyPubkey)
      };
    }
    exports.tweakKey = tweakKey;
    function tapBranchHash(a24, b10) {
      return bcrypto.taggedHash("TapBranch", buffer_1.Buffer.concat([a24, b10]));
    }
    function serializeScript(s15) {
      const varintLen = bufferutils_1.varuint.encodingLength(s15.length);
      const buffer = buffer_1.Buffer.allocUnsafe(varintLen);
      bufferutils_1.varuint.encode(s15.length, buffer);
      return buffer_1.Buffer.concat([buffer, s15]);
    }
  }
});

// node_modules/bitcoinjs-lib/src/payments/p2tr.js
var require_p2tr = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/p2tr.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2tr = void 0;
    var buffer_1 = (init_dist(), __toCommonJS(dist_exports));
    var networks_1 = require_networks();
    var bscript = require_script();
    var types_1 = require_types();
    var ecc_lib_1 = require_ecc_lib();
    var bip341_1 = require_bip341();
    var lazy = require_lazy();
    var bech32_1 = require_dist4();
    var address_1 = require_address();
    var OPS = bscript.OPS;
    var TAPROOT_WITNESS_VERSION = 1;
    var ANNEX_PREFIX = 80;
    function p2tr(a24, opts) {
      if (!a24.address && !a24.output && !a24.pubkey && !a24.internalPubkey && !(a24.witness && a24.witness.length > 1))
        throw new TypeError("Not enough data");
      opts = Object.assign({ validate: true }, opts || {});
      (0, types_1.typeforce)(
        {
          address: types_1.typeforce.maybe(types_1.typeforce.String),
          input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),
          network: types_1.typeforce.maybe(types_1.typeforce.Object),
          output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),
          internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),
          signature: types_1.typeforce.maybe(
            types_1.typeforce.anyOf(
              types_1.typeforce.BufferN(64),
              types_1.typeforce.BufferN(65)
            )
          ),
          witness: types_1.typeforce.maybe(
            types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
          ),
          scriptTree: types_1.typeforce.maybe(types_1.isTaptree),
          redeem: types_1.typeforce.maybe({
            output: types_1.typeforce.maybe(types_1.typeforce.Buffer),
            redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),
            witness: types_1.typeforce.maybe(
              types_1.typeforce.arrayOf(types_1.typeforce.Buffer)
            )
          }),
          redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number)
        },
        a24
      );
      const _address = lazy.value(() => {
        return (0, address_1.fromBech32)(a24.address);
      });
      const _witness = lazy.value(() => {
        if (!a24.witness || !a24.witness.length) return;
        if (a24.witness.length >= 2 && a24.witness[a24.witness.length - 1][0] === ANNEX_PREFIX) {
          return a24.witness.slice(0, -1);
        }
        return a24.witness.slice();
      });
      const _hashTree = lazy.value(() => {
        if (a24.scriptTree) return (0, bip341_1.toHashTree)(a24.scriptTree);
        if (a24.hash) return { hash: a24.hash };
        return;
      });
      const network = a24.network || networks_1.bitcoin;
      const o13 = { name: "p2tr", network };
      lazy.prop(o13, "address", () => {
        if (!o13.pubkey) return;
        const words = bech32_1.bech32m.toWords(o13.pubkey);
        words.unshift(TAPROOT_WITNESS_VERSION);
        return bech32_1.bech32m.encode(network.bech32, words);
      });
      lazy.prop(o13, "hash", () => {
        const hashTree = _hashTree();
        if (hashTree) return hashTree.hash;
        const w13 = _witness();
        if (w13 && w13.length > 1) {
          const controlBlock = w13[w13.length - 1];
          const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
          const script = w13[w13.length - 2];
          const leafHash = (0, bip341_1.tapleafHash)({
            output: script,
            version: leafVersion
          });
          return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
        }
        return null;
      });
      lazy.prop(o13, "output", () => {
        if (!o13.pubkey) return;
        return bscript.compile([OPS.OP_1, o13.pubkey]);
      });
      lazy.prop(o13, "redeemVersion", () => {
        if (a24.redeemVersion) return a24.redeemVersion;
        if (a24.redeem && a24.redeem.redeemVersion !== void 0 && a24.redeem.redeemVersion !== null) {
          return a24.redeem.redeemVersion;
        }
        return bip341_1.LEAF_VERSION_TAPSCRIPT;
      });
      lazy.prop(o13, "redeem", () => {
        const witness = _witness();
        if (!witness || witness.length < 2) return;
        return {
          output: witness[witness.length - 2],
          witness: witness.slice(0, -2),
          redeemVersion: witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK
        };
      });
      lazy.prop(o13, "pubkey", () => {
        if (a24.pubkey) return a24.pubkey;
        if (a24.output) return a24.output.slice(2);
        if (a24.address) return _address().data;
        if (o13.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(o13.internalPubkey, o13.hash);
          if (tweakedKey) return tweakedKey.x;
        }
      });
      lazy.prop(o13, "internalPubkey", () => {
        if (a24.internalPubkey) return a24.internalPubkey;
        const witness = _witness();
        if (witness && witness.length > 1)
          return witness[witness.length - 1].slice(1, 33);
      });
      lazy.prop(o13, "signature", () => {
        if (a24.signature) return a24.signature;
        const witness = _witness();
        if (!witness || witness.length !== 1) return;
        return witness[0];
      });
      lazy.prop(o13, "witness", () => {
        if (a24.witness) return a24.witness;
        const hashTree = _hashTree();
        if (hashTree && a24.redeem && a24.redeem.output && a24.internalPubkey) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a24.redeem.output,
            version: o13.redeemVersion
          });
          const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);
          if (!path) return;
          const outputKey = (0, bip341_1.tweakKey)(a24.internalPubkey, hashTree.hash);
          if (!outputKey) return;
          const controlBock = buffer_1.Buffer.concat(
            [
              buffer_1.Buffer.from([o13.redeemVersion | outputKey.parity]),
              a24.internalPubkey
            ].concat(path)
          );
          return [a24.redeem.output, controlBock];
        }
        if (a24.signature) return [a24.signature];
      });
      if (opts.validate) {
        let pubkey = buffer_1.Buffer.from([]);
        if (a24.address) {
          if (network && network.bech32 !== _address().prefix)
            throw new TypeError("Invalid prefix or Network mismatch");
          if (_address().version !== TAPROOT_WITNESS_VERSION)
            throw new TypeError("Invalid address version");
          if (_address().data.length !== 32)
            throw new TypeError("Invalid address data");
          pubkey = _address().data;
        }
        if (a24.pubkey) {
          if (pubkey.length > 0 && !pubkey.equals(a24.pubkey))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a24.pubkey;
        }
        if (a24.output) {
          if (a24.output.length !== 34 || a24.output[0] !== OPS.OP_1 || a24.output[1] !== 32)
            throw new TypeError("Output is invalid");
          if (pubkey.length > 0 && !pubkey.equals(a24.output.slice(2)))
            throw new TypeError("Pubkey mismatch");
          else pubkey = a24.output.slice(2);
        }
        if (a24.internalPubkey) {
          const tweakedKey = (0, bip341_1.tweakKey)(a24.internalPubkey, o13.hash);
          if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))
            throw new TypeError("Pubkey mismatch");
          else pubkey = tweakedKey.x;
        }
        if (pubkey && pubkey.length) {
          if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))
            throw new TypeError("Invalid pubkey for p2tr");
        }
        const hashTree = _hashTree();
        if (a24.hash && hashTree) {
          if (!a24.hash.equals(hashTree.hash)) throw new TypeError("Hash mismatch");
        }
        if (a24.redeem && a24.redeem.output && hashTree) {
          const leafHash = (0, bip341_1.tapleafHash)({
            output: a24.redeem.output,
            version: o13.redeemVersion
          });
          if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))
            throw new TypeError("Redeem script not in tree");
        }
        const witness = _witness();
        if (a24.redeem && o13.redeem) {
          if (a24.redeem.redeemVersion) {
            if (a24.redeem.redeemVersion !== o13.redeem.redeemVersion)
              throw new TypeError("Redeem.redeemVersion and witness mismatch");
          }
          if (a24.redeem.output) {
            if (bscript.decompile(a24.redeem.output).length === 0)
              throw new TypeError("Redeem.output is invalid");
            if (o13.redeem.output && !a24.redeem.output.equals(o13.redeem.output))
              throw new TypeError("Redeem.output and witness mismatch");
          }
          if (a24.redeem.witness) {
            if (o13.redeem.witness && !(0, types_1.stacksEqual)(a24.redeem.witness, o13.redeem.witness))
              throw new TypeError("Redeem.witness and witness mismatch");
          }
        }
        if (witness && witness.length) {
          if (witness.length === 1) {
            if (a24.signature && !a24.signature.equals(witness[0]))
              throw new TypeError("Signature mismatch");
          } else {
            const controlBlock = witness[witness.length - 1];
            if (controlBlock.length < 33)
              throw new TypeError(
                `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`
              );
            if ((controlBlock.length - 33) % 32 !== 0)
              throw new TypeError(
                `The control-block length of ${controlBlock.length} is incorrect!`
              );
            const m17 = (controlBlock.length - 33) / 32;
            if (m17 > 128)
              throw new TypeError(
                `The script path is too long. Got ${m17}, expected max 128.`
              );
            const internalPubkey = controlBlock.slice(1, 33);
            if (a24.internalPubkey && !a24.internalPubkey.equals(internalPubkey))
              throw new TypeError("Internal pubkey mismatch");
            if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))
              throw new TypeError("Invalid internalPubkey for p2tr witness");
            const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;
            const script = witness[witness.length - 2];
            const leafHash = (0, bip341_1.tapleafHash)({
              output: script,
              version: leafVersion
            });
            const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);
            const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);
            if (!outputKey)
              throw new TypeError("Invalid outputKey for p2tr witness");
            if (pubkey.length && !pubkey.equals(outputKey.x))
              throw new TypeError("Pubkey mismatch for p2tr witness");
            if (outputKey.parity !== (controlBlock[0] & 1))
              throw new Error("Incorrect parity");
          }
        }
      }
      return Object.assign(o13, a24);
    }
    exports.p2tr = p2tr;
  }
});

// node_modules/bitcoinjs-lib/src/payments/index.js
var require_payments = __commonJS({
  "node_modules/bitcoinjs-lib/src/payments/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.p2tr = exports.p2wsh = exports.p2wpkh = exports.p2sh = exports.p2pkh = exports.p2pk = exports.p2ms = exports.embed = void 0;
    var embed_1 = require_embed();
    Object.defineProperty(exports, "embed", {
      enumerable: true,
      get: function() {
        return embed_1.p2data;
      }
    });
    var p2ms_1 = require_p2ms();
    Object.defineProperty(exports, "p2ms", {
      enumerable: true,
      get: function() {
        return p2ms_1.p2ms;
      }
    });
    var p2pk_1 = require_p2pk();
    Object.defineProperty(exports, "p2pk", {
      enumerable: true,
      get: function() {
        return p2pk_1.p2pk;
      }
    });
    var p2pkh_1 = require_p2pkh();
    Object.defineProperty(exports, "p2pkh", {
      enumerable: true,
      get: function() {
        return p2pkh_1.p2pkh;
      }
    });
    var p2sh_1 = require_p2sh();
    Object.defineProperty(exports, "p2sh", {
      enumerable: true,
      get: function() {
        return p2sh_1.p2sh;
      }
    });
    var p2wpkh_1 = require_p2wpkh();
    Object.defineProperty(exports, "p2wpkh", {
      enumerable: true,
      get: function() {
        return p2wpkh_1.p2wpkh;
      }
    });
    var p2wsh_1 = require_p2wsh();
    Object.defineProperty(exports, "p2wsh", {
      enumerable: true,
      get: function() {
        return p2wsh_1.p2wsh;
      }
    });
    var p2tr_1 = require_p2tr();
    Object.defineProperty(exports, "p2tr", {
      enumerable: true,
      get: function() {
        return p2tr_1.p2tr;
      }
    });
  }
});

// node_modules/bitcoinjs-lib/src/address.js
var require_address = __commonJS({
  "node_modules/bitcoinjs-lib/src/address.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toOutputScript = exports.fromOutputScript = exports.toBech32 = exports.toBase58Check = exports.fromBech32 = exports.fromBase58Check = void 0;
    var networks = require_networks();
    var payments = require_payments();
    var bscript = require_script();
    var types_1 = require_types();
    var bech32_1 = require_dist4();
    var bs58check = require_bs58check2();
    var FUTURE_SEGWIT_MAX_SIZE = 40;
    var FUTURE_SEGWIT_MIN_SIZE = 2;
    var FUTURE_SEGWIT_MAX_VERSION = 16;
    var FUTURE_SEGWIT_MIN_VERSION = 2;
    var FUTURE_SEGWIT_VERSION_DIFF = 80;
    var FUTURE_SEGWIT_VERSION_WARNING = "WARNING: Sending to a future segwit version address can lead to loss of funds. End users MUST be warned carefully in the GUI and asked if they wish to proceed with caution. Wallets should verify the segwit version from the output of fromBech32, then decide when it is safe to use which version of segwit.";
    function _toFutureSegwitAddress(output, network) {
      const data = output.slice(2);
      if (data.length < FUTURE_SEGWIT_MIN_SIZE || data.length > FUTURE_SEGWIT_MAX_SIZE)
        throw new TypeError("Invalid program length for segwit address");
      const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;
      if (version < FUTURE_SEGWIT_MIN_VERSION || version > FUTURE_SEGWIT_MAX_VERSION)
        throw new TypeError("Invalid version for segwit address");
      if (output[1] !== data.length)
        throw new TypeError("Invalid script for segwit address");
      console.warn(FUTURE_SEGWIT_VERSION_WARNING);
      return toBech32(data, version, network.bech32);
    }
    function fromBase58Check(address) {
      const payload = Buffer.from(bs58check.decode(address));
      if (payload.length < 21) throw new TypeError(address + " is too short");
      if (payload.length > 21) throw new TypeError(address + " is too long");
      const version = payload.readUInt8(0);
      const hash = payload.slice(1);
      return { version, hash };
    }
    exports.fromBase58Check = fromBase58Check;
    function fromBech32(address) {
      let result;
      let version;
      try {
        result = bech32_1.bech32.decode(address);
      } catch (e17) {
      }
      if (result) {
        version = result.words[0];
        if (version !== 0) throw new TypeError(address + " uses wrong encoding");
      } else {
        result = bech32_1.bech32m.decode(address);
        version = result.words[0];
        if (version === 0) throw new TypeError(address + " uses wrong encoding");
      }
      const data = bech32_1.bech32.fromWords(result.words.slice(1));
      return {
        version,
        prefix: result.prefix,
        data: Buffer.from(data)
      };
    }
    exports.fromBech32 = fromBech32;
    function toBase58Check(hash, version) {
      (0, types_1.typeforce)(
        (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),
        arguments
      );
      const payload = Buffer.allocUnsafe(21);
      payload.writeUInt8(version, 0);
      hash.copy(payload, 1);
      return bs58check.encode(payload);
    }
    exports.toBase58Check = toBase58Check;
    function toBech32(data, version, prefix) {
      const words = bech32_1.bech32.toWords(data);
      words.unshift(version);
      return version === 0 ? bech32_1.bech32.encode(prefix, words) : bech32_1.bech32m.encode(prefix, words);
    }
    exports.toBech32 = toBech32;
    function fromOutputScript(output, network) {
      network = network || networks.bitcoin;
      try {
        return payments.p2pkh({ output, network }).address;
      } catch (e17) {
      }
      try {
        return payments.p2sh({ output, network }).address;
      } catch (e17) {
      }
      try {
        return payments.p2wpkh({ output, network }).address;
      } catch (e17) {
      }
      try {
        return payments.p2wsh({ output, network }).address;
      } catch (e17) {
      }
      try {
        return payments.p2tr({ output, network }).address;
      } catch (e17) {
      }
      try {
        return _toFutureSegwitAddress(output, network);
      } catch (e17) {
      }
      throw new Error(bscript.toASM(output) + " has no matching Address");
    }
    exports.fromOutputScript = fromOutputScript;
    function toOutputScript(address, network) {
      network = network || networks.bitcoin;
      let decodeBase58;
      let decodeBech32;
      try {
        decodeBase58 = fromBase58Check(address);
      } catch (e17) {
      }
      if (decodeBase58) {
        if (decodeBase58.version === network.pubKeyHash)
          return payments.p2pkh({ hash: decodeBase58.hash }).output;
        if (decodeBase58.version === network.scriptHash)
          return payments.p2sh({ hash: decodeBase58.hash }).output;
      } else {
        try {
          decodeBech32 = fromBech32(address);
        } catch (e17) {
        }
        if (decodeBech32) {
          if (decodeBech32.prefix !== network.bech32)
            throw new Error(address + " has an invalid prefix");
          if (decodeBech32.version === 0) {
            if (decodeBech32.data.length === 20)
              return payments.p2wpkh({ hash: decodeBech32.data }).output;
            if (decodeBech32.data.length === 32)
              return payments.p2wsh({ hash: decodeBech32.data }).output;
          } else if (decodeBech32.version === 1) {
            if (decodeBech32.data.length === 32)
              return payments.p2tr({ pubkey: decodeBech32.data }).output;
          } else if (decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION && decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION && decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE && decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE) {
            console.warn(FUTURE_SEGWIT_VERSION_WARNING);
            return bscript.compile([
              decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,
              decodeBech32.data
            ]);
          }
        }
      }
      throw new Error(address + " has no matching Script");
    }
    exports.toOutputScript = toOutputScript;
  }
});

// node_modules/bitcoinjs-lib/src/merkle.js
var require_merkle = __commonJS({
  "node_modules/bitcoinjs-lib/src/merkle.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fastMerkleRoot = void 0;
    function fastMerkleRoot(values, digestFn) {
      if (!Array.isArray(values)) throw TypeError("Expected values Array");
      if (typeof digestFn !== "function")
        throw TypeError("Expected digest Function");
      let length = values.length;
      const results = values.concat();
      while (length > 1) {
        let j6 = 0;
        for (let i18 = 0; i18 < length; i18 += 2, ++j6) {
          const left = results[i18];
          const right = i18 + 1 === length ? left : results[i18 + 1];
          const data = Buffer.concat([left, right]);
          results[j6] = digestFn(data);
        }
        length = j6;
      }
      return results[0];
    }
    exports.fastMerkleRoot = fastMerkleRoot;
  }
});

// node_modules/bitcoinjs-lib/src/transaction.js
var require_transaction = __commonJS({
  "node_modules/bitcoinjs-lib/src/transaction.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto5();
    var bscript = require_script();
    var script_1 = require_script();
    var types = require_types();
    var { typeforce } = types;
    function varSliceSize(someScript) {
      const length = someScript.length;
      return bufferutils_1.varuint.encodingLength(length) + length;
    }
    function vectorSize(someVector) {
      const length = someVector.length;
      return bufferutils_1.varuint.encodingLength(length) + someVector.reduce((sum, witness) => {
        return sum + varSliceSize(witness);
      }, 0);
    }
    var EMPTY_BUFFER = Buffer.allocUnsafe(0);
    var EMPTY_WITNESS = [];
    var ZERO = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000000",
      "hex"
    );
    var ONE = Buffer.from(
      "0000000000000000000000000000000000000000000000000000000000000001",
      "hex"
    );
    var VALUE_UINT64_MAX = Buffer.from("ffffffffffffffff", "hex");
    var BLANK_OUTPUT = {
      script: EMPTY_BUFFER,
      valueBuffer: VALUE_UINT64_MAX
    };
    function isOutput(out) {
      return out.value !== void 0;
    }
    var Transaction = class _Transaction {
      constructor() {
        this.version = 1;
        this.locktime = 0;
        this.ins = [];
        this.outs = [];
      }
      static fromBuffer(buffer, _NO_STRICT) {
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const tx = new _Transaction();
        tx.version = bufferReader.readInt32();
        const marker = bufferReader.readUInt8();
        const flag = bufferReader.readUInt8();
        let hasWitnesses = false;
        if (marker === _Transaction.ADVANCED_TRANSACTION_MARKER && flag === _Transaction.ADVANCED_TRANSACTION_FLAG) {
          hasWitnesses = true;
        } else {
          bufferReader.offset -= 2;
        }
        const vinLen = bufferReader.readVarInt();
        for (let i18 = 0; i18 < vinLen; ++i18) {
          tx.ins.push({
            hash: bufferReader.readSlice(32),
            index: bufferReader.readUInt32(),
            script: bufferReader.readVarSlice(),
            sequence: bufferReader.readUInt32(),
            witness: EMPTY_WITNESS
          });
        }
        const voutLen = bufferReader.readVarInt();
        for (let i18 = 0; i18 < voutLen; ++i18) {
          tx.outs.push({
            value: bufferReader.readUInt64(),
            script: bufferReader.readVarSlice()
          });
        }
        if (hasWitnesses) {
          for (let i18 = 0; i18 < vinLen; ++i18) {
            tx.ins[i18].witness = bufferReader.readVector();
          }
          if (!tx.hasWitnesses())
            throw new Error("Transaction has superfluous witness data");
        }
        tx.locktime = bufferReader.readUInt32();
        if (_NO_STRICT) return tx;
        if (bufferReader.offset !== buffer.length)
          throw new Error("Transaction has unexpected data");
        return tx;
      }
      static fromHex(hex) {
        return _Transaction.fromBuffer(Buffer.from(hex, "hex"), false);
      }
      static isCoinbaseHash(buffer) {
        typeforce(types.Hash256bit, buffer);
        for (let i18 = 0; i18 < 32; ++i18) {
          if (buffer[i18] !== 0) return false;
        }
        return true;
      }
      isCoinbase() {
        return this.ins.length === 1 && _Transaction.isCoinbaseHash(this.ins[0].hash);
      }
      addInput(hash, index, sequence, scriptSig) {
        typeforce(
          types.tuple(
            types.Hash256bit,
            types.UInt32,
            types.maybe(types.UInt32),
            types.maybe(types.Buffer)
          ),
          arguments
        );
        if (types.Null(sequence)) {
          sequence = _Transaction.DEFAULT_SEQUENCE;
        }
        return this.ins.push({
          hash,
          index,
          script: scriptSig || EMPTY_BUFFER,
          sequence,
          witness: EMPTY_WITNESS
        }) - 1;
      }
      addOutput(scriptPubKey, value) {
        typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);
        return this.outs.push({
          script: scriptPubKey,
          value
        }) - 1;
      }
      hasWitnesses() {
        return this.ins.some((x15) => {
          return x15.witness.length !== 0;
        });
      }
      weight() {
        const base = this.byteLength(false);
        const total = this.byteLength(true);
        return base * 3 + total;
      }
      virtualSize() {
        return Math.ceil(this.weight() / 4);
      }
      byteLength(_ALLOW_WITNESS = true) {
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        return (hasWitnesses ? 10 : 8) + bufferutils_1.varuint.encodingLength(this.ins.length) + bufferutils_1.varuint.encodingLength(this.outs.length) + this.ins.reduce((sum, input) => {
          return sum + 40 + varSliceSize(input.script);
        }, 0) + this.outs.reduce((sum, output) => {
          return sum + 8 + varSliceSize(output.script);
        }, 0) + (hasWitnesses ? this.ins.reduce((sum, input) => {
          return sum + vectorSize(input.witness);
        }, 0) : 0);
      }
      clone() {
        const newTx = new _Transaction();
        newTx.version = this.version;
        newTx.locktime = this.locktime;
        newTx.ins = this.ins.map((txIn) => {
          return {
            hash: txIn.hash,
            index: txIn.index,
            script: txIn.script,
            sequence: txIn.sequence,
            witness: txIn.witness
          };
        });
        newTx.outs = this.outs.map((txOut) => {
          return {
            script: txOut.script,
            value: txOut.value
          };
        });
        return newTx;
      }
      /**
       * Hash transaction for signing a specific input.
       *
       * Bitcoin uses a different hash for each signed transaction input.
       * This method copies the transaction, makes the necessary changes based on the
       * hashType, and then hashes the result.
       * This hash can then be used to sign the provided transaction input.
       */
      hashForSignature(inIndex, prevOutScript, hashType) {
        typeforce(
          types.tuple(
            types.UInt32,
            types.Buffer,
            /* types.UInt8 */
            types.Number
          ),
          arguments
        );
        if (inIndex >= this.ins.length) return ONE;
        const ourScript = bscript.compile(
          bscript.decompile(prevOutScript).filter((x15) => {
            return x15 !== script_1.OPS.OP_CODESEPARATOR;
          })
        );
        const txTmp = this.clone();
        if ((hashType & 31) === _Transaction.SIGHASH_NONE) {
          txTmp.outs = [];
          txTmp.ins.forEach((input, i18) => {
            if (i18 === inIndex) return;
            input.sequence = 0;
          });
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE) {
          if (inIndex >= this.outs.length) return ONE;
          txTmp.outs.length = inIndex + 1;
          for (let i18 = 0; i18 < inIndex; i18++) {
            txTmp.outs[i18] = BLANK_OUTPUT;
          }
          txTmp.ins.forEach((input, y13) => {
            if (y13 === inIndex) return;
            input.sequence = 0;
          });
        }
        if (hashType & _Transaction.SIGHASH_ANYONECANPAY) {
          txTmp.ins = [txTmp.ins[inIndex]];
          txTmp.ins[0].script = ourScript;
        } else {
          txTmp.ins.forEach((input) => {
            input.script = EMPTY_BUFFER;
          });
          txTmp.ins[inIndex].script = ourScript;
        }
        const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);
        buffer.writeInt32LE(hashType, buffer.length - 4);
        txTmp.__toBuffer(buffer, 0, false);
        return bcrypto.hash256(buffer);
      }
      hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {
        typeforce(
          types.tuple(
            types.UInt32,
            typeforce.arrayOf(types.Buffer),
            typeforce.arrayOf(types.Satoshi),
            types.UInt32
          ),
          arguments
        );
        if (values.length !== this.ins.length || prevOutScripts.length !== this.ins.length) {
          throw new Error("Must supply prevout script and value for all inputs");
        }
        const outputType = hashType === _Transaction.SIGHASH_DEFAULT ? _Transaction.SIGHASH_ALL : hashType & _Transaction.SIGHASH_OUTPUT_MASK;
        const inputType = hashType & _Transaction.SIGHASH_INPUT_MASK;
        const isAnyoneCanPay = inputType === _Transaction.SIGHASH_ANYONECANPAY;
        const isNone = outputType === _Transaction.SIGHASH_NONE;
        const isSingle = outputType === _Transaction.SIGHASH_SINGLE;
        let hashPrevouts = EMPTY_BUFFER;
        let hashAmounts = EMPTY_BUFFER;
        let hashScriptPubKeys = EMPTY_BUFFER;
        let hashSequences = EMPTY_BUFFER;
        let hashOutputs = EMPTY_BUFFER;
        if (!isAnyoneCanPay) {
          let bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            36 * this.ins.length
          );
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 * this.ins.length
          );
          values.forEach((value) => bufferWriter.writeUInt64(value));
          hashAmounts = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            prevOutScripts.map(varSliceSize).reduce((a24, b10) => a24 + b10)
          );
          prevOutScripts.forEach(
            (prevOutScript) => bufferWriter.writeVarSlice(prevOutScript)
          );
          hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());
          bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            4 * this.ins.length
          );
          this.ins.forEach((txIn) => bufferWriter.writeUInt32(txIn.sequence));
          hashSequences = bcrypto.sha256(bufferWriter.end());
        }
        if (!(isNone || isSingle)) {
          const txOutsSize = this.outs.map((output) => 8 + varSliceSize(output.script)).reduce((a24, b10) => a24 + b10);
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        } else if (isSingle && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            8 + varSliceSize(output.script)
          );
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.sha256(bufferWriter.end());
        }
        const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);
        const sigMsgSize = 174 - (isAnyoneCanPay ? 49 : 0) - (isNone ? 32 : 0) + (annex ? 32 : 0) + (leafHash ? 37 : 0);
        const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);
        sigMsgWriter.writeUInt8(hashType);
        sigMsgWriter.writeInt32(this.version);
        sigMsgWriter.writeUInt32(this.locktime);
        sigMsgWriter.writeSlice(hashPrevouts);
        sigMsgWriter.writeSlice(hashAmounts);
        sigMsgWriter.writeSlice(hashScriptPubKeys);
        sigMsgWriter.writeSlice(hashSequences);
        if (!(isNone || isSingle)) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        sigMsgWriter.writeUInt8(spendType);
        if (isAnyoneCanPay) {
          const input = this.ins[inIndex];
          sigMsgWriter.writeSlice(input.hash);
          sigMsgWriter.writeUInt32(input.index);
          sigMsgWriter.writeUInt64(values[inIndex]);
          sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);
          sigMsgWriter.writeUInt32(input.sequence);
        } else {
          sigMsgWriter.writeUInt32(inIndex);
        }
        if (annex) {
          const bufferWriter = bufferutils_1.BufferWriter.withCapacity(
            varSliceSize(annex)
          );
          bufferWriter.writeVarSlice(annex);
          sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));
        }
        if (isSingle) {
          sigMsgWriter.writeSlice(hashOutputs);
        }
        if (leafHash) {
          sigMsgWriter.writeSlice(leafHash);
          sigMsgWriter.writeUInt8(0);
          sigMsgWriter.writeUInt32(4294967295);
        }
        return bcrypto.taggedHash(
          "TapSighash",
          Buffer.concat([Buffer.from([0]), sigMsgWriter.end()])
        );
      }
      hashForWitnessV0(inIndex, prevOutScript, value, hashType) {
        typeforce(
          types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),
          arguments
        );
        let tbuffer = Buffer.from([]);
        let bufferWriter;
        let hashOutputs = ZERO;
        let hashPrevouts = ZERO;
        let hashSequence = ZERO;
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY)) {
          tbuffer = Buffer.allocUnsafe(36 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeSlice(txIn.hash);
            bufferWriter.writeUInt32(txIn.index);
          });
          hashPrevouts = bcrypto.hash256(tbuffer);
        }
        if (!(hashType & _Transaction.SIGHASH_ANYONECANPAY) && (hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          tbuffer = Buffer.allocUnsafe(4 * this.ins.length);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.ins.forEach((txIn) => {
            bufferWriter.writeUInt32(txIn.sequence);
          });
          hashSequence = bcrypto.hash256(tbuffer);
        }
        if ((hashType & 31) !== _Transaction.SIGHASH_SINGLE && (hashType & 31) !== _Transaction.SIGHASH_NONE) {
          const txOutsSize = this.outs.reduce((sum, output) => {
            return sum + 8 + varSliceSize(output.script);
          }, 0);
          tbuffer = Buffer.allocUnsafe(txOutsSize);
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          this.outs.forEach((out) => {
            bufferWriter.writeUInt64(out.value);
            bufferWriter.writeVarSlice(out.script);
          });
          hashOutputs = bcrypto.hash256(tbuffer);
        } else if ((hashType & 31) === _Transaction.SIGHASH_SINGLE && inIndex < this.outs.length) {
          const output = this.outs[inIndex];
          tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));
          bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
          bufferWriter.writeUInt64(output.value);
          bufferWriter.writeVarSlice(output.script);
          hashOutputs = bcrypto.hash256(tbuffer);
        }
        tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));
        bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);
        const input = this.ins[inIndex];
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(hashPrevouts);
        bufferWriter.writeSlice(hashSequence);
        bufferWriter.writeSlice(input.hash);
        bufferWriter.writeUInt32(input.index);
        bufferWriter.writeVarSlice(prevOutScript);
        bufferWriter.writeUInt64(value);
        bufferWriter.writeUInt32(input.sequence);
        bufferWriter.writeSlice(hashOutputs);
        bufferWriter.writeUInt32(this.locktime);
        bufferWriter.writeUInt32(hashType);
        return bcrypto.hash256(tbuffer);
      }
      getHash(forWitness) {
        if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);
        return bcrypto.hash256(this.__toBuffer(void 0, void 0, forWitness));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(
          "hex"
        );
      }
      toBuffer(buffer, initialOffset) {
        return this.__toBuffer(buffer, initialOffset, true);
      }
      toHex() {
        return this.toBuffer(void 0, void 0).toString("hex");
      }
      setInputScript(index, scriptSig) {
        typeforce(types.tuple(types.Number, types.Buffer), arguments);
        this.ins[index].script = scriptSig;
      }
      setWitness(index, witness) {
        typeforce(types.tuple(types.Number, [types.Buffer]), arguments);
        this.ins[index].witness = witness;
      }
      __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {
        if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));
        const bufferWriter = new bufferutils_1.BufferWriter(
          buffer,
          initialOffset || 0
        );
        bufferWriter.writeInt32(this.version);
        const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();
        if (hasWitnesses) {
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_MARKER);
          bufferWriter.writeUInt8(_Transaction.ADVANCED_TRANSACTION_FLAG);
        }
        bufferWriter.writeVarInt(this.ins.length);
        this.ins.forEach((txIn) => {
          bufferWriter.writeSlice(txIn.hash);
          bufferWriter.writeUInt32(txIn.index);
          bufferWriter.writeVarSlice(txIn.script);
          bufferWriter.writeUInt32(txIn.sequence);
        });
        bufferWriter.writeVarInt(this.outs.length);
        this.outs.forEach((txOut) => {
          if (isOutput(txOut)) {
            bufferWriter.writeUInt64(txOut.value);
          } else {
            bufferWriter.writeSlice(txOut.valueBuffer);
          }
          bufferWriter.writeVarSlice(txOut.script);
        });
        if (hasWitnesses) {
          this.ins.forEach((input) => {
            bufferWriter.writeVector(input.witness);
          });
        }
        bufferWriter.writeUInt32(this.locktime);
        if (initialOffset !== void 0)
          return buffer.slice(initialOffset, bufferWriter.offset);
        return buffer;
      }
    };
    exports.Transaction = Transaction;
    Transaction.DEFAULT_SEQUENCE = 4294967295;
    Transaction.SIGHASH_DEFAULT = 0;
    Transaction.SIGHASH_ALL = 1;
    Transaction.SIGHASH_NONE = 2;
    Transaction.SIGHASH_SINGLE = 3;
    Transaction.SIGHASH_ANYONECANPAY = 128;
    Transaction.SIGHASH_OUTPUT_MASK = 3;
    Transaction.SIGHASH_INPUT_MASK = 128;
    Transaction.ADVANCED_TRANSACTION_MARKER = 0;
    Transaction.ADVANCED_TRANSACTION_FLAG = 1;
  }
});

// node_modules/bitcoinjs-lib/src/block.js
var require_block = __commonJS({
  "node_modules/bitcoinjs-lib/src/block.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Block = void 0;
    var bufferutils_1 = require_bufferutils();
    var bcrypto = require_crypto5();
    var merkle_1 = require_merkle();
    var transaction_1 = require_transaction();
    var types = require_types();
    var { typeforce } = types;
    var errorMerkleNoTxes = new TypeError(
      "Cannot compute merkle root for zero transactions"
    );
    var errorWitnessNotSegwit = new TypeError(
      "Cannot compute witness commit for non-segwit block"
    );
    var Block = class _Block {
      constructor() {
        this.version = 1;
        this.prevHash = void 0;
        this.merkleRoot = void 0;
        this.timestamp = 0;
        this.witnessCommit = void 0;
        this.bits = 0;
        this.nonce = 0;
        this.transactions = void 0;
      }
      static fromBuffer(buffer) {
        if (buffer.length < 80) throw new Error("Buffer too small (< 80 bytes)");
        const bufferReader = new bufferutils_1.BufferReader(buffer);
        const block = new _Block();
        block.version = bufferReader.readInt32();
        block.prevHash = bufferReader.readSlice(32);
        block.merkleRoot = bufferReader.readSlice(32);
        block.timestamp = bufferReader.readUInt32();
        block.bits = bufferReader.readUInt32();
        block.nonce = bufferReader.readUInt32();
        if (buffer.length === 80) return block;
        const readTransaction = () => {
          const tx = transaction_1.Transaction.fromBuffer(
            bufferReader.buffer.slice(bufferReader.offset),
            true
          );
          bufferReader.offset += tx.byteLength();
          return tx;
        };
        const nTransactions = bufferReader.readVarInt();
        block.transactions = [];
        for (let i18 = 0; i18 < nTransactions; ++i18) {
          const tx = readTransaction();
          block.transactions.push(tx);
        }
        const witnessCommit = block.getWitnessCommit();
        if (witnessCommit) block.witnessCommit = witnessCommit;
        return block;
      }
      static fromHex(hex) {
        return _Block.fromBuffer(Buffer.from(hex, "hex"));
      }
      static calculateTarget(bits) {
        const exponent = ((bits & 4278190080) >> 24) - 3;
        const mantissa = bits & 8388607;
        const target = Buffer.alloc(32, 0);
        target.writeUIntBE(mantissa, 29 - exponent, 3);
        return target;
      }
      static calculateMerkleRoot(transactions, forWitness) {
        typeforce([{ getHash: types.Function }], transactions);
        if (transactions.length === 0) throw errorMerkleNoTxes;
        if (forWitness && !txesHaveWitnessCommit(transactions))
          throw errorWitnessNotSegwit;
        const hashes = transactions.map(
          (transaction) => transaction.getHash(forWitness)
        );
        const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);
        return forWitness ? bcrypto.hash256(
          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])
        ) : rootHash;
      }
      getWitnessCommit() {
        if (!txesHaveWitnessCommit(this.transactions)) return null;
        const witnessCommits = this.transactions[0].outs.filter(
          (out) => out.script.slice(0, 6).equals(Buffer.from("6a24aa21a9ed", "hex"))
        ).map((out) => out.script.slice(6, 38));
        if (witnessCommits.length === 0) return null;
        const result = witnessCommits[witnessCommits.length - 1];
        if (!(result instanceof Buffer && result.length === 32)) return null;
        return result;
      }
      hasWitnessCommit() {
        if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32)
          return true;
        if (this.getWitnessCommit() !== null) return true;
        return false;
      }
      hasWitness() {
        return anyTxHasWitness(this.transactions);
      }
      weight() {
        const base = this.byteLength(false, false);
        const total = this.byteLength(false, true);
        return base * 3 + total;
      }
      byteLength(headersOnly, allowWitness = true) {
        if (headersOnly || !this.transactions) return 80;
        return 80 + bufferutils_1.varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a24, x15) => a24 + x15.byteLength(allowWitness), 0);
      }
      getHash() {
        return bcrypto.hash256(this.toBuffer(true));
      }
      getId() {
        return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString("hex");
      }
      getUTCDate() {
        const date2 = /* @__PURE__ */ new Date(0);
        date2.setUTCSeconds(this.timestamp);
        return date2;
      }
      // TODO: buffer, offset compatibility
      toBuffer(headersOnly) {
        const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));
        const bufferWriter = new bufferutils_1.BufferWriter(buffer);
        bufferWriter.writeInt32(this.version);
        bufferWriter.writeSlice(this.prevHash);
        bufferWriter.writeSlice(this.merkleRoot);
        bufferWriter.writeUInt32(this.timestamp);
        bufferWriter.writeUInt32(this.bits);
        bufferWriter.writeUInt32(this.nonce);
        if (headersOnly || !this.transactions) return buffer;
        bufferutils_1.varuint.encode(
          this.transactions.length,
          buffer,
          bufferWriter.offset
        );
        bufferWriter.offset += bufferutils_1.varuint.encode.bytes;
        this.transactions.forEach((tx) => {
          const txSize = tx.byteLength();
          tx.toBuffer(buffer, bufferWriter.offset);
          bufferWriter.offset += txSize;
        });
        return buffer;
      }
      toHex(headersOnly) {
        return this.toBuffer(headersOnly).toString("hex");
      }
      checkTxRoots() {
        const hasWitnessCommit = this.hasWitnessCommit();
        if (!hasWitnessCommit && this.hasWitness()) return false;
        return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);
      }
      checkProofOfWork() {
        const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());
        const target = _Block.calculateTarget(this.bits);
        return hash.compare(target) <= 0;
      }
      __checkMerkleRoot() {
        if (!this.transactions) throw errorMerkleNoTxes;
        const actualMerkleRoot = _Block.calculateMerkleRoot(this.transactions);
        return this.merkleRoot.compare(actualMerkleRoot) === 0;
      }
      __checkWitnessCommit() {
        if (!this.transactions) throw errorMerkleNoTxes;
        if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;
        const actualWitnessCommit = _Block.calculateMerkleRoot(
          this.transactions,
          true
        );
        return this.witnessCommit.compare(actualWitnessCommit) === 0;
      }
    };
    exports.Block = Block;
    function txesHaveWitnessCommit(transactions) {
      return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;
    }
    function anyTxHasWitness(transactions) {
      return transactions instanceof Array && transactions.some(
        (tx) => typeof tx === "object" && tx.ins instanceof Array && tx.ins.some(
          (input) => typeof input === "object" && input.witness instanceof Array && input.witness.length > 0
        )
      );
    }
  }
});

// node_modules/bip174/src/lib/typeFields.js
var require_typeFields = __commonJS({
  "node_modules/bip174/src/lib/typeFields.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var GlobalTypes;
    (function(GlobalTypes2) {
      GlobalTypes2[GlobalTypes2["UNSIGNED_TX"] = 0] = "UNSIGNED_TX";
      GlobalTypes2[GlobalTypes2["GLOBAL_XPUB"] = 1] = "GLOBAL_XPUB";
    })(GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {}));
    exports.GLOBAL_TYPE_NAMES = ["unsignedTx", "globalXpub"];
    var InputTypes;
    (function(InputTypes2) {
      InputTypes2[InputTypes2["NON_WITNESS_UTXO"] = 0] = "NON_WITNESS_UTXO";
      InputTypes2[InputTypes2["WITNESS_UTXO"] = 1] = "WITNESS_UTXO";
      InputTypes2[InputTypes2["PARTIAL_SIG"] = 2] = "PARTIAL_SIG";
      InputTypes2[InputTypes2["SIGHASH_TYPE"] = 3] = "SIGHASH_TYPE";
      InputTypes2[InputTypes2["REDEEM_SCRIPT"] = 4] = "REDEEM_SCRIPT";
      InputTypes2[InputTypes2["WITNESS_SCRIPT"] = 5] = "WITNESS_SCRIPT";
      InputTypes2[InputTypes2["BIP32_DERIVATION"] = 6] = "BIP32_DERIVATION";
      InputTypes2[InputTypes2["FINAL_SCRIPTSIG"] = 7] = "FINAL_SCRIPTSIG";
      InputTypes2[InputTypes2["FINAL_SCRIPTWITNESS"] = 8] = "FINAL_SCRIPTWITNESS";
      InputTypes2[InputTypes2["POR_COMMITMENT"] = 9] = "POR_COMMITMENT";
      InputTypes2[InputTypes2["TAP_KEY_SIG"] = 19] = "TAP_KEY_SIG";
      InputTypes2[InputTypes2["TAP_SCRIPT_SIG"] = 20] = "TAP_SCRIPT_SIG";
      InputTypes2[InputTypes2["TAP_LEAF_SCRIPT"] = 21] = "TAP_LEAF_SCRIPT";
      InputTypes2[InputTypes2["TAP_BIP32_DERIVATION"] = 22] = "TAP_BIP32_DERIVATION";
      InputTypes2[InputTypes2["TAP_INTERNAL_KEY"] = 23] = "TAP_INTERNAL_KEY";
      InputTypes2[InputTypes2["TAP_MERKLE_ROOT"] = 24] = "TAP_MERKLE_ROOT";
    })(InputTypes = exports.InputTypes || (exports.InputTypes = {}));
    exports.INPUT_TYPE_NAMES = [
      "nonWitnessUtxo",
      "witnessUtxo",
      "partialSig",
      "sighashType",
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "finalScriptSig",
      "finalScriptWitness",
      "porCommitment",
      "tapKeySig",
      "tapScriptSig",
      "tapLeafScript",
      "tapBip32Derivation",
      "tapInternalKey",
      "tapMerkleRoot"
    ];
    var OutputTypes;
    (function(OutputTypes2) {
      OutputTypes2[OutputTypes2["REDEEM_SCRIPT"] = 0] = "REDEEM_SCRIPT";
      OutputTypes2[OutputTypes2["WITNESS_SCRIPT"] = 1] = "WITNESS_SCRIPT";
      OutputTypes2[OutputTypes2["BIP32_DERIVATION"] = 2] = "BIP32_DERIVATION";
      OutputTypes2[OutputTypes2["TAP_INTERNAL_KEY"] = 5] = "TAP_INTERNAL_KEY";
      OutputTypes2[OutputTypes2["TAP_TREE"] = 6] = "TAP_TREE";
      OutputTypes2[OutputTypes2["TAP_BIP32_DERIVATION"] = 7] = "TAP_BIP32_DERIVATION";
    })(OutputTypes = exports.OutputTypes || (exports.OutputTypes = {}));
    exports.OUTPUT_TYPE_NAMES = [
      "redeemScript",
      "witnessScript",
      "bip32Derivation",
      "tapInternalKey",
      "tapTree",
      "tapBip32Derivation"
    ];
  }
});

// node_modules/bip174/src/lib/converter/global/globalXpub.js
var require_globalXpub = __commonJS({
  "node_modules/bip174/src/lib/converter/global/globalXpub.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var range = (n13) => [...Array(n13).keys()];
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {
        throw new Error(
          "Decode Error: could not decode globalXpub with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {
        throw new Error(
          "Decode Error: globalXpub has invalid extended pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length / 4 % 1 !== 0) {
        throw new Error(
          "Decode Error: Global GLOBAL_XPUB value length should be multiple of 4"
        );
      }
      const extendedPubkey = keyVal.key.slice(1);
      const data = {
        masterFingerprint: keyVal.value.slice(0, 4),
        extendedPubkey,
        path: "m"
      };
      for (const i18 of range(keyVal.value.length / 4 - 1)) {
        const val = keyVal.value.readUInt32LE(i18 * 4 + 4);
        const isHard = !!(val & 2147483648);
        const idx = val & 2147483647;
        data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
      }
      return data;
    }
    exports.decode = decode;
    function encode(data) {
      const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);
      const key = Buffer.concat([head, data.extendedPubkey]);
      const splitPath = data.path.split("/");
      const value = Buffer.allocUnsafe(splitPath.length * 4);
      data.masterFingerprint.copy(value, 0);
      let offset = 4;
      splitPath.slice(1).forEach((level) => {
        const isHard = level.slice(-1) === "'";
        let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
        if (isHard) num += 2147483648;
        value.writeUInt32LE(num, offset);
        offset += 4;
      });
      return {
        key,
        value
      };
    }
    exports.encode = encode;
    exports.expected = "{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }";
    function check(data) {
      const epk = data.extendedPubkey;
      const mfp = data.masterFingerprint;
      const p20 = data.path;
      return Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p20 === "string" && !!p20.match(/^m(\/\d+'?)*$/);
    }
    exports.check = check;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.extendedPubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v8) => v8.extendedPubkey.equals(item.extendedPubkey)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/global/unsignedTx.js
var require_unsignedTx = __commonJS({
  "node_modules/bip174/src/lib/converter/global/unsignedTx.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),
        value: data.toBuffer()
      };
    }
    exports.encode = encode;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptSig.js
var require_finalScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptSig.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {
        throw new Error(
          "Decode Error: could not decode finalScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);
      return {
        key,
        value: data
      };
    }
    exports.encode = encode;
    exports.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptSig === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/finalScriptWitness.js
var require_finalScriptWitness = __commonJS({
  "node_modules/bip174/src/lib/converter/input/finalScriptWitness.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {
        throw new Error(
          "Decode Error: could not decode finalScriptWitness with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);
      return {
        key,
        value: data
      };
    }
    exports.encode = encode;
    exports.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.finalScriptWitness === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js
var require_nonWitnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/nonWitnessUtxo.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode nonWitnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode(data) {
      return {
        key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),
        value: data
      };
    }
    exports.encode = encode;
    exports.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data);
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.nonWitnessUtxo === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/partialSig.js
var require_partialSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/partialSig.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {
        throw new Error(
          "Decode Error: could not decode partialSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {
        throw new Error(
          "Decode Error: partialSig has invalid pubkey in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1);
      return {
        pubkey,
        signature: keyVal.value
      };
    }
    exports.decode = decode;
    function encode(pSig) {
      const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);
      return {
        key: Buffer.concat([head, pSig.pubkey]),
        value: pSig.signature
      };
    }
    exports.encode = encode;
    exports.expected = "{ pubkey: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.signature) && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && isDerSigWithSighash(data.signature);
    }
    exports.check = check;
    function isDerSigWithSighash(buf) {
      if (!Buffer.isBuffer(buf) || buf.length < 9) return false;
      if (buf[0] !== 48) return false;
      if (buf.length !== buf[1] + 3) return false;
      if (buf[2] !== 2) return false;
      const rLen = buf[3];
      if (rLen > 33 || rLen < 1) return false;
      if (buf[3 + rLen + 1] !== 2) return false;
      const sLen = buf[3 + rLen + 2];
      if (sLen > 33 || sLen < 1) return false;
      if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;
      return true;
    }
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v8) => v8.pubkey.equals(item.pubkey)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/porCommitment.js
var require_porCommitment = __commonJS({
  "node_modules/bip174/src/lib/converter/input/porCommitment.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {
        throw new Error(
          "Decode Error: could not decode porCommitment with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.toString("utf8");
    }
    exports.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);
      return {
        key,
        value: Buffer.from(data, "utf8")
      };
    }
    exports.encode = encode;
    exports.expected = "string";
    function check(data) {
      return typeof data === "string";
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.porCommitment === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/sighashType.js
var require_sighashType = __commonJS({
  "node_modules/bip174/src/lib/converter/input/sighashType.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {
        throw new Error(
          "Decode Error: could not decode sighashType with key 0x" + keyVal.key.toString("hex")
        );
      }
      return keyVal.value.readUInt32LE(0);
    }
    exports.decode = decode;
    function encode(data) {
      const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);
      const value = Buffer.allocUnsafe(4);
      value.writeUInt32LE(data, 0);
      return {
        key,
        value
      };
    }
    exports.encode = encode;
    exports.expected = "number";
    function check(data) {
      return typeof data === "number";
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.sighashType === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapKeySig.js
var require_tapKeySig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapKeySig.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapKeySig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error(
          "Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature"
        );
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);
      return { key, value };
    }
    exports.encode = encode;
    exports.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapKeySig === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapLeafScript.js
var require_tapLeafScript = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapLeafScript.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {
        throw new Error(
          "Decode Error: could not decode tapLeafScript with key 0x" + keyVal.key.toString("hex")
        );
      }
      if ((keyVal.key.length - 2) % 32 !== 0) {
        throw new Error(
          "Decode Error: tapLeafScript has invalid control block in key 0x" + keyVal.key.toString("hex")
        );
      }
      const leafVersion = keyVal.value[keyVal.value.length - 1];
      if ((keyVal.key[1] & 254) !== leafVersion) {
        throw new Error(
          "Decode Error: tapLeafScript bad leaf version in key 0x" + keyVal.key.toString("hex")
        );
      }
      const script = keyVal.value.slice(0, -1);
      const controlBlock = keyVal.key.slice(1);
      return { controlBlock, script, leafVersion };
    }
    exports.decode = decode;
    function encode(tScript) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);
      const verBuf = Buffer.from([tScript.leafVersion]);
      return {
        key: Buffer.concat([head, tScript.controlBlock]),
        value: Buffer.concat([tScript.script, verBuf])
      };
    }
    exports.encode = encode;
    exports.expected = "{ controlBlock: Buffer; leafVersion: number, script: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.controlBlock) && (data.controlBlock.length - 1) % 32 === 0 && (data.controlBlock[0] & 254) === data.leafVersion && Buffer.isBuffer(data.script);
    }
    exports.check = check;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.controlBlock.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter((v8) => v8.controlBlock.equals(item.controlBlock)).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js
var require_tapMerkleRoot = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapMerkleRoot.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapMerkleRoot with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (!check(keyVal.value)) {
        throw new Error("Decode Error: tapMerkleRoot not a 32-byte hash");
      }
      return keyVal.value;
    }
    exports.decode = decode;
    function encode(value) {
      const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);
      return { key, value };
    }
    exports.encode = encode;
    exports.expected = "Buffer";
    function check(data) {
      return Buffer.isBuffer(data) && data.length === 32;
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapMerkleRoot === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/input/tapScriptSig.js
var require_tapScriptSig = __commonJS({
  "node_modules/bip174/src/lib/converter/input/tapScriptSig.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {
        throw new Error(
          "Decode Error: could not decode tapScriptSig with key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.key.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid key 0x" + keyVal.key.toString("hex")
        );
      }
      if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {
        throw new Error(
          "Decode Error: tapScriptSig has invalid signature in key 0x" + keyVal.key.toString("hex")
        );
      }
      const pubkey = keyVal.key.slice(1, 33);
      const leafHash = keyVal.key.slice(33);
      return {
        pubkey,
        leafHash,
        signature: keyVal.value
      };
    }
    exports.decode = decode;
    function encode(tSig) {
      const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);
      return {
        key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),
        value: tSig.signature
      };
    }
    exports.encode = encode;
    exports.expected = "{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }";
    function check(data) {
      return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.leafHash) && Buffer.isBuffer(data.signature) && data.pubkey.length === 32 && data.leafHash.length === 32 && (data.signature.length === 64 || data.signature.length === 65);
    }
    exports.check = check;
    function canAddToArray(array2, item, dupeSet) {
      const dupeString = item.pubkey.toString("hex") + item.leafHash.toString("hex");
      if (dupeSet.has(dupeString)) return false;
      dupeSet.add(dupeString);
      return array2.filter(
        (v8) => v8.pubkey.equals(item.pubkey) && v8.leafHash.equals(item.leafHash)
      ).length === 0;
    }
    exports.canAddToArray = canAddToArray;
  }
});

// node_modules/bip174/src/lib/converter/varint.js
var require_varint = __commonJS({
  "node_modules/bip174/src/lib/converter/varint.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var MAX_SAFE_INTEGER = 9007199254740991;
    function checkUInt53(n13) {
      if (n13 < 0 || n13 > MAX_SAFE_INTEGER || n13 % 1 !== 0)
        throw new RangeError("value out of range");
    }
    function encode(_number, buffer, offset) {
      checkUInt53(_number);
      if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      if (_number < 253) {
        buffer.writeUInt8(_number, offset);
        Object.assign(encode, { bytes: 1 });
      } else if (_number <= 65535) {
        buffer.writeUInt8(253, offset);
        buffer.writeUInt16LE(_number, offset + 1);
        Object.assign(encode, { bytes: 3 });
      } else if (_number <= 4294967295) {
        buffer.writeUInt8(254, offset);
        buffer.writeUInt32LE(_number, offset + 1);
        Object.assign(encode, { bytes: 5 });
      } else {
        buffer.writeUInt8(255, offset);
        buffer.writeUInt32LE(_number >>> 0, offset + 1);
        buffer.writeUInt32LE(_number / 4294967296 | 0, offset + 5);
        Object.assign(encode, { bytes: 9 });
      }
      return buffer;
    }
    exports.encode = encode;
    function decode(buffer, offset) {
      if (!Buffer.isBuffer(buffer))
        throw new TypeError("buffer must be a Buffer instance");
      if (!offset) offset = 0;
      const first = buffer.readUInt8(offset);
      if (first < 253) {
        Object.assign(decode, { bytes: 1 });
        return first;
      } else if (first === 253) {
        Object.assign(decode, { bytes: 3 });
        return buffer.readUInt16LE(offset + 1);
      } else if (first === 254) {
        Object.assign(decode, { bytes: 5 });
        return buffer.readUInt32LE(offset + 1);
      } else {
        Object.assign(decode, { bytes: 9 });
        const lo = buffer.readUInt32LE(offset + 1);
        const hi = buffer.readUInt32LE(offset + 5);
        const _number = hi * 4294967296 + lo;
        checkUInt53(_number);
        return _number;
      }
    }
    exports.decode = decode;
    function encodingLength(_number) {
      checkUInt53(_number);
      return _number < 253 ? 1 : _number <= 65535 ? 3 : _number <= 4294967295 ? 5 : 9;
    }
    exports.encodingLength = encodingLength;
  }
});

// node_modules/bip174/src/lib/converter/tools.js
var require_tools = __commonJS({
  "node_modules/bip174/src/lib/converter/tools.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var varuint = require_varint();
    exports.range = (n13) => [...Array(n13).keys()];
    function reverseBuffer(buffer) {
      if (buffer.length < 1) return buffer;
      let j6 = buffer.length - 1;
      let tmp = 0;
      for (let i18 = 0; i18 < buffer.length / 2; i18++) {
        tmp = buffer[i18];
        buffer[i18] = buffer[j6];
        buffer[j6] = tmp;
        j6--;
      }
      return buffer;
    }
    exports.reverseBuffer = reverseBuffer;
    function keyValsToBuffer(keyVals) {
      const buffers = keyVals.map(keyValToBuffer);
      buffers.push(Buffer.from([0]));
      return Buffer.concat(buffers);
    }
    exports.keyValsToBuffer = keyValsToBuffer;
    function keyValToBuffer(keyVal) {
      const keyLen = keyVal.key.length;
      const valLen = keyVal.value.length;
      const keyVarIntLen = varuint.encodingLength(keyLen);
      const valVarIntLen = varuint.encodingLength(valLen);
      const buffer = Buffer.allocUnsafe(
        keyVarIntLen + keyLen + valVarIntLen + valLen
      );
      varuint.encode(keyLen, buffer, 0);
      keyVal.key.copy(buffer, keyVarIntLen);
      varuint.encode(valLen, buffer, keyVarIntLen + keyLen);
      keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);
      return buffer;
    }
    exports.keyValToBuffer = keyValToBuffer;
    function verifuint(value, max) {
      if (typeof value !== "number")
        throw new Error("cannot write a non-number as a number");
      if (value < 0)
        throw new Error("specified a negative value for writing an unsigned value");
      if (value > max) throw new Error("RangeError: value out of range");
      if (Math.floor(value) !== value)
        throw new Error("value has a fractional component");
    }
    function readUInt64LE(buffer, offset) {
      const a24 = buffer.readUInt32LE(offset);
      let b10 = buffer.readUInt32LE(offset + 4);
      b10 *= 4294967296;
      verifuint(b10 + a24, 9007199254740991);
      return b10 + a24;
    }
    exports.readUInt64LE = readUInt64LE;
    function writeUInt64LE(buffer, value, offset) {
      verifuint(value, 9007199254740991);
      buffer.writeInt32LE(value & -1, offset);
      buffer.writeUInt32LE(Math.floor(value / 4294967296), offset + 4);
      return offset + 8;
    }
    exports.writeUInt64LE = writeUInt64LE;
  }
});

// node_modules/bip174/src/lib/converter/input/witnessUtxo.js
var require_witnessUtxo = __commonJS({
  "node_modules/bip174/src/lib/converter/input/witnessUtxo.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var tools_1 = require_tools();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {
        throw new Error(
          "Decode Error: could not decode witnessUtxo with key 0x" + keyVal.key.toString("hex")
        );
      }
      const value = tools_1.readUInt64LE(keyVal.value, 0);
      let _offset = 8;
      const scriptLen = varuint.decode(keyVal.value, _offset);
      _offset += varuint.encodingLength(scriptLen);
      const script = keyVal.value.slice(_offset);
      if (script.length !== scriptLen) {
        throw new Error("Decode Error: WITNESS_UTXO script is not proper length");
      }
      return {
        script,
        value
      };
    }
    exports.decode = decode;
    function encode(data) {
      const { script, value } = data;
      const varintLen = varuint.encodingLength(script.length);
      const result = Buffer.allocUnsafe(8 + varintLen + script.length);
      tools_1.writeUInt64LE(result, value, 0);
      varuint.encode(script.length, result, 8);
      script.copy(result, 8 + varintLen);
      return {
        key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),
        value: result
      };
    }
    exports.encode = encode;
    exports.expected = "{ script: Buffer; value: number; }";
    function check(data) {
      return Buffer.isBuffer(data.script) && typeof data.value === "number";
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.witnessUtxo === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/output/tapTree.js
var require_tapTree = __commonJS({
  "node_modules/bip174/src/lib/converter/output/tapTree.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var varuint = require_varint();
    function decode(keyVal) {
      if (keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE || keyVal.key.length !== 1) {
        throw new Error(
          "Decode Error: could not decode tapTree with key 0x" + keyVal.key.toString("hex")
        );
      }
      let _offset = 0;
      const data = [];
      while (_offset < keyVal.value.length) {
        const depth = keyVal.value[_offset++];
        const leafVersion = keyVal.value[_offset++];
        const scriptLen = varuint.decode(keyVal.value, _offset);
        _offset += varuint.encodingLength(scriptLen);
        data.push({
          depth,
          leafVersion,
          script: keyVal.value.slice(_offset, _offset + scriptLen)
        });
        _offset += scriptLen;
      }
      return { leaves: data };
    }
    exports.decode = decode;
    function encode(tree) {
      const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);
      const bufs = [].concat(
        ...tree.leaves.map((tapLeaf) => [
          Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),
          varuint.encode(tapLeaf.script.length),
          tapLeaf.script
        ])
      );
      return {
        key,
        value: Buffer.concat(bufs)
      };
    }
    exports.encode = encode;
    exports.expected = "{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }";
    function check(data) {
      return Array.isArray(data.leaves) && data.leaves.every(
        (tapLeaf) => tapLeaf.depth >= 0 && tapLeaf.depth <= 128 && (tapLeaf.leafVersion & 254) === tapLeaf.leafVersion && Buffer.isBuffer(tapLeaf.script)
      );
    }
    exports.check = check;
    function canAdd(currentData, newData) {
      return !!currentData && !!newData && currentData.tapTree === void 0;
    }
    exports.canAdd = canAdd;
  }
});

// node_modules/bip174/src/lib/converter/shared/bip32Derivation.js
var require_bip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/bip32Derivation.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var range = (n13) => [...Array(n13).keys()];
    var isValidDERKey = (pubkey) => pubkey.length === 33 && [2, 3].includes(pubkey[0]) || pubkey.length === 65 && 4 === pubkey[0];
    function makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode bip32Derivation with key 0x" + keyVal.key.toString("hex")
          );
        }
        const pubkey = keyVal.key.slice(1);
        if (!isValidPubkey(pubkey)) {
          throw new Error(
            "Decode Error: bip32Derivation has invalid pubkey in key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length / 4 % 1 !== 0) {
          throw new Error(
            "Decode Error: Input BIP32_DERIVATION value length should be multiple of 4"
          );
        }
        const data = {
          masterFingerprint: keyVal.value.slice(0, 4),
          pubkey,
          path: "m"
        };
        for (const i18 of range(keyVal.value.length / 4 - 1)) {
          const val = keyVal.value.readUInt32LE(i18 * 4 + 4);
          const isHard = !!(val & 2147483648);
          const idx = val & 2147483647;
          data.path += "/" + idx.toString(10) + (isHard ? "'" : "");
        }
        return data;
      }
      function encode(data) {
        const head = Buffer.from([TYPE_BYTE]);
        const key = Buffer.concat([head, data.pubkey]);
        const splitPath = data.path.split("/");
        const value = Buffer.allocUnsafe(splitPath.length * 4);
        data.masterFingerprint.copy(value, 0);
        let offset = 4;
        splitPath.slice(1).forEach((level) => {
          const isHard = level.slice(-1) === "'";
          let num = 2147483647 & parseInt(isHard ? level.slice(0, -1) : level, 10);
          if (isHard) num += 2147483648;
          value.writeUInt32LE(num, offset);
          offset += 4;
        });
        return {
          key,
          value
        };
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }";
      function check(data) {
        return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === "string" && isValidPubkey(data.pubkey) && data.masterFingerprint.length === 4;
      }
      function canAddToArray(array2, item, dupeSet) {
        const dupeString = item.pubkey.toString("hex");
        if (dupeSet.has(dupeString)) return false;
        dupeSet.add(dupeString);
        return array2.filter((v8) => v8.pubkey.equals(item.pubkey)).length === 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/checkPubkey.js
var require_checkPubkey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/checkPubkey.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeChecker(pubkeyTypes) {
      return checkPubkey;
      function checkPubkey(keyVal) {
        let pubkey;
        if (pubkeyTypes.includes(keyVal.key[0])) {
          pubkey = keyVal.key.slice(1);
          if (!(pubkey.length === 33 || pubkey.length === 65) || ![2, 3, 4].includes(pubkey[0])) {
            throw new Error(
              "Format Error: invalid pubkey in key 0x" + keyVal.key.toString("hex")
            );
          }
        }
        return pubkey;
      }
    }
    exports.makeChecker = makeChecker;
  }
});

// node_modules/bip174/src/lib/converter/shared/redeemScript.js
var require_redeemScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/redeemScript.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode redeemScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.redeemScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js
var require_tapBip32Derivation = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapBip32Derivation.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var varuint = require_varint();
    var bip32Derivation = require_bip32Derivation();
    var isValidBIP340Key = (pubkey) => pubkey.length === 32;
    function makeConverter(TYPE_BYTE) {
      const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);
      function decode(keyVal) {
        const nHashes = varuint.decode(keyVal.value);
        const nHashesLen = varuint.encodingLength(nHashes);
        const base = parent.decode({
          key: keyVal.key,
          value: keyVal.value.slice(nHashesLen + nHashes * 32)
        });
        const leafHashes = new Array(nHashes);
        for (let i18 = 0, _offset = nHashesLen; i18 < nHashes; i18++, _offset += 32) {
          leafHashes[i18] = keyVal.value.slice(_offset, _offset + 32);
        }
        return Object.assign({}, base, { leafHashes });
      }
      function encode(data) {
        const base = parent.encode(data);
        const nHashesLen = varuint.encodingLength(data.leafHashes.length);
        const nHashesBuf = Buffer.allocUnsafe(nHashesLen);
        varuint.encode(data.leafHashes.length, nHashesBuf);
        const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);
        return Object.assign({}, base, { value });
      }
      const expected = "{ masterFingerprint: Buffer; pubkey: Buffer; path: string; leafHashes: Buffer[]; }";
      function check(data) {
        return Array.isArray(data.leafHashes) && data.leafHashes.every(
          (leafHash) => Buffer.isBuffer(leafHash) && leafHash.length === 32
        ) && parent.check(data);
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAddToArray: parent.canAddToArray
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/tapInternalKey.js
var require_tapInternalKey = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/tapInternalKey.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {
          throw new Error(
            "Decode Error: could not decode tapInternalKey with key 0x" + keyVal.key.toString("hex")
          );
        }
        if (keyVal.value.length !== 32) {
          throw new Error(
            "Decode Error: tapInternalKey not a 32-byte x-only pubkey"
          );
        }
        return keyVal.value;
      }
      function encode(value) {
        const key = Buffer.from([TYPE_BYTE]);
        return { key, value };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data) && data.length === 32;
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.tapInternalKey === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/shared/witnessScript.js
var require_witnessScript = __commonJS({
  "node_modules/bip174/src/lib/converter/shared/witnessScript.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    function makeConverter(TYPE_BYTE) {
      function decode(keyVal) {
        if (keyVal.key[0] !== TYPE_BYTE) {
          throw new Error(
            "Decode Error: could not decode witnessScript with key 0x" + keyVal.key.toString("hex")
          );
        }
        return keyVal.value;
      }
      function encode(data) {
        const key = Buffer.from([TYPE_BYTE]);
        return {
          key,
          value: data
        };
      }
      const expected = "Buffer";
      function check(data) {
        return Buffer.isBuffer(data);
      }
      function canAdd(currentData, newData) {
        return !!currentData && !!newData && currentData.witnessScript === void 0;
      }
      return {
        decode,
        encode,
        check,
        expected,
        canAdd
      };
    }
    exports.makeConverter = makeConverter;
  }
});

// node_modules/bip174/src/lib/converter/index.js
var require_converter = __commonJS({
  "node_modules/bip174/src/lib/converter/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var typeFields_1 = require_typeFields();
    var globalXpub = require_globalXpub();
    var unsignedTx = require_unsignedTx();
    var finalScriptSig = require_finalScriptSig();
    var finalScriptWitness = require_finalScriptWitness();
    var nonWitnessUtxo = require_nonWitnessUtxo();
    var partialSig = require_partialSig();
    var porCommitment = require_porCommitment();
    var sighashType = require_sighashType();
    var tapKeySig = require_tapKeySig();
    var tapLeafScript = require_tapLeafScript();
    var tapMerkleRoot = require_tapMerkleRoot();
    var tapScriptSig = require_tapScriptSig();
    var witnessUtxo = require_witnessUtxo();
    var tapTree = require_tapTree();
    var bip32Derivation = require_bip32Derivation();
    var checkPubkey = require_checkPubkey();
    var redeemScript = require_redeemScript();
    var tapBip32Derivation = require_tapBip32Derivation();
    var tapInternalKey = require_tapInternalKey();
    var witnessScript = require_witnessScript();
    var globals = {
      unsignedTx,
      globalXpub,
      // pass an Array of key bytes that require pubkey beside the key
      checkPubkey: checkPubkey.makeChecker([])
    };
    exports.globals = globals;
    var inputs = {
      nonWitnessUtxo,
      partialSig,
      sighashType,
      finalScriptSig,
      finalScriptWitness,
      porCommitment,
      witnessUtxo,
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.InputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.InputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.InputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.InputTypes.PARTIAL_SIG,
        typeFields_1.InputTypes.BIP32_DERIVATION
      ]),
      tapKeySig,
      tapScriptSig,
      tapLeafScript,
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.InputTypes.TAP_BIP32_DERIVATION
      ),
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.InputTypes.TAP_INTERNAL_KEY
      ),
      tapMerkleRoot
    };
    exports.inputs = inputs;
    var outputs = {
      bip32Derivation: bip32Derivation.makeConverter(
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ),
      redeemScript: redeemScript.makeConverter(
        typeFields_1.OutputTypes.REDEEM_SCRIPT
      ),
      witnessScript: witnessScript.makeConverter(
        typeFields_1.OutputTypes.WITNESS_SCRIPT
      ),
      checkPubkey: checkPubkey.makeChecker([
        typeFields_1.OutputTypes.BIP32_DERIVATION
      ]),
      tapBip32Derivation: tapBip32Derivation.makeConverter(
        typeFields_1.OutputTypes.TAP_BIP32_DERIVATION
      ),
      tapTree,
      tapInternalKey: tapInternalKey.makeConverter(
        typeFields_1.OutputTypes.TAP_INTERNAL_KEY
      )
    };
    exports.outputs = outputs;
  }
});

// node_modules/bip174/src/lib/parser/fromBuffer.js
var require_fromBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/fromBuffer.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    var varuint = require_varint();
    var typeFields_1 = require_typeFields();
    function psbtFromBuffer(buffer, txGetter) {
      let offset = 0;
      function varSlice() {
        const keyLen = varuint.decode(buffer, offset);
        offset += varuint.encodingLength(keyLen);
        const key = buffer.slice(offset, offset + keyLen);
        offset += keyLen;
        return key;
      }
      function readUInt32BE() {
        const num = buffer.readUInt32BE(offset);
        offset += 4;
        return num;
      }
      function readUInt8() {
        const num = buffer.readUInt8(offset);
        offset += 1;
        return num;
      }
      function getKeyValue() {
        const key = varSlice();
        const value = varSlice();
        return {
          key,
          value
        };
      }
      function checkEndOfKeyValPairs() {
        if (offset >= buffer.length) {
          throw new Error("Format Error: Unexpected End of PSBT");
        }
        const isEnd = buffer.readUInt8(offset) === 0;
        if (isEnd) {
          offset++;
        }
        return isEnd;
      }
      if (readUInt32BE() !== 1886610036) {
        throw new Error("Format Error: Invalid Magic Number");
      }
      if (readUInt8() !== 255) {
        throw new Error(
          "Format Error: Magic Number must be followed by 0xff separator"
        );
      }
      const globalMapKeyVals = [];
      const globalKeyIndex = {};
      while (!checkEndOfKeyValPairs()) {
        const keyVal = getKeyValue();
        const hexKey = keyVal.key.toString("hex");
        if (globalKeyIndex[hexKey]) {
          throw new Error(
            "Format Error: Keys must be unique for global keymap: key " + hexKey
          );
        }
        globalKeyIndex[hexKey] = 1;
        globalMapKeyVals.push(keyVal);
      }
      const unsignedTxMaps = globalMapKeyVals.filter(
        (keyVal) => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX
      );
      if (unsignedTxMaps.length !== 1) {
        throw new Error("Format Error: Only one UNSIGNED_TX allowed");
      }
      const unsignedTx = txGetter(unsignedTxMaps[0].value);
      const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();
      const inputKeyVals = [];
      const outputKeyVals = [];
      for (const index of tools_1.range(inputCount)) {
        const inputKeyIndex = {};
        const input = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (inputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each input: input index " + index + " key " + hexKey
            );
          }
          inputKeyIndex[hexKey] = 1;
          input.push(keyVal);
        }
        inputKeyVals.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const outputKeyIndex = {};
        const output = [];
        while (!checkEndOfKeyValPairs()) {
          const keyVal = getKeyValue();
          const hexKey = keyVal.key.toString("hex");
          if (outputKeyIndex[hexKey]) {
            throw new Error(
              "Format Error: Keys must be unique for each output: output index " + index + " key " + hexKey
            );
          }
          outputKeyIndex[hexKey] = 1;
          output.push(keyVal);
        }
        outputKeyVals.push(output);
      }
      return psbtFromKeyVals(unsignedTx, {
        globalMapKeyVals,
        inputKeyVals,
        outputKeyVals
      });
    }
    exports.psbtFromBuffer = psbtFromBuffer;
    function checkKeyBuffer(type, keyBuf, keyNum) {
      if (!keyBuf.equals(Buffer.from([keyNum]))) {
        throw new Error(
          `Format Error: Invalid ${type} key: ${keyBuf.toString("hex")}`
        );
      }
    }
    exports.checkKeyBuffer = checkKeyBuffer;
    function psbtFromKeyVals(unsignedTx, { globalMapKeyVals, inputKeyVals, outputKeyVals }) {
      const globalMap = {
        unsignedTx
      };
      let txCount = 0;
      for (const keyVal of globalMapKeyVals) {
        switch (keyVal.key[0]) {
          case typeFields_1.GlobalTypes.UNSIGNED_TX:
            checkKeyBuffer(
              "global",
              keyVal.key,
              typeFields_1.GlobalTypes.UNSIGNED_TX
            );
            if (txCount > 0) {
              throw new Error("Format Error: GlobalMap has multiple UNSIGNED_TX");
            }
            txCount++;
            break;
          case typeFields_1.GlobalTypes.GLOBAL_XPUB:
            if (globalMap.globalXpub === void 0) {
              globalMap.globalXpub = [];
            }
            globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));
            break;
          default:
            if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];
            globalMap.unknownKeyVals.push(keyVal);
        }
      }
      const inputCount = inputKeyVals.length;
      const outputCount = outputKeyVals.length;
      const inputs = [];
      const outputs = [];
      for (const index of tools_1.range(inputCount)) {
        const input = {};
        for (const keyVal of inputKeyVals[index]) {
          convert.inputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.InputTypes.NON_WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.NON_WITNESS_UTXO
              );
              if (input.nonWitnessUtxo !== void 0) {
                throw new Error(
                  "Format Error: Input has multiple NON_WITNESS_UTXO"
                );
              }
              input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_UTXO:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_UTXO
              );
              if (input.witnessUtxo !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_UTXO");
              }
              input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);
              break;
            case typeFields_1.InputTypes.PARTIAL_SIG:
              if (input.partialSig === void 0) {
                input.partialSig = [];
              }
              input.partialSig.push(convert.inputs.partialSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.SIGHASH_TYPE:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.SIGHASH_TYPE
              );
              if (input.sighashType !== void 0) {
                throw new Error("Format Error: Input has multiple SIGHASH_TYPE");
              }
              input.sighashType = convert.inputs.sighashType.decode(keyVal);
              break;
            case typeFields_1.InputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.REDEEM_SCRIPT
              );
              if (input.redeemScript !== void 0) {
                throw new Error("Format Error: Input has multiple REDEEM_SCRIPT");
              }
              input.redeemScript = convert.inputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.WITNESS_SCRIPT
              );
              if (input.witnessScript !== void 0) {
                throw new Error("Format Error: Input has multiple WITNESS_SCRIPT");
              }
              input.witnessScript = convert.inputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.InputTypes.BIP32_DERIVATION:
              if (input.bip32Derivation === void 0) {
                input.bip32Derivation = [];
              }
              input.bip32Derivation.push(
                convert.inputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTSIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTSIG
              );
              input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.FINAL_SCRIPTWITNESS
              );
              input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(
                keyVal
              );
              break;
            case typeFields_1.InputTypes.POR_COMMITMENT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.POR_COMMITMENT
              );
              input.porCommitment = convert.inputs.porCommitment.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_KEY_SIG:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_KEY_SIG
              );
              input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_SCRIPT_SIG:
              if (input.tapScriptSig === void 0) {
                input.tapScriptSig = [];
              }
              input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:
              if (input.tapLeafScript === void 0) {
                input.tapLeafScript = [];
              }
              input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));
              break;
            case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:
              if (input.tapBip32Derivation === void 0) {
                input.tapBip32Derivation = [];
              }
              input.tapBip32Derivation.push(
                convert.inputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.InputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_INTERNAL_KEY
              );
              input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.InputTypes.TAP_MERKLE_ROOT:
              checkKeyBuffer(
                "input",
                keyVal.key,
                typeFields_1.InputTypes.TAP_MERKLE_ROOT
              );
              input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);
              break;
            default:
              if (!input.unknownKeyVals) input.unknownKeyVals = [];
              input.unknownKeyVals.push(keyVal);
          }
        }
        inputs.push(input);
      }
      for (const index of tools_1.range(outputCount)) {
        const output = {};
        for (const keyVal of outputKeyVals[index]) {
          convert.outputs.checkPubkey(keyVal);
          switch (keyVal.key[0]) {
            case typeFields_1.OutputTypes.REDEEM_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.REDEEM_SCRIPT
              );
              if (output.redeemScript !== void 0) {
                throw new Error("Format Error: Output has multiple REDEEM_SCRIPT");
              }
              output.redeemScript = convert.outputs.redeemScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.WITNESS_SCRIPT:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.WITNESS_SCRIPT
              );
              if (output.witnessScript !== void 0) {
                throw new Error("Format Error: Output has multiple WITNESS_SCRIPT");
              }
              output.witnessScript = convert.outputs.witnessScript.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.BIP32_DERIVATION:
              if (output.bip32Derivation === void 0) {
                output.bip32Derivation = [];
              }
              output.bip32Derivation.push(
                convert.outputs.bip32Derivation.decode(keyVal)
              );
              break;
            case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_INTERNAL_KEY
              );
              output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_TREE:
              checkKeyBuffer(
                "output",
                keyVal.key,
                typeFields_1.OutputTypes.TAP_TREE
              );
              output.tapTree = convert.outputs.tapTree.decode(keyVal);
              break;
            case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:
              if (output.tapBip32Derivation === void 0) {
                output.tapBip32Derivation = [];
              }
              output.tapBip32Derivation.push(
                convert.outputs.tapBip32Derivation.decode(keyVal)
              );
              break;
            default:
              if (!output.unknownKeyVals) output.unknownKeyVals = [];
              output.unknownKeyVals.push(keyVal);
          }
        }
        outputs.push(output);
      }
      return { globalMap, inputs, outputs };
    }
    exports.psbtFromKeyVals = psbtFromKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/toBuffer.js
var require_toBuffer = __commonJS({
  "node_modules/bip174/src/lib/parser/toBuffer.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var convert = require_converter();
    var tools_1 = require_tools();
    function psbtToBuffer({ globalMap, inputs, outputs }) {
      const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({
        globalMap,
        inputs,
        outputs
      });
      const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);
      const keyValsOrEmptyToBuffer = (keyVals) => keyVals.length === 0 ? [Buffer.from([0])] : keyVals.map(tools_1.keyValsToBuffer);
      const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);
      const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);
      const header = Buffer.allocUnsafe(5);
      header.writeUIntBE(482972169471, 0, 5);
      return Buffer.concat(
        [header, globalBuffer].concat(inputBuffers, outputBuffers)
      );
    }
    exports.psbtToBuffer = psbtToBuffer;
    var sortKeyVals = (a24, b10) => {
      return a24.key.compare(b10.key);
    };
    function keyValsFromMap(keyValMap, converterFactory) {
      const keyHexSet = /* @__PURE__ */ new Set();
      const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {
        if (key === "unknownKeyVals") return result;
        const converter = converterFactory[key];
        if (converter === void 0) return result;
        const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(
          converter.encode
        );
        const keyHexes = encodedKeyVals.map((kv) => kv.key.toString("hex"));
        keyHexes.forEach((hex) => {
          if (keyHexSet.has(hex))
            throw new Error("Serialize Error: Duplicate key: " + hex);
          keyHexSet.add(hex);
        });
        return result.concat(encodedKeyVals);
      }, []);
      const otherKeyVals = keyValMap.unknownKeyVals ? keyValMap.unknownKeyVals.filter((keyVal) => {
        return !keyHexSet.has(keyVal.key.toString("hex"));
      }) : [];
      return keyVals.concat(otherKeyVals).sort(sortKeyVals);
    }
    function psbtToKeyVals({ globalMap, inputs, outputs }) {
      return {
        globalKeyVals: keyValsFromMap(globalMap, convert.globals),
        inputKeyVals: inputs.map((i18) => keyValsFromMap(i18, convert.inputs)),
        outputKeyVals: outputs.map((o13) => keyValsFromMap(o13, convert.outputs))
      };
    }
    exports.psbtToKeyVals = psbtToKeyVals;
  }
});

// node_modules/bip174/src/lib/parser/index.js
var require_parser = __commonJS({
  "node_modules/bip174/src/lib/parser/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    function __export2(m17) {
      for (var p20 in m17) if (!exports.hasOwnProperty(p20)) exports[p20] = m17[p20];
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    __export2(require_fromBuffer());
    __export2(require_toBuffer());
  }
});

// node_modules/bip174/src/lib/combiner/index.js
var require_combiner = __commonJS({
  "node_modules/bip174/src/lib/combiner/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var parser_1 = require_parser();
    function combine(psbts) {
      const self = psbts[0];
      const selfKeyVals = parser_1.psbtToKeyVals(self);
      const others = psbts.slice(1);
      if (others.length === 0) throw new Error("Combine: Nothing to combine");
      const selfTx = getTx(self);
      if (selfTx === void 0) {
        throw new Error("Combine: Self missing transaction");
      }
      const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);
      const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);
      const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);
      for (const other of others) {
        const otherTx = getTx(other);
        if (otherTx === void 0 || !otherTx.toBuffer().equals(selfTx.toBuffer())) {
          throw new Error(
            "Combine: One of the Psbts does not have the same transaction."
          );
        }
        const otherKeyVals = parser_1.psbtToKeyVals(other);
        const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);
        otherGlobalSet.forEach(
          keyPusher(
            selfGlobalSet,
            selfKeyVals.globalKeyVals,
            otherKeyVals.globalKeyVals
          )
        );
        const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);
        otherInputSets.forEach(
          (inputSet, idx) => inputSet.forEach(
            keyPusher(
              selfInputSets[idx],
              selfKeyVals.inputKeyVals[idx],
              otherKeyVals.inputKeyVals[idx]
            )
          )
        );
        const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);
        otherOutputSets.forEach(
          (outputSet, idx) => outputSet.forEach(
            keyPusher(
              selfOutputSets[idx],
              selfKeyVals.outputKeyVals[idx],
              otherKeyVals.outputKeyVals[idx]
            )
          )
        );
      }
      return parser_1.psbtFromKeyVals(selfTx, {
        globalMapKeyVals: selfKeyVals.globalKeyVals,
        inputKeyVals: selfKeyVals.inputKeyVals,
        outputKeyVals: selfKeyVals.outputKeyVals
      });
    }
    exports.combine = combine;
    function keyPusher(selfSet, selfKeyVals, otherKeyVals) {
      return (key) => {
        if (selfSet.has(key)) return;
        const newKv = otherKeyVals.filter((kv) => kv.key.toString("hex") === key)[0];
        selfKeyVals.push(newKv);
        selfSet.add(key);
      };
    }
    function getTx(psbt) {
      return psbt.globalMap.unsignedTx;
    }
    function getKeySet(keyVals) {
      const set = /* @__PURE__ */ new Set();
      keyVals.forEach((keyVal) => {
        const hex = keyVal.key.toString("hex");
        if (set.has(hex))
          throw new Error("Combine: KeyValue Map keys should be unique");
        set.add(hex);
      });
      return set;
    }
  }
});

// node_modules/bip174/src/lib/utils.js
var require_utils5 = __commonJS({
  "node_modules/bip174/src/lib/utils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var converter = require_converter();
    function checkForInput(inputs, inputIndex) {
      const input = inputs[inputIndex];
      if (input === void 0) throw new Error(`No input #${inputIndex}`);
      return input;
    }
    exports.checkForInput = checkForInput;
    function checkForOutput(outputs, outputIndex) {
      const output = outputs[outputIndex];
      if (output === void 0) throw new Error(`No output #${outputIndex}`);
      return output;
    }
    exports.checkForOutput = checkForOutput;
    function checkHasKey(checkKeyVal, keyVals, enumLength) {
      if (checkKeyVal.key[0] < enumLength) {
        throw new Error(
          `Use the method for your specific key instead of addUnknownKeyVal*`
        );
      }
      if (keyVals && keyVals.filter((kv) => kv.key.equals(checkKeyVal.key)).length !== 0) {
        throw new Error(`Duplicate Key: ${checkKeyVal.key.toString("hex")}`);
      }
    }
    exports.checkHasKey = checkHasKey;
    function getEnumLength(myenum) {
      let count = 0;
      Object.keys(myenum).forEach((val) => {
        if (Number(isNaN(Number(val)))) {
          count++;
        }
      });
      return count;
    }
    exports.getEnumLength = getEnumLength;
    function inputCheckUncleanFinalized(inputIndex, input) {
      let result = false;
      if (input.nonWitnessUtxo || input.witnessUtxo) {
        const needScriptSig = !!input.redeemScript;
        const needWitnessScript = !!input.witnessScript;
        const scriptSigOK = !needScriptSig || !!input.finalScriptSig;
        const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;
        const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;
        result = scriptSigOK && witnessScriptOK && hasOneFinal;
      }
      if (result === false) {
        throw new Error(
          `Input #${inputIndex} has too much or too little data to clean`
        );
      }
    }
    exports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;
    function throwForUpdateMaker(typeName, name, expected, data) {
      throw new Error(
        `Data for ${typeName} key ${name} is incorrect: Expected ${expected} and got ${JSON.stringify(data)}`
      );
    }
    function updateMaker(typeName) {
      return (updateData, mainData) => {
        for (const name of Object.keys(updateData)) {
          const data = updateData[name];
          const { canAdd, canAddToArray, check, expected } = (
            // @ts-ignore
            converter[typeName + "s"][name] || {}
          );
          const isArray = !!canAddToArray;
          if (check) {
            if (isArray) {
              if (!Array.isArray(data) || // @ts-ignore
              mainData[name] && !Array.isArray(mainData[name])) {
                throw new Error(`Key type ${name} must be an array`);
              }
              if (!data.every(check)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              const arr = mainData[name] || [];
              const dupeCheckSet = /* @__PURE__ */ new Set();
              if (!data.every((v8) => canAddToArray(arr, v8, dupeCheckSet))) {
                throw new Error("Can not add duplicate data to array");
              }
              mainData[name] = arr.concat(data);
            } else {
              if (!check(data)) {
                throwForUpdateMaker(typeName, name, expected, data);
              }
              if (!canAdd(mainData, data)) {
                throw new Error(`Can not add duplicate data to ${typeName}`);
              }
              mainData[name] = data;
            }
          }
        }
      };
    }
    exports.updateGlobal = updateMaker("global");
    exports.updateInput = updateMaker("input");
    exports.updateOutput = updateMaker("output");
    function addInputAttributes(inputs, data) {
      const index = inputs.length - 1;
      const input = checkForInput(inputs, index);
      exports.updateInput(data, input);
    }
    exports.addInputAttributes = addInputAttributes;
    function addOutputAttributes(outputs, data) {
      const index = outputs.length - 1;
      const output = checkForOutput(outputs, index);
      exports.updateOutput(data, output);
    }
    exports.addOutputAttributes = addOutputAttributes;
    function defaultVersionSetter(version, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Version: Invalid Transaction");
      }
      txBuf.writeUInt32LE(version, 0);
      return txBuf;
    }
    exports.defaultVersionSetter = defaultVersionSetter;
    function defaultLocktimeSetter(locktime, txBuf) {
      if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {
        throw new Error("Set Locktime: Invalid Transaction");
      }
      txBuf.writeUInt32LE(locktime, txBuf.length - 4);
      return txBuf;
    }
    exports.defaultLocktimeSetter = defaultLocktimeSetter;
  }
});

// node_modules/bip174/src/lib/psbt.js
var require_psbt = __commonJS({
  "node_modules/bip174/src/lib/psbt.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    var combiner_1 = require_combiner();
    var parser_1 = require_parser();
    var typeFields_1 = require_typeFields();
    var utils_1 = require_utils5();
    var Psbt = class {
      constructor(tx) {
        this.inputs = [];
        this.outputs = [];
        this.globalMap = {
          unsignedTx: tx
        };
      }
      static fromBase64(data, txFromBuffer) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromHex(data, txFromBuffer) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, txFromBuffer);
      }
      static fromBuffer(buffer, txFromBuffer) {
        const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);
        const psbt = new this(results.globalMap.unsignedTx);
        Object.assign(psbt, results);
        return psbt;
      }
      toBase64() {
        const buffer = this.toBuffer();
        return buffer.toString("base64");
      }
      toHex() {
        const buffer = this.toBuffer();
        return buffer.toString("hex");
      }
      toBuffer() {
        return parser_1.psbtToBuffer(this);
      }
      updateGlobal(updateData) {
        utils_1.updateGlobal(updateData, this.globalMap);
        return this;
      }
      updateInput(inputIndex, updateData) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.updateInput(updateData, input);
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.updateOutput(updateData, output);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        utils_1.checkHasKey(
          keyVal,
          this.globalMap.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.GlobalTypes)
        );
        if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];
        this.globalMap.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.checkHasKey(
          keyVal,
          input.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.InputTypes)
        );
        if (!input.unknownKeyVals) input.unknownKeyVals = [];
        input.unknownKeyVals.push(keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        const output = utils_1.checkForOutput(this.outputs, outputIndex);
        utils_1.checkHasKey(
          keyVal,
          output.unknownKeyVals,
          utils_1.getEnumLength(typeFields_1.OutputTypes)
        );
        if (!output.unknownKeyVals) output.unknownKeyVals = [];
        output.unknownKeyVals.push(keyVal);
        return this;
      }
      addInput(inputData) {
        this.globalMap.unsignedTx.addInput(inputData);
        this.inputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = inputData.unknownKeyVals || [];
        const inputIndex = this.inputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToInput(inputIndex, keyVal)
        );
        utils_1.addInputAttributes(this.inputs, inputData);
        return this;
      }
      addOutput(outputData) {
        this.globalMap.unsignedTx.addOutput(outputData);
        this.outputs.push({
          unknownKeyVals: []
        });
        const addKeyVals = outputData.unknownKeyVals || [];
        const outputIndex = this.outputs.length - 1;
        if (!Array.isArray(addKeyVals)) {
          throw new Error("unknownKeyVals must be an Array");
        }
        addKeyVals.forEach(
          (keyVal) => this.addUnknownKeyValToOutput(outputIndex, keyVal)
        );
        utils_1.addOutputAttributes(this.outputs, outputData);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        const input = utils_1.checkForInput(this.inputs, inputIndex);
        utils_1.inputCheckUncleanFinalized(inputIndex, input);
        for (const key of Object.keys(input)) {
          if (![
            "witnessUtxo",
            "nonWitnessUtxo",
            "finalScriptSig",
            "finalScriptWitness",
            "unknownKeyVals"
          ].includes(key)) {
            delete input[key];
          }
        }
        return this;
      }
      combine(...those) {
        const result = combiner_1.combine([this].concat(those));
        Object.assign(this, result);
        return this;
      }
      getTransaction() {
        return this.globalMap.unsignedTx.toBuffer();
      }
    };
    exports.Psbt = Psbt;
  }
});

// node_modules/bitcoinjs-lib/src/psbt/psbtutils.js
var require_psbtutils = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/psbtutils.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signatureBlocksAction = exports.checkInputForSig = exports.pubkeyInScript = exports.pubkeyPositionInScript = exports.witnessStackToScriptWitness = exports.isP2TR = exports.isP2SHScript = exports.isP2WSHScript = exports.isP2WPKH = exports.isP2PKH = exports.isP2PK = exports.isP2MS = void 0;
    var varuint = require_varint();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var crypto_1 = require_crypto5();
    var payments = require_payments();
    function isPaymentFactory(payment) {
      return (script) => {
        try {
          payment({ output: script });
          return true;
        } catch (err) {
          return false;
        }
      };
    }
    exports.isP2MS = isPaymentFactory(payments.p2ms);
    exports.isP2PK = isPaymentFactory(payments.p2pk);
    exports.isP2PKH = isPaymentFactory(payments.p2pkh);
    exports.isP2WPKH = isPaymentFactory(payments.p2wpkh);
    exports.isP2WSHScript = isPaymentFactory(payments.p2wsh);
    exports.isP2SHScript = isPaymentFactory(payments.p2sh);
    exports.isP2TR = isPaymentFactory(payments.p2tr);
    function witnessStackToScriptWitness(witness) {
      let buffer = Buffer.allocUnsafe(0);
      function writeSlice(slice2) {
        buffer = Buffer.concat([buffer, Buffer.from(slice2)]);
      }
      function writeVarInt(i18) {
        const currentLen = buffer.length;
        const varintLen = varuint.encodingLength(i18);
        buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);
        varuint.encode(i18, buffer, currentLen);
      }
      function writeVarSlice(slice2) {
        writeVarInt(slice2.length);
        writeSlice(slice2);
      }
      function writeVector(vector) {
        writeVarInt(vector.length);
        vector.forEach(writeVarSlice);
      }
      writeVector(witness);
      return buffer;
    }
    exports.witnessStackToScriptWitness = witnessStackToScriptWitness;
    function pubkeyPositionInScript(pubkey, script) {
      const pubkeyHash = (0, crypto_1.hash160)(pubkey);
      const pubkeyXOnly = pubkey.slice(1, 33);
      const decompiled = bscript.decompile(script);
      if (decompiled === null) throw new Error("Unknown script error");
      return decompiled.findIndex((element) => {
        if (typeof element === "number") return false;
        return element.equals(pubkey) || element.equals(pubkeyHash) || element.equals(pubkeyXOnly);
      });
    }
    exports.pubkeyPositionInScript = pubkeyPositionInScript;
    function pubkeyInScript(pubkey, script) {
      return pubkeyPositionInScript(pubkey, script) !== -1;
    }
    exports.pubkeyInScript = pubkeyInScript;
    function checkInputForSig(input, action) {
      const pSigs = extractPartialSigs(input);
      return pSigs.some(
        (pSig) => signatureBlocksAction(pSig, bscript.signature.decode, action)
      );
    }
    exports.checkInputForSig = checkInputForSig;
    function signatureBlocksAction(signature, signatureDecodeFn, action) {
      const { hashType } = signatureDecodeFn(signature);
      const whitelist = [];
      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;
      if (isAnyoneCanPay) whitelist.push("addInput");
      const hashMod = hashType & 31;
      switch (hashMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
        case transaction_1.Transaction.SIGHASH_NONE:
          whitelist.push("addOutput");
          whitelist.push("setInputSequence");
          break;
      }
      if (whitelist.indexOf(action) === -1) {
        return true;
      }
      return false;
    }
    exports.signatureBlocksAction = signatureBlocksAction;
    function extractPartialSigs(input) {
      let pSigs = [];
      if ((input.partialSig || []).length === 0) {
        if (!input.finalScriptSig && !input.finalScriptWitness) return [];
        pSigs = getPsigsFromInputFinalScripts(input);
      } else {
        pSigs = input.partialSig;
      }
      return pSigs.map((p20) => p20.signature);
    }
    function getPsigsFromInputFinalScripts(input) {
      const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];
      const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];
      return scriptItems.concat(witnessItems).filter((item) => {
        return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);
      }).map((sig) => ({ signature: sig }));
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt/bip371.js
var require_bip371 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt/bip371.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkTaprootInputForSigs = exports.tapTreeFromList = exports.tapTreeToList = exports.tweakInternalPubKey = exports.checkTaprootOutputFields = exports.checkTaprootInputFields = exports.isTaprootOutput = exports.isTaprootInput = exports.serializeTaprootSignature = exports.tapScriptFinalizer = exports.toXOnly = void 0;
    var types_1 = require_types();
    var transaction_1 = require_transaction();
    var psbtutils_1 = require_psbtutils();
    var bip341_1 = require_bip341();
    var payments_1 = require_payments();
    var psbtutils_2 = require_psbtutils();
    var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    exports.toXOnly = toXOnly;
    function tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {
      const tapLeaf = findTapLeafToFinalize(
        input,
        inputIndex,
        tapLeafHashToFinalize
      );
      try {
        const sigs = sortSignatures(input, tapLeaf);
        const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);
        return {
          finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness)
        };
      } catch (err) {
        throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);
      }
    }
    exports.tapScriptFinalizer = tapScriptFinalizer;
    function serializeTaprootSignature(sig, sighashType) {
      const sighashTypeByte = sighashType ? Buffer.from([sighashType]) : Buffer.from([]);
      return Buffer.concat([sig, sighashTypeByte]);
    }
    exports.serializeTaprootSignature = serializeTaprootSignature;
    function isTaprootInput(input) {
      return input && !!(input.tapInternalKey || input.tapMerkleRoot || input.tapLeafScript && input.tapLeafScript.length || input.tapBip32Derivation && input.tapBip32Derivation.length || input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script));
    }
    exports.isTaprootInput = isTaprootInput;
    function isTaprootOutput(output, script) {
      return output && !!(output.tapInternalKey || output.tapTree || output.tapBip32Derivation && output.tapBip32Derivation.length || script && (0, psbtutils_1.isP2TR)(script));
    }
    exports.isTaprootOutput = isTaprootOutput;
    function checkTaprootInputFields(inputData, newInputData, action) {
      checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);
      checkIfTapLeafInTree(inputData, newInputData, action);
    }
    exports.checkTaprootInputFields = checkTaprootInputFields;
    function checkTaprootOutputFields(outputData, newOutputData, action) {
      checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);
      checkTaprootScriptPubkey(outputData, newOutputData);
    }
    exports.checkTaprootOutputFields = checkTaprootOutputFields;
    function checkTaprootScriptPubkey(outputData, newOutputData) {
      if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;
      const tapInternalKey = newOutputData.tapInternalKey || outputData.tapInternalKey;
      const tapTree = newOutputData.tapTree || outputData.tapTree;
      if (tapInternalKey) {
        const { script: scriptPubkey } = outputData;
        const script = getTaprootScripPubkey(tapInternalKey, tapTree);
        if (scriptPubkey && !scriptPubkey.equals(script))
          throw new Error("Error adding output. Script or address missmatch.");
      }
    }
    function getTaprootScripPubkey(tapInternalKey, tapTree) {
      const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);
      const { output } = (0, payments_1.p2tr)({
        internalPubkey: tapInternalKey,
        scriptTree
      });
      return output;
    }
    function tweakInternalPubKey(inputIndex, input) {
      const tapInternalKey = input.tapInternalKey;
      const outputKey = tapInternalKey && (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);
      if (!outputKey)
        throw new Error(
          `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${tapInternalKey && tapInternalKey.toString("hex")}`
        );
      return outputKey.x;
    }
    exports.tweakInternalPubKey = tweakInternalPubKey;
    function tapTreeToList(tree) {
      if (!(0, types_1.isTaptree)(tree))
        throw new Error(
          "Cannot convert taptree to tapleaf list. Expecting a tapree structure."
        );
      return _tapTreeToList(tree);
    }
    exports.tapTreeToList = tapTreeToList;
    function tapTreeFromList(leaves = []) {
      if (leaves.length === 1 && leaves[0].depth === 0)
        return {
          output: leaves[0].script,
          version: leaves[0].leafVersion
        };
      return instertLeavesInTree(leaves);
    }
    exports.tapTreeFromList = tapTreeFromList;
    function checkTaprootInputForSigs(input, action) {
      const sigs = extractTaprootSigs(input);
      return sigs.some(
        (sig) => (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action)
      );
    }
    exports.checkTaprootInputForSigs = checkTaprootInputForSigs;
    function decodeSchnorrSignature(signature) {
      return {
        signature: signature.slice(0, 64),
        hashType: signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT
      };
    }
    function extractTaprootSigs(input) {
      const sigs = [];
      if (input.tapKeySig) sigs.push(input.tapKeySig);
      if (input.tapScriptSig)
        sigs.push(...input.tapScriptSig.map((s15) => s15.signature));
      if (!sigs.length) {
        const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);
        if (finalTapKeySig) sigs.push(finalTapKeySig);
      }
      return sigs;
    }
    function getTapKeySigFromWithness(finalScriptWitness) {
      if (!finalScriptWitness) return;
      const witness = finalScriptWitness.slice(2);
      if (witness.length === 64 || witness.length === 65) return witness;
    }
    function _tapTreeToList(tree, leaves = [], depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (!tree) return [];
      if ((0, types_1.isTapleaf)(tree)) {
        leaves.push({
          depth,
          leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,
          script: tree.output
        });
        return leaves;
      }
      if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);
      if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);
      return leaves;
    }
    function instertLeavesInTree(leaves) {
      let tree;
      for (const leaf of leaves) {
        tree = instertLeafInTree(leaf, tree);
        if (!tree) throw new Error(`No room left to insert tapleaf in tree`);
      }
      return tree;
    }
    function instertLeafInTree(leaf, tree, depth = 0) {
      if (depth > bip341_1.MAX_TAPTREE_DEPTH)
        throw new Error("Max taptree depth exceeded.");
      if (leaf.depth === depth) {
        if (!tree)
          return {
            output: leaf.script,
            version: leaf.leafVersion
          };
        return;
      }
      if ((0, types_1.isTapleaf)(tree)) return;
      const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);
      if (leftSide) return [leftSide, tree && tree[1]];
      const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);
      if (rightSide) return [tree && tree[0], rightSide];
    }
    function checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootInput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootInput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootInput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkMixedTaprootAndNonTaprootOutputFields(inputData, newInputData, action) {
      const isBadTaprootUpdate = isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);
      const isBadNonTaprootUpdate = hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);
      const hasMixedFields = inputData === newInputData && isTaprootOutput(newInputData) && hasNonTaprootFields(newInputData);
      if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)
        throw new Error(
          `Invalid arguments for Psbt.${action}. Cannot use both taproot and non-taproot fields.`
        );
    }
    function checkIfTapLeafInTree(inputData, newInputData, action) {
      if (newInputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l23) => isTapLeafInTree(l23, newInputData.tapMerkleRoot)
        );
        const oldLeafsInTree = (inputData.tapLeafScript || []).every(
          (l23) => isTapLeafInTree(l23, newInputData.tapMerkleRoot)
        );
        if (!newLeafsInTree || !oldLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      } else if (inputData.tapMerkleRoot) {
        const newLeafsInTree = (newInputData.tapLeafScript || []).every(
          (l23) => isTapLeafInTree(l23, inputData.tapMerkleRoot)
        );
        if (!newLeafsInTree)
          throw new Error(
            `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`
          );
      }
    }
    function isTapLeafInTree(tapLeaf, merkleRoot) {
      if (!merkleRoot) return true;
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      const rootHash = (0, bip341_1.rootHashFromPath)(
        tapLeaf.controlBlock,
        leafHash
      );
      return rootHash.equals(merkleRoot);
    }
    function sortSignatures(input, tapLeaf) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: tapLeaf.script,
        version: tapLeaf.leafVersion
      });
      return (input.tapScriptSig || []).filter((tss) => tss.leafHash.equals(leafHash)).map((tss) => addPubkeyPositionInScript(tapLeaf.script, tss)).sort((t1, t22) => t22.positionInScript - t1.positionInScript).map((t12) => t12.signature);
    }
    function addPubkeyPositionInScript(script, tss) {
      return Object.assign(
        {
          positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(
            tss.pubkey,
            script
          )
        },
        tss
      );
    }
    function findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {
      if (!input.tapScriptSig || !input.tapScriptSig.length)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`
        );
      const tapLeaf = (input.tapLeafScript || []).sort((a24, b10) => a24.controlBlock.length - b10.controlBlock.length).find(
        (leaf) => canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize)
      );
      if (!tapLeaf)
        throw new Error(
          `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`
        );
      return tapLeaf;
    }
    function canFinalizeLeaf(leaf, tapScriptSig, hash) {
      const leafHash = (0, bip341_1.tapleafHash)({
        output: leaf.script,
        version: leaf.leafVersion
      });
      const whiteListedHash = !hash || hash.equals(leafHash);
      return whiteListedHash && tapScriptSig.find((tss) => tss.leafHash.equals(leafHash)) !== void 0;
    }
    function hasNonTaprootFields(io) {
      return io && !!(io.redeemScript || io.witnessScript || io.bip32Derivation && io.bip32Derivation.length);
    }
  }
});

// node_modules/bitcoinjs-lib/src/psbt.js
var require_psbt2 = __commonJS({
  "node_modules/bitcoinjs-lib/src/psbt.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Psbt = void 0;
    var bip174_1 = require_psbt();
    var varuint = require_varint();
    var utils_1 = require_utils5();
    var address_1 = require_address();
    var bufferutils_1 = require_bufferutils();
    var networks_1 = require_networks();
    var payments = require_payments();
    var bip341_1 = require_bip341();
    var bscript = require_script();
    var transaction_1 = require_transaction();
    var bip371_1 = require_bip371();
    var psbtutils_1 = require_psbtutils();
    var DEFAULT_OPTS = {
      /**
       * A bitcoinjs Network object. This is only used if you pass an `address`
       * parameter to addOutput. Otherwise it is not needed and can be left default.
       */
      network: networks_1.bitcoin,
      /**
       * When extractTransaction is called, the fee rate is checked.
       * THIS IS NOT TO BE RELIED ON.
       * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.
       */
      maximumFeeRate: 5e3
      // satoshi per byte
    };
    var Psbt = class _Psbt {
      static fromBase64(data, opts = {}) {
        const buffer = Buffer.from(data, "base64");
        return this.fromBuffer(buffer, opts);
      }
      static fromHex(data, opts = {}) {
        const buffer = Buffer.from(data, "hex");
        return this.fromBuffer(buffer, opts);
      }
      static fromBuffer(buffer, opts = {}) {
        const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);
        const psbt = new _Psbt(opts, psbtBase);
        checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);
        return psbt;
      }
      constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {
        this.data = data;
        this.opts = Object.assign({}, DEFAULT_OPTS, opts);
        this.__CACHE = {
          __NON_WITNESS_UTXO_TX_CACHE: [],
          __NON_WITNESS_UTXO_BUF_CACHE: [],
          __TX_IN_CACHE: {},
          __TX: this.data.globalMap.unsignedTx.tx,
          // Psbt's predecessor (TransactionBuilder - now removed) behavior
          // was to not confirm input values  before signing.
          // Even though we highly encourage people to get
          // the full parent transaction to verify values, the ability to
          // sign non-segwit inputs without the full transaction was often
          // requested. So the only way to activate is to use @ts-ignore.
          // We will disable exporting the Psbt when unsafe sign is active.
          // because it is not BIP174 compliant.
          __UNSAFE_SIGN_NONSEGWIT: false
        };
        if (this.data.inputs.length === 0) this.setVersion(2);
        const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {
          enumerable,
          writable
        });
        dpew(this, "__CACHE", false, true);
        dpew(this, "opts", false, true);
      }
      get inputCount() {
        return this.data.inputs.length;
      }
      get version() {
        return this.__CACHE.__TX.version;
      }
      set version(version) {
        this.setVersion(version);
      }
      get locktime() {
        return this.__CACHE.__TX.locktime;
      }
      set locktime(locktime) {
        this.setLocktime(locktime);
      }
      get txInputs() {
        return this.__CACHE.__TX.ins.map((input) => ({
          hash: (0, bufferutils_1.cloneBuffer)(input.hash),
          index: input.index,
          sequence: input.sequence
        }));
      }
      get txOutputs() {
        return this.__CACHE.__TX.outs.map((output) => {
          let address;
          try {
            address = (0, address_1.fromOutputScript)(
              output.script,
              this.opts.network
            );
          } catch (_10) {
          }
          return {
            script: (0, bufferutils_1.cloneBuffer)(output.script),
            value: output.value,
            address
          };
        });
      }
      combine(...those) {
        this.data.combine(...those.map((o13) => o13.data));
        return this;
      }
      clone() {
        const res = _Psbt.fromBuffer(this.data.toBuffer());
        res.opts = JSON.parse(JSON.stringify(this.opts));
        return res;
      }
      setMaximumFeeRate(satoshiPerByte) {
        check32Bit(satoshiPerByte);
        this.opts.maximumFeeRate = satoshiPerByte;
      }
      setVersion(version) {
        check32Bit(version);
        checkInputsForPartialSig(this.data.inputs, "setVersion");
        const c10 = this.__CACHE;
        c10.__TX.version = version;
        c10.__EXTRACTED_TX = void 0;
        return this;
      }
      setLocktime(locktime) {
        check32Bit(locktime);
        checkInputsForPartialSig(this.data.inputs, "setLocktime");
        const c10 = this.__CACHE;
        c10.__TX.locktime = locktime;
        c10.__EXTRACTED_TX = void 0;
        return this;
      }
      setInputSequence(inputIndex, sequence) {
        check32Bit(sequence);
        checkInputsForPartialSig(this.data.inputs, "setInputSequence");
        const c10 = this.__CACHE;
        if (c10.__TX.ins.length <= inputIndex) {
          throw new Error("Input index too high");
        }
        c10.__TX.ins[inputIndex].sequence = sequence;
        c10.__EXTRACTED_TX = void 0;
        return this;
      }
      addInputs(inputDatas) {
        inputDatas.forEach((inputData) => this.addInput(inputData));
        return this;
      }
      addInput(inputData) {
        if (arguments.length > 1 || !inputData || inputData.hash === void 0 || inputData.index === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addInput. Requires single object with at least [hash] and [index]`
          );
        }
        (0, bip371_1.checkTaprootInputFields)(inputData, inputData, "addInput");
        checkInputsForPartialSig(this.data.inputs, "addInput");
        if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);
        const c10 = this.__CACHE;
        this.data.addInput(inputData);
        const txIn = c10.__TX.ins[c10.__TX.ins.length - 1];
        checkTxInputCache(c10, txIn);
        const inputIndex = this.data.inputs.length - 1;
        const input = this.data.inputs[inputIndex];
        if (input.nonWitnessUtxo) {
          addNonWitnessTxCache(this.__CACHE, input, inputIndex);
        }
        c10.__FEE = void 0;
        c10.__FEE_RATE = void 0;
        c10.__EXTRACTED_TX = void 0;
        return this;
      }
      addOutputs(outputDatas) {
        outputDatas.forEach((outputData) => this.addOutput(outputData));
        return this;
      }
      addOutput(outputData) {
        if (arguments.length > 1 || !outputData || outputData.value === void 0 || outputData.address === void 0 && outputData.script === void 0) {
          throw new Error(
            `Invalid arguments for Psbt.addOutput. Requires single object with at least [script or address] and [value]`
          );
        }
        checkInputsForPartialSig(this.data.inputs, "addOutput");
        const { address } = outputData;
        if (typeof address === "string") {
          const { network } = this.opts;
          const script = (0, address_1.toOutputScript)(address, network);
          outputData = Object.assign({}, outputData, { script });
        }
        (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, "addOutput");
        const c10 = this.__CACHE;
        this.data.addOutput(outputData);
        c10.__FEE = void 0;
        c10.__FEE_RATE = void 0;
        c10.__EXTRACTED_TX = void 0;
        return this;
      }
      extractTransaction(disableFeeCheck) {
        if (!this.data.inputs.every(isFinalized)) throw new Error("Not finalized");
        const c10 = this.__CACHE;
        if (!disableFeeCheck) {
          checkFees(this, c10, this.opts);
        }
        if (c10.__EXTRACTED_TX) return c10.__EXTRACTED_TX;
        const tx = c10.__TX.clone();
        inputFinalizeGetAmts(this.data.inputs, tx, c10, true);
        return tx;
      }
      getFeeRate() {
        return getTxCacheValue(
          "__FEE_RATE",
          "fee rate",
          this.data.inputs,
          this.__CACHE
        );
      }
      getFee() {
        return getTxCacheValue("__FEE", "fee", this.data.inputs, this.__CACHE);
      }
      finalizeAllInputs() {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        range(this.data.inputs.length).forEach((idx) => this.finalizeInput(idx));
        return this;
      }
      finalizeInput(inputIndex, finalScriptsFunc) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            void 0,
            finalScriptsFunc
          );
        return this._finalizeInput(inputIndex, input, finalScriptsFunc);
      }
      finalizeTaprootInput(inputIndex, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._finalizeTaprootInput(
            inputIndex,
            input,
            tapLeafHashToFinalize,
            finalScriptsFunc
          );
        throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);
      }
      _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {
        const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(
          inputIndex,
          input,
          this.__CACHE
        );
        if (!script) throw new Error(`No script found for input #${inputIndex}`);
        checkPartialSigSighashes(input);
        const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(
          inputIndex,
          input,
          script,
          isSegwit,
          isP2SH,
          isP2WSH
        );
        if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });
        if (finalScriptWitness)
          this.data.updateInput(inputIndex, { finalScriptWitness });
        if (!finalScriptSig && !finalScriptWitness)
          throw new Error(`Unknown error finalizing input #${inputIndex}`);
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      _finalizeTaprootInput(inputIndex, input, tapLeafHashToFinalize, finalScriptsFunc = bip371_1.tapScriptFinalizer) {
        if (!input.witnessUtxo)
          throw new Error(
            `Cannot finalize input #${inputIndex}. Missing withness utxo.`
          );
        if (input.tapKeySig) {
          const payment = payments.p2tr({
            output: input.witnessUtxo.script,
            signature: input.tapKeySig
          });
          const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        } else {
          const { finalScriptWitness } = finalScriptsFunc(
            inputIndex,
            input,
            tapLeafHashToFinalize
          );
          this.data.updateInput(inputIndex, { finalScriptWitness });
        }
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
      getInputType(inputIndex) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);
        const result = getMeaningfulScript(
          script,
          inputIndex,
          "input",
          input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),
          input.witnessScript || redeemFromFinalWitnessScript(input.finalScriptWitness)
        );
        const type = result.type === "raw" ? "" : result.type + "-";
        const mainType = classifyScript(result.meaningfulScript);
        return type + mainType;
      }
      inputHasPubkey(inputIndex, pubkey) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);
      }
      inputHasHDKey(inputIndex, root) {
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine);
      }
      outputHasPubkey(outputIndex, pubkey) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);
      }
      outputHasHDKey(outputIndex, root) {
        const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);
        const derivationIsMine = bip32DerivationIsMine(root);
        return !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine);
      }
      validateSignaturesOfAllInputs(validator) {
        (0, utils_1.checkForInput)(this.data.inputs, 0);
        const results = range(this.data.inputs.length).map(
          (idx) => this.validateSignaturesOfInput(idx, validator)
        );
        return results.reduce((final, res) => res === true && final, true);
      }
      validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        if ((0, bip371_1.isTaprootInput)(input))
          return this.validateSignaturesOfTaprootInput(
            inputIndex,
            validator,
            pubkey
          );
        return this._validateSignaturesOfInput(inputIndex, validator, pubkey);
      }
      _validateSignaturesOfInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const partialSig = (input || {}).partialSig;
        if (!input || !partialSig || partialSig.length < 1)
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        const mySigs = pubkey ? partialSig.filter((sig) => sig.pubkey.equals(pubkey)) : partialSig;
        if (mySigs.length < 1) throw new Error("No signatures for this pubkey");
        const results = [];
        let hashCache;
        let scriptCache;
        let sighashCache;
        for (const pSig of mySigs) {
          const sig = bscript.signature.decode(pSig.signature);
          const { hash, script } = sighashCache !== sig.hashType ? getHashForSig(
            inputIndex,
            Object.assign({}, input, { sighashType: sig.hashType }),
            this.__CACHE,
            true
          ) : { hash: hashCache, script: scriptCache };
          sighashCache = sig.hashType;
          hashCache = hash;
          scriptCache = script;
          checkScriptForPubkey(pSig.pubkey, script, "verify");
          results.push(validator(pSig.pubkey, hash, sig.signature));
        }
        return results.every((res) => res === true);
      }
      validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {
        const input = this.data.inputs[inputIndex];
        const tapKeySig = (input || {}).tapKeySig;
        const tapScriptSig = (input || {}).tapScriptSig;
        if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))
          throw new Error("No signatures to validate");
        if (typeof validator !== "function")
          throw new Error("Need validator function to validate signatures");
        pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);
        const allHashses = pubkey ? getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          pubkey,
          this.__CACHE
        ) : getAllTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          this.__CACHE
        );
        if (!allHashses.length) throw new Error("No signatures for this pubkey");
        const tapKeyHash = allHashses.find((h11) => !h11.leafHash);
        let validationResultCount = 0;
        if (tapKeySig && tapKeyHash) {
          const isValidTapkeySig = validator(
            tapKeyHash.pubkey,
            tapKeyHash.hash,
            trimTaprootSig(tapKeySig)
          );
          if (!isValidTapkeySig) return false;
          validationResultCount++;
        }
        if (tapScriptSig) {
          for (const tapSig of tapScriptSig) {
            const tapSigHash = allHashses.find((h11) => tapSig.pubkey.equals(h11.pubkey));
            if (tapSigHash) {
              const isValidTapScriptSig = validator(
                tapSig.pubkey,
                tapSigHash.hash,
                trimTaprootSig(tapSig.signature)
              );
              if (!isValidTapScriptSig) return false;
              validationResultCount++;
            }
          }
        }
        return validationResultCount > 0;
      }
      signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const results = [];
        for (const i18 of range(this.data.inputs.length)) {
          try {
            this.signInputHD(i18, hdKeyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v8) => v8 === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const results = [];
          const promises = [];
          for (const i18 of range(this.data.inputs.length)) {
            promises.push(
              this.signInputHDAsync(i18, hdKeyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v8) => v8 === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
          throw new Error("Need HDSigner to sign input");
        }
        const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
        signers.forEach((signer) => this.signInput(inputIndex, signer, sighashTypes));
        return this;
      }
      signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        return new Promise((resolve, reject) => {
          if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {
            return reject(new Error("Need HDSigner to sign input"));
          }
          const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);
          const promises = signers.map(
            (signer) => this.signInputAsync(inputIndex, signer, sighashTypes)
          );
          return Promise.all(promises).then(() => {
            resolve();
          }).catch(reject);
        });
      }
      signAllInputs(keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const results = [];
        for (const i18 of range(this.data.inputs.length)) {
          try {
            this.signInput(i18, keyPair, sighashTypes);
            results.push(true);
          } catch (err) {
            results.push(false);
          }
        }
        if (results.every((v8) => v8 === false)) {
          throw new Error("No inputs were signed");
        }
        return this;
      }
      signAllInputsAsync(keyPair, sighashTypes) {
        return new Promise((resolve, reject) => {
          if (!keyPair || !keyPair.publicKey)
            return reject(new Error("Need Signer to sign input"));
          const results = [];
          const promises = [];
          for (const [i18] of this.data.inputs.entries()) {
            promises.push(
              this.signInputAsync(i18, keyPair, sighashTypes).then(
                () => {
                  results.push(true);
                },
                () => {
                  results.push(false);
                }
              )
            );
          }
          return Promise.all(promises).then(() => {
            if (results.every((v8) => v8 === false)) {
              return reject(new Error("No inputs were signed"));
            }
            resolve();
          });
        });
      }
      signInput(inputIndex, keyPair, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input)) {
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            void 0,
            sighashTypes
          );
        }
        return this._signInput(inputIndex, keyPair, sighashTypes);
      }
      signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {
        if (!keyPair || !keyPair.publicKey)
          throw new Error("Need Signer to sign input");
        const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
        if ((0, bip371_1.isTaprootInput)(input))
          return this._signTaprootInput(
            inputIndex,
            input,
            keyPair,
            tapLeafHashToSign,
            sighashTypes
          );
        throw new Error(`Input #${inputIndex} is not of type Taproot.`);
      }
      _signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        const partialSig = [
          {
            pubkey: keyPair.publicKey,
            signature: bscript.signature.encode(keyPair.sign(hash), sighashType)
          }
        ];
        this.data.updateInput(inputIndex, { partialSig });
        return this;
      }
      _signTaprootInput(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        const tapKeySig = hashesForSig.filter((h11) => !h11.leafHash).map(
          (h11) => (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h11.hash),
            input.sighashType
          )
        )[0];
        const tapScriptSig = hashesForSig.filter((h11) => !!h11.leafHash).map((h11) => ({
          pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
          signature: (0, bip371_1.serializeTaprootSignature)(
            keyPair.signSchnorr(h11.hash),
            input.sighashType
          ),
          leafHash: h11.leafHash
        }));
        if (tapKeySig) {
          this.data.updateInput(inputIndex, { tapKeySig });
        }
        if (tapScriptSig.length) {
          this.data.updateInput(inputIndex, { tapScriptSig });
        }
        return this;
      }
      signInputAsync(inputIndex, keyPair, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              void 0,
              sighashTypes
            );
          return this._signInputAsync(inputIndex, keyPair, sighashTypes);
        });
      }
      signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {
        return Promise.resolve().then(() => {
          if (!keyPair || !keyPair.publicKey)
            throw new Error("Need Signer to sign input");
          const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);
          if ((0, bip371_1.isTaprootInput)(input))
            return this._signTaprootInputAsync(
              inputIndex,
              input,
              keyPair,
              tapLeafHash,
              sighashTypes
            );
          throw new Error(`Input #${inputIndex} is not of type Taproot.`);
        });
      }
      _signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {
        const { hash, sighashType } = getHashAndSighashType(
          this.data.inputs,
          inputIndex,
          keyPair.publicKey,
          this.__CACHE,
          sighashTypes
        );
        return Promise.resolve(keyPair.sign(hash)).then((signature) => {
          const partialSig = [
            {
              pubkey: keyPair.publicKey,
              signature: bscript.signature.encode(signature, sighashType)
            }
          ];
          this.data.updateInput(inputIndex, { partialSig });
        });
      }
      async _signTaprootInputAsync(inputIndex, input, keyPair, tapLeafHash, sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT]) {
        const hashesForSig = this.checkTaprootHashesForSig(
          inputIndex,
          input,
          keyPair,
          tapLeafHash,
          sighashTypes
        );
        const signaturePromises = [];
        const tapKeyHash = hashesForSig.filter((h11) => !h11.leafHash)[0];
        if (tapKeyHash) {
          const tapKeySigPromise = Promise.resolve(
            keyPair.signSchnorr(tapKeyHash.hash)
          ).then((sig) => {
            return {
              tapKeySig: (0, bip371_1.serializeTaprootSignature)(
                sig,
                input.sighashType
              )
            };
          });
          signaturePromises.push(tapKeySigPromise);
        }
        const tapScriptHashes = hashesForSig.filter((h11) => !!h11.leafHash);
        if (tapScriptHashes.length) {
          const tapScriptSigPromises = tapScriptHashes.map((tsh) => {
            return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(
              (signature) => {
                const tapScriptSig = [
                  {
                    pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),
                    signature: (0, bip371_1.serializeTaprootSignature)(
                      signature,
                      input.sighashType
                    ),
                    leafHash: tsh.leafHash
                  }
                ];
                return { tapScriptSig };
              }
            );
          });
          signaturePromises.push(...tapScriptSigPromises);
        }
        return Promise.all(signaturePromises).then((results) => {
          results.forEach((v8) => this.data.updateInput(inputIndex, v8));
        });
      }
      checkTaprootHashesForSig(inputIndex, input, keyPair, tapLeafHashToSign, allowedSighashTypes) {
        if (typeof keyPair.signSchnorr !== "function")
          throw new Error(
            `Need Schnorr Signer to sign taproot input #${inputIndex}.`
          );
        const hashesForSig = getTaprootHashesForSig(
          inputIndex,
          input,
          this.data.inputs,
          keyPair.publicKey,
          this.__CACHE,
          tapLeafHashToSign,
          allowedSighashTypes
        );
        if (!hashesForSig || !hashesForSig.length)
          throw new Error(
            `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(
              "hex"
            )}`
          );
        return hashesForSig;
      }
      toBuffer() {
        checkCache(this.__CACHE);
        return this.data.toBuffer();
      }
      toHex() {
        checkCache(this.__CACHE);
        return this.data.toHex();
      }
      toBase64() {
        checkCache(this.__CACHE);
        return this.data.toBase64();
      }
      updateGlobal(updateData) {
        this.data.updateGlobal(updateData);
        return this;
      }
      updateInput(inputIndex, updateData) {
        if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);
        (0, bip371_1.checkTaprootInputFields)(
          this.data.inputs[inputIndex],
          updateData,
          "updateInput"
        );
        this.data.updateInput(inputIndex, updateData);
        if (updateData.nonWitnessUtxo) {
          addNonWitnessTxCache(
            this.__CACHE,
            this.data.inputs[inputIndex],
            inputIndex
          );
        }
        return this;
      }
      updateOutput(outputIndex, updateData) {
        const outputData = this.data.outputs[outputIndex];
        (0, bip371_1.checkTaprootOutputFields)(
          outputData,
          updateData,
          "updateOutput"
        );
        this.data.updateOutput(outputIndex, updateData);
        return this;
      }
      addUnknownKeyValToGlobal(keyVal) {
        this.data.addUnknownKeyValToGlobal(keyVal);
        return this;
      }
      addUnknownKeyValToInput(inputIndex, keyVal) {
        this.data.addUnknownKeyValToInput(inputIndex, keyVal);
        return this;
      }
      addUnknownKeyValToOutput(outputIndex, keyVal) {
        this.data.addUnknownKeyValToOutput(outputIndex, keyVal);
        return this;
      }
      clearFinalizedInput(inputIndex) {
        this.data.clearFinalizedInput(inputIndex);
        return this;
      }
    };
    exports.Psbt = Psbt;
    var transactionFromBuffer = (buffer) => new PsbtTransaction(buffer);
    var PsbtTransaction = class {
      constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {
        this.tx = transaction_1.Transaction.fromBuffer(buffer);
        checkTxEmpty(this.tx);
        Object.defineProperty(this, "tx", {
          enumerable: false,
          writable: true
        });
      }
      getInputOutputCounts() {
        return {
          inputCount: this.tx.ins.length,
          outputCount: this.tx.outs.length
        };
      }
      addInput(input) {
        if (input.hash === void 0 || input.index === void 0 || !Buffer.isBuffer(input.hash) && typeof input.hash !== "string" || typeof input.index !== "number") {
          throw new Error("Error adding input.");
        }
        const hash = typeof input.hash === "string" ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, "hex")) : input.hash;
        this.tx.addInput(hash, input.index, input.sequence);
      }
      addOutput(output) {
        if (output.script === void 0 || output.value === void 0 || !Buffer.isBuffer(output.script) || typeof output.value !== "number") {
          throw new Error("Error adding output.");
        }
        this.tx.addOutput(output.script, output.value);
      }
      toBuffer() {
        return this.tx.toBuffer();
      }
    };
    function canFinalize(input, script, scriptType) {
      switch (scriptType) {
        case "pubkey":
        case "pubkeyhash":
        case "witnesspubkeyhash":
          return hasSigs(1, input.partialSig);
        case "multisig":
          const p2ms = payments.p2ms({ output: script });
          return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);
        default:
          return false;
      }
    }
    function checkCache(cache) {
      if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {
        throw new Error("Not BIP174 compliant, can not export");
      }
    }
    function hasSigs(neededSigs, partialSig, pubkeys) {
      if (!partialSig) return false;
      let sigs;
      if (pubkeys) {
        sigs = pubkeys.map((pkey) => {
          const pubkey = compressPubkey(pkey);
          return partialSig.find((pSig) => pSig.pubkey.equals(pubkey));
        }).filter((v8) => !!v8);
      } else {
        sigs = partialSig;
      }
      if (sigs.length > neededSigs) throw new Error("Too many signatures");
      return sigs.length === neededSigs;
    }
    function isFinalized(input) {
      return !!input.finalScriptSig || !!input.finalScriptWitness;
    }
    function bip32DerivationIsMine(root) {
      return (d20) => {
        if (!d20.masterFingerprint.equals(root.fingerprint)) return false;
        if (!root.derivePath(d20.path).publicKey.equals(d20.pubkey)) return false;
        return true;
      };
    }
    function check32Bit(num) {
      if (typeof num !== "number" || num !== Math.floor(num) || num > 4294967295 || num < 0) {
        throw new Error("Invalid 32 bit integer");
      }
    }
    function checkFees(psbt, cache, opts) {
      const feeRate = cache.__FEE_RATE || psbt.getFeeRate();
      const vsize = cache.__EXTRACTED_TX.virtualSize();
      const satoshis = feeRate * vsize;
      if (feeRate >= opts.maximumFeeRate) {
        throw new Error(
          `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in fees, which is ${feeRate} satoshi per byte for a transaction with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per byte). Use setMaximumFeeRate method to raise your threshold, or pass true to the first arg of extractTransaction.`
        );
      }
    }
    function checkInputsForPartialSig(inputs, action) {
      inputs.forEach((input) => {
        const throws = (0, bip371_1.isTaprootInput)(input) ? (0, bip371_1.checkTaprootInputForSigs)(input, action) : (0, psbtutils_1.checkInputForSig)(input, action);
        if (throws)
          throw new Error("Can not modify transaction, signatures exist.");
      });
    }
    function checkPartialSigSighashes(input) {
      if (!input.sighashType || !input.partialSig) return;
      const { partialSig, sighashType } = input;
      partialSig.forEach((pSig) => {
        const { hashType } = bscript.signature.decode(pSig.signature);
        if (sighashType !== hashType) {
          throw new Error("Signature sighash does not match input sighash type");
        }
      });
    }
    function checkScriptForPubkey(pubkey, script, action) {
      if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {
        throw new Error(
          `Can not ${action} for this input with the key ${pubkey.toString("hex")}`
        );
      }
    }
    function checkTxEmpty(tx) {
      const isEmpty = tx.ins.every(
        (input) => input.script && input.script.length === 0 && input.witness && input.witness.length === 0
      );
      if (!isEmpty) {
        throw new Error("Format Error: Transaction ScriptSigs are not empty");
      }
    }
    function checkTxForDupeIns(tx, cache) {
      tx.ins.forEach((input) => {
        checkTxInputCache(cache, input);
      });
    }
    function checkTxInputCache(cache, input) {
      const key = (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString("hex") + ":" + input.index;
      if (cache.__TX_IN_CACHE[key]) throw new Error("Duplicate input detected.");
      cache.__TX_IN_CACHE[key] = 1;
    }
    function scriptCheckerFactory(payment, paymentScriptName) {
      return (inputIndex, scriptPubKey, redeemScript, ioType) => {
        const redeemScriptOutput = payment({
          redeem: { output: redeemScript }
        }).output;
        if (!scriptPubKey.equals(redeemScriptOutput)) {
          throw new Error(
            `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`
          );
        }
      };
    }
    var checkRedeemScript = scriptCheckerFactory(payments.p2sh, "Redeem script");
    var checkWitnessScript = scriptCheckerFactory(
      payments.p2wsh,
      "Witness script"
    );
    function getTxCacheValue(key, name, inputs, c10) {
      if (!inputs.every(isFinalized))
        throw new Error(`PSBT must be finalized to calculate ${name}`);
      if (key === "__FEE_RATE" && c10.__FEE_RATE) return c10.__FEE_RATE;
      if (key === "__FEE" && c10.__FEE) return c10.__FEE;
      let tx;
      let mustFinalize = true;
      if (c10.__EXTRACTED_TX) {
        tx = c10.__EXTRACTED_TX;
        mustFinalize = false;
      } else {
        tx = c10.__TX.clone();
      }
      inputFinalizeGetAmts(inputs, tx, c10, mustFinalize);
      if (key === "__FEE_RATE") return c10.__FEE_RATE;
      else if (key === "__FEE") return c10.__FEE;
    }
    function getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {
      const scriptType = classifyScript(script);
      if (!canFinalize(input, script, scriptType))
        throw new Error(`Can not finalize input #${inputIndex}`);
      return prepareFinalScripts(
        script,
        scriptType,
        input.partialSig,
        isSegwit,
        isP2SH,
        isP2WSH
      );
    }
    function prepareFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {
      let finalScriptSig;
      let finalScriptWitness;
      const payment = getPayment(script, scriptType, partialSig);
      const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });
      const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });
      if (isSegwit) {
        if (p2wsh) {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            p2wsh.witness
          );
        } else {
          finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(
            payment.witness
          );
        }
        if (p2sh) {
          finalScriptSig = p2sh.input;
        }
      } else {
        if (p2sh) {
          finalScriptSig = p2sh.input;
        } else {
          finalScriptSig = payment.input;
        }
      }
      return {
        finalScriptSig,
        finalScriptWitness
      };
    }
    function getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      const { hash, sighashType, script } = getHashForSig(
        inputIndex,
        input,
        cache,
        false,
        sighashTypes
      );
      checkScriptForPubkey(pubkey, script, "sign");
      return {
        hash,
        sighashType
      };
    }
    function getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;
      checkSighashTypeAllowed(sighashType, sighashTypes);
      let hash;
      let prevout;
      if (input.nonWitnessUtxo) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const prevoutHash = unsignedTx.ins[inputIndex].hash;
        const utxoHash = nonWitnessUtxoTx.getHash();
        if (!prevoutHash.equals(utxoHash)) {
          throw new Error(
            `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`
          );
        }
        const prevoutIndex = unsignedTx.ins[inputIndex].index;
        prevout = nonWitnessUtxoTx.outs[prevoutIndex];
      } else if (input.witnessUtxo) {
        prevout = input.witnessUtxo;
      } else {
        throw new Error("Need a Utxo input item for signing");
      }
      const { meaningfulScript, type } = getMeaningfulScript(
        prevout.script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      if (["p2sh-p2wsh", "p2wsh"].indexOf(type) >= 0) {
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          meaningfulScript,
          prevout.value,
          sighashType
        );
      } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {
        const signingScript = payments.p2pkh({
          hash: meaningfulScript.slice(2)
        }).output;
        hash = unsignedTx.hashForWitnessV0(
          inputIndex,
          signingScript,
          prevout.value,
          sighashType
        );
      } else {
        if (input.nonWitnessUtxo === void 0 && cache.__UNSAFE_SIGN_NONSEGWIT === false)
          throw new Error(
            `Input #${inputIndex} has witnessUtxo but non-segwit script: ${meaningfulScript.toString("hex")}`
          );
        if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)
          console.warn(
            "Warning: Signing non-segwit inputs without the full parent transaction means there is a chance that a miner could feed you incorrect information to trick you into paying large fees. This behavior is the same as Psbt's predecessor (TransactionBuilder - now removed) when signing non-segwit scripts. You are not able to export this Psbt with toBuffer|toBase64|toHex since it is not BIP174 compliant.\n*********************\nPROCEED WITH CAUTION!\n*********************"
          );
        hash = unsignedTx.hashForSignature(
          inputIndex,
          meaningfulScript,
          sighashType
        );
      }
      return {
        script: meaningfulScript,
        sighashType,
        hash
      };
    }
    function getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {
      const allPublicKeys = [];
      if (input.tapInternalKey) {
        const key = getPrevoutTaprootKey(inputIndex, input, cache);
        if (key) {
          allPublicKeys.push(key);
        }
      }
      if (input.tapScriptSig) {
        const tapScriptPubkeys = input.tapScriptSig.map((tss) => tss.pubkey);
        allPublicKeys.push(...tapScriptPubkeys);
      }
      const allHashes = allPublicKeys.map(
        (pubicKey) => getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache)
      );
      return allHashes.flat();
    }
    function getPrevoutTaprootKey(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;
    }
    function trimTaprootSig(signature) {
      return signature.length === 64 ? signature : signature.subarray(0, 64);
    }
    function getTaprootHashesForSig(inputIndex, input, inputs, pubkey, cache, tapLeafHashToSign, allowedSighashTypes) {
      const unsignedTx = cache.__TX;
      const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;
      checkSighashTypeAllowed(sighashType, allowedSighashTypes);
      const prevOuts = inputs.map(
        (i18, index) => getScriptAndAmountFromUtxo(index, i18, cache)
      );
      const signingScripts = prevOuts.map((o13) => o13.script);
      const values = prevOuts.map((o13) => o13.value);
      const hashes = [];
      if (input.tapInternalKey && !tapLeafHashToSign) {
        const outputKey = getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);
        if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {
          const tapKeyHash = unsignedTx.hashForWitnessV1(
            inputIndex,
            signingScripts,
            values,
            sighashType
          );
          hashes.push({ pubkey, hash: tapKeyHash });
        }
      }
      const tapLeafHashes = (input.tapLeafScript || []).filter((tapLeaf) => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script)).map((tapLeaf) => {
        const hash = (0, bip341_1.tapleafHash)({
          output: tapLeaf.script,
          version: tapLeaf.leafVersion
        });
        return Object.assign({ hash }, tapLeaf);
      }).filter(
        (tapLeaf) => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash)
      ).map((tapLeaf) => {
        const tapScriptHash = unsignedTx.hashForWitnessV1(
          inputIndex,
          signingScripts,
          values,
          sighashType,
          tapLeaf.hash
        );
        return {
          pubkey,
          hash: tapScriptHash,
          leafHash: tapLeaf.hash
        };
      });
      return hashes.concat(tapLeafHashes);
    }
    function checkSighashTypeAllowed(sighashType, sighashTypes) {
      if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {
        const str = sighashTypeToString(sighashType);
        throw new Error(
          `Sighash type is not allowed. Retry the sign method passing the sighashTypes array of whitelisted types. Sighash type: ${str}`
        );
      }
    }
    function getPayment(script, scriptType, partialSig) {
      let payment;
      switch (scriptType) {
        case "multisig":
          const sigs = getSortedSigs(script, partialSig);
          payment = payments.p2ms({
            output: script,
            signatures: sigs
          });
          break;
        case "pubkey":
          payment = payments.p2pk({
            output: script,
            signature: partialSig[0].signature
          });
          break;
        case "pubkeyhash":
          payment = payments.p2pkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
        case "witnesspubkeyhash":
          payment = payments.p2wpkh({
            output: script,
            pubkey: partialSig[0].pubkey,
            signature: partialSig[0].signature
          });
          break;
      }
      return payment;
    }
    function getScriptFromInput(inputIndex, input, cache) {
      const unsignedTx = cache.__TX;
      const res = {
        script: null,
        isSegwit: false,
        isP2SH: false,
        isP2WSH: false
      };
      res.isP2SH = !!input.redeemScript;
      res.isP2WSH = !!input.witnessScript;
      if (input.witnessScript) {
        res.script = input.witnessScript;
      } else if (input.redeemScript) {
        res.script = input.redeemScript;
      } else {
        if (input.nonWitnessUtxo) {
          const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
            cache,
            input,
            inputIndex
          );
          const prevoutIndex = unsignedTx.ins[inputIndex].index;
          res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;
        } else if (input.witnessUtxo) {
          res.script = input.witnessUtxo.script;
        }
      }
      if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {
        res.isSegwit = true;
      }
      return res;
    }
    function getSignersFromHD(inputIndex, inputs, hdKeyPair) {
      const input = (0, utils_1.checkForInput)(inputs, inputIndex);
      if (!input.bip32Derivation || input.bip32Derivation.length === 0) {
        throw new Error("Need bip32Derivation to sign with HD");
      }
      const myDerivations = input.bip32Derivation.map((bipDv) => {
        if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {
          return bipDv;
        } else {
          return;
        }
      }).filter((v8) => !!v8);
      if (myDerivations.length === 0) {
        throw new Error(
          "Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint"
        );
      }
      const signers = myDerivations.map((bipDv) => {
        const node = hdKeyPair.derivePath(bipDv.path);
        if (!bipDv.pubkey.equals(node.publicKey)) {
          throw new Error("pubkey did not match bip32Derivation");
        }
        return node;
      });
      return signers;
    }
    function getSortedSigs(script, partialSig) {
      const p2ms = payments.p2ms({ output: script });
      return p2ms.pubkeys.map((pk) => {
        return (partialSig.filter((ps) => {
          return ps.pubkey.equals(pk);
        })[0] || {}).signature;
      }).filter((v8) => !!v8);
    }
    function scriptWitnessToWitnessStack(buffer) {
      let offset = 0;
      function readSlice(n13) {
        offset += n13;
        return buffer.slice(offset - n13, offset);
      }
      function readVarInt() {
        const vi = varuint.decode(buffer, offset);
        offset += varuint.decode.bytes;
        return vi;
      }
      function readVarSlice() {
        return readSlice(readVarInt());
      }
      function readVector() {
        const count = readVarInt();
        const vector = [];
        for (let i18 = 0; i18 < count; i18++) vector.push(readVarSlice());
        return vector;
      }
      return readVector();
    }
    function sighashTypeToString(sighashType) {
      let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? "SIGHASH_ANYONECANPAY | " : "";
      const sigMod = sighashType & 31;
      switch (sigMod) {
        case transaction_1.Transaction.SIGHASH_ALL:
          text += "SIGHASH_ALL";
          break;
        case transaction_1.Transaction.SIGHASH_SINGLE:
          text += "SIGHASH_SINGLE";
          break;
        case transaction_1.Transaction.SIGHASH_NONE:
          text += "SIGHASH_NONE";
          break;
      }
      return text;
    }
    function addNonWitnessTxCache(cache, input, inputIndex) {
      cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;
      const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);
      cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;
      const self = cache;
      const selfIndex = inputIndex;
      delete input.nonWitnessUtxo;
      Object.defineProperty(input, "nonWitnessUtxo", {
        enumerable: true,
        get() {
          const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];
          const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];
          if (buf !== void 0) {
            return buf;
          } else {
            const newBuf = txCache.toBuffer();
            self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;
            return newBuf;
          }
        },
        set(data) {
          self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;
        }
      });
    }
    function inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {
      let inputAmount = 0;
      inputs.forEach((input, idx) => {
        if (mustFinalize && input.finalScriptSig)
          tx.ins[idx].script = input.finalScriptSig;
        if (mustFinalize && input.finalScriptWitness) {
          tx.ins[idx].witness = scriptWitnessToWitnessStack(
            input.finalScriptWitness
          );
        }
        if (input.witnessUtxo) {
          inputAmount += input.witnessUtxo.value;
        } else if (input.nonWitnessUtxo) {
          const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);
          const vout = tx.ins[idx].index;
          const out = nwTx.outs[vout];
          inputAmount += out.value;
        }
      });
      const outputAmount = tx.outs.reduce((total, o13) => total + o13.value, 0);
      const fee = inputAmount - outputAmount;
      if (fee < 0) {
        throw new Error("Outputs are spending more than Inputs");
      }
      const bytes = tx.virtualSize();
      cache.__FEE = fee;
      cache.__EXTRACTED_TX = tx;
      cache.__FEE_RATE = Math.floor(fee / bytes);
    }
    function nonWitnessUtxoTxFromCache(cache, input, inputIndex) {
      const c10 = cache.__NON_WITNESS_UTXO_TX_CACHE;
      if (!c10[inputIndex]) {
        addNonWitnessTxCache(cache, input, inputIndex);
      }
      return c10[inputIndex];
    }
    function getScriptFromUtxo(inputIndex, input, cache) {
      const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);
      return script;
    }
    function getScriptAndAmountFromUtxo(inputIndex, input, cache) {
      if (input.witnessUtxo !== void 0) {
        return {
          script: input.witnessUtxo.script,
          value: input.witnessUtxo.value
        };
      } else if (input.nonWitnessUtxo !== void 0) {
        const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(
          cache,
          input,
          inputIndex
        );
        const o13 = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];
        return { script: o13.script, value: o13.value };
      } else {
        throw new Error("Can't find pubkey in input without Utxo data");
      }
    }
    function pubkeyInInput(pubkey, input, inputIndex, cache) {
      const script = getScriptFromUtxo(inputIndex, input, cache);
      const { meaningfulScript } = getMeaningfulScript(
        script,
        inputIndex,
        "input",
        input.redeemScript,
        input.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function pubkeyInOutput(pubkey, output, outputIndex, cache) {
      const script = cache.__TX.outs[outputIndex].script;
      const { meaningfulScript } = getMeaningfulScript(
        script,
        outputIndex,
        "output",
        output.redeemScript,
        output.witnessScript
      );
      return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);
    }
    function redeemFromFinalScriptSig(finalScript) {
      if (!finalScript) return;
      const decomp = bscript.decompile(finalScript);
      if (!decomp) return;
      const lastItem = decomp[decomp.length - 1];
      if (!Buffer.isBuffer(lastItem) || isPubkeyLike(lastItem) || isSigLike(lastItem))
        return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function redeemFromFinalWitnessScript(finalScript) {
      if (!finalScript) return;
      const decomp = scriptWitnessToWitnessStack(finalScript);
      const lastItem = decomp[decomp.length - 1];
      if (isPubkeyLike(lastItem)) return;
      const sDecomp = bscript.decompile(lastItem);
      if (!sDecomp) return;
      return lastItem;
    }
    function compressPubkey(pubkey) {
      if (pubkey.length === 65) {
        const parity = pubkey[64] & 1;
        const newKey = pubkey.slice(0, 33);
        newKey[0] = 2 | parity;
        return newKey;
      }
      return pubkey.slice();
    }
    function isPubkeyLike(buf) {
      return buf.length === 33 && bscript.isCanonicalPubKey(buf);
    }
    function isSigLike(buf) {
      return bscript.isCanonicalScriptSignature(buf);
    }
    function getMeaningfulScript(script, index, ioType, redeemScript, witnessScript) {
      const isP2SH = (0, psbtutils_1.isP2SHScript)(script);
      const isP2SHP2WSH = isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);
      const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);
      if (isP2SH && redeemScript === void 0)
        throw new Error("scriptPubkey is P2SH but redeemScript missing");
      if ((isP2WSH || isP2SHP2WSH) && witnessScript === void 0)
        throw new Error(
          "scriptPubkey or redeemScript is P2WSH but witnessScript missing"
        );
      let meaningfulScript;
      if (isP2SHP2WSH) {
        meaningfulScript = witnessScript;
        checkRedeemScript(index, script, redeemScript, ioType);
        checkWitnessScript(index, redeemScript, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2WSH) {
        meaningfulScript = witnessScript;
        checkWitnessScript(index, script, witnessScript, ioType);
        checkInvalidP2WSH(meaningfulScript);
      } else if (isP2SH) {
        meaningfulScript = redeemScript;
        checkRedeemScript(index, script, redeemScript, ioType);
      } else {
        meaningfulScript = script;
      }
      return {
        meaningfulScript,
        type: isP2SHP2WSH ? "p2sh-p2wsh" : isP2SH ? "p2sh" : isP2WSH ? "p2wsh" : "raw"
      };
    }
    function checkInvalidP2WSH(script) {
      if ((0, psbtutils_1.isP2WPKH)(script) || (0, psbtutils_1.isP2SHScript)(script)) {
        throw new Error("P2WPKH or P2SH can not be contained within P2WSH");
      }
    }
    function classifyScript(script) {
      if ((0, psbtutils_1.isP2WPKH)(script)) return "witnesspubkeyhash";
      if ((0, psbtutils_1.isP2PKH)(script)) return "pubkeyhash";
      if ((0, psbtutils_1.isP2MS)(script)) return "multisig";
      if ((0, psbtutils_1.isP2PK)(script)) return "pubkey";
      return "nonstandard";
    }
    function range(n13) {
      return [...Array(n13).keys()];
    }
  }
});

// node_modules/bitcoinjs-lib/src/index.js
var require_src5 = __commonJS({
  "node_modules/bitcoinjs-lib/src/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.initEccLib = exports.Transaction = exports.opcodes = exports.Psbt = exports.Block = exports.script = exports.payments = exports.networks = exports.crypto = exports.address = void 0;
    var address = require_address();
    exports.address = address;
    var crypto = require_crypto5();
    exports.crypto = crypto;
    var networks = require_networks();
    exports.networks = networks;
    var payments = require_payments();
    exports.payments = payments;
    var script = require_script();
    exports.script = script;
    var block_1 = require_block();
    Object.defineProperty(exports, "Block", {
      enumerable: true,
      get: function() {
        return block_1.Block;
      }
    });
    var psbt_1 = require_psbt2();
    Object.defineProperty(exports, "Psbt", {
      enumerable: true,
      get: function() {
        return psbt_1.Psbt;
      }
    });
    var ops_1 = require_ops();
    Object.defineProperty(exports, "opcodes", {
      enumerable: true,
      get: function() {
        return ops_1.OPS;
      }
    });
    var transaction_1 = require_transaction();
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function() {
        return transaction_1.Transaction;
      }
    });
    var ecc_lib_1 = require_ecc_lib();
    Object.defineProperty(exports, "initEccLib", {
      enumerable: true,
      get: function() {
        return ecc_lib_1.initEccLib;
      }
    });
  }
});

// node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "node_modules/property-expr/index.js"(exports, module) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values)) this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE);
    var setCache = new Cache(MAX_CACHE_SIZE);
    var getCache2 = new Cache(MAX_CACHE_SIZE);
    module.exports = {
      Cache,
      split: split2,
      normalizePath: normalizePath2,
      setter: function(path) {
        var parts = normalizePath2(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index = 0;
          var len = parts.length;
          var data = obj;
          while (index < len - 1) {
            var part = parts[index];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index++]];
          }
          data[parts[index]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath2(path);
        return getCache2.get(path) || getCache2.set(path, function getter2(data) {
          var index = 0, len = parts.length;
          while (index < len) {
            if (data != null || !safe) data = data[parts[index++]];
            else return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb, thisArg) {
        forEach2(Array.isArray(path) ? path : split2(path), cb, thisArg);
      }
    };
    function normalizePath2(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split2(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split2(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach2(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// node_modules/tiny-case/index.js
var require_tiny_case = __commonJS({
  "node_modules/tiny-case/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
    var words = (str) => str.match(reWords) || [];
    var upperFirst = (str) => str[0].toUpperCase() + str.slice(1);
    var join2 = (str, d20) => words(str).join(d20).toLowerCase();
    var camelCase2 = (str) => words(str).reduce(
      (acc, next) => `${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`,
      ""
    );
    var pascalCase = (str) => upperFirst(camelCase2(str));
    var snakeCase2 = (str) => join2(str, "_");
    var kebabCase = (str) => join2(str, "-");
    var sentenceCase = (str) => upperFirst(join2(str, " "));
    var titleCase = (str) => words(str).map(upperFirst).join(" ");
    module.exports = {
      words,
      upperFirst,
      camelCase: camelCase2,
      pascalCase,
      snakeCase: snakeCase2,
      kebabCase,
      sentenceCase,
      titleCase
    };
  }
});

// node_modules/toposort/index.js
var require_toposort = __commonJS({
  "node_modules/toposort/index.js"(exports, module) {
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    module.exports = function(edges) {
      return toposort2(uniqueNodes(edges), edges);
    };
    module.exports.array = toposort2;
    function toposort2(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i18 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i18--) {
        if (!visited[i18]) visit(nodes[i18], i18, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit(node, i19, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e17) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i19]) return;
        visited[i19] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i19 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i19];
            visit(child, nodesHash.get(child), predecessors);
          } while (i19);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i18 = 0, len = arr.length; i18 < len; i18++) {
        var edge = arr[i18];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i18 = 0, len = arr.length; i18 < len; i18++) {
        var edge = arr[i18];
        if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i18 = 0, len = arr.length; i18 < len; i18++) {
        res.set(arr[i18], i18);
      }
      return res;
    }
  }
});

// node_modules/ecpair/src/networks.js
var require_networks2 = __commonJS({
  "node_modules/ecpair/src/networks.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testnet = exports.bitcoin = void 0;
    exports.bitcoin = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "bc",
      bip32: {
        public: 76067358,
        private: 76066276
      },
      pubKeyHash: 0,
      scriptHash: 5,
      wif: 128
    };
    exports.testnet = {
      messagePrefix: "Bitcoin Signed Message:\n",
      bech32: "tb",
      bip32: {
        public: 70617039,
        private: 70615956
      },
      pubKeyHash: 111,
      scriptHash: 196,
      wif: 239
    };
  }
});

// node_modules/ecpair/src/types.js
var require_types2 = __commonJS({
  "node_modules/ecpair/src/types.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.maybe = exports.Boolean = exports.Array = exports.Buffer256bit = exports.Network = exports.typeforce = void 0;
    exports.typeforce = require_typeforce();
    exports.Network = exports.typeforce.compile({
      messagePrefix: exports.typeforce.oneOf(
        exports.typeforce.Buffer,
        exports.typeforce.String
      ),
      bip32: {
        public: exports.typeforce.UInt32,
        private: exports.typeforce.UInt32
      },
      pubKeyHash: exports.typeforce.UInt8,
      scriptHash: exports.typeforce.UInt8,
      wif: exports.typeforce.UInt8
    });
    exports.Buffer256bit = exports.typeforce.BufferN(32);
    exports.Array = exports.typeforce.Array;
    exports.Boolean = exports.typeforce.Boolean;
    exports.maybe = exports.typeforce.maybe;
  }
});

// node_modules/ecpair/src/testecc.js
var require_testecc2 = __commonJS({
  "node_modules/ecpair/src/testecc.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.testEcc = void 0;
    var h11 = (hex) => Buffer.from(hex, "hex");
    function testEcc(ecc) {
      assert(
        ecc.isPoint(
          h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        !ecc.isPoint(
          h11("030000000000000000000000000000000000000000000000000000000000000005")
        )
      );
      assert(
        ecc.isPrivate(
          h11("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        ecc.isPrivate(
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        )
      );
      assert(
        !ecc.isPrivate(
          h11("0000000000000000000000000000000000000000000000000000000000000000")
        )
      );
      assert(
        !ecc.isPrivate(
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
        )
      );
      assert(
        !ecc.isPrivate(
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364142")
        )
      );
      assert(
        Buffer.from(
          ecc.privateAdd(
            h11("0000000000000000000000000000000000000000000000000000000000000001"),
            h11("0000000000000000000000000000000000000000000000000000000000000000")
          )
        ).equals(
          h11("0000000000000000000000000000000000000000000000000000000000000001")
        )
      );
      assert(
        ecc.privateAdd(
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e"),
          h11("0000000000000000000000000000000000000000000000000000000000000003")
        ) === null
      );
      assert(
        Buffer.from(
          ecc.privateAdd(
            h11("e211078564db65c3ce7704f08262b1f38f1ef412ad15b5ac2d76657a63b2c500"),
            h11("b51fbb69051255d1becbd683de5848242a89c229348dd72896a87ada94ae8665")
          )
        ).equals(
          h11("9730c2ee69edbb958d42db7460bafa18fef9d955325aec99044c81c8282b0a24")
        )
      );
      assert(
        Buffer.from(
          ecc.privateNegate(
            h11("0000000000000000000000000000000000000000000000000000000000000001")
          )
        ).equals(
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        )
      );
      assert(
        Buffer.from(
          ecc.privateNegate(
            h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd036413e")
          )
        ).equals(
          h11("0000000000000000000000000000000000000000000000000000000000000003")
        )
      );
      assert(
        Buffer.from(
          ecc.privateNegate(
            h11("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
          )
        ).equals(
          h11("4eede1bf775995d70a494f0a7bb6bc11e0b8cccd41cce8009ab1132c8b0a3792")
        )
      );
      assert(
        Buffer.from(
          ecc.pointCompress(
            h11(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            ),
            true
          )
        ).equals(
          h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        Buffer.from(
          ecc.pointCompress(
            h11(
              "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
            ),
            false
          )
        ).equals(
          h11(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          )
        )
      );
      assert(
        Buffer.from(
          ecc.pointCompress(
            h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            true
          )
        ).equals(
          h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798")
        )
      );
      assert(
        Buffer.from(
          ecc.pointCompress(
            h11("0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
            false
          )
        ).equals(
          h11(
            "0479be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8"
          )
        )
      );
      assert(
        Buffer.from(
          ecc.pointFromScalar(
            h11("b1121e4088a66a28f5b6b0f5844943ecd9f610196d7bb83b25214b60452c09af")
          )
        ).equals(
          h11("02b07ba9dca9523b7ef4bd97703d43d20399eb698e194704791a25ce77a400df99")
        )
      );
      assert(
        ecc.xOnlyPointAddTweak(
          h11("79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
        ) === null
      );
      let xOnlyRes = ecc.xOnlyPointAddTweak(
        h11("1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b"),
        h11("a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac")
      );
      assert(
        Buffer.from(xOnlyRes.xOnlyPubkey).equals(
          h11("e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf")
        ) && xOnlyRes.parity === 1
      );
      xOnlyRes = ecc.xOnlyPointAddTweak(
        h11("2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991"),
        h11("823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47")
      );
      assert(
        Buffer.from(xOnlyRes.xOnlyPubkey).equals(
          h11("9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c")
        ) && xOnlyRes.parity === 0
      );
      assert(
        Buffer.from(
          ecc.sign(
            h11("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
            h11("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140")
          )
        ).equals(
          h11(
            "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
          )
        )
      );
      assert(
        ecc.verify(
          h11("5e9f0a0d593efdcf78ac923bc3313e4e7d408d574354ee2b3288c0da9fbba6ed"),
          h11("0379be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
          h11(
            "54c4a33c6423d689378f160a7ff8b61330444abb58fb470f96ea16d99d4a2fed07082304410efa6b2943111b6a4e0aaa7b7db55a07e9861d1fb3cb1f421044a5"
          )
        )
      );
      if (ecc.signSchnorr) {
        assert(
          Buffer.from(
            ecc.signSchnorr(
              h11("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
              h11("c90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b14e5c9"),
              h11("c87aa53824b4d7ae2eb035a2b5bbbccc080e76cdc6d1692c4b0b62d798e6d906")
            )
          ).equals(
            h11(
              "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
            )
          )
        );
      }
      if (ecc.verifySchnorr) {
        assert(
          ecc.verifySchnorr(
            h11("7e2d58d8b3bcdf1abadec7829054f90dda9805aab56c77333024b9d0a508b75c"),
            h11("dd308afec5777e13121fa72b9cc1b7cc0139715309b086c960e18fd969774eb8"),
            h11(
              "5831aaeed7b44bb74e5eab94ba9d4294c49bcf2a60728d8b4c200f50dd313c1bab745879a5ad954a72c45a91c3a51d3c7adea98d82f8481e0e1e03674a6f3fb7"
            )
          )
        );
      }
    }
    exports.testEcc = testEcc;
    function assert(bool) {
      if (!bool) throw new Error("ecc library invalid");
    }
  }
});

// node_modules/ecpair/src/ecpair.js
var require_ecpair = __commonJS({
  "node_modules/ecpair/src/ecpair.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECPairFactory = exports.networks = void 0;
    var networks = require_networks2();
    exports.networks = networks;
    var types = require_types2();
    var randomBytes = require_browser2();
    var wif = require_wif();
    var testecc_1 = require_testecc2();
    var isOptions = types.typeforce.maybe(
      types.typeforce.compile({
        compressed: types.maybe(types.Boolean),
        network: types.maybe(types.Network)
      })
    );
    var toXOnly = (pubKey) => pubKey.length === 32 ? pubKey : pubKey.slice(1, 33);
    function ECPairFactory(ecc) {
      (0, testecc_1.testEcc)(ecc);
      function isPoint(maybePoint) {
        return ecc.isPoint(maybePoint);
      }
      function fromPrivateKey(buffer, options) {
        types.typeforce(types.Buffer256bit, buffer);
        if (!ecc.isPrivate(buffer))
          throw new TypeError("Private key not in range [1, n)");
        types.typeforce(isOptions, options);
        return new ECPair(buffer, void 0, options);
      }
      function fromPublicKey(buffer, options) {
        types.typeforce(ecc.isPoint, buffer);
        types.typeforce(isOptions, options);
        return new ECPair(void 0, buffer, options);
      }
      function fromWIF(wifString, network) {
        const decoded = wif.decode(wifString);
        const version = decoded.version;
        if (types.Array(network)) {
          network = network.filter((x15) => {
            return version === x15.wif;
          }).pop();
          if (!network) throw new Error("Unknown network version");
        } else {
          network = network || networks.bitcoin;
          if (version !== network.wif) throw new Error("Invalid network version");
        }
        return fromPrivateKey(decoded.privateKey, {
          compressed: decoded.compressed,
          network
        });
      }
      function makeRandom(options) {
        types.typeforce(isOptions, options);
        if (options === void 0) options = {};
        const rng = options.rng || randomBytes;
        let d20;
        do {
          d20 = rng(32);
          types.typeforce(types.Buffer256bit, d20);
        } while (!ecc.isPrivate(d20));
        return fromPrivateKey(d20, options);
      }
      class ECPair {
        __D;
        __Q;
        compressed;
        network;
        lowR;
        constructor(__D, __Q, options) {
          this.__D = __D;
          this.__Q = __Q;
          this.lowR = false;
          if (options === void 0) options = {};
          this.compressed = options.compressed === void 0 ? true : options.compressed;
          this.network = options.network || networks.bitcoin;
          if (__Q !== void 0)
            this.__Q = Buffer.from(ecc.pointCompress(__Q, this.compressed));
        }
        get privateKey() {
          return this.__D;
        }
        get publicKey() {
          if (!this.__Q) {
            const p20 = ecc.pointFromScalar(this.__D, this.compressed);
            this.__Q = Buffer.from(p20);
          }
          return this.__Q;
        }
        toWIF() {
          if (!this.__D) throw new Error("Missing private key");
          return wif.encode(this.network.wif, this.__D, this.compressed);
        }
        tweak(t12) {
          if (this.privateKey) return this.tweakFromPrivateKey(t12);
          return this.tweakFromPublicKey(t12);
        }
        sign(hash, lowR) {
          if (!this.__D) throw new Error("Missing private key");
          if (lowR === void 0) lowR = this.lowR;
          if (lowR === false) {
            return Buffer.from(ecc.sign(hash, this.__D));
          } else {
            let sig = ecc.sign(hash, this.__D);
            const extraData = Buffer.alloc(32, 0);
            let counter = 0;
            while (sig[0] > 127) {
              counter++;
              extraData.writeUIntLE(counter, 0, 6);
              sig = ecc.sign(hash, this.__D, extraData);
            }
            return Buffer.from(sig);
          }
        }
        signSchnorr(hash) {
          if (!this.privateKey) throw new Error("Missing private key");
          if (!ecc.signSchnorr)
            throw new Error("signSchnorr not supported by ecc library");
          return Buffer.from(ecc.signSchnorr(hash, this.privateKey));
        }
        verify(hash, signature) {
          return ecc.verify(hash, this.publicKey, signature);
        }
        verifySchnorr(hash, signature) {
          if (!ecc.verifySchnorr)
            throw new Error("verifySchnorr not supported by ecc library");
          return ecc.verifySchnorr(hash, this.publicKey.subarray(1, 33), signature);
        }
        tweakFromPublicKey(t12) {
          const xOnlyPubKey = toXOnly(this.publicKey);
          const tweakedPublicKey = ecc.xOnlyPointAddTweak(xOnlyPubKey, t12);
          if (!tweakedPublicKey || tweakedPublicKey.xOnlyPubkey === null)
            throw new Error("Cannot tweak public key!");
          const parityByte = Buffer.from([
            tweakedPublicKey.parity === 0 ? 2 : 3
          ]);
          return fromPublicKey(
            Buffer.concat([parityByte, tweakedPublicKey.xOnlyPubkey]),
            { network: this.network, compressed: this.compressed }
          );
        }
        tweakFromPrivateKey(t12) {
          const hasOddY = this.publicKey[0] === 3 || this.publicKey[0] === 4 && (this.publicKey[64] & 1) === 1;
          const privateKey = hasOddY ? ecc.privateNegate(this.privateKey) : this.privateKey;
          const tweakedPrivateKey = ecc.privateAdd(privateKey, t12);
          if (!tweakedPrivateKey) throw new Error("Invalid tweaked private key!");
          return fromPrivateKey(Buffer.from(tweakedPrivateKey), {
            network: this.network,
            compressed: this.compressed
          });
        }
      }
      return {
        isPoint,
        fromPrivateKey,
        fromPublicKey,
        fromWIF,
        makeRandom
      };
    }
    exports.ECPairFactory = ECPairFactory;
  }
});

// node_modules/ecpair/src/index.js
var require_src6 = __commonJS({
  "node_modules/ecpair/src/index.js"(exports) {
    "use strict";
    var import_dist1036 = __toESM(require_dist());
    var import_dist1037 = __toESM(require_dist2());
    var import_dist1038 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.networks = exports.ECPairFactory = exports.default = void 0;
    var ecpair_1 = require_ecpair();
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ecpair_1.ECPairFactory;
      }
    });
    Object.defineProperty(exports, "ECPairFactory", {
      enumerable: true,
      get: function() {
        return ecpair_1.ECPairFactory;
      }
    });
    Object.defineProperty(exports, "networks", {
      enumerable: true,
      get: function() {
        return ecpair_1.networks;
      }
    });
  }
});

// node_modules/@catalogfi/wallets/dist/index.js
var import_dist1033 = __toESM(require_dist());
var import_dist1034 = __toESM(require_dist2());
var import_dist1035 = __toESM(require_dist3());

// node_modules/@catalogfi/wallets/dist/index2.js
var import_dist = __toESM(require_dist(), 1);
var import_dist2 = __toESM(require_dist2(), 1);
var import_dist3 = __toESM(require_dist3(), 1);
var a = ((i18) => (i18[i18.Bitcoin = 0] = "Bitcoin", i18[i18.EVM = 1] = "EVM", i18))(a || {});

// node_modules/@catalogfi/wallets/dist/index3.js
var import_dist10 = __toESM(require_dist(), 1);
var import_dist11 = __toESM(require_dist2(), 1);
var import_dist12 = __toESM(require_dist3(), 1);
var import_bip39 = __toESM(require_src(), 1);
var import_bip32 = __toESM(require_src3(), 1);

// node_modules/@catalogfi/wallets/dist/index19.js
var import_dist7 = __toESM(require_dist(), 1);
var import_dist8 = __toESM(require_dist2(), 1);
var import_dist9 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index8.js
var import_dist4 = __toESM(require_dist(), 1);
var import_dist5 = __toESM(require_dist2(), 1);
var import_dist6 = __toESM(require_dist3(), 1);
var e = ((t12) => (t12.Mainnet = "Mainnet", t12.Testnet = "Testnet", t12.Regtest = "Regtest", t12))(e || {});
var n = ((t12) => (t12.ALL = "ALL", t12.IN = "IN", t12.OUT = "OUT", t12))(n || {});
var s = ((t12) => (t12.SLOW = "SLOW", t12.MEDIUM = "MEDIUM", t12.FAST = "FAST", t12))(s || {});
var a2 = { SLOW: "economyFee", MEDIUM: "hourFee", FAST: "fastestFee" };

// node_modules/@catalogfi/wallets/dist/index19.js
var n2 = (i18, t12, o13, p20) => `m/${i18}'/${t12 === e.Mainnet ? 0 : 1}'/${o13}'/0/${p20 ?? 0}`;
var a3 = { bip44: (i18, t12, o13) => n2("44", i18, o13 ?? 0, t12), bip49: (i18, t12, o13) => n2("49", i18, o13 ?? 0, t12), bip84: (i18, t12, o13) => n2("84", i18, o13 ?? 0, t12) };

// node_modules/@catalogfi/wallets/dist/index3.js
var p = () => (0, import_bip39.generateMnemonic)();
function d2(r13, n13, o13) {
  if (!(0, import_bip39.validateMnemonic)(r13)) throw new Error("Invalid mnemonic");
  const t12 = (o13 == null ? void 0 : o13.path) ?? a3.bip44(n13, (o13 == null ? void 0 : o13.index) ?? 0), e17 = (0, import_bip32.BIP32Factory)(lib_exports).fromSeed((0, import_bip39.mnemonicToSeedSync)(r13));
  return v(e17, t12);
}
var v = (r13, n13) => {
  const o13 = r13.derivePath(n13).privateKey;
  if (!o13) throw new Error("Unable to derive private key from mnemonic");
  return o13.toString("hex");
};

// node_modules/@catalogfi/wallets/dist/index4.js
var import_dist13 = __toESM(require_dist(), 1);
var import_dist14 = __toESM(require_dist2(), 1);
var import_dist15 = __toESM(require_dist3(), 1);
var s2 = class _s {
  constructor(r13, t12) {
    this.isEVM = r13, this.address = t12;
  }
  static from_evm(r13) {
    return new _s(true, r13);
  }
  static from_btc(r13) {
    return new _s(false, r13);
  }
  unwrap_evm() {
    if (!this.isEVM) throw new Error("Not an EVM address");
    return this.address;
  }
  unwrap_btc() {
    if (this.isEVM) throw new Error("Not a BTC address");
    return this.address;
  }
  isEvm() {
    return this.isEVM;
  }
  isBtc() {
    return !this.isEVM;
  }
};

// node_modules/@catalogfi/wallets/dist/index5.js
var import_dist34 = __toESM(require_dist(), 1);
var import_dist35 = __toESM(require_dist2(), 1);
var import_dist36 = __toESM(require_dist3(), 1);
var import_bitcoinjs_lib4 = __toESM(require_src5(), 1);

// node_modules/@catalogfi/wallets/dist/index20.js
var import_dist16 = __toESM(require_dist(), 1);
var import_dist17 = __toESM(require_dist2(), 1);
var import_dist18 = __toESM(require_dist3(), 1);
var import_bitcoinjs_lib = __toESM(require_src5(), 1);
function n3(r13) {
  return Buffer.from(r13, "hex").reverse();
}
function o(r13) {
  if (r13 === e.Mainnet) return import_bitcoinjs_lib.networks.bitcoin;
  if (r13 === e.Testnet) return import_bitcoinjs_lib.networks.testnet;
  if (r13 === e.Regtest) return import_bitcoinjs_lib.networks.regtest;
  throw new Error("Invalid network");
}

// node_modules/@catalogfi/wallets/dist/index24.js
var import_dist19 = __toESM(require_dist(), 1);
var import_dist20 = __toESM(require_dist2(), 1);
var import_dist21 = __toESM(require_dist3(), 1);
var import_bitcoinjs_lib2 = __toESM(require_src5(), 1);
var E2 = (e17, c10, i18 = false) => {
  const t12 = (s15) => {
    try {
      s15 = import_bitcoinjs_lib2.address.fromBech32(s15).data.toString("hex");
    } catch (r13) {
      if (r13.message.includes("Mixed-case string") || r13.message.includes("too short")) s15 = import_bitcoinjs_lib2.address.fromBase58Check(s15).hash.toString("hex");
      else throw new Error(r13);
    }
    return s15;
  }, d20 = import_bitcoinjs_lib2.script.fromASM(`
          OP_IF
              OP_SHA256
              ${e17.secretHash}
              OP_EQUALVERIFY
              OP_DUP
              OP_HASH160
              ${t12(e17.recipientAddress.address)}
          OP_ELSE
              ${import_bitcoinjs_lib2.script.number.encode(e17.expiryBlocks).toString("hex")}
              OP_CHECKSEQUENCEVERIFY
              OP_DROP
              OP_DUP
              OP_HASH160
              ${t12(e17.refundAddress.address)}
              OP_ENDIF
            OP_EQUALVERIFY
            OP_CHECKSIG
      `.trim().replace(/\s+/g, " ")), o13 = import_bitcoinjs_lib2.payments[i18 ? "p2sh" : "p2wsh"]({ redeem: { output: d20 }, network: c10 });
  if (!o13.address) throw new Error("Could not build address");
  return { script: d20, address: o13.address };
};

// node_modules/@catalogfi/wallets/dist/index6.js
var import_dist22 = __toESM(require_dist(), 1);
var import_dist23 = __toESM(require_dist2(), 1);
var import_dist24 = __toESM(require_dist3(), 1);
var t = { INVALID_PK: "invalid private key", FEE_EXCEEDS_AMOUNT: (e17, n13) => `fee exceeds amount: fee: ${e17} > amount: ${n13}`, SWAP_NOT_FOUND: "swap config not found, please set the swap config first", SCRIPT_NOT_FUNDED: "script not funded", SWAP_NOT_EXPIRED: (e17) => `swap not expired. Need ${e17} more blocks`, MIN_AMOUNT: (e17) => `amount is too low. Minimum amount is ${e17}`, INSUFFICIENT_FUNDS: (e17, n13) => `insufficient funds, need ${n13} but got ${e17}`, AmtPlusFeeExceedsBalance: (e17, n13, o13) => `amount + fee exceeds balance. Need ${e17 + n13} but got ${o13}` };
var i2 = { INVALID_SECRET_HASH: "invalid secret hash", INVALID_PUBKEY_OR_SECRET: "invalid public key or secret", INVALID_PUBKEY: "invalid public key", ORDER_NOT_EXPIRED: "you cannot refund before your transaction expires" };

// node_modules/@catalogfi/wallets/dist/index12.js
var import_dist28 = __toESM(require_dist(), 1);
var import_dist29 = __toESM(require_dist2(), 1);
var import_dist30 = __toESM(require_dist3(), 1);
var import_bitcoinjs_lib3 = __toESM(require_src5(), 1);

// node_modules/yup/index.esm.js
var import_dist25 = __toESM(require_dist());
var import_dist26 = __toESM(require_dist2());
var import_dist27 = __toESM(require_dist3());
var import_property_expr = __toESM(require_property_expr());
var import_tiny_case = __toESM(require_tiny_case());
var import_toposort = __toESM(require_toposort());
var toString = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val) return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false) return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number") return printNumber(val);
  if (typeOf === "string") return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol") return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString.call(val).slice(8, -1);
  if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp") return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null) return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null) return result2;
    return value2;
  }, 2);
}
function toArray(value) {
  return value == null ? [] : [].concat(value);
}
var _Symbol$toStringTag;
var _Symbol$hasInstance;
var _Symbol$toStringTag2;
var strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
var ValidationErrorNoStack = class {
  constructor(errorOrErrors, value, field, type) {
    this.name = void 0;
    this.message = void 0;
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = void 0;
    this.inner = void 0;
    this[_Symbol$toStringTag] = "Error";
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        const innerErrors = err.inner.length ? err.inner : [err];
        this.inner.push(...innerErrors);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
  }
};
_Symbol$hasInstance = Symbol.hasInstance;
_Symbol$toStringTag2 = Symbol.toStringTag;
var ValidationError = class _ValidationError extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path) params = Object.assign({}, params, {
      path
    });
    if (typeof message === "string") return message.replace(strReg, (_10, key) => printValue(params[key]));
    if (typeof message === "function") return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type, disableStack) {
    const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
    if (disableStack) {
      return errorNoStack;
    }
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.params = void 0;
    this.errors = [];
    this.inner = [];
    this[_Symbol$toStringTag2] = "Error";
    this.name = errorNoStack.name;
    this.message = errorNoStack.message;
    this.type = errorNoStack.type;
    this.value = errorNoStack.value;
    this.path = errorNoStack.path;
    this.errors = errorNoStack.errors;
    this.inner = errorNoStack.inner;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _ValidationError);
    }
  }
  static [_Symbol$hasInstance](inst) {
    return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
  }
};
var mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  defined: "${path} must be defined",
  notNull: "${path} cannot be null",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
    return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
  }
};
var string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  datetime: "${path} must be a valid ISO date-time",
  datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
  datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
var number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
var date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
var boolean = {
  isValue: "${path} field must be ${value}"
};
var object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
var array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
var tuple = {
  notType: (params) => {
    const {
      path,
      value,
      spec
    } = params;
    const typeLen = spec.types.length;
    if (Array.isArray(value)) {
      if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
      if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
    }
    return ValidationError.formatError(mixed.notType, params);
  }
};
var locale = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean,
  tuple
});
var isSchema = (obj) => obj && obj.__isYupSchema__;
var Condition = class _Condition {
  static fromOptions(refs, config) {
    if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is,
      then,
      otherwise
    } = config;
    let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
    return new _Condition(refs, (values, schema) => {
      var _branch;
      let branch = check(...values) ? then : otherwise;
      return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
    });
  }
  constructor(refs, builder) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    this.fn = builder;
  }
  resolve(base, options) {
    let values = this.refs.map((ref) => (
      // TODO: ? operator here?
      ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)
    ));
    let schema = this.fn(values, base, options);
    if (schema === void 0 || // @ts-ignore this can be base
    schema === base) {
      return base;
    }
    if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
};
var prefixes = {
  context: "$",
  value: "."
};
var Reference = class {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "") throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix.length);
    this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent, context) {
    let result = this.isContext ? context : this.isValue ? value : parent;
    if (this.getter) result = this.getter(result || {});
    if (this.map) result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
};
Reference.prototype.__isYupRef = true;
var isAbsent = (value) => value == null;
function createValidation(config) {
  function validate({
    value,
    path = "",
    options,
    originalValue,
    schema
  }, panic, next) {
    const {
      name,
      test,
      params,
      message,
      skipAbsent
    } = config;
    let {
      parent,
      context,
      abortEarly = schema.spec.abortEarly,
      disableStackTrace = schema.spec.disableStackTrace
    } = options;
    function resolve(item) {
      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = Object.assign({
        value,
        originalValue,
        label: schema.spec.label,
        path: overrides.path || path,
        spec: schema.spec,
        disableStackTrace: overrides.disableStackTrace || disableStackTrace
      }, params, overrides.params);
      for (const key of Object.keys(nextParams)) nextParams[key] = resolve(nextParams[key]);
      const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
      error.params = nextParams;
      return error;
    }
    const invalid = abortEarly ? panic : next;
    let ctx = {
      path,
      parent,
      type: name,
      from: options.from,
      createError,
      resolve,
      options,
      originalValue,
      schema
    };
    const handleResult = (validOrError) => {
      if (ValidationError.isError(validOrError)) invalid(validOrError);
      else if (!validOrError) invalid(createError());
      else next(null);
    };
    const handleError = (err) => {
      if (ValidationError.isError(err)) invalid(err);
      else panic(err);
    };
    const shouldSkip = skipAbsent && isAbsent(value);
    if (shouldSkip) {
      return handleResult(true);
    }
    let result;
    try {
      var _result;
      result = test.call(ctx, value, ctx);
      if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
        if (options.sync) {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
        }
        return Promise.resolve(result).then(handleResult, handleError);
      }
    } catch (err) {
      handleError(err);
      return;
    }
    handleResult(result);
  }
  validate.OPTIONS = config;
  return validate;
}
function getIn(schema, path, value, context = value) {
  let parent, lastPart, lastPartDebug;
  if (!path) return {
    parent,
    parentPath: path,
    schema
  };
  (0, import_property_expr.forEach)(path, (_part, isBracket, isArray) => {
    let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
    schema = schema.resolve({
      context,
      parent,
      value
    });
    let isTuple = schema.type === "tuple";
    let idx = isArray ? parseInt(part, 10) : 0;
    if (schema.innerType || isTuple) {
      if (isTuple && !isArray) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent = value;
      value = value && value[idx];
      schema = isTuple ? schema.spec.types[idx] : schema.innerType;
    }
    if (!isArray) {
      if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
      parent = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent,
    parentPath: lastPart
  };
}
var ReferenceSet = class _ReferenceSet extends Set {
  describe() {
    const description = [];
    for (const item of this.values()) {
      description.push(Reference.isRef(item) ? item.describe() : item);
    }
    return description;
  }
  resolveAll(resolve) {
    let result = [];
    for (const item of this.values()) {
      result.push(resolve(item));
    }
    return result;
  }
  clone() {
    return new _ReferenceSet(this.values());
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.forEach((value) => next.add(value));
    removeItems.forEach((value) => next.delete(value));
    return next;
  }
};
function clone(src, seen = /* @__PURE__ */ new Map()) {
  if (isSchema(src) || !src || typeof src !== "object") return src;
  if (seen.has(src)) return seen.get(src);
  let copy;
  if (src instanceof Date) {
    copy = new Date(src.getTime());
    seen.set(src, copy);
  } else if (src instanceof RegExp) {
    copy = new RegExp(src);
    seen.set(src, copy);
  } else if (Array.isArray(src)) {
    copy = new Array(src.length);
    seen.set(src, copy);
    for (let i18 = 0; i18 < src.length; i18++) copy[i18] = clone(src[i18], seen);
  } else if (src instanceof Map) {
    copy = /* @__PURE__ */ new Map();
    seen.set(src, copy);
    for (const [k9, v8] of src.entries()) copy.set(k9, clone(v8, seen));
  } else if (src instanceof Set) {
    copy = /* @__PURE__ */ new Set();
    seen.set(src, copy);
    for (const v8 of src) copy.add(clone(v8, seen));
  } else if (src instanceof Object) {
    copy = {};
    seen.set(src, copy);
    for (const [k9, v8] of Object.entries(src)) copy[k9] = clone(v8, seen);
  } else {
    throw Error(`Unable to clone ${src}`);
  }
  return copy;
}
var Schema = class {
  constructor(options) {
    this.type = void 0;
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this.internalTests = {};
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this._typeCheck = void 0;
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = options.type;
    this._typeCheck = options.check;
    this.spec = Object.assign({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      disableStackTrace: false,
      nullable: false,
      optional: true,
      coerce: true
    }, options == null ? void 0 : options.spec);
    this.withMutation((s15) => {
      s15.nonNullable();
    });
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec) Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeCheck = this._typeCheck;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.internalTests = Object.assign({}, this.internalTests);
    next.exclusiveTests = Object.assign({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone(Object.assign({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0) return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  withMutation(fn) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this) return this;
    if (schema.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = Object.assign({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next) => {
      schema.tests.forEach((fn) => {
        next.test(fn.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v8) {
    if (v8 == null) {
      if (this.spec.nullable && v8 === null) return true;
      if (this.spec.optional && v8 === void 0) return true;
      return false;
    }
    return this._typeCheck(v8);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((prevSchema, condition) => condition.resolve(prevSchema, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  resolveOptions(options) {
    var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
    return Object.assign({}, options, {
      from: options.from || [],
      strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,
      abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
      recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,
      disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
    });
  }
  /**
   * Run the configured transform pipeline over an input value.
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(Object.assign({
      value
    }, options));
    let allowOptionality = options.assert === "ignore-optionality";
    let result = resolvedSchema._cast(value, options);
    if (options.assert !== false && !resolvedSchema.isType(result)) {
      if (allowOptionality && isAbsent(result)) {
        return result;
      }
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn) => fn.call(this, prevValue, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault(options);
    }
    return value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      path,
      originalValue = _value,
      strict = this.spec.strict
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, Object.assign({
        assert: false
      }, options));
    }
    let initialTests = [];
    for (let test of Object.values(this.internalTests)) {
      if (test) initialTests.push(test);
    }
    this.runTests({
      path,
      value,
      originalValue,
      options,
      tests: initialTests
    }, panic, (initialErrors) => {
      if (initialErrors.length) {
        return next(initialErrors, value);
      }
      this.runTests({
        path,
        value,
        originalValue,
        options,
        tests: this.tests
      }, panic, next);
    });
  }
  /**
   * Executes a set of validations, either schema, produced Tests or a nested
   * schema validate result.
   */
  runTests(runOptions, panic, next) {
    let fired = false;
    let {
      tests,
      value,
      originalValue,
      path,
      options
    } = runOptions;
    let panicOnce = (arg) => {
      if (fired) return;
      fired = true;
      panic(arg, value);
    };
    let nextOnce = (arg) => {
      if (fired) return;
      fired = true;
      next(arg, value);
    };
    let count = tests.length;
    let nestedErrors = [];
    if (!count) return nextOnce([]);
    let args = {
      value,
      originalValue,
      path,
      options,
      schema: this
    };
    for (let i18 = 0; i18 < tests.length; i18++) {
      const test = tests[i18];
      test(args, panicOnce, function finishTestRun(err) {
        if (err) {
          Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
        }
        if (--count <= 0) {
          nextOnce(nestedErrors);
        }
      });
    }
  }
  asNestedTest({
    key,
    index,
    parent,
    parentPath,
    originalParent,
    options
  }) {
    const k9 = key != null ? key : index;
    if (k9 == null) {
      throw TypeError("Must include `key` or `index` for nested validations");
    }
    const isIndex = typeof k9 === "number";
    let value = parent[k9];
    const testOptions = Object.assign({}, options, {
      // Nested validations fields are always strict:
      //    1. parent isn't strict so the casting will also have cast inner values
      //    2. parent is strict in which case the nested values weren't cast either
      strict: true,
      parent,
      value,
      originalValue: originalParent[k9],
      // FIXME: tests depend on `index` being passed around deeply,
      //   we should not let the options.key/index bleed through
      key: void 0,
      // index: undefined,
      [isIndex ? "index" : "key"]: k9,
      path: isIndex || k9.includes(".") ? `${parentPath || ""}[${isIndex ? k9 : `"${k9}"`}]` : (parentPath ? `${parentPath}.` : "") + key
    });
    return (_10, panic, next) => this.resolve(testOptions)._validate(value, testOptions, panic, next);
  }
  validate(value, options) {
    var _options$disableStack2;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
    return new Promise((resolve, reject) => schema._validate(value, options, (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      reject(error);
    }, (errors, validated) => {
      if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
      else resolve(validated);
    }));
  }
  validateSync(value, options) {
    var _options$disableStack3;
    let schema = this.resolve(Object.assign({}, options, {
      value
    }));
    let result;
    let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
    schema._validate(value, Object.assign({}, options, {
      sync: true
    }), (error, parsed) => {
      if (ValidationError.isError(error)) error.value = parsed;
      throw error;
    }, (errors, validated) => {
      if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
      result = validated;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err) => {
      if (ValidationError.isError(err)) return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err)) return false;
      throw err;
    }
  }
  _getDefault(options) {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this, options) : clone(defaultValue);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault(options);
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    return this.clone({
      strict: isStrict
    });
  }
  nullability(nullable, message) {
    const next = this.clone({
      nullable
    });
    next.internalTests.nullable = createValidation({
      message,
      name: "nullable",
      test(value) {
        return value === null ? this.schema.spec.nullable : true;
      }
    });
    return next;
  }
  optionality(optional, message) {
    const next = this.clone({
      optional
    });
    next.internalTests.optionality = createValidation({
      message,
      name: "optionality",
      test(value) {
        return value === void 0 ? this.schema.spec.optional : true;
      }
    });
    return next;
  }
  optional() {
    return this.optionality(true);
  }
  defined(message = mixed.defined) {
    return this.optionality(false, message);
  }
  nullable() {
    return this.nullability(true);
  }
  nonNullable(message = mixed.notNull) {
    return this.nullability(false, message);
  }
  required(message = mixed.required) {
    return this.clone().withMutation((next) => next.nonNullable(message).defined(message));
  }
  notRequired() {
    return this.clone().withMutation((next) => next.nullable().optional());
  }
  transform(fn) {
    let next = this.clone();
    next.transforms.push(fn);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0) opts.message = mixed.default;
    if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn) => {
      if (fn.OPTIONS.name === opts.name) {
        if (isExclusive) return false;
        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
      }
      return true;
    });
    next.tests.push(validate);
    return next;
  }
  when(keys, options) {
    if (!Array.isArray(keys) && typeof keys !== "string") {
      options = keys;
      keys = ".";
    }
    let next = this.clone();
    let deps = toArray(keys).map((key) => new Reference(key));
    deps.forEach((dep) => {
      if (dep.isSibling) next.deps.push(dep.key);
    });
    next.conditions.push(typeof options === "function" ? new Condition(deps, options) : Condition.fromOptions(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next.internalTests.typeError = createValidation({
      message,
      name: "typeError",
      skipAbsent: true,
      test(value) {
        if (!this.schema._typeCheck(value)) return this.createError({
          params: {
            type: this.schema.type
          }
        });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next.internalTests.whiteList = createValidation({
      message,
      name: "oneOf",
      skipAbsent: true,
      test(value) {
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: Array.from(valids).join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next.internalTests.blacklist = createValidation({
      message,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value)) return this.createError({
          params: {
            values: Array.from(invalids).join(", "),
            resolved
          }
        });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  /**
   * Return a serialized description of the schema including validations, flags, types etc.
   *
   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
   */
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const {
      label,
      meta,
      optional,
      nullable
    } = next.spec;
    const description = {
      meta,
      label,
      optional,
      nullable,
      default: next.getDefault(options),
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn) => ({
        name: fn.OPTIONS.name,
        params: fn.OPTIONS.params
      })).filter((n13, idx, list) => list.findIndex((c10) => c10.name === n13.name) === idx)
    };
    return description;
  }
};
Schema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"]) Schema.prototype[`${method}At`] = function(path, value, options = {}) {
  const {
    parent,
    parentPath,
    schema
  } = getIn(this, path, value, options.context);
  return schema[method](parent && parent[parentPath], Object.assign({}, options, {
    parent,
    path
  }));
};
for (const alias of ["equals", "is"]) Schema.prototype[alias] = Schema.prototype.oneOf;
for (const alias of ["not", "nope"]) Schema.prototype[alias] = Schema.prototype.notOneOf;
var returnsTrue = () => true;
function create$8(spec) {
  return new MixedSchema(spec);
}
var MixedSchema = class extends Schema {
  constructor(spec) {
    super(typeof spec === "function" ? {
      type: "mixed",
      check: spec
    } : Object.assign({
      type: "mixed",
      check: returnsTrue
    }, spec));
  }
};
create$8.prototype = MixedSchema.prototype;
function create$7() {
  return new BooleanSchema();
}
var BooleanSchema = class extends Schema {
  constructor() {
    super({
      type: "boolean",
      check(v8) {
        if (v8 instanceof Boolean) v8 = v8.valueOf();
        return typeof v8 === "boolean";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (ctx.spec.coerce && !ctx.isType(value)) {
          if (/^(true|1)$/i.test(String(value))) return true;
          if (/^(false|0)$/i.test(String(value))) return false;
        }
        return value;
      });
    });
  }
  isTrue(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent(value) || value === true;
      }
    });
  }
  isFalse(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent(value) || value === false;
      }
    });
  }
  default(def) {
    return super.default(def);
  }
  defined(msg) {
    return super.defined(msg);
  }
  optional() {
    return super.optional();
  }
  required(msg) {
    return super.required(msg);
  }
  notRequired() {
    return super.notRequired();
  }
  nullable() {
    return super.nullable();
  }
  nonNullable(msg) {
    return super.nonNullable(msg);
  }
  strip(v8) {
    return super.strip(v8);
  }
};
create$7.prototype = BooleanSchema.prototype;
var isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  const struct = parseDateStruct(date2);
  if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
  if (struct.z === void 0 && struct.plusMinus === void 0) {
    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
  }
  let totalMinutesOffset = 0;
  if (struct.z !== "Z" && struct.plusMinus !== void 0) {
    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
    if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
  }
  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
function parseDateStruct(date2) {
  var _regexResult$7$length, _regexResult$;
  const regexResult = isoReg.exec(date2);
  if (!regexResult) return null;
  return {
    year: toNumber(regexResult[1]),
    month: toNumber(regexResult[2], 1) - 1,
    day: toNumber(regexResult[3], 1),
    hour: toNumber(regexResult[4]),
    minute: toNumber(regexResult[5]),
    second: toNumber(regexResult[6]),
    millisecond: regexResult[7] ? (
      // allow arbitrary sub-second precision beyond milliseconds
      toNumber(regexResult[7].substring(0, 3))
    ) : 0,
    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
    z: regexResult[8] || void 0,
    plusMinus: regexResult[9] || void 0,
    hourOffset: toNumber(regexResult[10]),
    minuteOffset: toNumber(regexResult[11])
  };
}
function toNumber(str, defaultValue = 0) {
  return Number(str) || defaultValue;
}
var rEmail = (
  // eslint-disable-next-line
  /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
);
var rUrl = (
  // eslint-disable-next-line
  /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
);
var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
var yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
var hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
var zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
var rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
var isTrimmed = (value) => isAbsent(value) || value === value.trim();
var objStringTag = {}.toString();
function create$6() {
  return new StringSchema();
}
var StringSchema = class extends Schema {
  constructor() {
    super({
      type: "string",
      check(value) {
        if (value instanceof String) value = value.valueOf();
        return typeof value === "string";
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value)) return value;
        if (Array.isArray(value)) return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag) return value;
        return strValue;
      });
    });
  }
  required(message) {
    return super.required(message).withMutation((schema) => schema.test({
      message: message || mixed.required,
      name: "required",
      skipAbsent: true,
      test: (value) => !!value.length
    }));
  }
  notRequired() {
    return super.notRequired().withMutation((schema) => {
      schema.tests = schema.tests.filter((t12) => t12.OPTIONS.name !== "required");
      return schema;
    });
  }
  length(length, message = string.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message = string.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message,
          name
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name || "matches",
      message: message || string.matches,
      params: {
        regex
      },
      skipAbsent: true,
      test: (value) => value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message,
      excludeEmptyString: false
    });
  }
  datetime(options) {
    let message = "";
    let allowOffset;
    let precision;
    if (options) {
      if (typeof options === "object") {
        ({
          message = "",
          allowOffset = false,
          precision = void 0
        } = options);
      } else {
        message = options;
      }
    }
    return this.matches(rIsoDateTime, {
      name: "datetime",
      message: message || string.datetime,
      excludeEmptyString: true
    }).test({
      name: "datetime_offset",
      message: message || string.datetime_offset,
      params: {
        allowOffset
      },
      skipAbsent: true,
      test: (value) => {
        if (!value || allowOffset) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return !!struct.z;
      }
    }).test({
      name: "datetime_precision",
      message: message || string.datetime_precision,
      params: {
        precision
      },
      skipAbsent: true,
      test: (value) => {
        if (!value || precision == void 0) return true;
        const struct = parseDateStruct(value);
        if (!struct) return false;
        return struct.precision === precision;
      }
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform((value) => !isAbsent(value) ? value.toLowerCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform((value) => !isAbsent(value) ? value.toUpperCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      skipAbsent: true,
      test: (value) => isAbsent(value) || value === value.toUpperCase()
    });
  }
};
create$6.prototype = StringSchema.prototype;
var isNaN$1 = (value) => value != +value;
function create$5() {
  return new NumberSchema();
}
var NumberSchema = class extends Schema {
  constructor() {
    super({
      type: "number",
      check(value) {
        if (value instanceof Number) value = value.valueOf();
        return typeof value === "number" && !isNaN$1(value);
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce) return value;
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "") return NaN;
          parsed = +parsed;
        }
        if (ctx.isType(parsed) || parsed === null) return parsed;
        return parseFloat(parsed);
      });
    });
  }
  min(min, message = number.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(min);
      }
    });
  }
  max(max, message = number.max) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(max);
      }
    });
  }
  lessThan(less, message = number.lessThan) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      skipAbsent: true,
      test(value) {
        return value < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number.moreThan) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      skipAbsent: true,
      test(value) {
        return value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number.integer) {
    return this.test({
      name: "integer",
      message,
      skipAbsent: true,
      test: (val) => Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc") return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent(value) ? Math[method](value) : value);
  }
};
create$5.prototype = NumberSchema.prototype;
var invalidDate = /* @__PURE__ */ new Date("");
var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
function create$4() {
  return new DateSchema();
}
var DateSchema = class _DateSchema extends Schema {
  constructor() {
    super({
      type: "date",
      check(v8) {
        return isDate(v8) && !isNaN(v8.getTime());
      }
    });
    this.withMutation(() => {
      this.transform((value, _raw, ctx) => {
        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : _DateSchema.INVALID_DATE;
      });
    });
  }
  prepareParam(ref, name) {
    let param;
    if (!Reference.isRef(ref)) {
      let cast = this.cast(ref);
      if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref;
    }
    return param;
  }
  min(min, message = date.min) {
    let limit = this.prepareParam(min, "min");
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      test(value) {
        return value >= this.resolve(limit);
      }
    });
  }
  max(max, message = date.max) {
    let limit = this.prepareParam(max, "max");
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value <= this.resolve(limit);
      }
    });
  }
};
DateSchema.INVALID_DATE = invalidDate;
create$4.prototype = DateSchema.prototype;
create$4.INVALID_DATE = invalidDate;
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a24, b10]) => `${a24}-${b10}`));
  function addNode(depPath, key) {
    let node = (0, import_property_expr.split)(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`)) edges.push([key, node]);
  }
  for (const key of Object.keys(fields)) {
    let value = fields[key];
    nodes.add(key);
    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
    else if (isSchema(value) && "deps" in value) value.deps.forEach((path) => addNode(path, key));
  }
  return import_toposort.default.array(Array.from(nodes), edges).reverse();
}
function findIndex(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if ((_err$path = err.path) != null && _err$path.includes(key)) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys) {
  return (a24, b10) => {
    return findIndex(keys, a24) - findIndex(keys, b10);
  };
}
var parseJson = (value, _10, ctx) => {
  if (typeof value !== "string") {
    return value;
  }
  let parsed = value;
  try {
    parsed = JSON.parse(value);
  } catch (err) {
  }
  return ctx.isType(parsed) ? parsed : value;
};
function deepPartial(schema) {
  if ("fields" in schema) {
    const partial = {};
    for (const [key, fieldSchema] of Object.entries(schema.fields)) {
      partial[key] = deepPartial(fieldSchema);
    }
    return schema.setFields(partial);
  }
  if (schema.type === "array") {
    const nextArray = schema.optional();
    if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
    return nextArray;
  }
  if (schema.type === "tuple") {
    return schema.optional().clone({
      types: schema.spec.types.map(deepPartial)
    });
  }
  if ("optional" in schema) {
    return schema.optional();
  }
  return schema;
}
var deepHas = (obj, p20) => {
  const path = [...(0, import_property_expr.normalizePath)(p20)];
  if (path.length === 1) return path[0] in obj;
  let last = path.pop();
  let parent = (0, import_property_expr.getter)((0, import_property_expr.join)(path), true)(obj);
  return !!(parent && last in parent);
};
var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
var defaultSort = sortByKeyOrder([]);
function create$3(spec) {
  return new ObjectSchema(spec);
}
var ObjectSchema = class extends Schema {
  constructor(spec) {
    super({
      type: "object",
      check(value) {
        return isObject(value) || typeof value === "function";
      }
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0) return this.getDefault(options);
    if (!this._typeCheck(value)) return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = [].concat(this._nodes, Object.keys(value).filter((v8) => !this._nodes.includes(v8)));
    let intermediateValue = {};
    let innerOptions = Object.assign({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = prop in value;
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = field instanceof Schema ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec != null && fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, options = {}, panic, next) {
    let {
      from = [],
      originalValue = _value,
      recursive = this.spec.recursive
    } = options;
    options.from = [{
      schema: this,
      value: originalValue
    }, ...from];
    options.__validating = true;
    options.originalValue = originalValue;
    super._validate(_value, options, panic, (objectErrors, value) => {
      if (!recursive || !isObject(value)) {
        next(objectErrors, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = [];
      for (let key of this._nodes) {
        let field = this.fields[key];
        if (!field || Reference.isRef(field)) {
          continue;
        }
        tests.push(field.asNestedTest({
          options,
          key,
          parent: value,
          parentPath: options.path,
          originalParent: originalValue
        }));
      }
      this.runTests({
        tests,
        value,
        originalValue,
        options
      }, panic, (fieldErrors) => {
        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
      });
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = Object.assign({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      nextFields[field] = target === void 0 ? schemaOrRef : target;
    }
    return next.withMutation((s15) => (
      // XXX: excludes here is wrong
      s15.setFields(nextFields, [...this._excludedEdges, ...schema._excludedEdges])
    ));
  }
  _getDefault(options) {
    if ("default" in this.spec) {
      return super._getDefault(options);
    }
    if (!this._nodes.length) {
      return void 0;
    }
    let dft = {};
    this._nodes.forEach((key) => {
      var _innerOptions;
      const field = this.fields[key];
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
    });
    return dft;
  }
  setFields(shape, excludedEdges) {
    let next = this.clone();
    next.fields = shape;
    next._nodes = sortFields(shape, excludedEdges);
    next._sortErrors = sortByKeyOrder(Object.keys(shape));
    if (excludedEdges) next._excludedEdges = excludedEdges;
    return next;
  }
  shape(additions, excludes = []) {
    return this.clone().withMutation((next) => {
      let edges = next._excludedEdges;
      if (excludes.length) {
        if (!Array.isArray(excludes[0])) excludes = [excludes];
        edges = [...next._excludedEdges, ...excludes];
      }
      return next.setFields(Object.assign(next.fields, additions), edges);
    });
  }
  partial() {
    const partial = {};
    for (const [key, schema] of Object.entries(this.fields)) {
      partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
    }
    return this.setFields(partial);
  }
  deepPartial() {
    const next = deepPartial(this);
    return next;
  }
  pick(keys) {
    const picked = {};
    for (const key of keys) {
      if (this.fields[key]) picked[key] = this.fields[key];
    }
    return this.setFields(picked, this._excludedEdges.filter(([a24, b10]) => keys.includes(a24) && keys.includes(b10)));
  }
  omit(keys) {
    const remaining = [];
    for (const key of Object.keys(this.fields)) {
      if (keys.includes(key)) continue;
      remaining.push(key);
    }
    return this.pick(remaining);
  }
  from(from, to, alias) {
    let fromGetter = (0, import_property_expr.getter)(from, true);
    return this.transform((obj) => {
      if (!obj) return obj;
      let newObj = obj;
      if (deepHas(obj, from)) {
        newObj = Object.assign({}, obj);
        if (!alias) delete newObj[from];
        newObj[to] = fromGetter(obj);
      }
      return newObj;
    });
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow !== "boolean") {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message,
      test(value) {
        if (value == null) return true;
        const unknownKeys = unknown(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn) {
    return this.transform((obj) => {
      if (!obj) return obj;
      const result = {};
      for (const key of Object.keys(obj)) result[fn(key)] = obj[key];
      return result;
    });
  }
  camelCase() {
    return this.transformKeys(import_tiny_case.camelCase);
  }
  snakeCase() {
    return this.transformKeys(import_tiny_case.snakeCase);
  }
  constantCase() {
    return this.transformKeys((key) => (0, import_tiny_case.snakeCase)(key).toUpperCase());
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.fields = {};
    for (const [key, value] of Object.entries(next.fields)) {
      var _innerOptions2;
      let innerOptions = options;
      if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[key]
        });
      }
      base.fields[key] = value.describe(innerOptions);
    }
    return base;
  }
};
create$3.prototype = ObjectSchema.prototype;
function create$2(type) {
  return new ArraySchema(type);
}
var ArraySchema = class extends Schema {
  constructor(type) {
    super({
      type: "array",
      spec: {
        types: type
      },
      check(v8) {
        return Array.isArray(v8);
      }
    });
    this.innerType = void 0;
    this.innerType = type;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType) {
      return value;
    }
    let isChanged = false;
    const castArray = value.map((v8, idx) => {
      const castElement = this.innerType.cast(v8, Object.assign({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v8) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    var _options$recursive;
    let innerType = this.innerType;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, panic, (arrayErrors, value) => {
      var _options$originalValu2;
      if (!recursive || !innerType || !this._typeCheck(value)) {
        next(arrayErrors, value);
        return;
      }
      let tests = new Array(value.length);
      for (let index = 0; index < value.length; index++) {
        var _options$originalValu;
        tests[index] = innerType.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(arrayErrors), value));
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  /** Parse an input JSON string to an object */
  json() {
    return this.transform(parseJson);
  }
  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType)
      next.innerType = next.innerType ? (
        // @ts-expect-error Lazy doesn't have concat and will break
        next.innerType.concat(schema.innerType)
      ) : schema.innerType;
    return next;
  }
  of(schema) {
    let next = this.clone();
    if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
    next.innerType = schema;
    next.spec = Object.assign({}, next.spec, {
      types: schema
    });
    return next;
  }
  length(length, message = array.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      skipAbsent: true,
      test(value) {
        return value.length === this.resolve(length);
      }
    });
  }
  min(min, message) {
    message = message || array.min;
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min
      },
      skipAbsent: true,
      // FIXME(ts): Array<typeof T>
      test(value) {
        return value.length >= this.resolve(min);
      }
    });
  }
  max(max, message) {
    message = message || array.max;
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max
      },
      skipAbsent: true,
      test(value) {
        return value.length <= this.resolve(max);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val)) return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v8) => !!v8 : (v8, i18, a24) => !rejector(v8, i18, a24);
    return this.transform((values) => values != null ? values.filter(reject) : values);
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    if (next.innerType) {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[0]
        });
      }
      base.innerType = next.innerType.describe(innerOptions);
    }
    return base;
  }
};
create$2.prototype = ArraySchema.prototype;
function create$1(schemas) {
  return new TupleSchema(schemas);
}
var TupleSchema = class extends Schema {
  constructor(schemas) {
    super({
      type: "tuple",
      spec: {
        types: schemas
      },
      check(v8) {
        const types = this.spec.types;
        return Array.isArray(v8) && v8.length === types.length;
      }
    });
    this.withMutation(() => {
      this.typeError(tuple.notType);
    });
  }
  _cast(inputValue, options) {
    const {
      types
    } = this.spec;
    const value = super._cast(inputValue, options);
    if (!this._typeCheck(value)) {
      return value;
    }
    let isChanged = false;
    const castArray = types.map((type, idx) => {
      const castElement = type.cast(value[idx], Object.assign({}, options, {
        path: `${options.path || ""}[${idx}]`
      }));
      if (castElement !== value[idx]) isChanged = true;
      return castElement;
    });
    return isChanged ? castArray : value;
  }
  _validate(_value, options = {}, panic, next) {
    let itemTypes = this.spec.types;
    super._validate(_value, options, panic, (tupleErrors, value) => {
      var _options$originalValu2;
      if (!this._typeCheck(value)) {
        next(tupleErrors, value);
        return;
      }
      let tests = [];
      for (let [index, itemSchema] of itemTypes.entries()) {
        var _options$originalValu;
        tests[index] = itemSchema.asNestedTest({
          options,
          index,
          parent: value,
          parentPath: options.path,
          originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value
        });
      }
      this.runTests({
        value,
        tests,
        originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,
        options
      }, panic, (innerTypeErrors) => next(innerTypeErrors.concat(tupleErrors), value));
    });
  }
  describe(options) {
    const next = (options ? this.resolve(options) : this).clone();
    const base = super.describe(options);
    base.innerType = next.spec.types.map((schema, index) => {
      var _innerOptions;
      let innerOptions = options;
      if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
        innerOptions = Object.assign({}, innerOptions, {
          parent: innerOptions.value,
          value: innerOptions.value[index]
        });
      }
      return schema.describe(innerOptions);
    });
    return base;
  }
};
create$1.prototype = TupleSchema.prototype;

// node_modules/@catalogfi/wallets/dist/index12.js
var r = { ALL: import_bitcoinjs_lib3.Transaction.SIGHASH_ALL, NONE: import_bitcoinjs_lib3.Transaction.SIGHASH_NONE, SINGLE: import_bitcoinjs_lib3.Transaction.SIGHASH_SINGLE, ALL_ANYONECANPAY: import_bitcoinjs_lib3.Transaction.SIGHASH_ALL | import_bitcoinjs_lib3.Transaction.SIGHASH_ANYONECANPAY, NONE_ANYONECANPAY: import_bitcoinjs_lib3.Transaction.SIGHASH_NONE | import_bitcoinjs_lib3.Transaction.SIGHASH_ANYONECANPAY, SINGLE_ANYONECANPAY: import_bitcoinjs_lib3.Transaction.SIGHASH_SINGLE | import_bitcoinjs_lib3.Transaction.SIGHASH_ANYONECANPAY };
var i3 = class _i {
  constructor(s15, e17) {
    this._scriptType = s15, this._sigHashType = e17;
  }
  get scriptType() {
    return this._scriptType;
  }
  get sigHashType() {
    return this._sigHashType;
  }
  toString() {
    return `${this._scriptType} ${this._sigHashType}`;
  }
  static async fromString(s15) {
    const [e17, N10] = s15.split(" "), S8 = await create$8().oneOf(["segwitV0", "segwitV1", "p2shSignature"]).required().validate(e17), a24 = await create$8().oneOf(Object.values(r)).required().validate(parseInt(N10));
    return new _i(S8, a24);
  }
};

// node_modules/@catalogfi/wallets/dist/index21.js
var import_dist31 = __toESM(require_dist(), 1);
var import_dist32 = __toESM(require_dist2(), 1);
var import_dist33 = __toESM(require_dist3(), 1);
var p2 = { P2SH: "p2sh", P2WSH: "p2wsh", P2TR: "p2tr" };

// node_modules/@catalogfi/wallets/dist/index5.js
var A = class {
  addSignatureSegwitV0(e17 = r.ALL) {
    return new i3("segwitV0", e17);
  }
  addSignatureP2sh(e17 = r.ALL) {
    return new i3("p2shSignature", e17);
  }
  addSignatureSegwitV1(e17 = r.ALL) {
    return new i3("segwitV1", e17);
  }
  chain() {
    return a.Bitcoin;
  }
  async addAllInputs(e17, t12, r13, s15) {
    const i18 = (s15 == null ? void 0 : s15.utxos) || await r13.getUTXOs(t12);
    for (const h11 of i18) {
      const m17 = await r13.getTxIndex(h11.txid, t12);
      e17.addInput(n3(h11.txid), m17, s15 == null ? void 0 : s15.nSequence);
    }
    return e17;
  }
  async suggestFee(e17, t12) {
    const r13 = await this.getAddress();
    return (await this.getProvider()).suggestFee(r13, e17, t12);
  }
  async toOutputScript(e17) {
    return import_bitcoinjs_lib4.address.toOutputScript(e17, await this.getNetwork());
  }
  totalValueFromUTXOs(e17) {
    return e17.reduce((t12, r13) => t12 + r13.value, 0);
  }
  async scriptToAddress(e17) {
    const t12 = import_bitcoinjs_lib4.payments.p2wsh({ redeem: { output: e17 }, network: await this.getNetwork() });
    if (!t12.address) throw new Error("Could not generate p2wsh address");
    return t12.address;
  }
  async newSwap(e17) {
    if (e17.secretHash = R(e17.secretHash), e17.secretHash.length !== 64) throw new Error(i2.INVALID_SECRET_HASH);
    const { script: t12, address: r13 } = E2(e17, await this.getNetwork());
    return new l(this, { ...e17, redeemScript: t12, scriptAddress: r13 });
  }
  getScriptType(e17, t12) {
    try {
      if (import_bitcoinjs_lib4.address.fromBase58Check(e17).version === t12.scriptHash) return p2.P2SH;
    } catch {
      const r13 = import_bitcoinjs_lib4.address.fromBech32(e17);
      if (r13.prefix !== t12.bech32) throw new Error("Invalid address");
      if (r13.version === 0) {
        if (r13.data.length === 32) return p2.P2WSH;
      } else if (r13.version === 1 && r13.data.length === 32) return p2.P2TR;
    }
    throw new Error("Unsupported script type");
  }
};
var l = class {
  constructor(e17, t12) {
    if (t12.secretHash = R(t12.secretHash), t12.secretHash.length !== 64) throw new Error(i2.INVALID_SECRET_HASH);
    this.wallet = e17, this.swap = t12;
  }
  id() {
    return this.swap.scriptAddress;
  }
  async init() {
    return this.wallet.send(this.swap.scriptAddress, +this.swap.amount.toString());
  }
  async redeem(e17, t12) {
    e17 = R(e17);
    const r13 = [this.wallet.addSignatureSegwitV0(), Buffer.from(await this.wallet.getPublicKey(), "hex"), Buffer.from(e17, "hex"), import_bitcoinjs_lib4.script.number.encode(1), this.swap.redeemScript], s15 = import_bitcoinjs_lib4.payments.p2wsh({ redeem: { output: this.swap.redeemScript }, network: await this.wallet.getNetwork() }).address;
    if (!s15) throw new Error("Could not generate p2wsh address for redeem script");
    try {
      return await this.wallet.spend(this.swap.redeemScript, s15, { witness: r13, toAddress: t12 });
    } catch (i18) {
      throw i18.message.includes("OP_EQUALVERIFY") ? new Error(i2.INVALID_PUBKEY_OR_SECRET) : new Error(i18.message);
    }
  }
  async refund(e17) {
    const t12 = [this.wallet.addSignatureSegwitV0(), Buffer.from(await this.wallet.getPublicKey(), "hex"), import_bitcoinjs_lib4.script.number.encode(0), this.swap.redeemScript];
    try {
      const r13 = import_bitcoinjs_lib4.payments.p2wsh({ redeem: { output: this.swap.redeemScript }, network: await this.wallet.getNetwork() }).address;
      if (!r13) throw new Error("Could not generate p2wsh address for refund script");
      return await this.wallet.spend(this.swap.redeemScript, r13, { toAddress: e17, witness: t12, nSequence: this.swap.expiryBlocks });
    } catch (r13) {
      throw r13.message.includes("OP_EQUALVERIFY") ? new Error(i2.INVALID_PUBKEY) : r13.message.includes("BIP") ? new Error(i2.ORDER_NOT_EXPIRED) : new Error(r13.message);
    }
  }
};

// node_modules/@catalogfi/wallets/dist/index7.js
var import_dist49 = __toESM(require_dist(), 1);
var import_dist50 = __toESM(require_dist2(), 1);
var import_dist51 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/extension/dist/index.js
var import_dist40 = __toESM(require_dist());
var import_dist41 = __toESM(require_dist2());
var import_dist42 = __toESM(require_dist3());

// node_modules/@catalogfi/extension/dist/index2.js
var import_dist37 = __toESM(require_dist(), 1);
var import_dist38 = __toESM(require_dist2(), 1);
var import_dist39 = __toESM(require_dist3(), 1);
var d3 = class {
  /**
   * Initializes a new instance of the class.
   *
   * @param {Object} catalog - An optional object with an `id` property representing the catalog ID injected by the extension.
   * @throws {Error} If the catalog wallet extension is not found.
   */
  constructor(o13) {
    if (o13)
      this.extensionId = o13.id;
    else if (m2())
      this.extensionId = c2("chrome");
    else if (u2())
      this.extensionId = c2("window");
    else
      throw new Error("Catalog wallet extension not found");
  }
  send(o13, l23) {
    return new Promise((a24, i18) => {
      const n13 = { url: "", favicon: "" }, s15 = window.location.href.split("://")[1].replace(/\/$/, "");
      n13.url = s15;
      let e17 = document.querySelector("link[rel='icon']");
      if (e17 || (e17 = document.querySelector(
        "link[rel='shortcut icon']"
      )), e17 || (e17 = document.querySelector(
        "link[rel='apple-touch-icon']"
      )), e17 || (e17 = document.querySelector(
        "meta[property='og:image']"
      )), e17)
        n13.favicon = e17 instanceof HTMLMetaElement ? e17.content : e17.href;
      else {
        const t12 = new URL(window.location.href);
        n13.favicon = `${t12.protocol}//${t12.hostname}/favicon.ico`;
      }
      chrome.runtime.sendMessage(
        this.extensionId,
        {
          method: o13,
          params: l23,
          metadata: n13
        },
        (t12) => chrome.runtime.lastError ? i18(chrome.runtime.lastError) : typeof t12 == "object" && t12 && "error" in t12 ? i18(t12.error) : a24(t12)
      );
    });
  }
};
var u2 = () => {
  try {
    const r13 = window;
    return r13 && r13.catalog && r13.catalog.id;
  } catch {
    return false;
  }
};
var c2 = (r13) => {
  if (r13 === "chrome")
    return chrome.runtime.id;
  if (r13 === "window")
    return window.catalog.id;
  throw new Error("Invalid medium to get wallet id");
};
var m2 = () => {
  try {
    return chrome && !!chrome.runtime && !!chrome.runtime.id;
  } catch {
    return false;
  }
};

// node_modules/@catalogfi/wallets/dist/index7.js
var import_bitcoinjs_lib5 = __toESM(require_src5(), 1);

// node_modules/@catalogfi/wallets/dist/index10.js
var import_dist46 = __toESM(require_dist(), 1);
var import_dist47 = __toESM(require_dist2(), 1);
var import_dist48 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index22.js
var import_dist43 = __toESM(require_dist(), 1);
var import_dist44 = __toESM(require_dist2(), 1);
var import_dist45 = __toESM(require_dist3(), 1);
var a6 = (t12) => t12.map((o13) => o13);
var p3 = (t12) => {
  if (t12 === e.Testnet) return r2;
  if (t12 === e.Mainnet) return s3;
  throw new Error("Invalid network");
};
var r2 = ["https://mempool.space/testnet4/api"];
var s3 = ["https://mempool.space/api", "https://blockstream.info/api"];

// node_modules/@catalogfi/wallets/dist/index10.js
var F = class {
  constructor(t12, e17) {
    this.cacheTimeout = 2e3, this.utxosCache = /* @__PURE__ */ new Map(), this.APIs = e17 ? a6([e17]) : p3(t12), this.network = t12;
  }
  async getTxIndex(t12, e17) {
    const a24 = this.APIs.map((r13) => `${r13}/tx/${t12}`), { vout: s15 } = await k.getWithFallback(a24);
    for (let r13 = 0; r13 < s15.length; r13++) if (s15[r13].scriptpubkey_address === e17) return r13;
    throw new Error("failed to get tx index");
  }
  async broadcast(t12) {
    if (!/^[0-9a-fA-F]+$/.test(t12)) throw new Error("invalid tx hex");
    for (let e17 = 0; e17 < 5; e17++) try {
      return k.postWithFallback(this.APIs.map((a24) => `${a24}/tx`), { body: t12 });
    } catch (a24) {
      if (e17 === 4) throw a24;
      await new Promise((s15) => setTimeout(s15, 500));
    }
    throw new Error("failed to broadcast tx");
  }
  async getBalance(t12) {
    return (await this.getUTXOs(t12)).reduce((e17, a24) => e17 + a24.value, 0);
  }
  setTimeoutForCache(t12) {
    this.cacheTimeout = t12;
  }
  async getUTXOs(t12, e17) {
    const a24 = this.utxosCache.get(t12);
    if (a24 && Date.now() - a24.timestamp < this.cacheTimeout) return m3(a24.utxos, e17);
    const s15 = await k.getWithFallback(this.APIs.map((r13) => `${r13}/address/${t12}/utxo`));
    return this.utxosCache.set(t12, { timestamp: Date.now(), utxos: s15 }), m3(s15, e17);
  }
  async getTransactionHex(t12) {
    return k.getWithFallback(this.APIs.map((e17) => `${e17}/tx/${t12}/hex`));
  }
  async getTransaction(t12) {
    return k.getWithFallback(this.APIs.map((e17) => `${e17}/tx/${t12}`));
  }
  async getConfirmations(t12) {
    const e17 = await this.getTransaction(t12);
    return !e17.status.confirmed || !e17.status.block_height ? 0 : await this.getLatestTip() - e17.status.block_height + 1;
  }
  async getFeeRates() {
    if (this.network === e.Regtest) return { fastestFee: 8, halfHourFee: 7, hourFee: 6, economyFee: 4, minimumFee: 2 };
    let t12 = "";
    this.network === e.Testnet && (t12 = "testnet4/");
    const e17 = `https://mempool.space/${t12}api/v1/fees/recommended`, a24 = `https://blockstream.info/${t12}api/fee-estimates`, s15 = await k.getWithFallback([e17, a24]);
    return "fastestFee" in s15 ? s15.fastestFee === 1 ? { fastestFee: 5, halfHourFee: 5, hourFee: 5, economyFee: 5, minimumFee: 5 } : s15 : { fastestFee: s15[1], halfHourFee: s15[5], hourFee: s15[10], economyFee: s15[20], minimumFee: s15[25] };
  }
  async getTransactions(t12, e17) {
    const a24 = await k.getWithFallback(this.APIs.map((s15) => `${s15}/address/${t12}/txs`));
    if (e17 === n.ALL) return a24;
    if (e17 === n.IN) return a24.filter((s15) => s15.vout.find((r13) => r13.scriptpubkey_address === t12));
    if (e17 === n.OUT) return a24.filter((s15) => s15.vin.find((r13) => r13.prevout.scriptpubkey_address === t12));
    throw new Error("failed to get transactions: invalid bitcoin tx type");
  }
  getNetwork() {
    return this.network;
  }
  async getLatestTip() {
    return k.getWithFallback(this.APIs.map((t12) => `${t12}/blocks/tip/height`));
  }
  async suggestFee(t12, e17, a24) {
    const s15 = (await this.getUTXOs(t12, e17)).length, r13 = 2, n13 = await this.getFeeRates();
    return Math.floor(n13[a2[a24]] * 1.05) * (s15 * 70 + r13 * 31 + 10);
  }
};
var u3 = (i18) => i18.sort((t12, e17) => t12.status.confirmed != e17.status.confirmed ? t12.status.confirmed ? -1 : 1 : e17.value - t12.value);
var m3 = (i18, t12) => {
  if (Array.isArray(i18)) {
    if (t12) {
      const e17 = i18.reduce((r13, n13) => r13 + n13.value, 0);
      if (e17 < t12) throw new Error(t.INSUFFICIENT_FUNDS(e17, t12));
      let a24 = BigInt(0);
      i18.sort((r13, n13) => n13.value - r13.value);
      const s15 = [];
      for (const r13 of i18) if (a24 += BigInt(r13.value), s15.push(r13), a24 >= t12) break;
      return u3(s15);
    }
    return u3(i18);
  }
  return [];
};

// node_modules/@catalogfi/wallets/dist/index7.js
var r3 = { getAddress: "btc_getAddress", getBalance: "btc_getBalance", getPublicKey: "btc_getPublicKey", getNetwork: "btc_getNetwork", getWalletConfig: "btc_getWalletConfig", sign: "btc_sign", send: "btc_send", spend: "btc_spend" };
var u4 = class _u extends A {
  constructor(t12) {
    super(), this.connector = t12;
  }
  static async detect() {
    const t12 = new d3();
    return new _u(t12);
  }
  async getBalance() {
    const t12 = await this.connector.send(r3.getBalance);
    return await create$5().required().validate(t12);
  }
  async getPublicKey() {
    const t12 = await this.connector.send(r3.getPublicKey);
    return await create$6().required().validate(t12);
  }
  async getProviderNetwork() {
    const t12 = await this.connector.send(r3.getNetwork);
    return create$8().oneOf([e.Mainnet, e.Testnet, e.Regtest]).required().validate(t12);
  }
  async getNetwork() {
    const t12 = await this.getProviderNetwork();
    if (t12 === e.Mainnet) return import_bitcoinjs_lib5.networks.bitcoin;
    if (t12 === e.Testnet) return import_bitcoinjs_lib5.networks.testnet;
    if (t12 === e.Regtest) return import_bitcoinjs_lib5.networks.regtest;
    throw new Error("Invalid network from catalog wallet");
  }
  async getProvider() {
    const t12 = await this.getProviderNetwork();
    return new F(t12);
  }
  signSchnorr(t12) {
    throw new Error("signSchnorr: Method not supported");
  }
  async send(t12, i18, s15) {
    const a24 = await this.connector.send(r3.send, { toAddress: t12, amt: i18, fee: s15 });
    return await create$6().required().validate(a24);
  }
  async spend(t12, i18, { toAddress: s15, fee: a24, nSequence: f17, unlockScript: c10, witness: d20 }) {
    const l23 = d20 == null ? void 0 : d20.map((e17) => e17 instanceof i3 ? e17.toString() : e17.toString("hex")), p20 = c10 == null ? void 0 : c10.map((e17) => {
      if (e17 instanceof i3) return e17.toString();
      if (e17 instanceof Buffer) return e17.toString("hex");
      if (typeof e17 == "number") return "num_" + e17.toString();
      throw new Error("Invalid unlock script");
    }), h11 = await this.connector.send(r3.spend, { script: t12.toString("hex"), scriptAddress: i18, witness: l23, toAddress: s15, fee: a24, unlockScript: p20, nSequence: f17 });
    return await create$6().required().validate(h11);
  }
  walletConfig() {
    throw new Error("Method not supported");
  }
  async getAddress() {
    const t12 = await this.connector.send(r3.getAddress);
    return await create$6().required().validate(t12);
  }
  async sign(t12) {
    const i18 = await this.connector.send(r3.sign, { hexMsg: t12 });
    return await create$6().required().validate(i18);
  }
};

// node_modules/@catalogfi/wallets/dist/index9.js
var import_dist733 = __toESM(require_dist(), 1);
var import_dist734 = __toESM(require_dist2(), 1);
var import_dist735 = __toESM(require_dist3(), 1);
var import_bitcoinjs_lib6 = __toESM(require_src5(), 1);
var import_ecpair = __toESM(require_src6(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/index.js
var import_dist730 = __toESM(require_dist());
var import_dist731 = __toESM(require_dist2());
var import_dist732 = __toESM(require_dist3());

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/getContract.js
var import_dist232 = __toESM(require_dist(), 1);
var import_dist233 = __toESM(require_dist2(), 1);
var import_dist234 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/getAction.js
var import_dist52 = __toESM(require_dist(), 1);
var import_dist53 = __toESM(require_dist2(), 1);
var import_dist54 = __toESM(require_dist3(), 1);
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/createContractEventFilter.js
var import_dist64 = __toESM(require_dist(), 1);
var import_dist65 = __toESM(require_dist2(), 1);
var import_dist66 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/encodeEventTopics.js
var import_dist58 = __toESM(require_dist(), 1);
var import_dist59 = __toESM(require_dist2(), 1);
var import_dist60 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/log.js
var import_dist55 = __toESM(require_dist(), 1);
var import_dist56 = __toESM(require_dist2(), 1);
var import_dist57 = __toESM(require_dist3(), 1);
var FilterTypeNotSupportedError = class extends BaseError {
  constructor(type) {
    super(`Filter type "${type}" is not supported.`, {
      name: "FilterTypeNotSupportedError"
    });
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/encodeEventTopics.js
var docsPath = "/docs/contract/encodeEventTopics";
function encodeEventTopics(parameters) {
  const { abi, eventName, args } = parameters;
  let abiItem = abi[0];
  if (eventName) {
    const item = getAbiItem({ abi, name: eventName });
    if (!item)
      throw new AbiEventNotFoundError(eventName, { docsPath });
    abiItem = item;
  }
  if (abiItem.type !== "event")
    throw new AbiEventNotFoundError(void 0, { docsPath });
  const definition = formatAbiItem(abiItem);
  const signature = toEventSelector(definition);
  let topics = [];
  if (args && "inputs" in abiItem) {
    const indexedInputs = abiItem.inputs?.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? indexedInputs?.map((x15) => args[x15.name]) ?? [] : [];
    if (args_.length > 0) {
      topics = indexedInputs?.map((param, i18) => {
        if (Array.isArray(args_[i18]))
          return args_[i18].map((_10, j6) => encodeArg({ param, value: args_[i18][j6] }));
        return args_[i18] ? encodeArg({ param, value: args_[i18] }) : null;
      }) ?? [];
    }
  }
  return [signature, ...topics];
}
function encodeArg({ param, value }) {
  if (param.type === "string" || param.type === "bytes")
    return keccak256(toBytes(value));
  if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    throw new FilterTypeNotSupportedError(param.type);
  return encodeAbiParameters([param], [value]);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/filters/createFilterRequestScope.js
var import_dist61 = __toESM(require_dist(), 1);
var import_dist62 = __toESM(require_dist2(), 1);
var import_dist63 = __toESM(require_dist3(), 1);
function createFilterRequestScope(client, { method }) {
  const requestMap = {};
  if (client.transport.type === "fallback")
    client.transport.onResponse?.(({ method: method_, response: id, status, transport }) => {
      if (status === "success" && method === method_)
        requestMap[id] = transport.request;
    });
  return (id) => requestMap[id] || client.request;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/createContractEventFilter.js
async function createContractEventFilter(client, parameters) {
  const { address, abi, args, eventName, fromBlock, strict, toBlock } = parameters;
  const getRequest = createFilterRequestScope(client, {
    method: "eth_newFilter"
  });
  const topics = eventName ? encodeEventTopics({
    abi,
    args,
    eventName
  }) : void 0;
  const id = await client.request({
    method: "eth_newFilter",
    params: [
      {
        address,
        fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
        toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock,
        topics
      }
    ]
  });
  return {
    abi,
    args,
    eventName,
    id,
    request: getRequest(id),
    strict: Boolean(strict),
    type: "event"
  };
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateContractGas.js
var import_dist166 = __toESM(require_dist(), 1);
var import_dist167 = __toESM(require_dist2(), 1);
var import_dist168 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/errors/getContractError.js
var import_dist67 = __toESM(require_dist(), 1);
var import_dist68 = __toESM(require_dist2(), 1);
var import_dist69 = __toESM(require_dist3(), 1);
var EXECUTION_REVERTED_ERROR_CODE = 3;
function getContractError(err, { abi, address, args, docsPath: docsPath3, functionName, sender }) {
  const { code, data, message, shortMessage } = err instanceof RawContractError ? err : err instanceof BaseError ? err.walk((err2) => "data" in err2) || err.walk() : {};
  const cause = (() => {
    if (err instanceof AbiDecodingZeroDataError)
      return new ContractFunctionZeroDataError({ functionName });
    if ([EXECUTION_REVERTED_ERROR_CODE, InternalRpcError.code].includes(code) && (data || message || shortMessage)) {
      return new ContractFunctionRevertedError({
        abi,
        data: typeof data === "object" ? data.data : data,
        functionName,
        message: shortMessage ?? message
      });
    }
    return err;
  })();
  return new ContractFunctionExecutionError(cause, {
    abi,
    args,
    contractAddress: address,
    docsPath: docsPath3,
    functionName,
    sender
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateGas.js
var import_dist163 = __toESM(require_dist(), 1);
var import_dist164 = __toESM(require_dist2(), 1);
var import_dist165 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/experimental/eip7702/utils/recoverAuthorizationAddress.js
var import_dist85 = __toESM(require_dist(), 1);
var import_dist86 = __toESM(require_dist2(), 1);
var import_dist87 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverAddress.js
var import_dist76 = __toESM(require_dist(), 1);
var import_dist77 = __toESM(require_dist2(), 1);
var import_dist78 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/accounts/utils/publicKeyToAddress.js
var import_dist70 = __toESM(require_dist(), 1);
var import_dist71 = __toESM(require_dist2(), 1);
var import_dist72 = __toESM(require_dist3(), 1);
function publicKeyToAddress(publicKey) {
  const address = keccak256(`0x${publicKey.substring(4)}`).substring(26);
  return checksumAddress(`0x${address}`);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverPublicKey.js
var import_dist73 = __toESM(require_dist(), 1);
var import_dist74 = __toESM(require_dist2(), 1);
var import_dist75 = __toESM(require_dist3(), 1);
async function recoverPublicKey({ hash, signature }) {
  const hashHex = isHex(hash) ? hash : toHex(hash);
  const { secp256k1: secp256k12 } = await import("./secp256k1-IRULFI6Z.js");
  const signature_ = (() => {
    if (typeof signature === "object" && "r" in signature && "s" in signature) {
      const { r: r13, s: s15, v: v8, yParity } = signature;
      const yParityOrV2 = Number(yParity ?? v8);
      const recoveryBit2 = toRecoveryBit(yParityOrV2);
      return new secp256k12.Signature(hexToBigInt(r13), hexToBigInt(s15)).addRecoveryBit(recoveryBit2);
    }
    const signatureHex = isHex(signature) ? signature : toHex(signature);
    const yParityOrV = hexToNumber(`0x${signatureHex.slice(130)}`);
    const recoveryBit = toRecoveryBit(yParityOrV);
    return secp256k12.Signature.fromCompact(signatureHex.substring(2, 130)).addRecoveryBit(recoveryBit);
  })();
  const publicKey = signature_.recoverPublicKey(hashHex.substring(2)).toHex(false);
  return `0x${publicKey}`;
}
function toRecoveryBit(yParityOrV) {
  if (yParityOrV === 0 || yParityOrV === 1)
    return yParityOrV;
  if (yParityOrV === 27)
    return 0;
  if (yParityOrV === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverAddress.js
async function recoverAddress({ hash, signature }) {
  return publicKeyToAddress(await recoverPublicKey({ hash, signature }));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
var import_dist82 = __toESM(require_dist(), 1);
var import_dist83 = __toESM(require_dist2(), 1);
var import_dist84 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/encoding/toRlp.js
var import_dist79 = __toESM(require_dist(), 1);
var import_dist80 = __toESM(require_dist2(), 1);
var import_dist81 = __toESM(require_dist3(), 1);
function toRlp(bytes, to = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x15) => getEncodable(x15)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x15) => acc + x15.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/experimental/eip7702/utils/hashAuthorization.js
function hashAuthorization(parameters) {
  const { chainId, contractAddress, nonce, to } = parameters;
  const hash = keccak256(concatHex([
    "0x05",
    toRlp([
      chainId ? numberToHex(chainId) : "0x",
      contractAddress,
      nonce ? numberToHex(nonce) : "0x"
    ])
  ]));
  if (to === "bytes")
    return hexToBytes(hash);
  return hash;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/experimental/eip7702/utils/recoverAuthorizationAddress.js
async function recoverAuthorizationAddress(parameters) {
  const { authorization, signature } = parameters;
  return recoverAddress({
    hash: hashAuthorization(authorization),
    signature: signature ?? authorization
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/errors/getEstimateGasError.js
var import_dist91 = __toESM(require_dist(), 1);
var import_dist92 = __toESM(require_dist2(), 1);
var import_dist93 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/estimateGas.js
var import_dist88 = __toESM(require_dist(), 1);
var import_dist89 = __toESM(require_dist2(), 1);
var import_dist90 = __toESM(require_dist3(), 1);
var EstimateGasExecutionError = class extends BaseError {
  constructor(cause, { account, docsPath: docsPath3, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to, value }) {
    const prettyArgs = prettyPrint({
      from: account?.address,
      to,
      value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
      data,
      gas,
      gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
      maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
      maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
      nonce
    });
    super(cause.shortMessage, {
      cause,
      docsPath: docsPath3,
      metaMessages: [
        ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        prettyArgs
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/errors/getEstimateGasError.js
function getEstimateGasError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new EstimateGasExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var import_dist157 = __toESM(require_dist(), 1);
var import_dist158 = __toESM(require_dist2(), 1);
var import_dist159 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
var import_dist115 = __toESM(require_dist(), 1);
var import_dist116 = __toESM(require_dist2(), 1);
var import_dist117 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/fee.js
var import_dist94 = __toESM(require_dist(), 1);
var import_dist95 = __toESM(require_dist2(), 1);
var import_dist96 = __toESM(require_dist3(), 1);
var BaseFeeScalarError = class extends BaseError {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
};
var Eip1559FeesNotSupportedError = class extends BaseError {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
};
var MaxFeePerGasTooLowError = class extends BaseError {
  constructor({ maxPriorityFeePerGas }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
var import_dist112 = __toESM(require_dist(), 1);
var import_dist113 = __toESM(require_dist2(), 1);
var import_dist114 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlock.js
var import_dist106 = __toESM(require_dist(), 1);
var import_dist107 = __toESM(require_dist2(), 1);
var import_dist108 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/block.js
var import_dist97 = __toESM(require_dist(), 1);
var import_dist98 = __toESM(require_dist2(), 1);
var import_dist99 = __toESM(require_dist3(), 1);
var BlockNotFoundError = class extends BaseError {
  constructor({ blockHash, blockNumber }) {
    let identifier = "Block";
    if (blockHash)
      identifier = `Block at hash "${blockHash}"`;
    if (blockNumber)
      identifier = `Block at number "${blockNumber}"`;
    super(`${identifier} could not be found.`, { name: "BlockNotFoundError" });
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/block.js
var import_dist103 = __toESM(require_dist(), 1);
var import_dist104 = __toESM(require_dist2(), 1);
var import_dist105 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/transaction.js
var import_dist100 = __toESM(require_dist(), 1);
var import_dist101 = __toESM(require_dist2(), 1);
var import_dist102 = __toESM(require_dist3(), 1);
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = defineFormatter("transaction", formatTransaction);
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = block.transactions?.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = defineFormatter("block", formatBlock);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlock.js
async function getBlock(client, { blockHash, blockNumber, blockTag: blockTag_, includeTransactions: includeTransactions_ } = {}) {
  const blockTag = blockTag_ ?? "latest";
  const includeTransactions = includeTransactions_ ?? false;
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  let block = null;
  if (blockHash) {
    block = await client.request({
      method: "eth_getBlockByHash",
      params: [blockHash, includeTransactions]
    }, { dedupe: true });
  } else {
    block = await client.request({
      method: "eth_getBlockByNumber",
      params: [blockNumberHex || blockTag, includeTransactions]
    }, { dedupe: Boolean(blockNumberHex) });
  }
  if (!block)
    throw new BlockNotFoundError({ blockHash, blockNumber });
  const format = client.chain?.formatters?.block?.format || formatBlock;
  return format(block);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getGasPrice.js
var import_dist109 = __toESM(require_dist(), 1);
var import_dist110 = __toESM(require_dist2(), 1);
var import_dist111 = __toESM(require_dist3(), 1);
async function getGasPrice(client) {
  const gasPrice = await client.request({
    method: "eth_gasPrice"
  });
  return BigInt(gasPrice);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateMaxPriorityFeePerGas.js
async function internal_estimateMaxPriorityFeePerGas(client, args) {
  const { block: block_, chain = client.chain, request } = args || {};
  try {
    const maxPriorityFeePerGas = chain?.fees?.maxPriorityFeePerGas ?? chain?.fees?.defaultPriorityFee;
    if (typeof maxPriorityFeePerGas === "function") {
      const block = block_ || await getAction(client, getBlock, "getBlock")({});
      const maxPriorityFeePerGas_ = await maxPriorityFeePerGas({
        block,
        client,
        request
      });
      if (maxPriorityFeePerGas_ === null)
        throw new Error();
      return maxPriorityFeePerGas_;
    }
    if (typeof maxPriorityFeePerGas !== "undefined")
      return maxPriorityFeePerGas;
    const maxPriorityFeePerGasHex = await client.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return hexToBigInt(maxPriorityFeePerGasHex);
  } catch {
    const [block, gasPrice] = await Promise.all([
      block_ ? Promise.resolve(block_) : getAction(client, getBlock, "getBlock")({}),
      getAction(client, getGasPrice, "getGasPrice")({})
    ]);
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = gasPrice - block.baseFeePerGas;
    if (maxPriorityFeePerGas < 0n)
      return 0n;
    return maxPriorityFeePerGas;
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateFeesPerGas.js
async function internal_estimateFeesPerGas(client, args) {
  const { block: block_, chain = client.chain, request, type = "eip1559" } = args || {};
  const baseFeeMultiplier = await (async () => {
    if (typeof chain?.fees?.baseFeeMultiplier === "function")
      return chain.fees.baseFeeMultiplier({
        block: block_,
        client,
        request
      });
    return chain?.fees?.baseFeeMultiplier ?? 1.2;
  })();
  if (baseFeeMultiplier < 1)
    throw new BaseFeeScalarError();
  const decimals = baseFeeMultiplier.toString().split(".")[1]?.length ?? 0;
  const denominator = 10 ** decimals;
  const multiply = (base) => base * BigInt(Math.ceil(baseFeeMultiplier * denominator)) / BigInt(denominator);
  const block = block_ ? block_ : await getAction(client, getBlock, "getBlock")({});
  if (typeof chain?.fees?.estimateFeesPerGas === "function") {
    const fees = await chain.fees.estimateFeesPerGas({
      block: block_,
      client,
      multiply,
      request,
      type
    });
    if (fees !== null)
      return fees;
  }
  if (type === "eip1559") {
    if (typeof block.baseFeePerGas !== "bigint")
      throw new Eip1559FeesNotSupportedError();
    const maxPriorityFeePerGas = typeof request?.maxPriorityFeePerGas === "bigint" ? request.maxPriorityFeePerGas : await internal_estimateMaxPriorityFeePerGas(client, {
      block,
      chain,
      request
    });
    const baseFeePerGas = multiply(block.baseFeePerGas);
    const maxFeePerGas = request?.maxFeePerGas ?? baseFeePerGas + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
  const gasPrice = request?.gasPrice ?? multiply(await getAction(client, getGasPrice, "getGasPrice")({}));
  return {
    gasPrice
  };
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getTransactionCount.js
var import_dist118 = __toESM(require_dist(), 1);
var import_dist119 = __toESM(require_dist2(), 1);
var import_dist120 = __toESM(require_dist3(), 1);
async function getTransactionCount(client, { address, blockTag = "latest", blockNumber }) {
  const count = await client.request({
    method: "eth_getTransactionCount",
    params: [address, blockNumber ? numberToHex(blockNumber) : blockTag]
  }, { dedupe: Boolean(blockNumber) });
  return hexToNumber(count);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/blobsToCommitments.js
var import_dist121 = __toESM(require_dist(), 1);
var import_dist122 = __toESM(require_dist2(), 1);
var import_dist123 = __toESM(require_dist3(), 1);
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x15) => hexToBytes(x15)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to === "bytes" ? commitments : commitments.map((x15) => bytesToHex(x15));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/blobsToProofs.js
var import_dist124 = __toESM(require_dist(), 1);
var import_dist125 = __toESM(require_dist2(), 1);
var import_dist126 = __toESM(require_dist3(), 1);
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x15) => hexToBytes(x15)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x15) => hexToBytes(x15)) : parameters.commitments;
  const proofs = [];
  for (let i18 = 0; i18 < blobs.length; i18++) {
    const blob = blobs[i18];
    const commitment = commitments[i18];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to === "bytes" ? proofs : proofs.map((x15) => bytesToHex(x15));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
var import_dist133 = __toESM(require_dist(), 1);
var import_dist134 = __toESM(require_dist2(), 1);
var import_dist135 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
var import_dist130 = __toESM(require_dist(), 1);
var import_dist131 = __toESM(require_dist2(), 1);
var import_dist132 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/sha256.js
var import_dist127 = __toESM(require_dist(), 1);
var import_dist128 = __toESM(require_dist2(), 1);
var import_dist129 = __toESM(require_dist3(), 1);
function sha2562(value, to_) {
  const to = to_ || "hex";
  const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to === "bytes")
    return bytes;
  return toHex(bytes);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version = 1 } = parameters;
  const to = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version], 0);
  return to === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version } = parameters;
  const to = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to,
      version
    }));
  }
  return hashes;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/toBlobSidecars.js
var import_dist148 = __toESM(require_dist(), 1);
var import_dist149 = __toESM(require_dist2(), 1);
var import_dist150 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/toBlobs.js
var import_dist145 = __toESM(require_dist(), 1);
var import_dist146 = __toESM(require_dist2(), 1);
var import_dist147 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/constants/blob.js
var import_dist136 = __toESM(require_dist(), 1);
var import_dist137 = __toESM(require_dist2(), 1);
var import_dist138 = __toESM(require_dist3(), 1);
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/blob.js
var import_dist142 = __toESM(require_dist(), 1);
var import_dist143 = __toESM(require_dist2(), 1);
var import_dist144 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/constants/kzg.js
var import_dist139 = __toESM(require_dist(), 1);
var import_dist140 = __toESM(require_dist2(), 1);
var import_dist141 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/blob.js
var BlobSizeTooLargeError = class extends BaseError {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/toBlobs.js
function toBlobs(parameters) {
  const to = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to === "bytes" ? blobs.map((x15) => x15.bytes) : blobs.map((x15) => bytesToHex(x15.bytes));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to });
  const sidecars = [];
  for (let i18 = 0; i18 < blobs.length; i18++)
    sidecars.push({
      blob: blobs[i18],
      commitment: commitments[i18],
      proof: proofs[i18]
    });
  return sidecars;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/getTransactionType.js
var import_dist151 = __toESM(require_dist(), 1);
var import_dist152 = __toESM(require_dist2(), 1);
var import_dist153 = __toESM(require_dist3(), 1);
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getChainId.js
var import_dist154 = __toESM(require_dist(), 1);
var import_dist155 = __toESM(require_dist2(), 1);
var import_dist156 = __toESM(require_dist3(), 1);
async function getChainId(client) {
  const chainIdHex = await client.request({
    method: "eth_chainId"
  }, { dedupe: true });
  return hexToNumber(chainIdHex);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/prepareTransactionRequest.js
var defaultParameters = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function prepareTransactionRequest(client, args) {
  const { account: account_ = client.account, blobs, chain, gas, kzg, nonce, nonceManager: nonceManager2, parameters = defaultParameters, type } = args;
  const account = account_ ? parseAccount(account_) : account_;
  const request = { ...args, ...account ? { from: account?.address } : {} };
  let block;
  async function getBlock2() {
    if (block)
      return block;
    block = await getAction(client, getBlock, "getBlock")({ blockTag: "latest" });
    return block;
  }
  let chainId;
  async function getChainId2() {
    if (chainId)
      return chainId;
    if (chain)
      return chain.id;
    if (typeof args.chainId !== "undefined")
      return args.chainId;
    const chainId_ = await getAction(client, getChainId, "getChainId")({});
    chainId = chainId_;
    return chainId;
  }
  if ((parameters.includes("blobVersionedHashes") || parameters.includes("sidecars")) && blobs && kzg) {
    const commitments = blobsToCommitments({ blobs, kzg });
    if (parameters.includes("blobVersionedHashes")) {
      const versionedHashes = commitmentsToVersionedHashes({
        commitments,
        to: "hex"
      });
      request.blobVersionedHashes = versionedHashes;
    }
    if (parameters.includes("sidecars")) {
      const proofs = blobsToProofs({ blobs, commitments, kzg });
      const sidecars = toBlobSidecars({
        blobs,
        commitments,
        proofs,
        to: "hex"
      });
      request.sidecars = sidecars;
    }
  }
  if (parameters.includes("chainId"))
    request.chainId = await getChainId2();
  if (parameters.includes("nonce") && typeof nonce === "undefined" && account) {
    if (nonceManager2) {
      const chainId2 = await getChainId2();
      request.nonce = await nonceManager2.consume({
        address: account.address,
        chainId: chainId2,
        client
      });
    } else {
      request.nonce = await getAction(client, getTransactionCount, "getTransactionCount")({
        address: account.address,
        blockTag: "pending"
      });
    }
  }
  if ((parameters.includes("fees") || parameters.includes("type")) && typeof type === "undefined") {
    try {
      request.type = getTransactionType(request);
    } catch {
      const block2 = await getBlock2();
      request.type = typeof block2?.baseFeePerGas === "bigint" ? "eip1559" : "legacy";
    }
  }
  if (parameters.includes("fees")) {
    if (request.type !== "legacy" && request.type !== "eip2930") {
      if (typeof request.maxFeePerGas === "undefined" || typeof request.maxPriorityFeePerGas === "undefined") {
        const block2 = await getBlock2();
        const { maxFeePerGas, maxPriorityFeePerGas } = await internal_estimateFeesPerGas(client, {
          block: block2,
          chain,
          request
        });
        if (typeof args.maxPriorityFeePerGas === "undefined" && args.maxFeePerGas && args.maxFeePerGas < maxPriorityFeePerGas)
          throw new MaxFeePerGasTooLowError({
            maxPriorityFeePerGas
          });
        request.maxPriorityFeePerGas = maxPriorityFeePerGas;
        request.maxFeePerGas = maxFeePerGas;
      }
    } else {
      if (typeof args.maxFeePerGas !== "undefined" || typeof args.maxPriorityFeePerGas !== "undefined")
        throw new Eip1559FeesNotSupportedError();
      const block2 = await getBlock2();
      const { gasPrice: gasPrice_ } = await internal_estimateFeesPerGas(client, {
        block: block2,
        chain,
        request,
        type: "legacy"
      });
      request.gasPrice = gasPrice_;
    }
  }
  if (parameters.includes("gas") && typeof gas === "undefined")
    request.gas = await getAction(client, estimateGas, "estimateGas")({
      ...request,
      account: account ? { address: account.address, type: "json-rpc" } : account
    });
  assertRequest(request);
  delete request.parameters;
  return request;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBalance.js
var import_dist160 = __toESM(require_dist(), 1);
var import_dist161 = __toESM(require_dist2(), 1);
var import_dist162 = __toESM(require_dist3(), 1);
async function getBalance(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
  const balance = await client.request({
    method: "eth_getBalance",
    params: [address, blockNumberHex || blockTag]
  });
  return BigInt(balance);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateGas.js
async function estimateGas(client, args) {
  const { account: account_ = client.account } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  try {
    let estimateGas_rpc = function(parameters) {
      const { block: block2, request: request2, rpcStateOverride: rpcStateOverride2 } = parameters;
      return client.request({
        method: "eth_estimateGas",
        params: rpcStateOverride2 ? [request2, block2 ?? "latest", rpcStateOverride2] : block2 ? [request2, block2] : [request2]
      });
    };
    const { accessList, authorizationList, blobs, blobVersionedHashes, blockNumber, blockTag, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, stateOverride, ...rest } = await prepareTransactionRequest(client, {
      ...args,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        account?.type === "local" ? void 0 : ["blobVersionedHashes"]
      )
    });
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    const rpcStateOverride = serializeStateOverride(stateOverride);
    const to = await (async () => {
      if (rest.to)
        return rest.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`");
        });
      return void 0;
    })();
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      authorizationList,
      blobs,
      blobVersionedHashes,
      data,
      gas,
      gasPrice,
      maxFeePerBlobGas,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to,
      value
    });
    let estimate = BigInt(await estimateGas_rpc({ block, request, rpcStateOverride }));
    if (authorizationList) {
      const value2 = await getBalance(client, { address: request.from });
      const estimates = await Promise.all(authorizationList.map(async (authorization) => {
        const { contractAddress } = authorization;
        const estimate2 = await estimateGas_rpc({
          block,
          request: {
            authorizationList: void 0,
            data,
            from: account?.address,
            to: contractAddress,
            value: numberToHex(value2)
          },
          rpcStateOverride
        }).catch(() => 100000n);
        return 2n * BigInt(estimate2);
      }));
      estimate += estimates.reduce((acc, curr) => acc + curr, 0n);
    }
    return estimate;
  } catch (err) {
    throw getEstimateGasError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/estimateContractGas.js
async function estimateContractGas(client, parameters) {
  const { abi, address, args, functionName, ...request } = parameters;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const gas = await getAction(client, estimateGas, "estimateGas")({
      data,
      to: address,
      ...request
    });
    return gas;
  } catch (error) {
    const account = request.account ? parseAccount(request.account) : void 0;
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/estimateContractGas",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getContractEvents.js
var import_dist181 = __toESM(require_dist(), 1);
var import_dist182 = __toESM(require_dist2(), 1);
var import_dist183 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getLogs.js
var import_dist178 = __toESM(require_dist(), 1);
var import_dist179 = __toESM(require_dist2(), 1);
var import_dist180 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/parseEventLogs.js
var import_dist172 = __toESM(require_dist(), 1);
var import_dist173 = __toESM(require_dist2(), 1);
var import_dist174 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/decodeEventLog.js
var import_dist169 = __toESM(require_dist(), 1);
var import_dist170 = __toESM(require_dist2(), 1);
var import_dist171 = __toESM(require_dist3(), 1);
var docsPath2 = "/docs/contract/decodeEventLog";
function decodeEventLog(parameters) {
  const { abi, data, strict: strict_, topics } = parameters;
  const strict = strict_ ?? true;
  const [signature, ...argTopics] = topics;
  if (!signature)
    throw new AbiEventSignatureEmptyTopicsError({ docsPath: docsPath2 });
  const abiItem = (() => {
    if (abi.length === 1)
      return abi[0];
    return abi.find((x15) => x15.type === "event" && signature === toEventSelector(formatAbiItem(x15)));
  })();
  if (!(abiItem && "name" in abiItem) || abiItem.type !== "event")
    throw new AbiEventSignatureNotFoundError(signature, { docsPath: docsPath2 });
  const { name, inputs } = abiItem;
  const isUnnamed = inputs?.some((x15) => !("name" in x15 && x15.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x15) => "indexed" in x15 && x15.indexed);
  for (let i18 = 0; i18 < indexedInputs.length; i18++) {
    const param = indexedInputs[i18];
    const topic = argTopics[i18];
    if (!topic)
      throw new DecodeLogTopicsMismatch({
        abiItem,
        param
      });
    args[isUnnamed ? i18 : param.name || i18] = decodeTopic({ param, value: topic });
  }
  const nonIndexedInputs = inputs.filter((x15) => !("indexed" in x15 && x15.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decodeAbiParameters(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i18 = 0; i18 < nonIndexedInputs.length; i18++) {
              args[nonIndexedInputs[i18].name] = decodedData[i18];
            }
          }
        }
      } catch (err) {
        if (strict) {
          if (err instanceof AbiDecodingDataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
            throw new DecodeLogDataMismatch({
              abiItem,
              data,
              params: nonIndexedInputs,
              size: size(data)
            });
          throw err;
        }
      }
    } else if (strict) {
      throw new DecodeLogDataMismatch({
        abiItem,
        data: "0x",
        params: nonIndexedInputs,
        size: 0
      });
    }
  }
  return {
    eventName: name,
    args: Object.values(args).length > 0 ? args : void 0
  };
}
function decodeTopic({ param, value }) {
  if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
    return value;
  const decodedArg = decodeAbiParameters([param], value) || [];
  return decodedArg[0];
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/parseEventLogs.js
function parseEventLogs(parameters) {
  const { abi, args, logs, strict = true } = parameters;
  const eventName = (() => {
    if (!parameters.eventName)
      return void 0;
    if (Array.isArray(parameters.eventName))
      return parameters.eventName;
    return [parameters.eventName];
  })();
  return logs.map((log) => {
    try {
      const abiItem = abi.find((abiItem2) => abiItem2.type === "event" && log.topics[0] === toEventSelector(abiItem2));
      if (!abiItem)
        return null;
      const event = decodeEventLog({
        ...log,
        abi: [abiItem],
        strict
      });
      if (eventName && !eventName.includes(event.eventName))
        return null;
      if (!includesArgs({
        args: event.args,
        inputs: abiItem.inputs,
        matchArgs: args
      }))
        return null;
      return { ...event, ...log };
    } catch (err) {
      let eventName2;
      let isUnnamed;
      if (err instanceof AbiEventSignatureNotFoundError)
        return null;
      if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
        if (strict)
          return null;
        eventName2 = err.abiItem.name;
        isUnnamed = err.abiItem.inputs?.some((x15) => !("name" in x15 && x15.name));
      }
      return { ...log, args: isUnnamed ? [] : {}, eventName: eventName2 };
    }
  }).filter(Boolean);
}
function includesArgs(parameters) {
  const { args, inputs, matchArgs } = parameters;
  if (!matchArgs)
    return true;
  if (!args)
    return false;
  function isEqual(input, value, arg) {
    try {
      if (input.type === "address")
        return isAddressEqual(value, arg);
      if (input.type === "string" || input.type === "bytes")
        return keccak256(toBytes(value)) === arg;
      return value === arg;
    } catch {
      return false;
    }
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    return matchArgs.every((value, index) => {
      if (value === null || value === void 0)
        return true;
      const input = inputs[index];
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[index]));
    });
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    return Object.entries(matchArgs).every(([key, value]) => {
      if (value === null || value === void 0)
        return true;
      const input = inputs.find((input2) => input2.name === key);
      if (!input)
        return false;
      const value_ = Array.isArray(value) ? value : [value];
      return value_.some((value2) => isEqual(input, value2, args[key]));
    });
  return false;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/log.js
var import_dist175 = __toESM(require_dist(), 1);
var import_dist176 = __toESM(require_dist2(), 1);
var import_dist177 = __toESM(require_dist3(), 1);
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getLogs.js
async function getLogs(client, { address, blockHash, fromBlock, toBlock, event, events: events_, args, strict: strict_ } = {}) {
  const strict = strict_ ?? false;
  const events = events_ ?? (event ? [event] : void 0);
  let topics = [];
  if (events) {
    const encoded = events.flatMap((event2) => encodeEventTopics({
      abi: [event2],
      eventName: event2.name,
      args: events_ ? void 0 : args
    }));
    topics = [encoded];
    if (event)
      topics = topics[0];
  }
  let logs;
  if (blockHash) {
    logs = await client.request({
      method: "eth_getLogs",
      params: [{ address, topics, blockHash }]
    });
  } else {
    logs = await client.request({
      method: "eth_getLogs",
      params: [
        {
          address,
          topics,
          fromBlock: typeof fromBlock === "bigint" ? numberToHex(fromBlock) : fromBlock,
          toBlock: typeof toBlock === "bigint" ? numberToHex(toBlock) : toBlock
        }
      ]
    });
  }
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!events)
    return formattedLogs;
  return parseEventLogs({
    abi: events,
    args,
    logs: formattedLogs,
    strict
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getContractEvents.js
async function getContractEvents(client, parameters) {
  const { abi, address, args, blockHash, eventName, fromBlock, toBlock, strict } = parameters;
  const event = eventName ? getAbiItem({ abi, name: eventName }) : void 0;
  const events = !event ? abi.filter((x15) => x15.type === "event") : void 0;
  return getAction(client, getLogs, "getLogs")({
    address,
    args,
    blockHash,
    event,
    events,
    fromBlock,
    toBlock,
    strict
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/readContract.js
var import_dist184 = __toESM(require_dist(), 1);
var import_dist185 = __toESM(require_dist2(), 1);
var import_dist186 = __toESM(require_dist3(), 1);
async function readContract(client, parameters) {
  const { abi, address, args, functionName, ...rest } = parameters;
  const calldata = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    const { data } = await getAction(client, call, "call")({
      ...rest,
      data: calldata,
      to: address
    });
    return decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/readContract",
      functionName
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/simulateContract.js
var import_dist187 = __toESM(require_dist(), 1);
var import_dist188 = __toESM(require_dist2(), 1);
var import_dist189 = __toESM(require_dist3(), 1);
async function simulateContract(client, parameters) {
  const { abi, address, args, dataSuffix, functionName, ...callRequest } = parameters;
  const account = callRequest.account ? parseAccount(callRequest.account) : client.account;
  const calldata = encodeFunctionData({ abi, args, functionName });
  try {
    const { data } = await getAction(client, call, "call")({
      batch: false,
      data: `${calldata}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      ...callRequest,
      account
    });
    const result = decodeFunctionResult({
      abi,
      args,
      functionName,
      data: data || "0x"
    });
    const minimizedAbi = abi.filter((abiItem) => "name" in abiItem && abiItem.name === parameters.functionName);
    return {
      result,
      request: {
        abi: minimizedAbi,
        address,
        args,
        dataSuffix,
        functionName,
        ...callRequest,
        account
      }
    };
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/simulateContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchContractEvent.js
var import_dist211 = __toESM(require_dist(), 1);
var import_dist212 = __toESM(require_dist2(), 1);
var import_dist213 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/observe.js
var import_dist190 = __toESM(require_dist(), 1);
var import_dist191 = __toESM(require_dist2(), 1);
var import_dist192 = __toESM(require_dist3(), 1);
var listenersCache = /* @__PURE__ */ new Map();
var cleanupCache = /* @__PURE__ */ new Map();
var callbackCount = 0;
function observe(observerId, callbacks, fn) {
  const callbackId = ++callbackCount;
  const getListeners = () => listenersCache.get(observerId) || [];
  const unsubscribe = () => {
    const listeners2 = getListeners();
    listenersCache.set(observerId, listeners2.filter((cb) => cb.id !== callbackId));
  };
  const unwatch = () => {
    const cleanup2 = cleanupCache.get(observerId);
    if (getListeners().length === 1 && cleanup2)
      cleanup2();
    unsubscribe();
  };
  const listeners = getListeners();
  listenersCache.set(observerId, [
    ...listeners,
    { id: callbackId, fns: callbacks }
  ]);
  if (listeners && listeners.length > 0)
    return unwatch;
  const emit = {};
  for (const key in callbacks) {
    emit[key] = (...args) => {
      const listeners2 = getListeners();
      if (listeners2.length === 0)
        return;
      for (const listener of listeners2)
        listener.fns[key]?.(...args);
    };
  }
  const cleanup = fn(emit);
  if (typeof cleanup === "function")
    cleanupCache.set(observerId, cleanup);
  return unwatch;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/poll.js
var import_dist196 = __toESM(require_dist(), 1);
var import_dist197 = __toESM(require_dist2(), 1);
var import_dist198 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/wait.js
var import_dist193 = __toESM(require_dist(), 1);
var import_dist194 = __toESM(require_dist2(), 1);
var import_dist195 = __toESM(require_dist3(), 1);
async function wait(time) {
  return new Promise((res) => setTimeout(res, time));
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/poll.js
function poll(fn, { emitOnBegin, initialWaitTime, interval }) {
  let active = true;
  const unwatch = () => active = false;
  const watch = async () => {
    let data = void 0;
    if (emitOnBegin)
      data = await fn({ unpoll: unwatch });
    const initialWait = await initialWaitTime?.(data) ?? interval;
    await wait(initialWait);
    const poll2 = async () => {
      if (!active)
        return;
      await fn({ unpoll: unwatch });
      await wait(interval);
      poll2();
    };
    poll2();
  };
  watch();
  return unwatch;
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlockNumber.js
var import_dist202 = __toESM(require_dist(), 1);
var import_dist203 = __toESM(require_dist2(), 1);
var import_dist204 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/promise/withCache.js
var import_dist199 = __toESM(require_dist(), 1);
var import_dist200 = __toESM(require_dist2(), 1);
var import_dist201 = __toESM(require_dist3(), 1);
var promiseCache = /* @__PURE__ */ new Map();
var responseCache = /* @__PURE__ */ new Map();
function getCache(cacheKey2) {
  const buildCache = (cacheKey3, cache) => ({
    clear: () => cache.delete(cacheKey3),
    get: () => cache.get(cacheKey3),
    set: (data) => cache.set(cacheKey3, data)
  });
  const promise = buildCache(cacheKey2, promiseCache);
  const response = buildCache(cacheKey2, responseCache);
  return {
    clear: () => {
      promise.clear();
      response.clear();
    },
    promise,
    response
  };
}
async function withCache(fn, { cacheKey: cacheKey2, cacheTime = Number.POSITIVE_INFINITY }) {
  const cache = getCache(cacheKey2);
  const response = cache.response.get();
  if (response && cacheTime > 0) {
    const age = (/* @__PURE__ */ new Date()).getTime() - response.created.getTime();
    if (age < cacheTime)
      return response.data;
  }
  let promise = cache.promise.get();
  if (!promise) {
    promise = fn();
    cache.promise.set(promise);
  }
  try {
    const data = await promise;
    cache.response.set({ created: /* @__PURE__ */ new Date(), data });
    return data;
  } finally {
    cache.promise.clear();
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlockNumber.js
var cacheKey = (id) => `blockNumber.${id}`;
async function getBlockNumber(client, { cacheTime = client.cacheTime } = {}) {
  const blockNumberHex = await withCache(() => client.request({
    method: "eth_blockNumber"
  }), { cacheKey: cacheKey(client.uid), cacheTime });
  return BigInt(blockNumberHex);
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getFilterChanges.js
var import_dist205 = __toESM(require_dist(), 1);
var import_dist206 = __toESM(require_dist2(), 1);
var import_dist207 = __toESM(require_dist3(), 1);
async function getFilterChanges(_client, { filter }) {
  const strict = "strict" in filter && filter.strict;
  const logs = await filter.request({
    method: "eth_getFilterChanges",
    params: [filter.id]
  });
  if (typeof logs[0] === "string")
    return logs;
  const formattedLogs = logs.map((log) => formatLog(log));
  if (!("abi" in filter) || !filter.abi)
    return formattedLogs;
  return parseEventLogs({
    abi: filter.abi,
    logs: formattedLogs,
    strict
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/uninstallFilter.js
var import_dist208 = __toESM(require_dist(), 1);
var import_dist209 = __toESM(require_dist2(), 1);
var import_dist210 = __toESM(require_dist3(), 1);
async function uninstallFilter(_client, { filter }) {
  return filter.request({
    method: "eth_uninstallFilter",
    params: [filter.id]
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchContractEvent.js
function watchContractEvent(client, parameters) {
  const { abi, address, args, batch = true, eventName, fromBlock, onError, onLogs, poll: poll_, pollingInterval = client.pollingInterval, strict: strict_ } = parameters;
  const enablePolling = (() => {
    if (typeof poll_ !== "undefined")
      return poll_;
    if (typeof fromBlock === "bigint")
      return true;
    if (client.transport.type === "webSocket")
      return false;
    if (client.transport.type === "fallback" && client.transport.transports[0].config.type === "webSocket")
      return false;
    return true;
  })();
  const pollContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict,
      fromBlock
    ]);
    return observe(observerId, { onLogs, onError }, (emit) => {
      let previousBlockNumber;
      if (fromBlock !== void 0)
        previousBlockNumber = fromBlock - 1n;
      let filter;
      let initialized = false;
      const unwatch = poll(async () => {
        if (!initialized) {
          try {
            filter = await getAction(client, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              args,
              eventName,
              strict,
              fromBlock
            });
          } catch {
          }
          initialized = true;
          return;
        }
        try {
          let logs;
          if (filter) {
            logs = await getAction(client, getFilterChanges, "getFilterChanges")({ filter });
          } else {
            const blockNumber = await getAction(client, getBlockNumber, "getBlockNumber")({});
            if (previousBlockNumber && previousBlockNumber < blockNumber) {
              logs = await getAction(client, getContractEvents, "getContractEvents")({
                abi,
                address,
                args,
                eventName,
                fromBlock: previousBlockNumber + 1n,
                toBlock: blockNumber,
                strict
              });
            } else {
              logs = [];
            }
            previousBlockNumber = blockNumber;
          }
          if (logs.length === 0)
            return;
          if (batch)
            emit.onLogs(logs);
          else
            for (const log of logs)
              emit.onLogs([log]);
        } catch (err) {
          if (filter && err instanceof InvalidInputRpcError)
            initialized = false;
          emit.onError?.(err);
        }
      }, {
        emitOnBegin: true,
        interval: pollingInterval
      });
      return async () => {
        if (filter)
          await getAction(client, uninstallFilter, "uninstallFilter")({ filter });
        unwatch();
      };
    });
  };
  const subscribeContractEvent = () => {
    const strict = strict_ ?? false;
    const observerId = stringify([
      "watchContractEvent",
      address,
      args,
      batch,
      client.uid,
      eventName,
      pollingInterval,
      strict
    ]);
    let active = true;
    let unsubscribe = () => active = false;
    return observe(observerId, { onLogs, onError }, (emit) => {
      ;
      (async () => {
        try {
          const transport = (() => {
            if (client.transport.type === "fallback") {
              const transport2 = client.transport.transports.find((transport3) => transport3.config.type === "webSocket");
              if (!transport2)
                return client.transport;
              return transport2.value;
            }
            return client.transport;
          })();
          const topics = eventName ? encodeEventTopics({
            abi,
            eventName,
            args
          }) : [];
          const { unsubscribe: unsubscribe_ } = await transport.subscribe({
            params: ["logs", { address, topics }],
            onData(data) {
              if (!active)
                return;
              const log = data.result;
              try {
                const { eventName: eventName2, args: args2 } = decodeEventLog({
                  abi,
                  data: log.data,
                  topics: log.topics,
                  strict: strict_
                });
                const formatted = formatLog(log, {
                  args: args2,
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              } catch (err) {
                let eventName2;
                let isUnnamed;
                if (err instanceof DecodeLogDataMismatch || err instanceof DecodeLogTopicsMismatch) {
                  if (strict_)
                    return;
                  eventName2 = err.abiItem.name;
                  isUnnamed = err.abiItem.inputs?.some((x15) => !("name" in x15 && x15.name));
                }
                const formatted = formatLog(log, {
                  args: isUnnamed ? [] : {},
                  eventName: eventName2
                });
                emit.onLogs([formatted]);
              }
            },
            onError(error) {
              emit.onError?.(error);
            }
          });
          unsubscribe = unsubscribe_;
          if (!active)
            unsubscribe();
        } catch (err) {
          onError?.(err);
        }
      })();
      return () => unsubscribe();
    });
  };
  return enablePolling ? pollContractEvent() : subscribeContractEvent();
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/writeContract.js
var import_dist229 = __toESM(require_dist(), 1);
var import_dist230 = __toESM(require_dist2(), 1);
var import_dist231 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/account.js
var import_dist214 = __toESM(require_dist(), 1);
var import_dist215 = __toESM(require_dist2(), 1);
var import_dist216 = __toESM(require_dist3(), 1);
var AccountNotFoundError = class extends BaseError {
  constructor({ docsPath: docsPath3 } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath: docsPath3,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};
var AccountTypeNotSupportedError = class extends BaseError {
  constructor({ docsPath: docsPath3, metaMessages, type }) {
    super(`Account type "${type}" is not supported.`, {
      docsPath: docsPath3,
      metaMessages,
      name: "AccountTypeNotSupportedError"
    });
  }
};

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var import_dist226 = __toESM(require_dist(), 1);
var import_dist227 = __toESM(require_dist2(), 1);
var import_dist228 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/chain/assertCurrentChain.js
var import_dist217 = __toESM(require_dist(), 1);
var import_dist218 = __toESM(require_dist2(), 1);
var import_dist219 = __toESM(require_dist3(), 1);
function assertCurrentChain({ chain, currentChainId }) {
  if (!chain)
    throw new ChainNotFoundError();
  if (currentChainId !== chain.id)
    throw new ChainMismatchError({ chain, currentChainId });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/errors/getTransactionError.js
var import_dist220 = __toESM(require_dist(), 1);
var import_dist221 = __toESM(require_dist2(), 1);
var import_dist222 = __toESM(require_dist3(), 1);
function getTransactionError(err, { docsPath: docsPath3, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new TransactionExecutionError(cause, {
    docsPath: docsPath3,
    ...args
  });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/sendRawTransaction.js
var import_dist223 = __toESM(require_dist(), 1);
var import_dist224 = __toESM(require_dist2(), 1);
var import_dist225 = __toESM(require_dist3(), 1);
async function sendRawTransaction(client, { serializedTransaction }) {
  return client.request({
    method: "eth_sendRawTransaction",
    params: [serializedTransaction]
  }, { retryCount: 0 });
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/sendTransaction.js
var supportsWalletNamespace = new LruMap(128);
async function sendTransaction(client, parameters) {
  const { account: account_ = client.account, chain = client.chain, accessList, authorizationList, blobs, data, gas, gasPrice, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, nonce, value, ...rest } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/actions/wallet/sendTransaction"
    });
  const account = account_ ? parseAccount(account_) : null;
  try {
    assertRequest(parameters);
    const to = await (async () => {
      if (parameters.to)
        return parameters.to;
      if (authorizationList && authorizationList.length > 0)
        return await recoverAuthorizationAddress({
          authorization: authorizationList[0]
        }).catch(() => {
          throw new BaseError("`to` is required. Could not infer from `authorizationList`.");
        });
      return void 0;
    })();
    if (account?.type === "json-rpc" || account === null) {
      let chainId;
      if (chain !== null) {
        chainId = await getAction(client, getChainId, "getChainId")({});
        assertCurrentChain({
          currentChainId: chainId,
          chain
        });
      }
      const chainFormat = client.chain?.formatters?.transactionRequest?.format;
      const format = chainFormat || formatTransactionRequest;
      const request = format({
        // Pick out extra data that might exist on the chain's transaction request type.
        ...extract(rest, { format: chainFormat }),
        accessList,
        authorizationList,
        blobs,
        chainId,
        data,
        from: account?.address,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        to,
        value
      });
      const method = supportsWalletNamespace.get(client.uid) ? "wallet_sendTransaction" : "eth_sendTransaction";
      try {
        return await client.request({
          method,
          params: [request]
        }, { retryCount: 0 });
      } catch (e17) {
        const error = e17;
        if (error.name === "InvalidInputRpcError" || error.name === "InvalidParamsRpcError" || error.name === "MethodNotFoundRpcError" || error.name === "MethodNotSupportedRpcError")
          return await client.request({
            method: "wallet_sendTransaction",
            params: [request]
          }, { retryCount: 0 }).then((hash) => {
            supportsWalletNamespace.set(client.uid, true);
            return hash;
          });
        throw error;
      }
    }
    if (account?.type === "local") {
      const request = await getAction(client, prepareTransactionRequest, "prepareTransactionRequest")({
        account,
        accessList,
        authorizationList,
        blobs,
        chain,
        data,
        gas,
        gasPrice,
        maxFeePerBlobGas,
        maxFeePerGas,
        maxPriorityFeePerGas,
        nonce,
        nonceManager: account.nonceManager,
        parameters: [...defaultParameters, "sidecars"],
        value,
        ...rest,
        to
      });
      const serializer = chain?.serializers?.transaction;
      const serializedTransaction = await account.signTransaction(request, {
        serializer
      });
      return await getAction(client, sendRawTransaction, "sendRawTransaction")({
        serializedTransaction
      });
    }
    if (account?.type === "smart")
      throw new AccountTypeNotSupportedError({
        metaMessages: [
          "Consider using the `sendUserOperation` Action instead."
        ],
        docsPath: "/docs/actions/bundler/sendUserOperation",
        type: "smart"
      });
    throw new AccountTypeNotSupportedError({
      docsPath: "/docs/actions/wallet/sendTransaction",
      type: account?.type
    });
  } catch (err) {
    if (err instanceof AccountTypeNotSupportedError)
      throw err;
    throw getTransactionError(err, {
      ...parameters,
      account,
      chain: parameters.chain || void 0
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/writeContract.js
async function writeContract(client, parameters) {
  const { abi, account: account_ = client.account, address, args, dataSuffix, functionName, ...request } = parameters;
  if (typeof account_ === "undefined")
    throw new AccountNotFoundError({
      docsPath: "/docs/contract/writeContract"
    });
  const account = account_ ? parseAccount(account_) : null;
  const data = encodeFunctionData({
    abi,
    args,
    functionName
  });
  try {
    return await getAction(client, sendTransaction, "sendTransaction")({
      data: `${data}${dataSuffix ? dataSuffix.replace("0x", "") : ""}`,
      to: address,
      account,
      ...request
    });
  } catch (error) {
    throw getContractError(error, {
      abi,
      address,
      args,
      docsPath: "/docs/contract/writeContract",
      functionName,
      sender: account?.address
    });
  }
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/getContract.js
function getContract({ abi, address, client: client_ }) {
  const client = client_;
  const [publicClient, walletClient] = (() => {
    if (!client)
      return [void 0, void 0];
    if ("public" in client && "wallet" in client)
      return [client.public, client.wallet];
    if ("public" in client)
      return [client.public, void 0];
    if ("wallet" in client)
      return [void 0, client.wallet];
    return [client, client];
  })();
  const hasPublicClient = publicClient !== void 0 && publicClient !== null;
  const hasWalletClient = walletClient !== void 0 && walletClient !== null;
  const contract = {};
  let hasReadFunction = false;
  let hasWriteFunction = false;
  let hasEvent = false;
  for (const item of abi) {
    if (item.type === "function")
      if (item.stateMutability === "view" || item.stateMutability === "pure")
        hasReadFunction = true;
      else
        hasWriteFunction = true;
    else if (item.type === "event")
      hasEvent = true;
    if (hasReadFunction && hasWriteFunction && hasEvent)
      break;
  }
  if (hasPublicClient) {
    if (hasReadFunction)
      contract.read = new Proxy({}, {
        get(_10, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, readContract, "readContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasWriteFunction)
      contract.simulate = new Proxy({}, {
        get(_10, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(publicClient, simulateContract, "simulateContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
    if (hasEvent) {
      contract.createEventFilter = new Proxy({}, {
        get(_10, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x15) => x15.type === "event" && x15.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, createContractEventFilter, "createContractEventFilter")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.getEvents = new Proxy({}, {
        get(_10, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x15) => x15.type === "event" && x15.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, getContractEvents, "getContractEvents")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
      contract.watchEvent = new Proxy({}, {
        get(_10, eventName) {
          return (...parameters) => {
            const abiEvent = abi.find((x15) => x15.type === "event" && x15.name === eventName);
            const { args, options } = getEventParameters(parameters, abiEvent);
            return getAction(publicClient, watchContractEvent, "watchContractEvent")({
              abi,
              address,
              eventName,
              args,
              ...options
            });
          };
        }
      });
    }
  }
  if (hasWalletClient) {
    if (hasWriteFunction)
      contract.write = new Proxy({}, {
        get(_10, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            return getAction(walletClient, writeContract, "writeContract")({
              abi,
              address,
              functionName,
              args,
              ...options
            });
          };
        }
      });
  }
  if (hasPublicClient || hasWalletClient) {
    if (hasWriteFunction)
      contract.estimateGas = new Proxy({}, {
        get(_10, functionName) {
          return (...parameters) => {
            const { args, options } = getFunctionParameters(parameters);
            const client2 = publicClient ?? walletClient;
            return getAction(client2, estimateContractGas, "estimateContractGas")({
              abi,
              address,
              functionName,
              args,
              ...options,
              account: options.account ?? walletClient.account
            });
          };
        }
      });
  }
  contract.address = address;
  contract.abi = abi;
  return contract;
}
function getFunctionParameters(values) {
  const hasArgs = values.length && Array.isArray(values[0]);
  const args = hasArgs ? values[0] : [];
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}
function getEventParameters(values, abiEvent) {
  let hasArgs = false;
  if (Array.isArray(values[0]))
    hasArgs = true;
  else if (values.length === 1) {
    hasArgs = abiEvent.inputs.some((x15) => x15.indexed);
  } else if (values.length === 2) {
    hasArgs = true;
  }
  const args = hasArgs ? values[0] : void 0;
  const options = (hasArgs ? values[1] : values[0]) ?? {};
  return { args, options };
}

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getEip712Domain.js
var import_dist238 = __toESM(require_dist(), 1);
var import_dist239 = __toESM(require_dist2(), 1);
var import_dist240 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/eip712.js
var import_dist235 = __toESM(require_dist(), 1);
var import_dist236 = __toESM(require_dist2(), 1);
var import_dist237 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/addChain.js
var import_dist241 = __toESM(require_dist(), 1);
var import_dist242 = __toESM(require_dist2(), 1);
var import_dist243 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/createClient.js
var import_dist247 = __toESM(require_dist(), 1);
var import_dist248 = __toESM(require_dist2(), 1);
var import_dist249 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/uid.js
var import_dist244 = __toESM(require_dist(), 1);
var import_dist245 = __toESM(require_dist2(), 1);
var import_dist246 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/transports/custom.js
var import_dist262 = __toESM(require_dist(), 1);
var import_dist263 = __toESM(require_dist2(), 1);
var import_dist264 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/transports/createTransport.js
var import_dist259 = __toESM(require_dist(), 1);
var import_dist260 = __toESM(require_dist2(), 1);
var import_dist261 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/buildRequest.js
var import_dist256 = __toESM(require_dist(), 1);
var import_dist257 = __toESM(require_dist2(), 1);
var import_dist258 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/promise/withDedupe.js
var import_dist250 = __toESM(require_dist(), 1);
var import_dist251 = __toESM(require_dist2(), 1);
var import_dist252 = __toESM(require_dist3(), 1);
var promiseCache2 = new LruMap(8192);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/promise/withRetry.js
var import_dist253 = __toESM(require_dist(), 1);
var import_dist254 = __toESM(require_dist2(), 1);
var import_dist255 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/transports/fallback.js
var import_dist265 = __toESM(require_dist(), 1);
var import_dist266 = __toESM(require_dist2(), 1);
var import_dist267 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/transports/http.js
var import_dist280 = __toESM(require_dist(), 1);
var import_dist281 = __toESM(require_dist2(), 1);
var import_dist282 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/transport.js
var import_dist268 = __toESM(require_dist(), 1);
var import_dist269 = __toESM(require_dist2(), 1);
var import_dist270 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/rpc/http.js
var import_dist277 = __toESM(require_dist(), 1);
var import_dist278 = __toESM(require_dist2(), 1);
var import_dist279 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/promise/withTimeout.js
var import_dist271 = __toESM(require_dist(), 1);
var import_dist272 = __toESM(require_dist2(), 1);
var import_dist273 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/rpc/id.js
var import_dist274 = __toESM(require_dist(), 1);
var import_dist275 = __toESM(require_dist2(), 1);
var import_dist276 = __toESM(require_dist3(), 1);
function createIdStore() {
  return {
    current: 0,
    take() {
      return this.current++;
    },
    reset() {
      this.current = 0;
    }
  };
}
var idCache = createIdStore();

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/createPublicClient.js
var import_dist553 = __toESM(require_dist(), 1);
var import_dist554 = __toESM(require_dist2(), 1);
var import_dist555 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/decorators/public.js
var import_dist550 = __toESM(require_dist(), 1);
var import_dist551 = __toESM(require_dist2(), 1);
var import_dist552 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/ens/getEnsAddress.js
var import_dist301 = __toESM(require_dist(), 1);
var import_dist302 = __toESM(require_dist2(), 1);
var import_dist303 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/errors.js
var import_dist283 = __toESM(require_dist(), 1);
var import_dist284 = __toESM(require_dist2(), 1);
var import_dist285 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/namehash.js
var import_dist289 = __toESM(require_dist(), 1);
var import_dist290 = __toESM(require_dist2(), 1);
var import_dist291 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/encodedLabelToLabelhash.js
var import_dist286 = __toESM(require_dist(), 1);
var import_dist287 = __toESM(require_dist2(), 1);
var import_dist288 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/packetToBytes.js
var import_dist298 = __toESM(require_dist(), 1);
var import_dist299 = __toESM(require_dist2(), 1);
var import_dist300 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/encodeLabelhash.js
var import_dist292 = __toESM(require_dist(), 1);
var import_dist293 = __toESM(require_dist2(), 1);
var import_dist294 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/labelhash.js
var import_dist295 = __toESM(require_dist(), 1);
var import_dist296 = __toESM(require_dist2(), 1);
var import_dist297 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/ens/getEnsAvatar.js
var import_dist316 = __toESM(require_dist(), 1);
var import_dist317 = __toESM(require_dist2(), 1);
var import_dist318 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/avatar/parseAvatarRecord.js
var import_dist310 = __toESM(require_dist(), 1);
var import_dist311 = __toESM(require_dist2(), 1);
var import_dist312 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/ens/avatar/utils.js
var import_dist307 = __toESM(require_dist(), 1);
var import_dist308 = __toESM(require_dist2(), 1);
var import_dist309 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/ens.js
var import_dist304 = __toESM(require_dist(), 1);
var import_dist305 = __toESM(require_dist2(), 1);
var import_dist306 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/ens/getEnsText.js
var import_dist313 = __toESM(require_dist(), 1);
var import_dist314 = __toESM(require_dist2(), 1);
var import_dist315 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/ens/getEnsName.js
var import_dist319 = __toESM(require_dist(), 1);
var import_dist320 = __toESM(require_dist2(), 1);
var import_dist321 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/ens/getEnsResolver.js
var import_dist322 = __toESM(require_dist(), 1);
var import_dist323 = __toESM(require_dist2(), 1);
var import_dist324 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/createBlockFilter.js
var import_dist325 = __toESM(require_dist(), 1);
var import_dist326 = __toESM(require_dist2(), 1);
var import_dist327 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/createEventFilter.js
var import_dist328 = __toESM(require_dist(), 1);
var import_dist329 = __toESM(require_dist2(), 1);
var import_dist330 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/createPendingTransactionFilter.js
var import_dist331 = __toESM(require_dist(), 1);
var import_dist332 = __toESM(require_dist2(), 1);
var import_dist333 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlobBaseFee.js
var import_dist334 = __toESM(require_dist(), 1);
var import_dist335 = __toESM(require_dist2(), 1);
var import_dist336 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getBlockTransactionCount.js
var import_dist337 = __toESM(require_dist(), 1);
var import_dist338 = __toESM(require_dist2(), 1);
var import_dist339 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getCode.js
var import_dist340 = __toESM(require_dist(), 1);
var import_dist341 = __toESM(require_dist2(), 1);
var import_dist342 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getFeeHistory.js
var import_dist346 = __toESM(require_dist(), 1);
var import_dist347 = __toESM(require_dist2(), 1);
var import_dist348 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/feeHistory.js
var import_dist343 = __toESM(require_dist(), 1);
var import_dist344 = __toESM(require_dist2(), 1);
var import_dist345 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getFilterLogs.js
var import_dist349 = __toESM(require_dist(), 1);
var import_dist350 = __toESM(require_dist2(), 1);
var import_dist351 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getProof.js
var import_dist496 = __toESM(require_dist(), 1);
var import_dist497 = __toESM(require_dist2(), 1);
var import_dist498 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/proof.js
var import_dist493 = __toESM(require_dist(), 1);
var import_dist494 = __toESM(require_dist2(), 1);
var import_dist495 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/index.js
var import_dist490 = __toESM(require_dist(), 1);
var import_dist491 = __toESM(require_dist2(), 1);
var import_dist492 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/chain/defineChain.js
var import_dist352 = __toESM(require_dist(), 1);
var import_dist353 = __toESM(require_dist2(), 1);
var import_dist354 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/chain/extractChain.js
var import_dist355 = __toESM(require_dist(), 1);
var import_dist356 = __toESM(require_dist2(), 1);
var import_dist357 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/regex.js
var import_dist358 = __toESM(require_dist(), 1);
var import_dist359 = __toESM(require_dist2(), 1);
var import_dist360 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/rpc/compat.js
var import_dist367 = __toESM(require_dist(), 1);
var import_dist368 = __toESM(require_dist2(), 1);
var import_dist369 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/rpc/webSocket.js
var import_dist364 = __toESM(require_dist(), 1);
var import_dist365 = __toESM(require_dist2(), 1);
var import_dist366 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/rpc/socket.js
var import_dist361 = __toESM(require_dist(), 1);
var import_dist362 = __toESM(require_dist2(), 1);
var import_dist363 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/typedData.js
var import_dist376 = __toESM(require_dist(), 1);
var import_dist377 = __toESM(require_dist2(), 1);
var import_dist378 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/typedData.js
var import_dist370 = __toESM(require_dist(), 1);
var import_dist371 = __toESM(require_dist2(), 1);
var import_dist372 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/hashTypedData.js
var import_dist373 = __toESM(require_dist(), 1);
var import_dist374 = __toESM(require_dist2(), 1);
var import_dist375 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/decodeFunctionData.js
var import_dist379 = __toESM(require_dist(), 1);
var import_dist380 = __toESM(require_dist2(), 1);
var import_dist381 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/encodeErrorResult.js
var import_dist382 = __toESM(require_dist(), 1);
var import_dist383 = __toESM(require_dist2(), 1);
var import_dist384 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/encodeFunctionResult.js
var import_dist385 = __toESM(require_dist(), 1);
var import_dist386 = __toESM(require_dist2(), 1);
var import_dist387 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/encodePacked.js
var import_dist388 = __toESM(require_dist(), 1);
var import_dist389 = __toESM(require_dist2(), 1);
var import_dist390 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/address/getContractAddress.js
var import_dist394 = __toESM(require_dist(), 1);
var import_dist395 = __toESM(require_dist2(), 1);
var import_dist396 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/data/isBytes.js
var import_dist391 = __toESM(require_dist(), 1);
var import_dist392 = __toESM(require_dist2(), 1);
var import_dist393 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/formatters/transactionReceipt.js
var import_dist397 = __toESM(require_dist(), 1);
var import_dist398 = __toESM(require_dist2(), 1);
var import_dist399 = __toESM(require_dist3(), 1);
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/encoding/fromRlp.js
var import_dist400 = __toESM(require_dist(), 1);
var import_dist401 = __toESM(require_dist2(), 1);
var import_dist402 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/toEventSignature.js
var import_dist403 = __toESM(require_dist(), 1);
var import_dist404 = __toESM(require_dist2(), 1);
var import_dist405 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/toFunctionSignature.js
var import_dist406 = __toESM(require_dist(), 1);
var import_dist407 = __toESM(require_dist2(), 1);
var import_dist408 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/toEventHash.js
var import_dist409 = __toESM(require_dist(), 1);
var import_dist410 = __toESM(require_dist2(), 1);
var import_dist411 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/toFunctionHash.js
var import_dist412 = __toESM(require_dist(), 1);
var import_dist413 = __toESM(require_dist2(), 1);
var import_dist414 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/isHash.js
var import_dist415 = __toESM(require_dist(), 1);
var import_dist416 = __toESM(require_dist2(), 1);
var import_dist417 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/hash/ripemd160.js
var import_dist418 = __toESM(require_dist(), 1);
var import_dist419 = __toESM(require_dist2(), 1);
var import_dist420 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverMessageAddress.js
var import_dist430 = __toESM(require_dist(), 1);
var import_dist431 = __toESM(require_dist2(), 1);
var import_dist432 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/hashMessage.js
var import_dist427 = __toESM(require_dist(), 1);
var import_dist428 = __toESM(require_dist2(), 1);
var import_dist429 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/toPrefixedMessage.js
var import_dist424 = __toESM(require_dist(), 1);
var import_dist425 = __toESM(require_dist2(), 1);
var import_dist426 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/constants/strings.js
var import_dist421 = __toESM(require_dist(), 1);
var import_dist422 = __toESM(require_dist2(), 1);
var import_dist423 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverTypedDataAddress.js
var import_dist433 = __toESM(require_dist(), 1);
var import_dist434 = __toESM(require_dist2(), 1);
var import_dist435 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/verifyHash.js
var import_dist436 = __toESM(require_dist(), 1);
var import_dist437 = __toESM(require_dist2(), 1);
var import_dist438 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/verifyMessage.js
var import_dist439 = __toESM(require_dist(), 1);
var import_dist440 = __toESM(require_dist2(), 1);
var import_dist441 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/verifyTypedData.js
var import_dist442 = __toESM(require_dist(), 1);
var import_dist443 = __toESM(require_dist2(), 1);
var import_dist444 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/parseErc6492Signature.js
var import_dist451 = __toESM(require_dist(), 1);
var import_dist452 = __toESM(require_dist2(), 1);
var import_dist453 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/isErc6492Signature.js
var import_dist448 = __toESM(require_dist(), 1);
var import_dist449 = __toESM(require_dist2(), 1);
var import_dist450 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/constants/bytes.js
var import_dist445 = __toESM(require_dist(), 1);
var import_dist446 = __toESM(require_dist2(), 1);
var import_dist447 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/serializeErc6492Signature.js
var import_dist454 = __toESM(require_dist(), 1);
var import_dist455 = __toESM(require_dist2(), 1);
var import_dist456 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/getSerializedTransactionType.js
var import_dist457 = __toESM(require_dist(), 1);
var import_dist458 = __toESM(require_dist2(), 1);
var import_dist459 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/assertTransaction.js
var import_dist460 = __toESM(require_dist(), 1);
var import_dist461 = __toESM(require_dist2(), 1);
var import_dist462 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/parseTransaction.js
var import_dist463 = __toESM(require_dist(), 1);
var import_dist464 = __toESM(require_dist2(), 1);
var import_dist465 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/serializeTransaction.js
var import_dist472 = __toESM(require_dist(), 1);
var import_dist473 = __toESM(require_dist2(), 1);
var import_dist474 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/experimental/eip7702/utils/serializeAuthorizationList.js
var import_dist466 = __toESM(require_dist(), 1);
var import_dist467 = __toESM(require_dist2(), 1);
var import_dist468 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/transaction/serializeAccessList.js
var import_dist469 = __toESM(require_dist(), 1);
var import_dist470 = __toESM(require_dist2(), 1);
var import_dist471 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/unit/parseUnits.js
var import_dist478 = __toESM(require_dist(), 1);
var import_dist479 = __toESM(require_dist2(), 1);
var import_dist480 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/errors/unit.js
var import_dist475 = __toESM(require_dist(), 1);
var import_dist476 = __toESM(require_dist2(), 1);
var import_dist477 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/unit/parseEther.js
var import_dist481 = __toESM(require_dist(), 1);
var import_dist482 = __toESM(require_dist2(), 1);
var import_dist483 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/unit/parseGwei.js
var import_dist484 = __toESM(require_dist(), 1);
var import_dist485 = __toESM(require_dist2(), 1);
var import_dist486 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/nonceManager.js
var import_dist487 = __toESM(require_dist(), 1);
var import_dist488 = __toESM(require_dist2(), 1);
var import_dist489 = __toESM(require_dist3(), 1);
function createNonceManager(parameters) {
  const { source } = parameters;
  const deltaMap = /* @__PURE__ */ new Map();
  const nonceMap = new LruMap(8192);
  const promiseMap = /* @__PURE__ */ new Map();
  const getKey = ({ address, chainId }) => `${address}.${chainId}`;
  return {
    async consume({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      const promise = this.get({ address, chainId, client });
      this.increment({ address, chainId });
      const nonce = await promise;
      await source.set({ address, chainId }, nonce);
      nonceMap.set(key, nonce);
      return nonce;
    },
    async increment({ address, chainId }) {
      const key = getKey({ address, chainId });
      const delta = deltaMap.get(key) ?? 0;
      deltaMap.set(key, delta + 1);
    },
    async get({ address, chainId, client }) {
      const key = getKey({ address, chainId });
      let promise = promiseMap.get(key);
      if (!promise) {
        promise = (async () => {
          try {
            const nonce = await source.get({ address, chainId, client });
            const previousNonce = nonceMap.get(key) ?? 0;
            if (previousNonce > 0 && nonce <= previousNonce)
              return previousNonce + 1;
            nonceMap.delete(key);
            return nonce;
          } finally {
            this.reset({ address, chainId });
          }
        })();
        promiseMap.set(key, promise);
      }
      const delta = deltaMap.get(key) ?? 0;
      return delta + await promise;
    },
    reset({ address, chainId }) {
      const key = getKey({ address, chainId });
      deltaMap.delete(key);
      promiseMap.delete(key);
    }
  };
}
function jsonRpc() {
  return {
    async get(parameters) {
      const { address, client } = parameters;
      return getTransactionCount(client, {
        address,
        blockTag: "pending"
      });
    },
    set() {
    }
  };
}
var nonceManager = createNonceManager({
  source: jsonRpc()
});

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getStorageAt.js
var import_dist499 = __toESM(require_dist(), 1);
var import_dist500 = __toESM(require_dist2(), 1);
var import_dist501 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getTransaction.js
var import_dist502 = __toESM(require_dist(), 1);
var import_dist503 = __toESM(require_dist2(), 1);
var import_dist504 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getTransactionConfirmations.js
var import_dist505 = __toESM(require_dist(), 1);
var import_dist506 = __toESM(require_dist2(), 1);
var import_dist507 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/getTransactionReceipt.js
var import_dist508 = __toESM(require_dist(), 1);
var import_dist509 = __toESM(require_dist2(), 1);
var import_dist510 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/multicall.js
var import_dist511 = __toESM(require_dist(), 1);
var import_dist512 = __toESM(require_dist2(), 1);
var import_dist513 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/verifyMessage.js
var import_dist520 = __toESM(require_dist(), 1);
var import_dist521 = __toESM(require_dist2(), 1);
var import_dist522 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/verifyHash.js
var import_dist517 = __toESM(require_dist(), 1);
var import_dist518 = __toESM(require_dist2(), 1);
var import_dist519 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/serializeSignature.js
var import_dist514 = __toESM(require_dist(), 1);
var import_dist515 = __toESM(require_dist2(), 1);
var import_dist516 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/verifyTypedData.js
var import_dist523 = __toESM(require_dist(), 1);
var import_dist524 = __toESM(require_dist2(), 1);
var import_dist525 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/waitForTransactionReceipt.js
var import_dist529 = __toESM(require_dist(), 1);
var import_dist530 = __toESM(require_dist2(), 1);
var import_dist531 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchBlockNumber.js
var import_dist526 = __toESM(require_dist(), 1);
var import_dist527 = __toESM(require_dist2(), 1);
var import_dist528 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchBlocks.js
var import_dist532 = __toESM(require_dist(), 1);
var import_dist533 = __toESM(require_dist2(), 1);
var import_dist534 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchEvent.js
var import_dist535 = __toESM(require_dist(), 1);
var import_dist536 = __toESM(require_dist2(), 1);
var import_dist537 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/public/watchPendingTransactions.js
var import_dist538 = __toESM(require_dist(), 1);
var import_dist539 = __toESM(require_dist2(), 1);
var import_dist540 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/siwe/verifySiweMessage.js
var import_dist547 = __toESM(require_dist(), 1);
var import_dist548 = __toESM(require_dist2(), 1);
var import_dist549 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/siwe/parseSiweMessage.js
var import_dist541 = __toESM(require_dist(), 1);
var import_dist542 = __toESM(require_dist2(), 1);
var import_dist543 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/siwe/validateSiweMessage.js
var import_dist544 = __toESM(require_dist(), 1);
var import_dist545 = __toESM(require_dist2(), 1);
var import_dist546 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/createTestClient.js
var import_dist649 = __toESM(require_dist(), 1);
var import_dist650 = __toESM(require_dist2(), 1);
var import_dist651 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/decorators/test.js
var import_dist646 = __toESM(require_dist(), 1);
var import_dist647 = __toESM(require_dist2(), 1);
var import_dist648 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/dropTransaction.js
var import_dist556 = __toESM(require_dist(), 1);
var import_dist557 = __toESM(require_dist2(), 1);
var import_dist558 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/dumpState.js
var import_dist559 = __toESM(require_dist(), 1);
var import_dist560 = __toESM(require_dist2(), 1);
var import_dist561 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/getAutomine.js
var import_dist562 = __toESM(require_dist(), 1);
var import_dist563 = __toESM(require_dist2(), 1);
var import_dist564 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/getTxpoolContent.js
var import_dist565 = __toESM(require_dist(), 1);
var import_dist566 = __toESM(require_dist2(), 1);
var import_dist567 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/getTxpoolStatus.js
var import_dist568 = __toESM(require_dist(), 1);
var import_dist569 = __toESM(require_dist2(), 1);
var import_dist570 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/impersonateAccount.js
var import_dist571 = __toESM(require_dist(), 1);
var import_dist572 = __toESM(require_dist2(), 1);
var import_dist573 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/increaseTime.js
var import_dist574 = __toESM(require_dist(), 1);
var import_dist575 = __toESM(require_dist2(), 1);
var import_dist576 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/inspectTxpool.js
var import_dist577 = __toESM(require_dist(), 1);
var import_dist578 = __toESM(require_dist2(), 1);
var import_dist579 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/loadState.js
var import_dist580 = __toESM(require_dist(), 1);
var import_dist581 = __toESM(require_dist2(), 1);
var import_dist582 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/mine.js
var import_dist583 = __toESM(require_dist(), 1);
var import_dist584 = __toESM(require_dist2(), 1);
var import_dist585 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/removeBlockTimestampInterval.js
var import_dist586 = __toESM(require_dist(), 1);
var import_dist587 = __toESM(require_dist2(), 1);
var import_dist588 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/reset.js
var import_dist589 = __toESM(require_dist(), 1);
var import_dist590 = __toESM(require_dist2(), 1);
var import_dist591 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/revert.js
var import_dist592 = __toESM(require_dist(), 1);
var import_dist593 = __toESM(require_dist2(), 1);
var import_dist594 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/sendUnsignedTransaction.js
var import_dist595 = __toESM(require_dist(), 1);
var import_dist596 = __toESM(require_dist2(), 1);
var import_dist597 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setAutomine.js
var import_dist598 = __toESM(require_dist(), 1);
var import_dist599 = __toESM(require_dist2(), 1);
var import_dist600 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setBalance.js
var import_dist601 = __toESM(require_dist(), 1);
var import_dist602 = __toESM(require_dist2(), 1);
var import_dist603 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setBlockGasLimit.js
var import_dist604 = __toESM(require_dist(), 1);
var import_dist605 = __toESM(require_dist2(), 1);
var import_dist606 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setBlockTimestampInterval.js
var import_dist607 = __toESM(require_dist(), 1);
var import_dist608 = __toESM(require_dist2(), 1);
var import_dist609 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setCode.js
var import_dist610 = __toESM(require_dist(), 1);
var import_dist611 = __toESM(require_dist2(), 1);
var import_dist612 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setCoinbase.js
var import_dist613 = __toESM(require_dist(), 1);
var import_dist614 = __toESM(require_dist2(), 1);
var import_dist615 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setIntervalMining.js
var import_dist616 = __toESM(require_dist(), 1);
var import_dist617 = __toESM(require_dist2(), 1);
var import_dist618 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setLoggingEnabled.js
var import_dist619 = __toESM(require_dist(), 1);
var import_dist620 = __toESM(require_dist2(), 1);
var import_dist621 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setMinGasPrice.js
var import_dist622 = __toESM(require_dist(), 1);
var import_dist623 = __toESM(require_dist2(), 1);
var import_dist624 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setNextBlockBaseFeePerGas.js
var import_dist625 = __toESM(require_dist(), 1);
var import_dist626 = __toESM(require_dist2(), 1);
var import_dist627 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setNextBlockTimestamp.js
var import_dist628 = __toESM(require_dist(), 1);
var import_dist629 = __toESM(require_dist2(), 1);
var import_dist630 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setNonce.js
var import_dist631 = __toESM(require_dist(), 1);
var import_dist632 = __toESM(require_dist2(), 1);
var import_dist633 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setRpcUrl.js
var import_dist634 = __toESM(require_dist(), 1);
var import_dist635 = __toESM(require_dist2(), 1);
var import_dist636 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/setStorageAt.js
var import_dist637 = __toESM(require_dist(), 1);
var import_dist638 = __toESM(require_dist2(), 1);
var import_dist639 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/snapshot.js
var import_dist640 = __toESM(require_dist(), 1);
var import_dist641 = __toESM(require_dist2(), 1);
var import_dist642 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/test/stopImpersonatingAccount.js
var import_dist643 = __toESM(require_dist(), 1);
var import_dist644 = __toESM(require_dist2(), 1);
var import_dist645 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/decorators/wallet.js
var import_dist682 = __toESM(require_dist(), 1);
var import_dist683 = __toESM(require_dist2(), 1);
var import_dist684 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/deployContract.js
var import_dist652 = __toESM(require_dist(), 1);
var import_dist653 = __toESM(require_dist2(), 1);
var import_dist654 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/getAddresses.js
var import_dist655 = __toESM(require_dist(), 1);
var import_dist656 = __toESM(require_dist2(), 1);
var import_dist657 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/getPermissions.js
var import_dist658 = __toESM(require_dist(), 1);
var import_dist659 = __toESM(require_dist2(), 1);
var import_dist660 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/requestAddresses.js
var import_dist661 = __toESM(require_dist(), 1);
var import_dist662 = __toESM(require_dist2(), 1);
var import_dist663 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/requestPermissions.js
var import_dist664 = __toESM(require_dist(), 1);
var import_dist665 = __toESM(require_dist2(), 1);
var import_dist666 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/signMessage.js
var import_dist667 = __toESM(require_dist(), 1);
var import_dist668 = __toESM(require_dist2(), 1);
var import_dist669 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/signTransaction.js
var import_dist670 = __toESM(require_dist(), 1);
var import_dist671 = __toESM(require_dist2(), 1);
var import_dist672 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/signTypedData.js
var import_dist673 = __toESM(require_dist(), 1);
var import_dist674 = __toESM(require_dist2(), 1);
var import_dist675 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/switchChain.js
var import_dist676 = __toESM(require_dist(), 1);
var import_dist677 = __toESM(require_dist2(), 1);
var import_dist678 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/actions/wallet/watchAsset.js
var import_dist679 = __toESM(require_dist(), 1);
var import_dist680 = __toESM(require_dist2(), 1);
var import_dist681 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/createWalletClient.js
var import_dist685 = __toESM(require_dist(), 1);
var import_dist686 = __toESM(require_dist2(), 1);
var import_dist687 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/clients/transports/webSocket.js
var import_dist688 = __toESM(require_dist(), 1);
var import_dist689 = __toESM(require_dist2(), 1);
var import_dist690 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/constants/address.js
var import_dist691 = __toESM(require_dist(), 1);
var import_dist692 = __toESM(require_dist2(), 1);
var import_dist693 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/types/eip1193.js
var import_dist694 = __toESM(require_dist(), 1);
var import_dist695 = __toESM(require_dist2(), 1);
var import_dist696 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/abi/decodeDeployData.js
var import_dist697 = __toESM(require_dist(), 1);
var import_dist698 = __toESM(require_dist2(), 1);
var import_dist699 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/compactSignatureToSignature.js
var import_dist700 = __toESM(require_dist(), 1);
var import_dist701 = __toESM(require_dist2(), 1);
var import_dist702 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/parseCompactSignature.js
var import_dist703 = __toESM(require_dist(), 1);
var import_dist704 = __toESM(require_dist2(), 1);
var import_dist705 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/parseSignature.js
var import_dist706 = __toESM(require_dist(), 1);
var import_dist707 = __toESM(require_dist2(), 1);
var import_dist708 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/recoverTransactionAddress.js
var import_dist709 = __toESM(require_dist(), 1);
var import_dist710 = __toESM(require_dist2(), 1);
var import_dist711 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/signatureToCompactSignature.js
var import_dist712 = __toESM(require_dist(), 1);
var import_dist713 = __toESM(require_dist2(), 1);
var import_dist714 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/signature/serializeCompactSignature.js
var import_dist715 = __toESM(require_dist(), 1);
var import_dist716 = __toESM(require_dist2(), 1);
var import_dist717 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/sidecarsToVersionedHashes.js
var import_dist718 = __toESM(require_dist(), 1);
var import_dist719 = __toESM(require_dist2(), 1);
var import_dist720 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/blob/fromBlobs.js
var import_dist721 = __toESM(require_dist(), 1);
var import_dist722 = __toESM(require_dist2(), 1);
var import_dist723 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/kzg/defineKzg.js
var import_dist724 = __toESM(require_dist(), 1);
var import_dist725 = __toESM(require_dist2(), 1);
var import_dist726 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/node_modules/viem/_esm/utils/kzg/setupKzg.js
var import_dist727 = __toESM(require_dist(), 1);
var import_dist728 = __toESM(require_dist2(), 1);
var import_dist729 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index9.js
var x;
var F2 = (async () => {
  x = class extends A {
    constructor(t12, e17, s15, i18) {
      if (super(), this.minAmt = 1e3, !e17.signTypedData) throw new Error("Signer must have signTypedData method");
      this.jsonRPCSigner = e17, this.evmNetwork = s15, this.nonce = i18 || 0, this.provider = t12, this.network = t12.getNetwork() === e.Mainnet ? import_bitcoinjs_lib6.networks.bitcoin : t12.getNetwork() === e.Testnet ? import_bitcoinjs_lib6.networks.testnet : import_bitcoinjs_lib6.networks.regtest;
    }
    async getSigner() {
      return this.signer || (this.signer = await this.getBitcoinSigner()), this.signer;
    }
    getProvider() {
      return Promise.resolve(this.provider);
    }
    async getAddress() {
      const t12 = await this.getSigner(), e17 = import_bitcoinjs_lib6.payments.p2wpkh({ pubkey: t12.publicKey, network: this.network }).address;
      if (!e17) throw new Error("failed to generate address");
      return e17;
    }
    async getBalance() {
      const t12 = await this.getAddress();
      return this.provider.getBalance(t12);
    }
    async sign(t12) {
      return t12 = R(t12), (await this.getSigner()).sign(Buffer.from(t12, "hex")).toString("hex");
    }
    async signSchnorr(t12) {
      return (await this.getSigner()).signSchnorr(t12);
    }
    async getPublicKey() {
      return (await this.getSigner()).publicKey.toString("hex");
    }
    getNetwork() {
      return Promise.resolve(this.network);
    }
    walletConfig() {
      return { network: this.provider.getNetwork(), path: "" };
    }
    async getBitcoinSigner() {
      const t12 = { Data: [{ name: "Message", type: "string" }, { name: "Version", type: "string" }, { name: "Nonce", type: "uint256" }] }, e17 = { Message: "Initialize your swap", Version: "1.1.0", Nonce: this.nonce }, s15 = { name: "CATALOG x WBTC GARDEN", version: "1", chainId: this.evmNetwork }, i18 = await this.jsonRPCSigner.signTypedData({ domain: s15, types: t12, message: e17, primaryType: "Data" }), c10 = await import("./lib-J5YNBWJR.js").then(async (o13) => (await o13.__tla, o13));
      return (0, import_ecpair.ECPairFactory)(c10).fromPrivateKey(Buffer.from(sha2562(i18).slice(2), "hex"), { network: this.network });
    }
    async send(t12, e17, s15) {
      const i18 = await this.getSigner();
      if (s15 || (s15 = await this.provider.suggestFee(await this.getAddress(), e17, s.FAST)), s15 > e17) throw new Error(t.FEE_EXCEEDS_AMOUNT(s15, e17));
      if (e17 < this.minAmt) throw new Error(t.MIN_AMOUNT(this.minAmt));
      const c10 = await this.getAddress(), o13 = await this.provider.getUTXOs(c10, e17 + s15), w13 = o13.reduce((r13, g15) => r13 + g15.value, 0), n13 = new import_bitcoinjs_lib6.Psbt({ network: this.network });
      for (const r13 of o13) {
        const g15 = await this.provider.getTransactionHex(r13.txid);
        n13.addInput({ hash: n3(r13.txid), index: r13.vout, nonWitnessUtxo: Buffer.from(g15, "hex") });
      }
      const a24 = w13 - e17 - s15;
      return n13.addOutput({ address: t12, value: e17 }), a24 > 0 && n13.addOutput({ address: c10, value: a24 }), n13.signAllInputs(i18).finalizeAllInputs(), this.provider.broadcast(n13.extractTransaction().toHex());
    }
    async spend(t12, e17, { toAddress: s15, fee: i18, nSequence: c10, unlockScript: o13, witness: w13 }) {
      var S8;
      const n13 = this.getScriptType(e17, this.network), a24 = await this.provider.getBalance(e17);
      if (a24 === 0) throw new Error(t.SCRIPT_NOT_FUNDED);
      let r13 = new import_bitcoinjs_lib6.Transaction();
      if (r13.version = 2, i18 ?? (i18 = await this.provider.suggestFee(e17, a24, s.FAST)), i18 > a24) throw new Error(t.FEE_EXCEEDS_AMOUNT(i18, a24));
      const g15 = await this.provider.getUTXOs(e17);
      r13 = await this.addAllInputs(r13, e17, this.provider, { nSequence: c10, utxos: g15 }), r13.addOutput(await this.toOutputScript(s15 ?? await this.getAddress()), a24 - i18);
      for (let h11 = 0; h11 < r13.ins.length; h11++) if (n13 === p2.P2SH) {
        if (!o13) throw new Error("Unlock script is required for p2sh");
        const p20 = [];
        for (const d20 of o13) if (d20 instanceof i3) {
          const f17 = d20.sigHashType, N10 = r13.hashForSignature(h11, t12, f17);
          p20.push(import_bitcoinjs_lib6.script.signature.encode(Buffer.from(await this.sign(N10.toString("hex")), "hex"), f17));
        } else p20.push(d20);
        const u22 = (S8 = import_bitcoinjs_lib6.payments.p2sh({ redeem: { input: import_bitcoinjs_lib6.script.compile(p20), output: t12 }, network: this.network }).redeem) == null ? void 0 : S8.input;
        r13.setInputScript(h11, u22);
      } else if (n13 === p2.P2WSH) {
        if (!w13) throw new Error("Witness is required for p2wsh");
        const p20 = [];
        for (const u22 of w13) if (u22 instanceof i3) {
          const d20 = u22.sigHashType, f17 = r13.hashForWitnessV0(h11, t12, g15[h11].value, d20);
          p20.push(import_bitcoinjs_lib6.script.signature.encode(Buffer.from(await this.sign(f17.toString("hex")), "hex"), d20));
        } else p20.push(u22);
        r13.setWitness(h11, p20);
      } else throw new Error("Invalid script type " + n13);
      return this.provider.broadcast(r13.toHex());
    }
  };
})();

// node_modules/@catalogfi/wallets/dist/index11.js
var import_dist739 = __toESM(require_dist(), 1);
var import_dist740 = __toESM(require_dist2(), 1);
var import_dist741 = __toESM(require_dist3(), 1);
var import_ecpair2 = __toESM(require_src6(), 1);
var import_bitcoinjs_lib7 = __toESM(require_src5(), 1);

// node_modules/@catalogfi/wallets/dist/index14.js
var import_dist736 = __toESM(require_dist(), 1);
var import_dist737 = __toESM(require_dist2(), 1);
var import_dist738 = __toESM(require_dist3(), 1);
var p4 = { p2pkh: "p2pkh", p2wpkh: "p2wpkh", "p2wpkh-p2sh": "p2wpkh-p2sh" };

// node_modules/@catalogfi/wallets/dist/index11.js
var k2 = class _k extends A {
  constructor({ privateKey: t12, provider: e17, pkPath: r13, pkType: s15 }) {
    const n13 = (0, import_ecpair2.ECPairFactory)(lib_exports), a24 = o(e17.getNetwork()), o13 = Buffer.from(t12, "hex");
    if (o13.length === 0) throw new Error("invalid private key");
    super(), this.minAmt = 1e3, this.path = r13 || "", this.pkType = s15, this.signer = n13.fromPrivateKey(o13, { network: a24 }), this.provider = e17, this.network = a24;
  }
  static fromMnemonic(t12, e17, r13) {
    const s15 = a3.bip84(e17.getNetwork(), r13 == null ? void 0 : r13.index), n13 = d2(t12, e17.getNetwork(), { path: s15 });
    return new _k({ privateKey: n13, provider: e17, pkType: p4.p2wpkh, pkPath: s15 });
  }
  static fromPrivateKey(t12, e17, r13) {
    return new _k({ privateKey: t12, provider: e17, pkType: (r13 == null ? void 0 : r13.pkType) ?? p4.p2wpkh, pkPath: (r13 == null ? void 0 : r13.pkPath) ?? "unknown" });
  }
  static createRandom(t12) {
    const e17 = (0, import_ecpair2.ECPairFactory)(lib_exports), r13 = o(t12.getNetwork()), s15 = e17.makeRandom({ network: r13 });
    if (!s15.privateKey) throw new Error("Failed to create random key");
    return new _k({ privateKey: s15.privateKey.toString("hex"), provider: t12, pkType: p4.p2wpkh, pkPath: "unknown" });
  }
  static fromWIF(t12, e17, r13) {
    const s15 = (0, import_ecpair2.ECPairFactory)(lib_exports), n13 = o(e17.getNetwork()), a24 = s15.fromWIF(t12, n13);
    if (!a24.privateKey) throw new Error("Invalid WIF");
    return _k.fromPrivateKey(a24.privateKey.toString("hex"), e17, r13);
  }
  walletConfig() {
    return { network: this.provider.getNetwork(), path: this.path, addressType: this.pkType };
  }
  async spend(t12, e17, { toAddress: r13, fee: s15, nSequence: n13, unlockScript: a24, witness: o13 }) {
    var y13;
    const w13 = this.getScriptType(e17, this.network), h11 = await this.provider.getBalance(e17);
    if (h11 === 0) throw new Error(t.SCRIPT_NOT_FUNDED);
    let i18 = new import_bitcoinjs_lib7.Transaction();
    if (i18.version = 2, s15 ?? (s15 = await this.provider.suggestFee(e17, h11, s.FAST)), s15 > h11) throw new Error(t.FEE_EXCEEDS_AMOUNT(s15, h11));
    const c10 = await this.provider.getUTXOs(e17);
    i18 = await this.addAllInputs(i18, e17, this.provider, { nSequence: n13, utxos: c10 }), i18.addOutput(await this.toOutputScript(r13 ?? await this.getAddress()), h11 - s15);
    for (let p20 = 0; p20 < i18.ins.length; p20++) if (w13 === p2.P2SH) {
      if (!a24) throw new Error("Unlock script is required for p2sh");
      const d20 = [];
      for (const u22 of a24) if (u22 instanceof i3) {
        const l23 = u22.sigHashType, b10 = i18.hashForSignature(p20, t12, l23);
        d20.push(import_bitcoinjs_lib7.script.signature.encode(Buffer.from(await this.sign(b10.toString("hex")), "hex"), l23));
      } else d20.push(u22);
      const m17 = (y13 = import_bitcoinjs_lib7.payments.p2sh({ redeem: { input: import_bitcoinjs_lib7.script.compile(d20), output: t12 }, network: this.network }).redeem) == null ? void 0 : y13.input;
      i18.setInputScript(p20, m17);
    } else if (w13 === p2.P2WSH) {
      if (!o13) throw new Error("Witness is required for p2wsh");
      const d20 = [];
      for (const m17 of o13) if (m17 instanceof i3) {
        const u22 = m17.sigHashType, l23 = i18.hashForWitnessV0(p20, t12, c10[p20].value, u22);
        d20.push(import_bitcoinjs_lib7.script.signature.encode(Buffer.from(await this.sign(l23.toString("hex")), "hex"), u22));
      } else d20.push(m17);
      i18.setWitness(p20, d20);
    } else throw new Error("Invalid script type " + w13);
    return this.provider.broadcast(i18.toHex());
  }
  async getAddress() {
    if (this.pkType === p4["p2wpkh-p2sh"]) {
      const { address: e17 } = import_bitcoinjs_lib7.payments.p2sh({ redeem: import_bitcoinjs_lib7.payments.p2wpkh({ pubkey: this.signer.publicKey, network: this.network }), network: this.network });
      if (!e17) throw new Error("failed to get the p2wpkh-p2sh address");
      return e17;
    }
    const { address: t12 } = import_bitcoinjs_lib7.payments[this.pkType]({ pubkey: this.signer.publicKey, network: this.network });
    if (!t12) throw new Error("failed to get the p2wpkh address");
    return t12;
  }
  getProvider() {
    return Promise.resolve(this.provider);
  }
  async getBalance() {
    return this.provider.getBalance(await this.getAddress());
  }
  async getPublicKey() {
    return this.signer.publicKey.toString("hex");
  }
  getNetwork() {
    return Promise.resolve(this.network);
  }
  async _send(t12, e17, r13) {
    var h11;
    if (r13 || (r13 = await this.provider.suggestFee(await this.getAddress(), e17, s.FAST)), r13 > e17) throw new Error(t.FEE_EXCEEDS_AMOUNT(r13, e17));
    if (e17 < this.minAmt) throw new Error(t.MIN_AMOUNT(this.minAmt));
    const s15 = await this.getAddress(), n13 = await this.provider.getUTXOs(s15, e17 + r13), a24 = n13.reduce((i18, c10) => i18 + c10.value, 0), o13 = new import_bitcoinjs_lib7.Psbt({ network: this.network });
    for (const i18 of n13) {
      const c10 = await this.provider.getTransactionHex(i18.txid), y13 = await this.provider.getTransaction(i18.txid);
      let p20;
      this.pkType === p4["p2wpkh-p2sh"] && (p20 = { witnessUtxo: { script: Buffer.from(y13.vout[i18.vout].scriptpubkey, "hex"), value: i18.value }, redeemScript: (h11 = import_bitcoinjs_lib7.payments.p2sh({ redeem: import_bitcoinjs_lib7.payments.p2wpkh({ pubkey: this.signer.publicKey, network: this.network }), network: this.network }).redeem) == null ? void 0 : h11.output }), o13.addInput({ hash: n3(i18.txid), index: i18.vout, nonWitnessUtxo: Buffer.from(c10, "hex"), ...p20 });
    }
    const w13 = a24 - e17 - r13;
    return o13.addOutput({ address: t12, value: e17 }), w13 > 0 && o13.addOutput({ address: s15, value: w13 }), o13.signAllInputs(this.signer).finalizeAllInputs(), o13.extractTransaction().toHex();
  }
  async send(t12, e17, r13) {
    const s15 = await this._send(t12, e17, r13);
    return this.provider.broadcast(s15);
  }
  async sign(t12) {
    return t12 = t12.startsWith("0x") ? t12.slice(2) : t12, this.signer.sign(Buffer.from(t12, "hex")).toString("hex");
  }
  async signSchnorr(t12) {
    return this.signer.signSchnorr(t12);
  }
};

// node_modules/@catalogfi/wallets/dist/index.js
var import_bitcoinjs_lib10 = __toESM(require_src5());

// node_modules/@catalogfi/wallets/dist/index13.js
var import_dist775 = __toESM(require_dist(), 1);
var import_dist776 = __toESM(require_dist2(), 1);
var import_dist777 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index29.js
var import_dist742 = __toESM(require_dist(), 1);
var import_dist743 = __toESM(require_dist2(), 1);
var import_dist744 = __toESM(require_dist3(), 1);
var i4 = (s15, e17, t12) => {
  if (!e17.has(s15)) throw TypeError("Cannot " + t12);
};
var o3 = (s15, e17, t12) => (i4(s15, e17, "read from private field"), t12 ? t12.call(s15) : e17.get(s15));
var n6 = (s15, e17, t12) => {
  if (e17.has(s15)) throw TypeError("Cannot add the same private member more than once");
  e17 instanceof WeakSet ? e17.add(s15) : e17.set(s15, t12);
};
var a7 = (s15, e17, t12, l23) => (i4(s15, e17, "write to private field"), l23 ? l23.call(s15, t12) : e17.set(s15, t12), t12);
var r4;
var u5 = class {
  constructor() {
    n6(this, r4, void 0);
    a7(this, r4, /* @__PURE__ */ new Map());
  }
  get(e17) {
    return Promise.resolve(o3(this, r4).get(e17) || null);
  }
  set(e17, t12) {
    return o3(this, r4).set(e17, t12), Promise.resolve();
  }
};
r4 = /* @__PURE__ */ new WeakMap();

// node_modules/@catalogfi/wallets/dist/index23.js
var import_dist745 = __toESM(require_dist(), 1);
var import_dist746 = __toESM(require_dist2(), 1);
var import_dist747 = __toESM(require_dist3(), 1);
var import_bip322 = __toESM(require_src3(), 1);
var y2 = __toESM(require_src(), 1);
var import_bitcoinjs_lib8 = __toESM(require_src5(), 1);
var S = { p2pk: a3.bip44, p2pkh: a3.bip44, "p2wpkh-p2sh": a3.bip49, p2wpkh: a3.bip84 };
function b(t12) {
  return { [e.Mainnet]: import_bitcoinjs_lib8.networks.bitcoin, [e.Testnet]: import_bitcoinjs_lib8.networks.testnet, [e.Regtest]: import_bitcoinjs_lib8.networks.regtest }[t12];
}
function w(t12, e17, o13, s15, r13) {
  var m17;
  const a24 = b(r13.getNetwork()), i18 = S[t12], p20 = i18(r13.getNetwork(), e17, o13), n13 = s15.derivePath(p20);
  let c10;
  return t12.split("-").length > 1 ? c10 = import_bitcoinjs_lib8.payments.p2sh({ network: a24, redeem: import_bitcoinjs_lib8.payments.p2wpkh({ network: a24, pubkey: n13.publicKey }) }).address : c10 = import_bitcoinjs_lib8.payments[t12]({ network: a24, pubkey: n13.publicKey }).address, { address: c10, privateKey: ((m17 = n13.privateKey) == null ? void 0 : m17.toString("hex")) || "", type: t12, path: p20 };
}
function x2(t12, e17, o13, s15, r13) {
  const a24 = [];
  for (let i18 = e17; i18 < o13; i18++) for (const p20 of Object.values(p4)) {
    const { address: n13, type: c10, path: m17, privateKey: v8 } = w(p20, i18, t12, s15, r13), N10 = new Promise((K7, P6) => {
      r13.getTransactions(n13, n.ALL).then((d20) => K7({ address: n13, path: m17, type: c10, privateKey: v8, transactions: d20 })).catch((d20) => P6(d20));
    });
    a24.push(N10);
  }
  return a24;
}
var h = (t12, e17) => {
  if (!y2.validateMnemonic(t12)) throw new Error("Invalid mnemonic");
  const o13 = y2.mnemonicToSeedSync(t12);
  return (0, import_bip322.BIP32Factory)(lib_exports).fromSeed(o13, b(e17));
};
var I = (t12, e17, o13 = 0) => {
  const s15 = h(t12, e17.getNetwork());
  return Object.values(p4).map((r13) => w(r13, 0, o13, s15, e17));
};
var M = (t12, e17, o13, s15 = 0) => {
  const r13 = h(t12, e17.getNetwork());
  return w(o13, 0, s15, r13, e17);
};
var O2 = async (t12, e17) => {
  const o13 = h(t12, e17.getNetwork()), s15 = 20;
  let r13 = [];
  for (let a24 = 0; ; a24++) {
    const i18 = [];
    let p20 = 0;
    for (let n13 = 0; p20 <= s15; n13 += s15) {
      const c10 = await Promise.all(x2(a24, n13, n13 + s15, o13, e17));
      for (const m17 of c10) m17.transactions.length === 0 ? p20++ : (i18.push(m17), p20 > 0 && (p20 = 0));
    }
    if (i18.length === 0) break;
    r13.push(...i18);
  }
  return r13;
};

// node_modules/@catalogfi/wallets/dist/index13.js
var import_bitcoinjs_lib9 = __toESM(require_src5(), 1);

// node_modules/@catalogfi/wallets/dist/index30.js
var import_dist760 = __toESM(require_dist(), 1);
var import_dist761 = __toESM(require_dist2(), 1);
var import_dist762 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index63.js
var import_dist757 = __toESM(require_dist(), 1);
var import_dist758 = __toESM(require_dist2(), 1);
var import_dist759 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index37.js
var import_dist748 = __toESM(require_dist(), 1);
var import_dist749 = __toESM(require_dist2(), 1);
var import_dist750 = __toESM(require_dist3(), 1);
function e3(t12) {
  if (!Number.isSafeInteger(t12) || t12 < 0) throw new Error(`positive integer expected, not ${t12}`);
}
function o4(t12) {
  return t12 instanceof Uint8Array || t12 != null && typeof t12 == "object" && t12.constructor.name === "Uint8Array";
}
function s4(t12, ...n13) {
  if (!o4(t12)) throw new Error("Uint8Array expected");
  if (n13.length > 0 && !n13.includes(t12.length)) throw new Error(`Uint8Array expected of length ${n13}, not of length=${t12.length}`);
}
function i5(t12) {
  if (typeof t12 != "function" || typeof t12.create != "function") throw new Error("Hash should be wrapped by utils.wrapConstructor");
  e3(t12.outputLen), e3(t12.blockLen);
}
function a8(t12, n13 = true) {
  if (t12.destroyed) throw new Error("Hash instance has been destroyed");
  if (n13 && t12.finished) throw new Error("Hash#digest() has already been called");
}
function f3(t12, n13) {
  s4(t12);
  const r13 = n13.outputLen;
  if (t12.length < r13) throw new Error(`digestInto() expects output buffer of length at least ${r13}`);
}

// node_modules/@catalogfi/wallets/dist/index38.js
var import_dist754 = __toESM(require_dist(), 1);
var import_dist755 = __toESM(require_dist2(), 1);
var import_dist756 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index65.js
var import_dist751 = __toESM(require_dist(), 1);
var import_dist752 = __toESM(require_dist2(), 1);
var import_dist753 = __toESM(require_dist3(), 1);
var o5 = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@catalogfi/wallets/dist/index38.js
var p5 = (e17) => new Uint32Array(e17.buffer, e17.byteOffset, Math.floor(e17.byteLength / 4));
var w2 = (e17) => new DataView(e17.buffer, e17.byteOffset, e17.byteLength);
var _3 = (e17, n13) => e17 << 32 - n13 | e17 >>> n13;
var b2 = (e17, n13) => e17 << n13 | e17 >>> 32 - n13 >>> 0;
var x3 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var y3 = (e17) => e17 << 24 & 4278190080 | e17 << 8 & 16711680 | e17 >>> 8 & 65280 | e17 >>> 24 & 255;
function A2(e17) {
  for (let n13 = 0; n13 < e17.length; n13++) e17[n13] = y3(e17[n13]);
}
var m4 = Array.from({ length: 256 }, (e17, n13) => n13.toString(16).padStart(2, "0"));
function E4(e17) {
  s4(e17);
  let n13 = "";
  for (let r13 = 0; r13 < e17.length; r13++) n13 += m4[e17[r13]];
  return n13;
}
var a9 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function h2(e17) {
  if (e17 >= a9._0 && e17 <= a9._9) return e17 - a9._0;
  if (e17 >= a9._A && e17 <= a9._F) return e17 - (a9._A - 10);
  if (e17 >= a9._a && e17 <= a9._f) return e17 - (a9._a - 10);
}
function L(e17) {
  if (typeof e17 != "string") throw new Error("hex string expected, got " + typeof e17);
  const n13 = e17.length, r13 = n13 / 2;
  if (n13 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + n13);
  const t12 = new Uint8Array(r13);
  for (let o13 = 0, s15 = 0; o13 < r13; o13++, s15 += 2) {
    const c10 = h2(e17.charCodeAt(s15)), u22 = h2(e17.charCodeAt(s15 + 1));
    if (c10 === void 0 || u22 === void 0) {
      const l23 = e17[s15] + e17[s15 + 1];
      throw new Error('hex string expected, got non-hex character "' + l23 + '" at index ' + s15);
    }
    t12[o13] = c10 * 16 + u22;
  }
  return t12;
}
function g2(e17) {
  if (typeof e17 != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e17}`);
  return new Uint8Array(new TextEncoder().encode(e17));
}
function d4(e17) {
  return typeof e17 == "string" && (e17 = g2(e17)), s4(e17), e17;
}
function U(...e17) {
  let n13 = 0;
  for (let t12 = 0; t12 < e17.length; t12++) {
    const o13 = e17[t12];
    s4(o13), n13 += o13.length;
  }
  const r13 = new Uint8Array(n13);
  for (let t12 = 0, o13 = 0; t12 < e17.length; t12++) {
    const s15 = e17[t12];
    r13.set(s15, o13), o13 += s15.length;
  }
  return r13;
}
var B = class {
  clone() {
    return this._cloneInto();
  }
};
function T4(e17) {
  const n13 = (t12) => e17().update(d4(t12)).digest(), r13 = e17();
  return n13.outputLen = r13.outputLen, n13.blockLen = r13.blockLen, n13.create = () => e17(), n13;
}
function V(e17 = 32) {
  if (o5 && typeof o5.getRandomValues == "function") return o5.getRandomValues(new Uint8Array(e17));
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@catalogfi/wallets/dist/index63.js
function L2(h11, s15, t12, i18) {
  if (typeof h11.setBigUint64 == "function") return h11.setBigUint64(s15, t12, i18);
  const n13 = BigInt(32), o13 = BigInt(4294967295), e17 = Number(t12 >> n13 & o13), r13 = Number(t12 & o13), u22 = i18 ? 4 : 0, c10 = i18 ? 0 : 4;
  h11.setUint32(s15 + u22, e17, i18), h11.setUint32(s15 + c10, r13, i18);
}
var w3 = (h11, s15, t12) => h11 & s15 ^ ~h11 & t12;
var y4 = (h11, s15, t12) => h11 & s15 ^ h11 & t12 ^ s15 & t12;
var m5 = class extends B {
  constructor(s15, t12, i18, n13) {
    super(), this.blockLen = s15, this.outputLen = t12, this.padOffset = i18, this.isLE = n13, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(s15), this.view = w2(this.buffer);
  }
  update(s15) {
    a8(this);
    const { view: t12, buffer: i18, blockLen: n13 } = this;
    s15 = d4(s15);
    const o13 = s15.length;
    for (let e17 = 0; e17 < o13; ) {
      const r13 = Math.min(n13 - this.pos, o13 - e17);
      if (r13 === n13) {
        const u22 = w2(s15);
        for (; n13 <= o13 - e17; e17 += n13) this.process(u22, e17);
        continue;
      }
      i18.set(s15.subarray(e17, e17 + r13), this.pos), this.pos += r13, e17 += r13, this.pos === n13 && (this.process(t12, 0), this.pos = 0);
    }
    return this.length += s15.length, this.roundClean(), this;
  }
  digestInto(s15) {
    a8(this), f3(s15, this), this.finished = true;
    const { buffer: t12, view: i18, blockLen: n13, isLE: o13 } = this;
    let { pos: e17 } = this;
    t12[e17++] = 128, this.buffer.subarray(e17).fill(0), this.padOffset > n13 - e17 && (this.process(i18, 0), e17 = 0);
    for (let f17 = e17; f17 < n13; f17++) t12[f17] = 0;
    L2(i18, n13 - 8, BigInt(this.length * 8), o13), this.process(i18, 0);
    const r13 = w2(s15), u22 = this.outputLen;
    if (u22 % 4) throw new Error("_sha2: outputLen should be aligned to 32bit");
    const c10 = u22 / 4, p20 = this.get();
    if (c10 > p20.length) throw new Error("_sha2: outputLen bigger than state");
    for (let f17 = 0; f17 < c10; f17++) r13.setUint32(4 * f17, p20[f17], o13);
  }
  digest() {
    const { buffer: s15, outputLen: t12 } = this;
    this.digestInto(s15);
    const i18 = s15.slice(0, t12);
    return this.destroy(), i18;
  }
  _cloneInto(s15) {
    s15 || (s15 = new this.constructor()), s15.set(...this.get());
    const { blockLen: t12, buffer: i18, length: n13, finished: o13, destroyed: e17, pos: r13 } = this;
    return s15.length = n13, s15.pos = r13, s15.finished = o13, s15.destroyed = e17, n13 % t12 && s15.buffer.set(i18), s15;
  }
};

// node_modules/@catalogfi/wallets/dist/index30.js
var B2 = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var b3 = new Uint8Array(new Array(16).fill(0).map((h11, t12) => t12));
var F4 = b3.map((h11) => (9 * h11 + 5) % 16);
var U2 = [b3];
var d5 = [F4];
for (let h11 = 0; h11 < 4; h11++) for (let t12 of [U2, d5]) t12.push(t12[h11].map((s15) => B2[s15]));
var g3 = [[11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8], [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7], [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9], [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6], [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]].map((h11) => new Uint8Array(h11));
var G = U2.map((h11, t12) => h11.map((s15) => g3[t12][s15]));
var J = d5.map((h11, t12) => h11.map((s15) => g3[t12][s15]));
var K = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var L3 = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
function x4(h11, t12, s15, i18) {
  return h11 === 0 ? t12 ^ s15 ^ i18 : h11 === 1 ? t12 & s15 | ~t12 & i18 : h11 === 2 ? (t12 | ~s15) ^ i18 : h11 === 3 ? t12 & i18 | s15 & ~i18 : t12 ^ (s15 | ~i18);
}
var y5 = new Uint32Array(16);
var C = class extends m5 {
  constructor() {
    super(64, 20, 8, true), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776;
  }
  get() {
    const { h0: t12, h1: s15, h2: i18, h3: e17, h4: n13 } = this;
    return [t12, s15, i18, e17, n13];
  }
  set(t12, s15, i18, e17, n13) {
    this.h0 = t12 | 0, this.h1 = s15 | 0, this.h2 = i18 | 0, this.h3 = e17 | 0, this.h4 = n13 | 0;
  }
  process(t12, s15) {
    for (let r13 = 0; r13 < 16; r13++, s15 += 4) y5[r13] = t12.getUint32(s15, true);
    let i18 = this.h0 | 0, e17 = i18, n13 = this.h1 | 0, f17 = n13, a24 = this.h2 | 0, c10 = a24, l23 = this.h3 | 0, m17 = l23, p20 = this.h4 | 0, u22 = p20;
    for (let r13 = 0; r13 < 5; r13++) {
      const D7 = 4 - r13, M8 = K[r13], E14 = L3[r13], H7 = U2[r13], I10 = d5[r13], P6 = G[r13], R5 = J[r13];
      for (let o13 = 0; o13 < 16; o13++) {
        const A13 = b2(i18 + x4(r13, n13, a24, l23) + y5[H7[o13]] + M8, P6[o13]) + p20 | 0;
        i18 = p20, p20 = l23, l23 = b2(a24, 10) | 0, a24 = n13, n13 = A13;
      }
      for (let o13 = 0; o13 < 16; o13++) {
        const A13 = b2(e17 + x4(D7, f17, c10, m17) + y5[I10[o13]] + E14, R5[o13]) + u22 | 0;
        e17 = u22, u22 = m17, m17 = b2(c10, 10) | 0, c10 = f17, f17 = A13;
      }
    }
    this.set(this.h1 + a24 + m17 | 0, this.h2 + l23 + u22 | 0, this.h3 + p20 + e17 | 0, this.h4 + i18 + f17 | 0, this.h0 + n13 + c10 | 0);
  }
  roundClean() {
    y5.fill(0);
  }
  destroy() {
    this.destroyed = true, this.buffer.fill(0), this.set(0, 0, 0, 0, 0);
  }
};
var _4 = T4(() => new C());

// node_modules/@catalogfi/wallets/dist/index31.js
var import_dist763 = __toESM(require_dist(), 1);
var import_dist764 = __toESM(require_dist2(), 1);
var import_dist765 = __toESM(require_dist3(), 1);
var B3 = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var a10 = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var c3 = new Uint32Array(64);
var E5 = class extends m5 {
  constructor() {
    super(64, 32, 8, false), this.A = a10[0] | 0, this.B = a10[1] | 0, this.C = a10[2] | 0, this.D = a10[3] | 0, this.E = a10[4] | 0, this.F = a10[5] | 0, this.G = a10[6] | 0, this.H = a10[7] | 0;
  }
  get() {
    const { A: C7, B: f17, C: s15, D: h11, E: r13, F: o13, G: i18, H: e17 } = this;
    return [C7, f17, s15, h11, r13, o13, i18, e17];
  }
  set(C7, f17, s15, h11, r13, o13, i18, e17) {
    this.A = C7 | 0, this.B = f17 | 0, this.C = s15 | 0, this.D = h11 | 0, this.E = r13 | 0, this.F = o13 | 0, this.G = i18 | 0, this.H = e17 | 0;
  }
  process(C7, f17) {
    for (let t12 = 0; t12 < 16; t12++, f17 += 4) c3[t12] = C7.getUint32(f17, false);
    for (let t12 = 16; t12 < 64; t12++) {
      const p20 = c3[t12 - 15], A13 = c3[t12 - 2], u22 = _3(p20, 7) ^ _3(p20, 18) ^ p20 >>> 3, D7 = _3(A13, 17) ^ _3(A13, 19) ^ A13 >>> 10;
      c3[t12] = D7 + c3[t12 - 7] + u22 + c3[t12 - 16] | 0;
    }
    let { A: s15, B: h11, C: r13, D: o13, E: i18, F: e17, G: l23, H: H7 } = this;
    for (let t12 = 0; t12 < 64; t12++) {
      const p20 = _3(i18, 6) ^ _3(i18, 11) ^ _3(i18, 25), A13 = H7 + p20 + w3(i18, e17, l23) + B3[t12] + c3[t12] | 0, u22 = (_3(s15, 2) ^ _3(s15, 13) ^ _3(s15, 22)) + y4(s15, h11, r13) | 0;
      H7 = l23, l23 = e17, e17 = i18, i18 = o13 + A13 | 0, o13 = r13, r13 = h11, h11 = s15, s15 = A13 + u22 | 0;
    }
    s15 = s15 + this.A | 0, h11 = h11 + this.B | 0, r13 = r13 + this.C | 0, o13 = o13 + this.D | 0, i18 = i18 + this.E | 0, e17 = e17 + this.F | 0, l23 = l23 + this.G | 0, H7 = H7 + this.H | 0, this.set(s15, h11, r13, o13, i18, e17, l23, H7);
  }
  roundClean() {
    c3.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var F5 = T4(() => new E5());

// node_modules/@catalogfi/wallets/dist/index32.js
var import_dist769 = __toESM(require_dist(), 1);
var import_dist770 = __toESM(require_dist2(), 1);
var import_dist771 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index33.js
var import_dist766 = __toESM(require_dist(), 1);
var import_dist767 = __toESM(require_dist2(), 1);
var import_dist768 = __toESM(require_dist3(), 1);
var e4 = class {
  static getAccountNumber(r13) {
    const t12 = r13.split("/");
    if (t12.length < 6) throw new Error("Invalid path");
    return parseInt(t12[3]);
  }
};

// node_modules/@catalogfi/wallets/dist/index32.js
var e5 = class e6 {
  constructor(t12, s15) {
    this.store = t12, this.network = s15, this.store = t12, this.network = s15;
  }
  async getMnemonic() {
    return await this.store.get(e6.storeKeys.mnemonic);
  }
  static getMnemonic(t12) {
    return t12.get(e6.storeKeys.mnemonic);
  }
  static async getAccounts(t12, s15 = 0, n13) {
    return await new e6(t12, n13).getAccounts(s15);
  }
  async getAccounts(t12 = 0) {
    const s15 = JSON.parse(await this.store.get(e6.storeKeys.paths + t12.toString() + this.network) || "[]");
    return s15.length === 0 ? new Error("No accounts found in store with account number " + t12) : s15;
  }
  async save(t12, s15) {
    var a24;
    await this.store.set(e6.storeKeys.mnemonic, t12);
    const n13 = /* @__PURE__ */ new Map();
    for (const o13 of s15) {
      const r13 = e4.getAccountNumber(o13.path);
      n13.has(r13) ? (a24 = n13.get(r13)) == null || a24.push(o13) : n13.set(r13, [o13]);
    }
    for (const [o13, r13] of n13) await this.store.set(e6.storeKeys.paths + o13.toString() + this.network, JSON.stringify(r13));
  }
  static async save(t12, s15, n13, a24) {
    return await new e6(n13, a24).save(t12, s15);
  }
};
e5.storeKeys = { paths: "wallet_paths", mnemonic: "mnemonic" };
var c4 = e5;

// node_modules/@catalogfi/wallets/dist/index34.js
var import_dist772 = __toESM(require_dist(), 1);
var import_dist773 = __toESM(require_dist2(), 1);
var import_dist774 = __toESM(require_dist3(), 1);
var s5 = class s6 {
};
s5.MissingMnemonic = "Missing mnemonic";
var i6 = s5;

// node_modules/@catalogfi/wallets/dist/index13.js
var U3 = (h11, t12, e17) => {
  if (!t12.has(h11)) throw TypeError("Cannot " + e17);
};
var p6 = (h11, t12, e17) => (U3(h11, t12, "read from private field"), e17 ? e17.call(h11) : t12.get(h11));
var k3 = (h11, t12, e17) => {
  if (t12.has(h11)) throw TypeError("Cannot add the same private member more than once");
  t12 instanceof WeakSet ? t12.add(h11) : t12.set(h11, e17);
};
var v2 = (h11, t12, e17, r13) => (U3(h11, t12, "write to private field"), r13 ? r13.call(h11, e17) : t12.set(h11, e17), e17);
var w4;
var f4;
var A3;
var g4;
var l4 = class l5 {
  constructor(t12, e17, r13) {
    k3(this, w4, void 0);
    k3(this, f4, void 0);
    k3(this, A3, void 0);
    k3(this, g4, void 0);
    v2(this, w4, t12), v2(this, f4, e17), v2(this, A3, r13), v2(this, g4, new c4(r13, e17.getNetwork()));
  }
  async getAccounts() {
    const t12 = [];
    let e17 = -1;
    const r13 = _(await p6(this, g4).getMnemonic(), i6.MissingMnemonic), s15 = h(r13, p6(this, f4).getNetwork());
    for (; ++e17 >= 0; ) {
      const a24 = await p6(this, g4).getAccounts(e17);
      if (a24 instanceof Error) break;
      for (const o13 of a24) {
        const i18 = s15.derivePath(o13.path).privateKey;
        if (!i18) throw new Error("Unable to generate private key");
        const n13 = k2.fromPrivateKey(i18.toString("hex"), p6(this, f4), { pkType: o13.addressType, pkPath: o13.path });
        t12.push({ ...o13, accountNumber: e4.getAccountNumber(o13.path), address: await n13.getAddress() });
      }
    }
    return t12;
  }
  async getMnemonic() {
    return _(await p6(this, g4).getMnemonic(), i6.MissingMnemonic);
  }
  get provider() {
    return p6(this, f4);
  }
  wallets() {
    return Array.from(p6(this, w4).values());
  }
  walletByAddress(t12) {
    const e17 = p6(this, w4).get(t12);
    if (!e17) throw new Error("Wallet not found");
    return e17;
  }
  walletByType(t12) {
    for (const e17 of p6(this, w4).values()) if (e17.walletConfig().addressType === t12) return e17;
  }
  getNetwork() {
    return z(p6(this, f4).getNetwork());
  }
  async getAddresses() {
    const t12 = p6(this, w4).keys(), e17 = [];
    for (const r13 of t12) {
      const s15 = p6(this, w4).get(r13);
      if (!s15) throw new Error("Wallet not found");
      const a24 = s15.walletConfig().addressType;
      e17.push({ address: r13, type: a24 });
    }
    return e17;
  }
  async getBalance() {
    let t12 = 0;
    for (const e17 of this.wallets()) t12 += await e17.getBalance();
    return t12;
  }
  async nextAccount(t12) {
    if (t12 ?? (t12 = e4.getAccountNumber(this.wallets()[0].walletConfig().path) + 1), !(await p6(this, g4).getAccounts(t12) instanceof Error)) return this.nextAccount(t12 + 1);
    const e17 = I(await this.getMnemonic(), p6(this, f4), t12), r13 = e17.map((a24) => ({ ...a24, transactions: [] })), s15 = B4(r13, p6(this, f4));
    return await p6(this, g4).save(await this.getMnemonic(), e17.map((a24) => ({ path: a24.path, addressType: a24.type }))), new l5(s15, p6(this, f4), p6(this, A3));
  }
  static async createRandom(t12, e17) {
    const r13 = p(), s15 = new u5(), a24 = I(r13, t12), o13 = a24.map((n13) => ({ ...n13, transactions: [] })), i18 = B4(o13, t12);
    return await c4.save(r13, a24.map((n13) => ({ path: n13.path, addressType: n13.type })), s15, t12.getNetwork()), new l5(i18, t12, s15);
  }
  static async fromDisk(t12, e17, r13 = 0) {
    const s15 = _(await c4.getMnemonic(e17), i6.MissingMnemonic), a24 = await c4.getAccounts(e17, r13, t12.getNetwork());
    if (a24 instanceof Error) {
      const i18 = I(s15, t12, r13), n13 = B4(i18, t12);
      return await c4.save(s15, i18.map((c10) => ({ path: c10.path, addressType: c10.type })), e17, t12.getNetwork()), new l5(n13, t12, e17);
    }
    const o13 = /* @__PURE__ */ new Map();
    for (const i18 of a24) {
      const n13 = h(s15, t12.getNetwork()).derivePath(i18.path).privateKey;
      if (!n13) throw new Error("Unable to generate private key");
      const c10 = k2.fromPrivateKey(n13.toString("hex"), t12, { pkType: i18.addressType, pkPath: i18.path });
      o13.set(await c10.getAddress(), c10);
    }
    return new l5(o13, t12, e17);
  }
  static async fromMnemonic(t12, e17, r13) {
    if (await c4.getMnemonic(r13) && e17.getNetwork() === e.Mainnet) throw new Error("Wallet already exists in store");
    const s15 = await O2(t12, e17);
    if (s15.length === 0) {
      const n13 = I(t12, e17);
      s15.push(...n13.map((c10) => ({ ...c10 })));
    }
    const a24 = s15.map((n13) => n13.type);
    for (const n13 of Object.values(p4)) if (!a24.includes(n13)) {
      const c10 = M(t12, e17, n13);
      s15.push({ ...c10 });
    }
    const o13 = [];
    for (const n13 of s15) {
      const c10 = e4.getAccountNumber(n13.path), u22 = s15.filter((d20) => e4.getAccountNumber(d20.path) === c10).map((d20) => d20.type);
      if (u22.length !== Object.values(p4).length) {
        for (const d20 of Object.values(p4)) if (!u22.includes(d20)) {
          const E14 = M(t12, e17, d20, c10);
          o13.push(E14);
        }
      }
    }
    s15.push(...o13);
    const i18 = B4(s15, e17);
    return await c4.save(t12, s15.map((n13) => ({ path: n13.path, addressType: n13.type })), r13, e17.getNetwork()), new l5(i18, e17, r13);
  }
  static async fromPrivateKeys(t12, e17) {
    const r13 = /* @__PURE__ */ new Map();
    for (const s15 of t12) for (const a24 of Object.values(p4)) {
      const o13 = k2.fromPrivateKey(s15, e17, { pkType: a24 });
      r13.set(await o13.getAddress(), o13);
    }
    return new l5(r13, e17, new u5());
  }
  async sanityChecksBeforeSend(t12) {
    if (await this.getBalance() < t12) throw new Error("Insufficient balance");
  }
  async getUTXOs(t12, e17) {
    try {
      return await this.provider.getUTXOs(t12, e17);
    } catch {
      return await this.getUTXOs(t12, 0);
    }
  }
  async getPayouts(t12, e17) {
    const r13 = await this.getAddresses();
    let s15 = t12;
    const a24 = [];
    for (const i18 of r13) {
      const n13 = this.walletByAddress(i18.address), c10 = await this.getUTXOs(i18.address, s15);
      if (c10.length === 0) continue;
      const u22 = c10.reduce((d20, E14) => d20 + E14.value, 0);
      if (s15 > u22) {
        a24.push({ address: i18.address, amt: u22, fee: 0, change: 0 }), s15 -= u22;
        continue;
      } else if (e17 ?? (e17 = await n13.suggestFee(s15, s.FAST)), e17 + s15 > u22) {
        a24.push({ address: i18.address, amt: s15, fee: u22 - s15, change: 0 }), s15 -= u22;
        continue;
      } else {
        a24.push({ address: i18.address, amt: s15 > 0 ? s15 : 0, fee: s15 > 0 ? e17 : e17 + s15, change: u22 - s15 - e17 });
        break;
      }
    }
    const o13 = a24.reduce((i18, n13) => i18 + n13.amt + n13.fee, 0);
    if (o13 !== t12 + e17) throw new Error("Amounts do not match: Expected " + (t12 + e17) + " but got " + o13);
    return a24;
  }
  async addPayoutsToTx(t12, e17, r13) {
    const s15 = [];
    for (const o13 of e17) {
      const i18 = await this.provider.getUTXOs(o13.address, o13.amt + o13.fee + o13.change);
      for (const n13 of i18) t12.addInput(n3(n13.txid), n13.vout), s15.push({ address: o13.address, val: n13.value });
    }
    const a24 = e17.reduce((o13, i18) => o13 + i18.amt, 0);
    t12.addOutput(import_bitcoinjs_lib9.address.toOutputScript(r13, this.getNetwork()), a24);
    for (const o13 of e17) o13.change > 0 && t12.addOutput(import_bitcoinjs_lib9.address.toOutputScript(o13.address, this.getNetwork()), o13.change);
    return s15;
  }
  async handleP2wpkh(t12, e17, r13, s15) {
    const a24 = Buffer.from(await e17.getPublicKey(), "hex"), o13 = import_bitcoinjs_lib9.Transaction.SIGHASH_ALL, i18 = import_bitcoinjs_lib9.payments.p2pkh({ pubkey: a24, network: await e17.getNetwork() }), n13 = t12.hashForWitnessV0(r13, i18.output, s15, o13), c10 = await e17.sign(n13.toString("hex")), u22 = [import_bitcoinjs_lib9.script.signature.encode(Buffer.from(c10, "hex"), o13), a24];
    return t12.setWitness(r13, u22), t12;
  }
  async handleP2pkh(t12, e17, r13) {
    var u22;
    const s15 = Buffer.from(await e17.getPublicKey(), "hex"), a24 = import_bitcoinjs_lib9.payments.p2pkh({ pubkey: s15, network: this.getNetwork() }), o13 = import_bitcoinjs_lib9.Transaction.SIGHASH_ALL, i18 = t12.hashForSignature(r13, a24.output, o13), n13 = await e17.sign(i18.toString("hex")), c10 = (u22 = import_bitcoinjs_lib9.payments.p2pkh({ pubkey: s15, redeem: { input: import_bitcoinjs_lib9.script.compile([import_bitcoinjs_lib9.script.signature.encode(Buffer.from(n13, "hex"), o13), s15]), output: a24.output }, network: this.getNetwork() }).redeem) == null ? void 0 : u22.input;
    if (!c10) throw new Error("Redeem script not found");
    return t12.setInputScript(r13, c10), t12;
  }
  async handleP2wpkhP2sh(t12, e17, r13, s15) {
    const a24 = Buffer.from(await e17.getPublicKey(), "hex"), o13 = import_bitcoinjs_lib9.payments.p2pkh({ network: await e17.getNetwork(), pubkey: a24 }), i18 = `160014${q(a24).toString("hex")}`, n13 = import_bitcoinjs_lib9.Transaction.SIGHASH_ALL, c10 = t12.hashForWitnessV0(r13, o13.output, s15, n13), u22 = await e17.sign(c10.toString("hex")), d20 = [import_bitcoinjs_lib9.script.signature.encode(Buffer.from(u22, "hex"), n13), a24];
    t12.setInputScript(r13, Buffer.from(i18, "hex")), t12.setWitness(r13, d20);
  }
  async send(t12, e17, r13) {
    await this.sanityChecksBeforeSend(e17);
    const s15 = await this.getPayouts(e17, r13);
    let a24 = $();
    const o13 = await this.addPayoutsToTx(a24, s15, t12);
    for (let i18 = 0; i18 < o13.length; i18++) {
      const n13 = o13[i18], c10 = this.walletByAddress(n13.address);
      switch (c10.walletConfig().addressType) {
        case p4.p2pkh:
          a24 = await this.handleP2pkh(a24, c10, i18);
          break;
        case p4.p2wpkh:
          a24 = await this.handleP2wpkh(a24, c10, i18, n13.val);
          break;
        case p4["p2wpkh-p2sh"]:
          await this.handleP2wpkhP2sh(a24, c10, i18, n13.val);
          break;
      }
    }
    return await this.provider.broadcast(a24.toHex());
  }
};
w4 = /* @__PURE__ */ new WeakMap(), f4 = /* @__PURE__ */ new WeakMap(), A3 = /* @__PURE__ */ new WeakMap(), g4 = /* @__PURE__ */ new WeakMap();
var I2 = l4;
function $() {
  const h11 = new import_bitcoinjs_lib9.Transaction();
  return h11.version = 2, h11;
}
function q(h11) {
  return Buffer.from(_4(F5(Uint8Array.from(h11))));
}
function z(h11) {
  switch (h11) {
    case e.Mainnet:
      return import_bitcoinjs_lib9.networks.bitcoin;
    case e.Testnet:
      return import_bitcoinjs_lib9.networks.testnet;
    case e.Regtest:
      return import_bitcoinjs_lib9.networks.regtest;
    default:
      throw new Error("Invalid network");
  }
}
function B4(h11, t12) {
  const e17 = /* @__PURE__ */ new Map();
  for (const r13 of h11) {
    const s15 = k2.fromPrivateKey(r13.privateKey, t12, { pkType: r13.type, pkPath: r13.path });
    e17.set(r13.address, s15);
  }
  return e17;
}

// node_modules/@catalogfi/wallets/dist/index15.js
var import_dist787 = __toESM(require_dist(), 1);
var import_dist788 = __toESM(require_dist2(), 1);
var import_dist789 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index16.js
var import_dist778 = __toESM(require_dist(), 1);
var import_dist779 = __toESM(require_dist2(), 1);
var import_dist780 = __toESM(require_dist3(), 1);
var i7 = { INVALID_SECRET_HASH: "invalid secret hash", INSUFFICIENT_TOKENS: "insufficient token balance", ORDER_INITIATED: "your order has been initiated already", INVALID_SECRET: "invalid secret", ORDER_NOT_EXPIRED: "you cannot refund before your transaction expires", INSUFFICIENT_FUNDS: (e17, n13) => "you have insufficient funds. You have: " + e17 + " ETH, you need: " + n13 };

// node_modules/@catalogfi/wallets/dist/index25.js
var import_dist781 = __toESM(require_dist(), 1);
var import_dist782 = __toESM(require_dist2(), 1);
var import_dist783 = __toESM(require_dist3(), 1);
var e7 = [{ inputs: [{ internalType: "address", name: "token_", type: "address" }, { internalType: "string", name: "name", type: "string" }, { internalType: "string", name: "version", type: "string" }], stateMutability: "nonpayable", type: "constructor" }, { inputs: [], name: "InvalidShortString", type: "error" }, { inputs: [{ internalType: "string", name: "str", type: "string" }], name: "StringTooLong", type: "error" }, { anonymous: false, inputs: [], name: "EIP712DomainChanged", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "orderID", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "secretHash", type: "bytes32" }, { indexed: false, internalType: "uint256", name: "amount", type: "uint256" }], name: "Initiated", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "orderID", type: "bytes32" }, { indexed: true, internalType: "bytes32", name: "secretHash", type: "bytes32" }, { indexed: false, internalType: "bytes", name: "secret", type: "bytes" }], name: "Redeemed", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "bytes32", name: "orderID", type: "bytes32" }], name: "Refunded", type: "event" }, { inputs: [], name: "eip712Domain", outputs: [{ internalType: "bytes1", name: "fields", type: "bytes1" }, { internalType: "string", name: "name", type: "string" }, { internalType: "string", name: "version", type: "string" }, { internalType: "uint256", name: "chainId", type: "uint256" }, { internalType: "address", name: "verifyingContract", type: "address" }, { internalType: "bytes32", name: "salt", type: "bytes32" }, { internalType: "uint256[]", name: "extensions", type: "uint256[]" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "redeemer", type: "address" }, { internalType: "uint256", name: "timelock", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes32", name: "secretHash", type: "bytes32" }], name: "initiate", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "redeemer", type: "address" }, { internalType: "uint256", name: "timelock", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes32", name: "secretHash", type: "bytes32" }, { internalType: "bytes", name: "signature", type: "bytes" }], name: "initiateWithSignature", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "orderID", type: "bytes32" }, { internalType: "bytes", name: "signature", type: "bytes" }], name: "instantRefund", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ components: [{ internalType: "address", name: "redeemer", type: "address" }, { internalType: "uint256", name: "expiry", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }, { internalType: "bytes32", name: "secretHash", type: "bytes32" }, { internalType: "bytes", name: "signature", type: "bytes" }], internalType: "struct HTLC.InitWithSig[]", name: "inits", type: "tuple[]" }, { components: [{ internalType: "bytes32", name: "orderID", type: "bytes32" }, { internalType: "bytes", name: "secret", type: "bytes" }], internalType: "struct HTLC.Redeem[]", name: "redeems", type: "tuple[]" }, { components: [{ internalType: "bytes32", name: "orderID", type: "bytes32" }], internalType: "struct HTLC.Refund[]", name: "refunds", type: "tuple[]" }], name: "multicall", outputs: [{ internalType: "bool[]", name: "results", type: "bool[]" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }], name: "orders", outputs: [{ internalType: "bool", name: "isFulfilled", type: "bool" }, { internalType: "address", name: "initiator", type: "address" }, { internalType: "address", name: "redeemer", type: "address" }, { internalType: "uint256", name: "initiatedAt", type: "uint256" }, { internalType: "uint256", name: "timelock", type: "uint256" }, { internalType: "uint256", name: "amount", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "bytes32", name: "orderID", type: "bytes32" }, { internalType: "bytes", name: "secret", type: "bytes" }], name: "redeem", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "bytes32", name: "orderID", type: "bytes32" }], name: "refund", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "token", outputs: [{ internalType: "contract IERC20", name: "", type: "address" }], stateMutability: "view", type: "function" }];

// node_modules/@catalogfi/wallets/dist/index26.js
var import_dist784 = __toESM(require_dist(), 1);
var import_dist785 = __toESM(require_dist2(), 1);
var import_dist786 = __toESM(require_dist3(), 1);
var e8 = [{ inputs: [], stateMutability: "nonpayable", type: "constructor" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "owner", type: "address" }, { indexed: true, internalType: "address", name: "spender", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Approval", type: "event" }, { anonymous: false, inputs: [{ indexed: true, internalType: "address", name: "from", type: "address" }, { indexed: true, internalType: "address", name: "to", type: "address" }, { indexed: false, internalType: "uint256", name: "value", type: "uint256" }], name: "Transfer", type: "event" }, { inputs: [{ internalType: "address", name: "owner", type: "address" }, { internalType: "address", name: "spender", type: "address" }], name: "allowance", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "approve", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "account", type: "address" }], name: "balanceOf", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [], name: "decimals", outputs: [{ internalType: "uint8", name: "", type: "uint8" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "subtractedValue", type: "uint256" }], name: "decreaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "spender", type: "address" }, { internalType: "uint256", name: "addedValue", type: "uint256" }], name: "increaseAllowance", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "mint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "name", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }], name: "selfMint", outputs: [], stateMutability: "nonpayable", type: "function" }, { inputs: [], name: "symbol", outputs: [{ internalType: "string", name: "", type: "string" }], stateMutability: "view", type: "function" }, { inputs: [], name: "totalSupply", outputs: [{ internalType: "uint256", name: "", type: "uint256" }], stateMutability: "view", type: "function" }, { inputs: [{ internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transfer", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }, { inputs: [{ internalType: "address", name: "from", type: "address" }, { internalType: "address", name: "to", type: "address" }, { internalType: "uint256", name: "amount", type: "uint256" }], name: "transferFrom", outputs: [{ internalType: "bool", name: "", type: "bool" }], stateMutability: "nonpayable", type: "function" }];

// node_modules/@catalogfi/wallets/dist/index15.js
var C2 = class {
  newSwap(t12) {
    return Promise.resolve(new n7(t12, this));
  }
  chain() {
    return a.EVM;
  }
};
var n7 = class {
  constructor(t12, a24) {
    if (this.swap = { ...t12, contractAddress: t12.contractAddress }, this.swap.secretHash = E(this.swap.secretHash), this.swap.secretHash.length !== 66) throw new Error(i7.INVALID_SECRET_HASH);
    this.wallet = a24;
  }
  async getHTLCContract() {
    return getContract({ address: this.swap.contractAddress, abi: e7, client: { public: this.wallet.getPublicClient(), wallet: this.wallet.getSigner(), signer: this.wallet.getSigner() } });
  }
  async getERC20Contract() {
    const t12 = await (await this.getHTLCContract()).read.token();
    return getContract({ address: t12, abi: e8, client: this.wallet.getSigner() });
  }
  id() {
    return this.swap.contractAddress;
  }
  async init() {
    let t12 = this.wallet.getSigner().account;
    if (!t12) throw new Error("Account not found");
    const a24 = await this.wallet.getAddress(), e17 = await this.getERC20Contract();
    return await e17.read.allowance([a24, this.swap.contractAddress]) < this.swap.amount && await e17.write.approve([this.swap.contractAddress, maxUint256], { account: t12, chain: this.wallet.getSigner().chain }), (await this.getHTLCContract()).write.initiate([this.swap.recipientAddress.unwrap_evm(), BigInt(this.swap.expiryBlocks), this.swap.amount, this.swap.secretHash], { account: t12, chain: this.wallet.getSigner().chain });
  }
  async redeem(t12) {
    t12 = E(t12);
    let a24 = this.wallet.getSigner().account;
    if (!a24) throw new Error("Account not found");
    let e17 = sha2562(t12);
    const o13 = this.swap.initiatorAddress, w13 = this.getOrderId(e17, o13.unwrap_evm());
    return (await this.getHTLCContract()).write.redeem([w13, t12], { account: a24, chain: void 0 });
  }
  getOrderId(t12, a24) {
    return sha2562(encodeAbiParameters(parseAbiParameters(["bytes32", "address"]), [t12, a24]));
  }
  async refund() {
    const t12 = this.swap.initiatorAddress, a24 = this.getOrderId(E(this.swap.secretHash), t12.unwrap_evm());
    return (await this.getHTLCContract()).write.refund([a24], { account: t12.unwrap_evm(), chain: void 0 });
  }
};

// node_modules/@catalogfi/wallets/dist/index17.js
var import_dist790 = __toESM(require_dist(), 1);
var import_dist791 = __toESM(require_dist2(), 1);
var import_dist792 = __toESM(require_dist3(), 1);
var r5 = class extends C2 {
  constructor(t12, s15) {
    if (!t12.account) throw new Error("Signer must have an account");
    super(), this.publicClient = s15, this.account = t12.account, this.signer = t12;
  }
  sign(t12) {
    return this.signer.signMessage({ account: this.account, message: t12 });
  }
  getPublicClient() {
    return this.publicClient;
  }
  async contractCall(t12) {
    return await this.signer.sendTransaction({ account: this.account, to: t12.to, data: t12.data, from: t12.from || this.account.address, value: t12.value || BigInt(0), chain: this.signer.chain });
  }
  getAddress() {
    return Promise.resolve(this.account.address);
  }
  async rpc(t12, s15) {
    return this.publicClient.request({ method: t12, params: s15 });
  }
  async signTypedData(t12, s15, e17, a24) {
    return this.signer.signTypedData({ primaryType: a24, account: this.account, domain: t12, types: s15, message: e17 });
  }
  getSigner() {
    return this.signer;
  }
};

// node_modules/@catalogfi/wallets/dist/index18.js
var import_dist1030 = __toESM(require_dist(), 1);
var import_dist1031 = __toESM(require_dist2(), 1);
var import_dist1032 = __toESM(require_dist3(), 1);
var w12 = __toESM(require_src(), 1);

// node_modules/@catalogfi/wallets/dist/index27.js
var import_dist823 = __toESM(require_dist(), 1);
var import_dist824 = __toESM(require_dist2(), 1);
var import_dist825 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index35.js
var import_dist793 = __toESM(require_dist(), 1);
var import_dist794 = __toESM(require_dist2(), 1);
var import_dist795 = __toESM(require_dist3(), 1);
var n8 = class extends B {
  constructor(s15, i18) {
    super(), this.finished = false, this.destroyed = false, i5(s15);
    const h11 = d4(i18);
    if (this.iHash = s15.create(), typeof this.iHash.update != "function") throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const a24 = this.blockLen, t12 = new Uint8Array(a24);
    t12.set(h11.length > a24 ? s15.create().update(h11).digest() : h11);
    for (let e17 = 0; e17 < t12.length; e17++) t12[e17] ^= 54;
    this.iHash.update(t12), this.oHash = s15.create();
    for (let e17 = 0; e17 < t12.length; e17++) t12[e17] ^= 106;
    this.oHash.update(t12), t12.fill(0);
  }
  update(s15) {
    return a8(this), this.iHash.update(s15), this;
  }
  digestInto(s15) {
    a8(this), s4(s15, this.outputLen), this.finished = true, this.iHash.digestInto(s15), this.oHash.update(s15), this.oHash.digestInto(s15), this.destroy();
  }
  digest() {
    const s15 = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(s15), s15;
  }
  _cloneInto(s15) {
    s15 || (s15 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: i18, iHash: h11, finished: a24, destroyed: t12, blockLen: e17, outputLen: c10 } = this;
    return s15 = s15, s15.finished = a24, s15.destroyed = t12, s15.blockLen = e17, s15.outputLen = c10, s15.oHash = i18._cloneInto(s15.oHash), s15.iHash = h11._cloneInto(s15.iHash), s15;
  }
  destroy() {
    this.destroyed = true, this.oHash.destroy(), this.iHash.destroy();
  }
};
var d6 = (o13, s15, i18) => new n8(o13, s15).update(i18).digest();
d6.create = (o13, s15) => new n8(o13, s15);

// node_modules/@catalogfi/wallets/dist/index36.js
var import_dist799 = __toESM(require_dist(), 1);
var import_dist800 = __toESM(require_dist2(), 1);
var import_dist801 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index64.js
var import_dist796 = __toESM(require_dist(), 1);
var import_dist797 = __toESM(require_dist2(), 1);
var import_dist798 = __toESM(require_dist3(), 1);
var d7 = BigInt(4294967295);
var H = BigInt(32);
function L4(r13, a24 = false) {
  return a24 ? { h: Number(r13 & d7), l: Number(r13 >> H & d7) } : { h: Number(r13 >> H & d7) | 0, l: Number(r13 & d7) | 0 };
}
function e9(r13, a24 = false) {
  let t12 = new Uint32Array(r13.length), o13 = new Uint32Array(r13.length);
  for (let s15 = 0; s15 < r13.length; s15++) {
    const { h: l23, l: M8 } = L4(r13[s15], a24);
    [t12[s15], o13[s15]] = [l23, M8];
  }
  return [t12, o13];
}
var n9 = (r13, a24) => BigInt(r13 >>> 0) << H | BigInt(a24 >>> 0);
var B5 = (r13, a24, t12) => r13 >>> t12;
var i8 = (r13, a24, t12) => r13 << 32 - t12 | a24 >>> t12;
var S2 = (r13, a24, t12) => r13 >>> t12 | a24 << 32 - t12;
var g5 = (r13, a24, t12) => r13 << 32 - t12 | a24 >>> t12;
var h3 = (r13, a24, t12) => r13 << 64 - t12 | a24 >>> t12 - 32;
var u6 = (r13, a24, t12) => r13 >>> t12 - 32 | a24 << 64 - t12;
var c5 = (r13, a24) => a24;
var f5 = (r13, a24) => r13;
var m6 = (r13, a24, t12) => r13 << t12 | a24 >>> 32 - t12;
var b4 = (r13, a24, t12) => a24 << t12 | r13 >>> 32 - t12;
var I3 = (r13, a24, t12) => a24 << t12 - 32 | r13 >>> 64 - t12;
var N3 = (r13, a24, t12) => r13 << t12 - 32 | a24 >>> 64 - t12;
function p7(r13, a24, t12, o13) {
  const s15 = (a24 >>> 0) + (o13 >>> 0);
  return { h: r13 + t12 + (s15 / 2 ** 32 | 0) | 0, l: s15 | 0 };
}
var w5 = (r13, a24, t12) => (r13 >>> 0) + (a24 >>> 0) + (t12 >>> 0);
var y6 = (r13, a24, t12, o13) => a24 + t12 + o13 + (r13 / 2 ** 32 | 0) | 0;
var A4 = (r13, a24, t12, o13) => (r13 >>> 0) + (a24 >>> 0) + (t12 >>> 0) + (o13 >>> 0);
var U4 = (r13, a24, t12, o13, s15) => a24 + t12 + o13 + s15 + (r13 / 2 ** 32 | 0) | 0;
var x6 = (r13, a24, t12, o13, s15) => (r13 >>> 0) + (a24 >>> 0) + (t12 >>> 0) + (o13 >>> 0) + (s15 >>> 0);
var K3 = (r13, a24, t12, o13, s15, l23) => a24 + t12 + o13 + s15 + l23 + (r13 / 2 ** 32 | 0) | 0;
var _5 = { fromBig: L4, split: e9, toBig: n9, shrSH: B5, shrSL: i8, rotrSH: S2, rotrSL: g5, rotrBH: h3, rotrBL: u6, rotr32H: c5, rotr32L: f5, rotlSH: m6, rotlSL: b4, rotlBH: I3, rotlBL: N3, add: p7, add3L: w5, add3H: y6, add4L: A4, add4H: U4, add5H: K3, add5L: x6 };

// node_modules/@catalogfi/wallets/dist/index36.js
var [M3, N4] = _5.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map((I10) => BigInt(I10)));
var C3 = new Uint32Array(80);
var p8 = new Uint32Array(80);
var _6 = class extends m5 {
  constructor() {
    super(128, 64, 16, false), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  get() {
    const { Ah: G6, Al: F11, Bh: t12, Bl: c10, Ch: b10, Cl: f17, Dh: s15, Dl: x15, Eh: H7, El: n13, Fh: e17, Fl: d20, Gh: r13, Gl: i18, Hh: l23, Hl: o13 } = this;
    return [G6, F11, t12, c10, b10, f17, s15, x15, H7, n13, e17, d20, r13, i18, l23, o13];
  }
  set(G6, F11, t12, c10, b10, f17, s15, x15, H7, n13, e17, d20, r13, i18, l23, o13) {
    this.Ah = G6 | 0, this.Al = F11 | 0, this.Bh = t12 | 0, this.Bl = c10 | 0, this.Ch = b10 | 0, this.Cl = f17 | 0, this.Dh = s15 | 0, this.Dl = x15 | 0, this.Eh = H7 | 0, this.El = n13 | 0, this.Fh = e17 | 0, this.Fl = d20 | 0, this.Gh = r13 | 0, this.Gl = i18 | 0, this.Hh = l23 | 0, this.Hl = o13 | 0;
  }
  process(G6, F11) {
    for (let h11 = 0; h11 < 16; h11++, F11 += 4) C3[h11] = G6.getUint32(F11), p8[h11] = G6.getUint32(F11 += 4);
    for (let h11 = 16; h11 < 80; h11++) {
      const L12 = C3[h11 - 15] | 0, A13 = p8[h11 - 15] | 0, g15 = _5.rotrSH(L12, A13, 1) ^ _5.rotrSH(L12, A13, 8) ^ _5.shrSH(L12, A13, 7), U6 = _5.rotrSL(L12, A13, 1) ^ _5.rotrSL(L12, A13, 8) ^ _5.shrSL(L12, A13, 7), B12 = C3[h11 - 2] | 0, S8 = p8[h11 - 2] | 0, m17 = _5.rotrSH(B12, S8, 19) ^ _5.rotrBH(B12, S8, 61) ^ _5.shrSH(B12, S8, 6), w13 = _5.rotrSL(B12, S8, 19) ^ _5.rotrBL(B12, S8, 61) ^ _5.shrSL(B12, S8, 6), u22 = _5.add4L(U6, w13, p8[h11 - 7], p8[h11 - 16]), y13 = _5.add4H(u22, g15, m17, C3[h11 - 7], C3[h11 - 16]);
      C3[h11] = y13 | 0, p8[h11] = u22 | 0;
    }
    let { Ah: t12, Al: c10, Bh: b10, Bl: f17, Ch: s15, Cl: x15, Dh: H7, Dl: n13, Eh: e17, El: d20, Fh: r13, Fl: i18, Gh: l23, Gl: o13, Hh: D7, Hl: E14 } = this;
    for (let h11 = 0; h11 < 80; h11++) {
      const L12 = _5.rotrSH(e17, d20, 14) ^ _5.rotrSH(e17, d20, 18) ^ _5.rotrBH(e17, d20, 41), A13 = _5.rotrSL(e17, d20, 14) ^ _5.rotrSL(e17, d20, 18) ^ _5.rotrBL(e17, d20, 41), g15 = e17 & r13 ^ ~e17 & l23, U6 = d20 & i18 ^ ~d20 & o13, B12 = _5.add5L(E14, A13, U6, N4[h11], p8[h11]), S8 = _5.add5H(B12, D7, L12, g15, M3[h11], C3[h11]), m17 = B12 | 0, w13 = _5.rotrSH(t12, c10, 28) ^ _5.rotrBH(t12, c10, 34) ^ _5.rotrBH(t12, c10, 39), u22 = _5.rotrSL(t12, c10, 28) ^ _5.rotrBL(t12, c10, 34) ^ _5.rotrBL(t12, c10, 39), y13 = t12 & b10 ^ t12 & s15 ^ b10 & s15, j6 = c10 & f17 ^ c10 & x15 ^ f17 & x15;
      D7 = l23 | 0, E14 = o13 | 0, l23 = r13 | 0, o13 = i18 | 0, r13 = e17 | 0, i18 = d20 | 0, { h: e17, l: d20 } = _5.add(H7 | 0, n13 | 0, S8 | 0, m17 | 0), H7 = s15 | 0, n13 = x15 | 0, s15 = b10 | 0, x15 = f17 | 0, b10 = t12 | 0, f17 = c10 | 0;
      const W2 = _5.add3L(m17, u22, j6);
      t12 = _5.add3H(W2, S8, w13, y13), c10 = W2 | 0;
    }
    ({ h: t12, l: c10 } = _5.add(this.Ah | 0, this.Al | 0, t12 | 0, c10 | 0)), { h: b10, l: f17 } = _5.add(this.Bh | 0, this.Bl | 0, b10 | 0, f17 | 0), { h: s15, l: x15 } = _5.add(this.Ch | 0, this.Cl | 0, s15 | 0, x15 | 0), { h: H7, l: n13 } = _5.add(this.Dh | 0, this.Dl | 0, H7 | 0, n13 | 0), { h: e17, l: d20 } = _5.add(this.Eh | 0, this.El | 0, e17 | 0, d20 | 0), { h: r13, l: i18 } = _5.add(this.Fh | 0, this.Fl | 0, r13 | 0, i18 | 0), { h: l23, l: o13 } = _5.add(this.Gh | 0, this.Gl | 0, l23 | 0, o13 | 0), { h: D7, l: E14 } = _5.add(this.Hh | 0, this.Hl | 0, D7 | 0, E14 | 0), this.set(t12, c10, b10, f17, s15, x15, H7, n13, e17, d20, r13, i18, l23, o13, D7, E14);
  }
  roundClean() {
    C3.fill(0), p8.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var T5 = T4(() => new _6());

// node_modules/@catalogfi/wallets/dist/index39.js
var import_dist817 = __toESM(require_dist(), 1);
var import_dist818 = __toESM(require_dist2(), 1);
var import_dist819 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index66.js
var import_dist814 = __toESM(require_dist(), 1);
var import_dist815 = __toESM(require_dist2(), 1);
var import_dist816 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index92.js
var import_dist811 = __toESM(require_dist(), 1);
var import_dist812 = __toESM(require_dist2(), 1);
var import_dist813 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index93.js
var import_dist808 = __toESM(require_dist(), 1);
var import_dist809 = __toESM(require_dist2(), 1);
var import_dist810 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index40.js
var import_dist805 = __toESM(require_dist(), 1);
var import_dist806 = __toESM(require_dist2(), 1);
var import_dist807 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index67.js
var index67_exports = {};
__export(index67_exports, {
  abytes: () => p9,
  bitGet: () => H2,
  bitLen: () => C4,
  bitMask: () => V2,
  bitSet: () => q2,
  bytesToHex: () => d8,
  bytesToNumberBE: () => v3,
  bytesToNumberLE: () => S3,
  concatBytes: () => _7,
  createHmacDrbg: () => k4,
  ensureBytes: () => j,
  equalBytes: () => F7,
  hexToBytes: () => b5,
  hexToNumber: () => w6,
  isBytes: () => l6,
  numberToBytesBE: () => A5,
  numberToBytesLE: () => L5,
  numberToHexUnpadded: () => B6,
  numberToVarBytesBE: () => N5,
  utf8ToBytes: () => O3,
  validateObject: () => G2
});
var import_dist802 = __toESM(require_dist(), 1);
var import_dist803 = __toESM(require_dist2(), 1);
var import_dist804 = __toESM(require_dist3(), 1);
var x7 = BigInt(0);
var h4 = BigInt(1);
var I4 = BigInt(2);
function l6(e17) {
  return e17 instanceof Uint8Array || e17 != null && typeof e17 == "object" && e17.constructor.name === "Uint8Array";
}
function p9(e17) {
  if (!l6(e17)) throw new Error("Uint8Array expected");
}
var T6 = Array.from({ length: 256 }, (e17, r13) => r13.toString(16).padStart(2, "0"));
function d8(e17) {
  p9(e17);
  let r13 = "";
  for (let o13 = 0; o13 < e17.length; o13++) r13 += T6[e17[o13]];
  return r13;
}
function B6(e17) {
  const r13 = e17.toString(16);
  return r13.length & 1 ? `0${r13}` : r13;
}
function w6(e17) {
  if (typeof e17 != "string") throw new Error("hex string expected, got " + typeof e17);
  return BigInt(e17 === "" ? "0" : `0x${e17}`);
}
var u7 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function E6(e17) {
  if (e17 >= u7._0 && e17 <= u7._9) return e17 - u7._0;
  if (e17 >= u7._A && e17 <= u7._F) return e17 - (u7._A - 10);
  if (e17 >= u7._a && e17 <= u7._f) return e17 - (u7._a - 10);
}
function b5(e17) {
  if (typeof e17 != "string") throw new Error("hex string expected, got " + typeof e17);
  const r13 = e17.length, o13 = r13 / 2;
  if (r13 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + r13);
  const t12 = new Uint8Array(o13);
  for (let n13 = 0, i18 = 0; n13 < o13; n13++, i18 += 2) {
    const c10 = E6(e17.charCodeAt(i18)), s15 = E6(e17.charCodeAt(i18 + 1));
    if (c10 === void 0 || s15 === void 0) {
      const a24 = e17[i18] + e17[i18 + 1];
      throw new Error('hex string expected, got non-hex character "' + a24 + '" at index ' + i18);
    }
    t12[n13] = c10 * 16 + s15;
  }
  return t12;
}
function v3(e17) {
  return w6(d8(e17));
}
function S3(e17) {
  return p9(e17), w6(d8(Uint8Array.from(e17).reverse()));
}
function A5(e17, r13) {
  return b5(e17.toString(16).padStart(r13 * 2, "0"));
}
function L5(e17, r13) {
  return A5(e17, r13).reverse();
}
function N5(e17) {
  return b5(B6(e17));
}
function j(e17, r13, o13) {
  let t12;
  if (typeof r13 == "string") try {
    t12 = b5(r13);
  } catch (i18) {
    throw new Error(`${e17} must be valid hex string, got "${r13}". Cause: ${i18}`);
  }
  else if (l6(r13)) t12 = Uint8Array.from(r13);
  else throw new Error(`${e17} must be hex string or Uint8Array`);
  const n13 = t12.length;
  if (typeof o13 == "number" && n13 !== o13) throw new Error(`${e17} expected ${o13} bytes, got ${n13}`);
  return t12;
}
function _7(...e17) {
  let r13 = 0;
  for (let t12 = 0; t12 < e17.length; t12++) {
    const n13 = e17[t12];
    p9(n13), r13 += n13.length;
  }
  const o13 = new Uint8Array(r13);
  for (let t12 = 0, n13 = 0; t12 < e17.length; t12++) {
    const i18 = e17[t12];
    o13.set(i18, n13), n13 += i18.length;
  }
  return o13;
}
function F7(e17, r13) {
  if (e17.length !== r13.length) return false;
  let o13 = 0;
  for (let t12 = 0; t12 < e17.length; t12++) o13 |= e17[t12] ^ r13[t12];
  return o13 === 0;
}
function O3(e17) {
  if (typeof e17 != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e17}`);
  return new Uint8Array(new TextEncoder().encode(e17));
}
function C4(e17) {
  let r13;
  for (r13 = 0; e17 > x7; e17 >>= h4, r13 += 1) ;
  return r13;
}
function H2(e17, r13) {
  return e17 >> BigInt(r13) & h4;
}
function q2(e17, r13, o13) {
  return e17 | (o13 ? h4 : x7) << BigInt(r13);
}
var V2 = (e17) => (I4 << BigInt(e17 - 1)) - h4;
var m7 = (e17) => new Uint8Array(e17);
var $2 = (e17) => Uint8Array.from(e17);
function k4(e17, r13, o13) {
  if (typeof e17 != "number" || e17 < 2) throw new Error("hashLen must be a number");
  if (typeof r13 != "number" || r13 < 2) throw new Error("qByteLen must be a number");
  if (typeof o13 != "function") throw new Error("hmacFn must be a function");
  let t12 = m7(e17), n13 = m7(e17), i18 = 0;
  const c10 = () => {
    t12.fill(1), n13.fill(0), i18 = 0;
  }, s15 = (...f17) => o13(n13, t12, ...f17), a24 = (f17 = m7()) => {
    n13 = s15($2([0]), f17), t12 = s15(), f17.length !== 0 && (n13 = s15($2([1]), f17), t12 = s15());
  }, U6 = () => {
    if (i18++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f17 = 0;
    const g15 = [];
    for (; f17 < r13; ) {
      t12 = s15();
      const y13 = t12.slice();
      g15.push(y13), f17 += t12.length;
    }
    return _7(...g15);
  };
  return (f17, g15) => {
    c10(), a24(f17);
    let y13;
    for (; !(y13 = g15(U6())); ) a24();
    return c10(), y13;
  };
}
var D = { bigint: (e17) => typeof e17 == "bigint", function: (e17) => typeof e17 == "function", boolean: (e17) => typeof e17 == "boolean", string: (e17) => typeof e17 == "string", stringOrUint8Array: (e17) => typeof e17 == "string" || l6(e17), isSafeInteger: (e17) => Number.isSafeInteger(e17), array: (e17) => Array.isArray(e17), field: (e17, r13) => r13.Fp.isValid(e17), hash: (e17) => typeof e17 == "function" && Number.isSafeInteger(e17.outputLen) };
function G2(e17, r13, o13 = {}) {
  const t12 = (n13, i18, c10) => {
    const s15 = D[i18];
    if (typeof s15 != "function") throw new Error(`Invalid validator "${i18}", expected function`);
    const a24 = e17[n13];
    if (!(c10 && a24 === void 0) && !s15(a24, e17)) throw new Error(`Invalid param ${String(n13)}=${a24} (${typeof a24}), expected ${i18}`);
  };
  for (const [n13, i18] of Object.entries(r13)) t12(n13, i18, false);
  for (const [n13, i18] of Object.entries(o13)) t12(n13, i18, true);
  return e17;
}

// node_modules/@catalogfi/wallets/dist/index40.js
var a11 = BigInt(0);
var l7 = BigInt(1);
var d9 = BigInt(2);
var A6 = BigInt(3);
var m8 = BigInt(4);
var I5 = BigInt(5);
var S4 = BigInt(8);
BigInt(9), BigInt(16);
function g6(n13, t12) {
  const e17 = n13 % t12;
  return e17 >= a11 ? e17 : t12 + e17;
}
function x8(n13, t12, e17) {
  if (e17 <= a11 || t12 < a11) throw new Error("Expected power/modulo > 0");
  if (e17 === l7) return a11;
  let o13 = l7;
  for (; t12 > a11; ) t12 & l7 && (o13 = o13 * n13 % e17), n13 = n13 * n13 % e17, t12 >>= l7;
  return o13;
}
function Z(n13, t12, e17) {
  let o13 = n13;
  for (; t12-- > a11; ) o13 *= o13, o13 %= e17;
  return o13;
}
function B7(n13, t12) {
  if (n13 === a11 || t12 <= a11) throw new Error(`invert: expected positive integers, got n=${n13} mod=${t12}`);
  let e17 = g6(n13, t12), o13 = t12, s15 = a11, u22 = l7;
  for (; e17 !== a11; ) {
    const i18 = o13 / e17, c10 = o13 % e17, r13 = s15 - u22 * i18;
    o13 = e17, e17 = c10, s15 = u22, u22 = r13;
  }
  if (o13 !== l7) throw new Error("invert: does not exist");
  return g6(s15, t12);
}
function F8(n13) {
  const t12 = (n13 - l7) / d9;
  let e17, o13, s15;
  for (e17 = n13 - l7, o13 = 0; e17 % d9 === a11; e17 /= d9, o13++) ;
  for (s15 = d9; s15 < n13 && x8(s15, t12, n13) !== n13 - l7; s15++) ;
  if (o13 === 1) {
    const i18 = (n13 + l7) / m8;
    return function(c10, r13) {
      const f17 = c10.pow(r13, i18);
      if (!c10.eql(c10.sqr(f17), r13)) throw new Error("Cannot find square root");
      return f17;
    };
  }
  const u22 = (e17 + l7) / d9;
  return function(i18, c10) {
    if (i18.pow(c10, t12) === i18.neg(i18.ONE)) throw new Error("Cannot find square root");
    let r13 = o13, f17 = i18.pow(i18.mul(i18.ONE, s15), e17), w13 = i18.pow(c10, u22), h11 = i18.pow(c10, e17);
    for (; !i18.eql(h11, i18.ONE); ) {
      if (i18.eql(h11, i18.ZERO)) return i18.ZERO;
      let E14 = 1;
      for (let p20 = i18.sqr(h11); E14 < r13 && !i18.eql(p20, i18.ONE); E14++) p20 = i18.sqr(p20);
      const b10 = i18.pow(f17, l7 << BigInt(r13 - E14 - 1));
      f17 = i18.sqr(b10), w13 = i18.mul(w13, b10), h11 = i18.mul(h11, f17), r13 = E14;
    }
    return w13;
  };
}
function L6(n13) {
  if (n13 % m8 === A6) {
    const t12 = (n13 + l7) / m8;
    return function(e17, o13) {
      const s15 = e17.pow(o13, t12);
      if (!e17.eql(e17.sqr(s15), o13)) throw new Error("Cannot find square root");
      return s15;
    };
  }
  if (n13 % S4 === I5) {
    const t12 = (n13 - I5) / S4;
    return function(e17, o13) {
      const s15 = e17.mul(o13, d9), u22 = e17.pow(s15, t12), i18 = e17.mul(o13, u22), c10 = e17.mul(e17.mul(i18, d9), u22), r13 = e17.mul(i18, e17.sub(c10, e17.ONE));
      if (!e17.eql(e17.sqr(r13), o13)) throw new Error("Cannot find square root");
      return r13;
    };
  }
  return F8(n13);
}
var k5 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function z2(n13) {
  const t12 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, e17 = k5.reduce((o13, s15) => (o13[s15] = "function", o13), t12);
  return G2(n13, e17);
}
function R2(n13, t12, e17) {
  if (e17 < a11) throw new Error("Expected power > 0");
  if (e17 === a11) return n13.ONE;
  if (e17 === l7) return t12;
  let o13 = n13.ONE, s15 = t12;
  for (; e17 > a11; ) e17 & l7 && (o13 = n13.mul(o13, s15)), s15 = n13.sqr(s15), e17 >>= l7;
  return o13;
}
function T7(n13, t12) {
  const e17 = new Array(t12.length), o13 = t12.reduce((u22, i18, c10) => n13.is0(i18) ? u22 : (e17[c10] = u22, n13.mul(u22, i18)), n13.ONE), s15 = n13.inv(o13);
  return t12.reduceRight((u22, i18, c10) => n13.is0(i18) ? u22 : (e17[c10] = n13.mul(u22, e17[c10]), n13.mul(u22, i18)), s15), e17;
}
function $3(n13, t12) {
  const e17 = t12 !== void 0 ? t12 : n13.toString(2).length, o13 = Math.ceil(e17 / 8);
  return { nBitLength: e17, nByteLength: o13 };
}
function D2(n13, t12, e17 = false, o13 = {}) {
  if (n13 <= a11) throw new Error(`Expected Field ORDER > 0, got ${n13}`);
  const { nBitLength: s15, nByteLength: u22 } = $3(n13, t12);
  if (u22 > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const i18 = L6(n13), c10 = Object.freeze({ ORDER: n13, BITS: s15, BYTES: u22, MASK: V2(s15), ZERO: a11, ONE: l7, create: (r13) => g6(r13, n13), isValid: (r13) => {
    if (typeof r13 != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof r13}`);
    return a11 <= r13 && r13 < n13;
  }, is0: (r13) => r13 === a11, isOdd: (r13) => (r13 & l7) === l7, neg: (r13) => g6(-r13, n13), eql: (r13, f17) => r13 === f17, sqr: (r13) => g6(r13 * r13, n13), add: (r13, f17) => g6(r13 + f17, n13), sub: (r13, f17) => g6(r13 - f17, n13), mul: (r13, f17) => g6(r13 * f17, n13), pow: (r13, f17) => R2(c10, r13, f17), div: (r13, f17) => g6(r13 * B7(f17, n13), n13), sqrN: (r13) => r13 * r13, addN: (r13, f17) => r13 + f17, subN: (r13, f17) => r13 - f17, mulN: (r13, f17) => r13 * f17, inv: (r13) => B7(r13, n13), sqrt: o13.sqrt || ((r13) => i18(c10, r13)), invertBatch: (r13) => T7(c10, r13), cmov: (r13, f17, w13) => w13 ? f17 : r13, toBytes: (r13) => e17 ? L5(r13, u22) : A5(r13, u22), fromBytes: (r13) => {
    if (r13.length !== u22) throw new Error(`Fp.fromBytes: expected ${u22}, got ${r13.length}`);
    return e17 ? S3(r13) : v3(r13);
  } });
  return Object.freeze(c10);
}
function q3(n13) {
  if (typeof n13 != "bigint") throw new Error("field order must be bigint");
  const t12 = n13.toString(2).length;
  return Math.ceil(t12 / 8);
}
function M4(n13) {
  const t12 = q3(n13);
  return t12 + Math.ceil(t12 / 2);
}
function H3(n13, t12, e17 = false) {
  const o13 = n13.length, s15 = q3(t12), u22 = M4(t12);
  if (o13 < 16 || o13 < u22 || o13 > 1024) throw new Error(`expected ${u22}-1024 bytes of input, got ${o13}`);
  const i18 = e17 ? v3(n13) : S3(n13), c10 = g6(i18, t12 - l7) + l7;
  return e17 ? L5(c10, s15) : A5(c10, s15);
}

// node_modules/@catalogfi/wallets/dist/index93.js
var A7 = BigInt(0);
var u8 = BigInt(1);
function z3(r13, h11) {
  const l23 = (e17, t12) => {
    const n13 = t12.negate();
    return e17 ? n13 : t12;
  }, g15 = (e17) => {
    const t12 = Math.ceil(h11 / e17) + 1, n13 = 2 ** (e17 - 1);
    return { windows: t12, windowSize: n13 };
  };
  return { constTimeNegate: l23, unsafeLadder(e17, t12) {
    let n13 = r13.ZERO, d20 = e17;
    for (; t12 > A7; ) t12 & u8 && (n13 = n13.add(d20)), d20 = d20.double(), t12 >>= u8;
    return n13;
  }, precomputeWindow(e17, t12) {
    const { windows: n13, windowSize: d20 } = g15(t12), s15 = [];
    let o13 = e17, i18 = o13;
    for (let c10 = 0; c10 < n13; c10++) {
      i18 = o13, s15.push(i18);
      for (let w13 = 1; w13 < d20; w13++) i18 = i18.add(o13), s15.push(i18);
      o13 = i18.double();
    }
    return s15;
  }, wNAF(e17, t12, n13) {
    const { windows: d20, windowSize: s15 } = g15(e17);
    let o13 = r13.ZERO, i18 = r13.BASE;
    const c10 = BigInt(2 ** e17 - 1), w13 = 2 ** e17, B12 = BigInt(e17);
    for (let f17 = 0; f17 < d20; f17++) {
      const p20 = f17 * s15;
      let a24 = Number(n13 & c10);
      n13 >>= B12, a24 > s15 && (a24 -= w13, n13 += u8);
      const b10 = p20, m17 = p20 + Math.abs(a24) - 1, I10 = f17 % 2 !== 0, F11 = a24 < 0;
      a24 === 0 ? i18 = i18.add(l23(I10, t12[b10])) : o13 = o13.add(l23(F11, t12[m17]));
    }
    return { p: o13, f: i18 };
  }, wNAFCached(e17, t12, n13, d20) {
    const s15 = e17._WINDOW_SIZE || 1;
    let o13 = t12.get(e17);
    return o13 || (o13 = this.precomputeWindow(e17, s15), s15 !== 1 && t12.set(e17, d20(o13))), this.wNAF(s15, o13, n13);
  } };
}
function E7(r13) {
  return z2(r13.Fp), G2(r13, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...$3(r13.n, r13.nBitLength), ...r13, p: r13.Fp.ORDER });
}

// node_modules/@catalogfi/wallets/dist/index92.js
function Bt(v8) {
  const n13 = E7(v8);
  G2(n13, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: t12, Fp: B12, a: O9 } = n13;
  if (t12) {
    if (!B12.eql(O9, B12.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t12 != "object" || typeof t12.beta != "bigint" || typeof t12.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...n13 });
}
var { bytesToNumberBE: St, hexToBytes: xt } = index67_exports;
var j2 = { Err: class extends Error {
  constructor(v8 = "") {
    super(v8);
  }
}, _parseInt(v8) {
  const { Err: n13 } = j2;
  if (v8.length < 2 || v8[0] !== 2) throw new n13("Invalid signature integer tag");
  const t12 = v8[1], B12 = v8.subarray(2, t12 + 2);
  if (!t12 || B12.length !== t12) throw new n13("Invalid signature integer: wrong length");
  if (B12[0] & 128) throw new n13("Invalid signature integer: negative");
  if (B12[0] === 0 && !(B12[1] & 128)) throw new n13("Invalid signature integer: unnecessary leading zero");
  return { d: St(B12), l: v8.subarray(t12 + 2) };
}, toSig(v8) {
  const { Err: n13 } = j2, t12 = typeof v8 == "string" ? xt(v8) : v8;
  p9(t12);
  let B12 = t12.length;
  if (B12 < 2 || t12[0] != 48) throw new n13("Invalid signature tag");
  if (t12[1] !== B12 - 2) throw new n13("Invalid signature: incorrect length");
  const { d: O9, l: T14 } = j2._parseInt(t12.subarray(2)), { d: K7, l: x15 } = j2._parseInt(T14);
  if (x15.length) throw new n13("Invalid signature: left bytes after parsing");
  return { r: O9, s: K7 };
}, hexFromSig(v8) {
  const n13 = (S8) => Number.parseInt(S8[0], 16) & 8 ? "00" + S8 : S8, t12 = (S8) => {
    const H7 = S8.toString(16);
    return H7.length & 1 ? `0${H7}` : H7;
  }, B12 = n13(t12(v8.s)), O9 = n13(t12(v8.r)), T14 = B12.length / 2, K7 = O9.length / 2, x15 = t12(T14), C7 = t12(K7);
  return `30${t12(K7 + T14 + 4)}02${C7}${O9}02${x15}${B12}`;
} };
var L7 = BigInt(0);
var z4 = BigInt(1);
BigInt(2);
var dt = BigInt(3);
BigInt(4);
function ht(v8) {
  const n13 = Bt(v8), { Fp: t12 } = n13, B12 = n13.toBytes || ((p20, r13, s15) => {
    const o13 = r13.toAffine();
    return _7(Uint8Array.from([4]), t12.toBytes(o13.x), t12.toBytes(o13.y));
  }), O9 = n13.fromBytes || ((p20) => {
    const r13 = p20.subarray(1), s15 = t12.fromBytes(r13.subarray(0, t12.BYTES)), o13 = t12.fromBytes(r13.subarray(t12.BYTES, 2 * t12.BYTES));
    return { x: s15, y: o13 };
  });
  function T14(p20) {
    const { a: r13, b: s15 } = n13, o13 = t12.sqr(p20), c10 = t12.mul(o13, p20);
    return t12.add(t12.add(c10, t12.mul(p20, r13)), s15);
  }
  if (!t12.eql(t12.sqr(n13.Gy), T14(n13.Gx))) throw new Error("bad generator point: equation left != right");
  function K7(p20) {
    return typeof p20 == "bigint" && L7 < p20 && p20 < n13.n;
  }
  function x15(p20) {
    if (!K7(p20)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function C7(p20) {
    const { allowedPrivateKeyLengths: r13, nByteLength: s15, wrapPrivateKey: o13, n: c10 } = n13;
    if (r13 && typeof p20 != "bigint") {
      if (l6(p20) && (p20 = d8(p20)), typeof p20 != "string" || !r13.includes(p20.length)) throw new Error("Invalid key");
      p20 = p20.padStart(s15 * 2, "0");
    }
    let f17;
    try {
      f17 = typeof p20 == "bigint" ? p20 : v3(j("private key", p20, s15));
    } catch {
      throw new Error(`private key must be ${s15} bytes, hex or bigint, not ${typeof p20}`);
    }
    return o13 && (f17 = g6(f17, c10)), x15(f17), f17;
  }
  const S8 = /* @__PURE__ */ new Map();
  function H7(p20) {
    if (!(p20 instanceof w13)) throw new Error("ProjectivePoint expected");
  }
  class w13 {
    constructor(r13, s15, o13) {
      if (this.px = r13, this.py = s15, this.pz = o13, r13 == null || !t12.isValid(r13)) throw new Error("x required");
      if (s15 == null || !t12.isValid(s15)) throw new Error("y required");
      if (o13 == null || !t12.isValid(o13)) throw new Error("z required");
    }
    static fromAffine(r13) {
      const { x: s15, y: o13 } = r13 || {};
      if (!r13 || !t12.isValid(s15) || !t12.isValid(o13)) throw new Error("invalid affine point");
      if (r13 instanceof w13) throw new Error("projective point not allowed");
      const c10 = (f17) => t12.eql(f17, t12.ZERO);
      return c10(s15) && c10(o13) ? w13.ZERO : new w13(s15, o13, t12.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(r13) {
      const s15 = t12.invertBatch(r13.map((o13) => o13.pz));
      return r13.map((o13, c10) => o13.toAffine(s15[c10])).map(w13.fromAffine);
    }
    static fromHex(r13) {
      const s15 = w13.fromAffine(O9(j("pointHex", r13)));
      return s15.assertValidity(), s15;
    }
    static fromPrivateKey(r13) {
      return w13.BASE.multiply(C7(r13));
    }
    _setWindowSize(r13) {
      this._WINDOW_SIZE = r13, S8.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (n13.allowInfinityPoint && !t12.is0(this.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: r13, y: s15 } = this.toAffine();
      if (!t12.isValid(r13) || !t12.isValid(s15)) throw new Error("bad point: x or y not FE");
      const o13 = t12.sqr(s15), c10 = T14(r13);
      if (!t12.eql(o13, c10)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: r13 } = this.toAffine();
      if (t12.isOdd) return !t12.isOdd(r13);
      throw new Error("Field doesn't support isOdd");
    }
    equals(r13) {
      H7(r13);
      const { px: s15, py: o13, pz: c10 } = this, { px: f17, py: g15, pz: h11 } = r13, a24 = t12.eql(t12.mul(s15, h11), t12.mul(f17, c10)), u22 = t12.eql(t12.mul(o13, h11), t12.mul(g15, c10));
      return a24 && u22;
    }
    negate() {
      return new w13(this.px, t12.neg(this.py), this.pz);
    }
    double() {
      const { a: r13, b: s15 } = n13, o13 = t12.mul(s15, dt), { px: c10, py: f17, pz: g15 } = this;
      let h11 = t12.ZERO, a24 = t12.ZERO, u22 = t12.ZERO, d20 = t12.mul(c10, c10), Z3 = t12.mul(f17, f17), E14 = t12.mul(g15, g15), y13 = t12.mul(c10, f17);
      return y13 = t12.add(y13, y13), u22 = t12.mul(c10, g15), u22 = t12.add(u22, u22), h11 = t12.mul(r13, u22), a24 = t12.mul(o13, E14), a24 = t12.add(h11, a24), h11 = t12.sub(Z3, a24), a24 = t12.add(Z3, a24), a24 = t12.mul(h11, a24), h11 = t12.mul(y13, h11), u22 = t12.mul(o13, u22), E14 = t12.mul(r13, E14), y13 = t12.sub(d20, E14), y13 = t12.mul(r13, y13), y13 = t12.add(y13, u22), u22 = t12.add(d20, d20), d20 = t12.add(u22, d20), d20 = t12.add(d20, E14), d20 = t12.mul(d20, y13), a24 = t12.add(a24, d20), E14 = t12.mul(f17, g15), E14 = t12.add(E14, E14), d20 = t12.mul(E14, y13), h11 = t12.sub(h11, d20), u22 = t12.mul(E14, Z3), u22 = t12.add(u22, u22), u22 = t12.add(u22, u22), new w13(h11, a24, u22);
    }
    add(r13) {
      H7(r13);
      const { px: s15, py: o13, pz: c10 } = this, { px: f17, py: g15, pz: h11 } = r13;
      let a24 = t12.ZERO, u22 = t12.ZERO, d20 = t12.ZERO;
      const Z3 = n13.a, E14 = t12.mul(n13.b, dt);
      let y13 = t12.mul(s15, f17), P6 = t12.mul(o13, g15), I10 = t12.mul(c10, h11), $9 = t12.add(s15, o13), e17 = t12.add(f17, g15);
      $9 = t12.mul($9, e17), e17 = t12.add(y13, P6), $9 = t12.sub($9, e17), e17 = t12.add(s15, c10);
      let i18 = t12.add(f17, h11);
      return e17 = t12.mul(e17, i18), i18 = t12.add(y13, I10), e17 = t12.sub(e17, i18), i18 = t12.add(o13, c10), a24 = t12.add(g15, h11), i18 = t12.mul(i18, a24), a24 = t12.add(P6, I10), i18 = t12.sub(i18, a24), d20 = t12.mul(Z3, e17), a24 = t12.mul(E14, I10), d20 = t12.add(a24, d20), a24 = t12.sub(P6, d20), d20 = t12.add(P6, d20), u22 = t12.mul(a24, d20), P6 = t12.add(y13, y13), P6 = t12.add(P6, y13), I10 = t12.mul(Z3, I10), e17 = t12.mul(E14, e17), P6 = t12.add(P6, I10), I10 = t12.sub(y13, I10), I10 = t12.mul(Z3, I10), e17 = t12.add(e17, I10), y13 = t12.mul(P6, e17), u22 = t12.add(u22, y13), y13 = t12.mul(i18, e17), a24 = t12.mul($9, a24), a24 = t12.sub(a24, y13), y13 = t12.mul($9, P6), d20 = t12.mul(i18, d20), d20 = t12.add(d20, y13), new w13(a24, u22, d20);
    }
    subtract(r13) {
      return this.add(r13.negate());
    }
    is0() {
      return this.equals(w13.ZERO);
    }
    wNAF(r13) {
      return U6.wNAFCached(this, S8, r13, (s15) => {
        const o13 = t12.invertBatch(s15.map((c10) => c10.pz));
        return s15.map((c10, f17) => c10.toAffine(o13[f17])).map(w13.fromAffine);
      });
    }
    multiplyUnsafe(r13) {
      const s15 = w13.ZERO;
      if (r13 === L7) return s15;
      if (x15(r13), r13 === z4) return this;
      const { endo: o13 } = n13;
      if (!o13) return U6.unsafeLadder(this, r13);
      let { k1neg: c10, k1: f17, k2neg: g15, k2: h11 } = o13.splitScalar(r13), a24 = s15, u22 = s15, d20 = this;
      for (; f17 > L7 || h11 > L7; ) f17 & z4 && (a24 = a24.add(d20)), h11 & z4 && (u22 = u22.add(d20)), d20 = d20.double(), f17 >>= z4, h11 >>= z4;
      return c10 && (a24 = a24.negate()), g15 && (u22 = u22.negate()), u22 = new w13(t12.mul(u22.px, o13.beta), u22.py, u22.pz), a24.add(u22);
    }
    multiply(r13) {
      x15(r13);
      let s15 = r13, o13, c10;
      const { endo: f17 } = n13;
      if (f17) {
        const { k1neg: g15, k1: h11, k2neg: a24, k2: u22 } = f17.splitScalar(s15);
        let { p: d20, f: Z3 } = this.wNAF(h11), { p: E14, f: y13 } = this.wNAF(u22);
        d20 = U6.constTimeNegate(g15, d20), E14 = U6.constTimeNegate(a24, E14), E14 = new w13(t12.mul(E14.px, f17.beta), E14.py, E14.pz), o13 = d20.add(E14), c10 = Z3.add(y13);
      } else {
        const { p: g15, f: h11 } = this.wNAF(s15);
        o13 = g15, c10 = h11;
      }
      return w13.normalizeZ([o13, c10])[0];
    }
    multiplyAndAddUnsafe(r13, s15, o13) {
      const c10 = w13.BASE, f17 = (h11, a24) => a24 === L7 || a24 === z4 || !h11.equals(c10) ? h11.multiplyUnsafe(a24) : h11.multiply(a24), g15 = f17(this, s15).add(f17(r13, o13));
      return g15.is0() ? void 0 : g15;
    }
    toAffine(r13) {
      const { px: s15, py: o13, pz: c10 } = this, f17 = this.is0();
      r13 == null && (r13 = f17 ? t12.ONE : t12.inv(c10));
      const g15 = t12.mul(s15, r13), h11 = t12.mul(o13, r13), a24 = t12.mul(c10, r13);
      if (f17) return { x: t12.ZERO, y: t12.ZERO };
      if (!t12.eql(a24, t12.ONE)) throw new Error("invZ was invalid");
      return { x: g15, y: h11 };
    }
    isTorsionFree() {
      const { h: r13, isTorsionFree: s15 } = n13;
      if (r13 === z4) return true;
      if (s15) return s15(w13, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: r13, clearCofactor: s15 } = n13;
      return r13 === z4 ? this : s15 ? s15(w13, this) : this.multiplyUnsafe(n13.h);
    }
    toRawBytes(r13 = true) {
      return this.assertValidity(), B12(w13, this, r13);
    }
    toHex(r13 = true) {
      return d8(this.toRawBytes(r13));
    }
  }
  w13.BASE = new w13(n13.Gx, n13.Gy, t12.ONE), w13.ZERO = new w13(t12.ZERO, t12.ONE, t12.ZERO);
  const W2 = n13.nBitLength, U6 = z3(w13, n13.endo ? Math.ceil(W2 / 2) : W2);
  return { CURVE: n13, ProjectivePoint: w13, normPrivateKeyToScalar: C7, weierstrassEquation: T14, isWithinCurveOrder: K7 };
}
function Rt(v8) {
  const n13 = E7(v8);
  return G2(n13, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n13 });
}
function At(v8) {
  const n13 = Rt(v8), { Fp: t12, n: B12 } = n13, O9 = t12.BYTES + 1, T14 = 2 * t12.BYTES + 1;
  function K7(e17) {
    return L7 < e17 && e17 < t12.ORDER;
  }
  function x15(e17) {
    return g6(e17, B12);
  }
  function C7(e17) {
    return B7(e17, B12);
  }
  const { ProjectivePoint: S8, normPrivateKeyToScalar: H7, weierstrassEquation: w13, isWithinCurveOrder: W2 } = ht({ ...n13, toBytes(e17, i18, l23) {
    const b10 = i18.toAffine(), m17 = t12.toBytes(b10.x), R5 = _7;
    return l23 ? R5(Uint8Array.from([i18.hasEvenY() ? 2 : 3]), m17) : R5(Uint8Array.from([4]), m17, t12.toBytes(b10.y));
  }, fromBytes(e17) {
    const i18 = e17.length, l23 = e17[0], b10 = e17.subarray(1);
    if (i18 === O9 && (l23 === 2 || l23 === 3)) {
      const m17 = v3(b10);
      if (!K7(m17)) throw new Error("Point is not on curve");
      const R5 = w13(m17);
      let q9;
      try {
        q9 = t12.sqrt(R5);
      } catch (F11) {
        const N10 = F11 instanceof Error ? ": " + F11.message : "";
        throw new Error("Point is not on curve" + N10);
      }
      const A13 = (q9 & z4) === z4;
      return (l23 & 1) === 1 !== A13 && (q9 = t12.neg(q9)), { x: m17, y: q9 };
    } else if (i18 === T14 && l23 === 4) {
      const m17 = t12.fromBytes(b10.subarray(0, t12.BYTES)), R5 = t12.fromBytes(b10.subarray(t12.BYTES, 2 * t12.BYTES));
      return { x: m17, y: R5 };
    } else throw new Error(`Point of length ${i18} was invalid. Expected ${O9} compressed bytes or ${T14} uncompressed bytes`);
  } }), U6 = (e17) => d8(A5(e17, n13.nByteLength));
  function p20(e17) {
    const i18 = B12 >> z4;
    return e17 > i18;
  }
  function r13(e17) {
    return p20(e17) ? x15(-e17) : e17;
  }
  const s15 = (e17, i18, l23) => v3(e17.slice(i18, l23));
  class o13 {
    constructor(i18, l23, b10) {
      this.r = i18, this.s = l23, this.recovery = b10, this.assertValidity();
    }
    static fromCompact(i18) {
      const l23 = n13.nByteLength;
      return i18 = j("compactSignature", i18, l23 * 2), new o13(s15(i18, 0, l23), s15(i18, l23, 2 * l23));
    }
    static fromDER(i18) {
      const { r: l23, s: b10 } = j2.toSig(j("DER", i18));
      return new o13(l23, b10);
    }
    assertValidity() {
      if (!W2(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!W2(this.s)) throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(i18) {
      return new o13(this.r, this.s, i18);
    }
    recoverPublicKey(i18) {
      const { r: l23, s: b10, recovery: m17 } = this, R5 = u22(j("msgHash", i18));
      if (m17 == null || ![0, 1, 2, 3].includes(m17)) throw new Error("recovery id invalid");
      const q9 = m17 === 2 || m17 === 3 ? l23 + n13.n : l23;
      if (q9 >= t12.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const A13 = m17 & 1 ? "03" : "02", F11 = S8.fromHex(A13 + U6(q9)), N10 = C7(q9), G6 = x15(-R5 * N10), X = x15(b10 * N10), Y = S8.BASE.multiplyAndAddUnsafe(F11, G6, X);
      if (!Y) throw new Error("point at infinify");
      return Y.assertValidity(), Y;
    }
    hasHighS() {
      return p20(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new o13(this.r, x15(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return b5(this.toDERHex());
    }
    toDERHex() {
      return j2.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return b5(this.toCompactHex());
    }
    toCompactHex() {
      return U6(this.r) + U6(this.s);
    }
  }
  const c10 = { isValidPrivateKey(e17) {
    try {
      return H7(e17), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: H7, randomPrivateKey: () => {
    const e17 = M4(n13.n);
    return H3(n13.randomBytes(e17), n13.n);
  }, precompute(e17 = 8, i18 = S8.BASE) {
    return i18._setWindowSize(e17), i18.multiply(BigInt(3)), i18;
  } };
  function f17(e17, i18 = true) {
    return S8.fromPrivateKey(e17).toRawBytes(i18);
  }
  function g15(e17) {
    const i18 = l6(e17), l23 = typeof e17 == "string", b10 = (i18 || l23) && e17.length;
    return i18 ? b10 === O9 || b10 === T14 : l23 ? b10 === 2 * O9 || b10 === 2 * T14 : e17 instanceof S8;
  }
  function h11(e17, i18, l23 = true) {
    if (g15(e17)) throw new Error("first arg must be private key");
    if (!g15(i18)) throw new Error("second arg must be public key");
    return S8.fromHex(i18).multiply(H7(e17)).toRawBytes(l23);
  }
  const a24 = n13.bits2int || function(e17) {
    const i18 = v3(e17), l23 = e17.length * 8 - n13.nBitLength;
    return l23 > 0 ? i18 >> BigInt(l23) : i18;
  }, u22 = n13.bits2int_modN || function(e17) {
    return x15(a24(e17));
  }, d20 = V2(n13.nBitLength);
  function Z3(e17) {
    if (typeof e17 != "bigint") throw new Error("bigint expected");
    if (!(L7 <= e17 && e17 < d20)) throw new Error(`bigint expected < 2^${n13.nBitLength}`);
    return A5(e17, n13.nByteLength);
  }
  function E14(e17, i18, l23 = y13) {
    if (["recovered", "canonical"].some((D7) => D7 in l23)) throw new Error("sign() legacy options not supported");
    const { hash: b10, randomBytes: m17 } = n13;
    let { lowS: R5, prehash: q9, extraEntropy: A13 } = l23;
    R5 == null && (R5 = true), e17 = j("msgHash", e17), q9 && (e17 = j("prehashed msgHash", b10(e17)));
    const F11 = u22(e17), N10 = H7(i18), G6 = [Z3(N10), Z3(F11)];
    if (A13 != null && A13 !== false) {
      const D7 = A13 === true ? m17(t12.BYTES) : A13;
      G6.push(j("extraEntropy", D7));
    }
    const X = _7(...G6), Y = F11;
    function et(D7) {
      const M8 = a24(D7);
      if (!W2(M8)) return;
      const J3 = C7(M8), V4 = S8.BASE.multiply(M8).toAffine(), Q2 = x15(V4.x);
      if (Q2 === L7) return;
      const _10 = x15(J3 * x15(Y + Q2 * N10));
      if (_10 === L7) return;
      let ot = (V4.x === Q2 ? 0 : 2) | Number(V4.y & z4), st = _10;
      return R5 && p20(_10) && (st = r13(_10), ot ^= 1), new o13(Q2, st, ot);
    }
    return { seed: X, k2sig: et };
  }
  const y13 = { lowS: n13.lowS, prehash: false }, P6 = { lowS: n13.lowS, prehash: false };
  function I10(e17, i18, l23 = y13) {
    const { seed: b10, k2sig: m17 } = E14(e17, i18, l23), R5 = n13;
    return k4(R5.hash.outputLen, R5.nByteLength, R5.hmac)(b10, m17);
  }
  S8.BASE._setWindowSize(8);
  function $9(e17, i18, l23, b10 = P6) {
    var J3;
    const m17 = e17;
    if (i18 = j("msgHash", i18), l23 = j("publicKey", l23), "strict" in b10) throw new Error("options.strict was renamed to lowS");
    const { lowS: R5, prehash: q9 } = b10;
    let A13, F11;
    try {
      if (typeof m17 == "string" || l6(m17)) try {
        A13 = o13.fromDER(m17);
      } catch (V4) {
        if (!(V4 instanceof j2.Err)) throw V4;
        A13 = o13.fromCompact(m17);
      }
      else if (typeof m17 == "object" && typeof m17.r == "bigint" && typeof m17.s == "bigint") {
        const { r: V4, s: Q2 } = m17;
        A13 = new o13(V4, Q2);
      } else throw new Error("PARSE");
      F11 = S8.fromHex(l23);
    } catch (V4) {
      if (V4.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (R5 && A13.hasHighS()) return false;
    q9 && (i18 = n13.hash(i18));
    const { r: N10, s: G6 } = A13, X = u22(i18), Y = C7(G6), et = x15(X * Y), D7 = x15(N10 * Y), M8 = (J3 = S8.BASE.multiplyAndAddUnsafe(F11, et, D7)) == null ? void 0 : J3.toAffine();
    return M8 ? x15(M8.x) === N10 : false;
  }
  return { CURVE: n13, getPublicKey: f17, getSharedSecret: h11, sign: I10, verify: $9, ProjectivePoint: S8, Signature: o13, utils: c10 };
}

// node_modules/@catalogfi/wallets/dist/index66.js
function a12(e17) {
  return { hash: e17, hmac: (t12, ...r13) => d6(e17, t12, U(...r13)), randomBytes: V };
}
function f6(e17, t12) {
  const r13 = (s15) => At({ ...e17, ...a12(s15) });
  return Object.freeze({ ...r13(t12), create: r13 });
}

// node_modules/@catalogfi/wallets/dist/index39.js
var u9 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var q4 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var N6 = BigInt(1);
var l8 = BigInt(2);
var v4 = (t12, f17) => (t12 + f17 / l8) / f17;
function O4(t12) {
  const f17 = u9, o13 = BigInt(3), c10 = BigInt(6), d20 = BigInt(11), g15 = BigInt(22), a24 = BigInt(23), r13 = BigInt(44), B12 = BigInt(88), i18 = t12 * t12 * t12 % f17, n13 = i18 * i18 * t12 % f17, I10 = Z(n13, o13, f17) * n13 % f17, s15 = Z(I10, o13, f17) * n13 % f17, x15 = Z(s15, l8, f17) * i18 % f17, p20 = Z(x15, d20, f17) * x15 % f17, b10 = Z(p20, g15, f17) * p20 % f17, k9 = Z(b10, r13, f17) * b10 % f17, S8 = Z(k9, B12, f17) * k9 % f17, C7 = Z(S8, r13, f17) * b10 % f17, F11 = Z(C7, o13, f17) * n13 % f17, G6 = Z(F11, a24, f17) * p20 % f17, P6 = Z(G6, c10, f17) * i18 % f17, w13 = Z(P6, l8, f17);
  if (!m9.eql(m9.sqr(w13), t12)) throw new Error("Cannot find square root");
  return w13;
}
var m9 = D2(u9, void 0, void 0, { sqrt: O4 });
var E8 = f6({ a: BigInt(0), b: BigInt(7), Fp: m9, n: q4, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (t12) => {
  const f17 = q4, o13 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), c10 = -N6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), d20 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), g15 = o13, a24 = BigInt("0x100000000000000000000000000000000"), r13 = v4(g15 * t12, f17), B12 = v4(-c10 * t12, f17);
  let i18 = g6(t12 - r13 * o13 - B12 * d20, f17), n13 = g6(-r13 * c10 - B12 * g15, f17);
  const I10 = i18 > a24, s15 = n13 > a24;
  if (I10 && (i18 = f17 - i18), s15 && (n13 = f17 - n13), i18 > a24 || n13 > a24) throw new Error("splitScalar: Endomorphism failed, k=" + t12);
  return { k1neg: I10, k1: i18, k2neg: s15, k2: n13 };
} } }, F5);
BigInt(0), E8.ProjectivePoint;

// node_modules/@catalogfi/wallets/dist/index41.js
var import_dist820 = __toESM(require_dist(), 1);
var import_dist821 = __toESM(require_dist2(), 1);
var import_dist822 = __toESM(require_dist3(), 1);
function h5(e17) {
  return e17 instanceof Uint8Array || e17 != null && typeof e17 == "object" && e17.constructor.name === "Uint8Array";
}
function l9(...e17) {
  const r13 = (n13) => n13, o13 = (n13, t12) => (c10) => n13(t12(c10)), i18 = e17.map((n13) => n13.encode).reduceRight(o13, r13), a24 = e17.map((n13) => n13.decode).reduce(o13, r13);
  return { encode: i18, decode: a24 };
}
function p10(e17) {
  return { encode: (r13) => {
    if (!Array.isArray(r13) || r13.length && typeof r13[0] != "number") throw new Error("alphabet.encode input should be an array of numbers");
    return r13.map((o13) => {
      if (o13 < 0 || o13 >= e17.length) throw new Error(`Digit index outside alphabet: ${o13} (alphabet: ${e17.length})`);
      return e17[o13];
    });
  }, decode: (r13) => {
    if (!Array.isArray(r13) || r13.length && typeof r13[0] != "string") throw new Error("alphabet.decode input should be array of strings");
    return r13.map((o13) => {
      if (typeof o13 != "string") throw new Error(`alphabet.decode: not string element=${o13}`);
      const i18 = e17.indexOf(o13);
      if (i18 === -1) throw new Error(`Unknown letter: "${o13}". Allowed: ${e17}`);
      return i18;
    });
  } };
}
function g7(e17 = "") {
  if (typeof e17 != "string") throw new Error("join separator should be string");
  return { encode: (r13) => {
    if (!Array.isArray(r13) || r13.length && typeof r13[0] != "string") throw new Error("join.encode input should be array of strings");
    for (let o13 of r13) if (typeof o13 != "string") throw new Error(`join.encode: non-string input=${o13}`);
    return r13.join(e17);
  }, decode: (r13) => {
    if (typeof r13 != "string") throw new Error("join.decode input should be string");
    return r13.split(e17);
  } };
}
function w7(e17, r13, o13) {
  if (r13 < 2) throw new Error(`convertRadix: wrong from=${r13}, base cannot be less than 2`);
  if (o13 < 2) throw new Error(`convertRadix: wrong to=${o13}, base cannot be less than 2`);
  if (!Array.isArray(e17)) throw new Error("convertRadix: data should be array");
  if (!e17.length) return [];
  let i18 = 0;
  const a24 = [], n13 = Array.from(e17);
  for (n13.forEach((t12) => {
    if (t12 < 0 || t12 >= r13) throw new Error(`Wrong integer: ${t12}`);
  }); ; ) {
    let t12 = 0, c10 = true;
    for (let s15 = i18; s15 < n13.length; s15++) {
      const d20 = n13[s15], f17 = r13 * t12 + d20;
      if (!Number.isSafeInteger(f17) || r13 * t12 / r13 !== t12 || f17 - d20 !== r13 * t12) throw new Error("convertRadix: carry overflow");
      t12 = f17 % o13;
      const u22 = Math.floor(f17 / o13);
      if (n13[s15] = u22, !Number.isSafeInteger(u22) || u22 * o13 + t12 !== f17) throw new Error("convertRadix: carry overflow");
      if (c10) u22 ? c10 = false : i18 = s15;
      else continue;
    }
    if (a24.push(t12), c10) break;
  }
  for (let t12 = 0; t12 < e17.length - 1 && e17[t12] === 0; t12++) a24.push(0);
  return a24.reverse();
}
function b6(e17) {
  return { encode: (r13) => {
    if (!h5(r13)) throw new Error("radix.encode input should be Uint8Array");
    return w7(Array.from(r13), 2 ** 8, e17);
  }, decode: (r13) => {
    if (!Array.isArray(r13) || r13.length && typeof r13[0] != "number") throw new Error("radix.decode input should be array of numbers");
    return Uint8Array.from(w7(r13, e17, 2 ** 8));
  } };
}
function E9(e17, r13) {
  if (typeof r13 != "function") throw new Error("checksum fn should be function");
  return { encode(o13) {
    if (!h5(o13)) throw new Error("checksum.encode: input should be Uint8Array");
    const i18 = r13(o13).slice(0, e17), a24 = new Uint8Array(o13.length + e17);
    return a24.set(o13), a24.set(i18, o13.length), a24;
  }, decode(o13) {
    if (!h5(o13)) throw new Error("checksum.decode: input should be Uint8Array");
    const i18 = o13.slice(0, -e17), a24 = r13(i18).slice(0, e17), n13 = o13.slice(-e17);
    for (let t12 = 0; t12 < e17; t12++) if (a24[t12] !== n13[t12]) throw new Error("Invalid checksum");
    return i18;
  } };
}
var m10 = (e17) => l9(b6(58), p10(e17), g7(""));
var y7 = m10("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var A8 = (e17) => l9(E9(4, (r13) => e17(e17(r13))), y7);

// node_modules/@catalogfi/wallets/dist/index27.js
var c6 = E8.ProjectivePoint;
var w8 = A8(F5);
function E10(s15) {
  return BigInt(`0x${E4(s15)}`);
}
function S5(s15) {
  return L(s15.toString(16).padStart(64, "0"));
}
var P3 = g2("Bitcoin seed");
var K4 = { private: 76066276, public: 76067358 };
var u10 = 2147483648;
var U5 = (s15) => _4(F5(s15));
var D3 = (s15) => w2(s15).getUint32(0, false);
var l10 = (s15) => {
  if (!Number.isSafeInteger(s15) || s15 < 0 || s15 > 2 ** 32 - 1) throw new Error(`Invalid number=${s15}. Should be from 0 to 2 ** 32 - 1`);
  const e17 = new Uint8Array(4);
  return w2(e17).setUint32(0, s15, false), e17;
};
var p11 = class _p {
  get fingerprint() {
    if (!this.pubHash) throw new Error("No publicKey set!");
    return D3(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const e17 = this.privateKey;
    if (!e17) throw new Error("No private key");
    return w8.encode(this.serialize(this.versions.private, U(new Uint8Array([0]), e17)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) throw new Error("No public key");
    return w8.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(e17, t12 = K4) {
    if (s4(e17), 8 * e17.length < 128 || 8 * e17.length > 512) throw new Error(`HDKey: wrong seed length=${e17.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    const i18 = d6(T5, P3, e17);
    return new _p({ versions: t12, chainCode: i18.slice(32), privateKey: i18.slice(0, 32) });
  }
  static fromExtendedKey(e17, t12 = K4) {
    const i18 = w8.decode(e17), n13 = w2(i18), o13 = n13.getUint32(0, false), h11 = { versions: t12, depth: i18[4], parentFingerprint: n13.getUint32(5, false), index: n13.getUint32(9, false), chainCode: i18.slice(13, 45) }, r13 = i18.slice(45), f17 = r13[0] === 0;
    if (o13 !== t12[f17 ? "private" : "public"]) throw new Error("Version mismatch");
    return f17 ? new _p({ ...h11, privateKey: r13.slice(1) }) : new _p({ ...h11, publicKey: r13 });
  }
  static fromJSON(e17) {
    return _p.fromExtendedKey(e17.xpriv);
  }
  constructor(e17) {
    if (this.depth = 0, this.index = 0, this.chainCode = null, this.parentFingerprint = 0, !e17 || typeof e17 != "object") throw new Error("HDKey.constructor must not be called directly");
    if (this.versions = e17.versions || K4, this.depth = e17.depth || 0, this.chainCode = e17.chainCode || null, this.index = e17.index || 0, this.parentFingerprint = e17.parentFingerprint || 0, !this.depth && (this.parentFingerprint || this.index)) throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
    if (e17.publicKey && e17.privateKey) throw new Error("HDKey: publicKey and privateKey at same time.");
    if (e17.privateKey) {
      if (!E8.utils.isValidPrivateKey(e17.privateKey)) throw new Error("Invalid private key");
      this.privKey = typeof e17.privateKey == "bigint" ? e17.privateKey : E10(e17.privateKey), this.privKeyBytes = S5(this.privKey), this.pubKey = E8.getPublicKey(e17.privateKey, true);
    } else if (e17.publicKey) this.pubKey = c6.fromHex(e17.publicKey).toRawBytes(true);
    else throw new Error("HDKey: no public or private key provided");
    this.pubHash = U5(this.pubKey);
  }
  derive(e17) {
    if (!/^[mM]'?/.test(e17)) throw new Error('Path must start with "m" or "M"');
    if (/^[mM]'?$/.test(e17)) return this;
    const t12 = e17.replace(/^[mM]'?\//, "").split("/");
    let i18 = this;
    for (const n13 of t12) {
      const o13 = /^(\d+)('?)$/.exec(n13), h11 = o13 && o13[1];
      if (!o13 || o13.length !== 3 || typeof h11 != "string") throw new Error(`Invalid child index: ${n13}`);
      let r13 = +h11;
      if (!Number.isSafeInteger(r13) || r13 >= u10) throw new Error("Invalid index");
      o13[2] === "'" && (r13 += u10), i18 = i18.deriveChild(r13);
    }
    return i18;
  }
  deriveChild(e17) {
    if (!this.pubKey || !this.chainCode) throw new Error("No publicKey or chainCode set");
    let t12 = l10(e17);
    if (e17 >= u10) {
      const r13 = this.privateKey;
      if (!r13) throw new Error("Could not derive hardened child key");
      t12 = U(new Uint8Array([0]), r13, t12);
    } else t12 = U(this.pubKey, t12);
    const i18 = d6(T5, this.chainCode, t12), n13 = E10(i18.slice(0, 32)), o13 = i18.slice(32);
    if (!E8.utils.isValidPrivateKey(n13)) throw new Error("Tweak bigger than curve order");
    const h11 = { versions: this.versions, chainCode: o13, depth: this.depth + 1, parentFingerprint: this.fingerprint, index: e17 };
    try {
      if (this.privateKey) {
        const r13 = g6(this.privKey + n13, E8.CURVE.n);
        if (!E8.utils.isValidPrivateKey(r13)) throw new Error("The tweak was out of range or the resulted private key is invalid");
        h11.privateKey = r13;
      } else {
        const r13 = c6.fromHex(this.pubKey).add(c6.fromPrivateKey(n13));
        if (r13.equals(c6.ZERO)) throw new Error("The tweak was equal to negative P, which made the result key invalid");
        h11.publicKey = r13.toRawBytes(true);
      }
      return new _p(h11);
    } catch {
      return this.deriveChild(e17 + 1);
    }
  }
  sign(e17) {
    if (!this.privateKey) throw new Error("No privateKey set!");
    return s4(e17, 32), E8.sign(e17, this.privKey).toCompactRawBytes();
  }
  verify(e17, t12) {
    if (s4(e17, 32), s4(t12, 64), !this.publicKey) throw new Error("No publicKey set!");
    let i18;
    try {
      i18 = E8.Signature.fromCompact(t12);
    } catch {
      return false;
    }
    return E8.verify(i18, e17, this.publicKey);
  }
  wipePrivateData() {
    return this.privKey = void 0, this.privKeyBytes && (this.privKeyBytes.fill(0), this.privKeyBytes = void 0), this;
  }
  toJSON() {
    return { xpriv: this.privateExtendedKey, xpub: this.publicExtendedKey };
  }
  serialize(e17, t12) {
    if (!this.chainCode) throw new Error("No chainCode set");
    return s4(t12, 33), U(l10(e17), new Uint8Array([this.depth]), l10(this.parentFingerprint), l10(this.index), this.chainCode, t12);
  }
};

// node_modules/@catalogfi/wallets/dist/index28.js
var import_dist1027 = __toESM(require_dist(), 1);
var import_dist1028 = __toESM(require_dist2(), 1);
var import_dist1029 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index42.js
var import_dist850 = __toESM(require_dist(), 1);
var import_dist851 = __toESM(require_dist2(), 1);
var import_dist852 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index70.js
var import_dist832 = __toESM(require_dist(), 1);
var import_dist833 = __toESM(require_dist2(), 1);
var import_dist834 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index72.js
var import_dist829 = __toESM(require_dist(), 1);
var import_dist830 = __toESM(require_dist2(), 1);
var import_dist831 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index98.js
var import_dist826 = __toESM(require_dist(), 1);
var import_dist827 = __toESM(require_dist2(), 1);
var import_dist828 = __toESM(require_dist3(), 1);
var o6 = "2.20.1";

// node_modules/@catalogfi/wallets/dist/index72.js
var r6 = { getDocsUrl: ({ docsBaseUrl: a24, docsPath: s15 = "", docsSlug: e17 }) => s15 ? `${a24 ?? "https://viem.sh"}${s15}${e17 ? `#${e17}` : ""}` : void 0, version: o6 };
var t3 = class _t extends Error {
  constructor(s15, e17 = {}) {
    var n13, l23;
    const i18 = e17.cause instanceof _t ? e17.cause.details : (n13 = e17.cause) != null && n13.message ? e17.cause.message : e17.details, o13 = e17.cause instanceof _t && e17.cause.docsPath || e17.docsPath, c10 = (l23 = r6.getDocsUrl) == null ? void 0 : l23.call(r6, { ...e17, docsPath: o13 }), b10 = [s15 || "An error occurred.", "", ...e17.metaMessages ? [...e17.metaMessages, ""] : [], ...c10 ? [`Docs: ${c10}`] : [], ...i18 ? [`Details: ${i18}`] : [], `Version: ${r6.version}`].join(`
`);
    super(b10, e17.cause ? { cause: e17.cause } : void 0), Object.defineProperty(this, "details", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "docsPath", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "metaMessages", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "shortMessage", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "version", { enumerable: true, configurable: true, writable: true, value: void 0 }), Object.defineProperty(this, "name", { enumerable: true, configurable: true, writable: true, value: "BaseError" }), this.details = i18, this.docsPath = o13, this.metaMessages = e17.metaMessages, this.name = e17.name ?? this.name, this.shortMessage = s15, this.version = o6;
  }
  walk(s15) {
    return d10(this, s15);
  }
};
function d10(a24, s15) {
  return s15 != null && s15(a24) ? a24 : a24 && typeof a24 == "object" && "cause" in a24 ? d10(a24.cause, s15) : s15 ? null : a24;
}

// node_modules/@catalogfi/wallets/dist/index70.js
var a13 = class extends t3 {
  constructor({ max: e17, min: r13, signed: i18, size: s15, value: o13 }) {
    super(`Number "${o13}" is not in safe ${s15 ? `${s15 * 8}-bit ${i18 ? "signed" : "unsigned"} ` : ""}integer range ${e17 ? `(${r13} to ${e17})` : `(above ${r13})`}`, { name: "IntegerOutOfRangeError" });
  }
};
var $4 = class extends t3 {
  constructor({ givenSize: e17, maxSize: r13 }) {
    super(`Size cannot exceed ${r13} bytes. Given size: ${e17} bytes.`, { name: "SizeOverflowError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index71.js
var import_dist838 = __toESM(require_dist(), 1);
var import_dist839 = __toESM(require_dist2(), 1);
var import_dist840 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index94.js
var import_dist835 = __toESM(require_dist(), 1);
var import_dist836 = __toESM(require_dist2(), 1);
var import_dist837 = __toESM(require_dist3(), 1);
var i9 = class extends t3 {
  constructor({ offset: s15, position: r13, size: e17 }) {
    super(`Slice ${r13 === "start" ? "starting" : "ending"} at offset "${s15}" is out-of-bounds (size: ${e17}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
};
var a14 = class extends t3 {
  constructor({ size: s15, targetSize: r13, type: e17 }) {
    super(`${e17.charAt(0).toUpperCase()}${e17.slice(1).toLowerCase()} size (${s15}) exceeds padding size (${r13}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index71.js
function l11(r13, { dir: i18, size: e17 = 32 } = {}) {
  return typeof r13 == "string" ? d11(r13, { dir: i18, size: e17 }) : o7(r13, { dir: i18, size: e17 });
}
function d11(r13, { dir: i18, size: e17 = 32 } = {}) {
  if (e17 === null) return r13;
  const t12 = r13.replace("0x", "");
  if (t12.length > e17 * 2) throw new a14({ size: Math.ceil(t12.length / 2), targetSize: e17, type: "hex" });
  return `0x${t12[i18 === "right" ? "padEnd" : "padStart"](e17 * 2, "0")}`;
}
function o7(r13, { dir: i18, size: e17 = 32 } = {}) {
  if (e17 === null) return r13;
  if (r13.length > e17) throw new a14({ size: r13.length, targetSize: e17, type: "bytes" });
  const t12 = new Uint8Array(e17);
  for (let n13 = 0; n13 < e17; n13++) {
    const s15 = i18 === "right";
    t12[s15 ? n13 : e17 - n13 - 1] = r13[s15 ? n13 : r13.length - n13 - 1];
  }
  return t12;
}

// node_modules/@catalogfi/wallets/dist/index55.js
var import_dist847 = __toESM(require_dist(), 1);
var import_dist848 = __toESM(require_dist2(), 1);
var import_dist849 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index74.js
var import_dist844 = __toESM(require_dist(), 1);
var import_dist845 = __toESM(require_dist2(), 1);
var import_dist846 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index75.js
var import_dist841 = __toESM(require_dist(), 1);
var import_dist842 = __toESM(require_dist2(), 1);
var import_dist843 = __toESM(require_dist3(), 1);
function e10(t12, { strict: s15 = true } = {}) {
  return !t12 || typeof t12 != "string" ? false : s15 ? /^0x[0-9a-fA-F]*$/.test(t12) : t12.startsWith("0x");
}

// node_modules/@catalogfi/wallets/dist/index74.js
function r7(e17) {
  return e10(e17, { strict: false }) ? Math.ceil((e17.length - 2) / 2) : e17.length;
}

// node_modules/@catalogfi/wallets/dist/index55.js
function o8(e17, { size: n13 }) {
  if (r7(e17) > n13) throw new $4({ givenSize: r7(e17), maxSize: n13 });
}
function s7(e17, n13 = {}) {
  const { signed: f17 } = n13;
  n13.size && o8(e17, { size: n13.size });
  const t12 = BigInt(e17);
  if (!f17) return t12;
  const r13 = (e17.length - 2) / 2, z10 = (1n << BigInt(r13) * 8n - 1n) - 1n;
  return t12 <= z10 ? t12 : t12 - BigInt(`0x${"f".padStart(r13 * 2, "f")}`) - 1n;
}
function u11(e17, n13 = {}) {
  return Number(s7(e17, n13));
}

// node_modules/@catalogfi/wallets/dist/index42.js
var x9 = Array.from({ length: 256 }, (t12, e17) => e17.toString(16).padStart(2, "0"));
function y8(t12, e17 = {}) {
  return typeof t12 == "number" || typeof t12 == "bigint" ? p12(t12, e17) : typeof t12 == "string" ? z5(t12, e17) : typeof t12 == "boolean" ? m11(t12, e17) : g8(t12, e17);
}
function m11(t12, e17 = {}) {
  const n13 = `0x${Number(t12)}`;
  return typeof e17.size == "number" ? (o8(n13, { size: e17.size }), l11(n13, { size: e17.size })) : n13;
}
function g8(t12, e17 = {}) {
  let n13 = "";
  for (let i18 = 0; i18 < t12.length; i18++) n13 += x9[t12[i18]];
  const o13 = `0x${n13}`;
  return typeof e17.size == "number" ? (o8(o13, { size: e17.size }), l11(o13, { dir: "right", size: e17.size })) : o13;
}
function p12(t12, e17 = {}) {
  const { signed: n13, size: o13 } = e17, i18 = BigInt(t12);
  let r13;
  o13 ? n13 ? r13 = (1n << BigInt(o13) * 8n - 1n) - 1n : r13 = 2n ** (BigInt(o13) * 8n) - 1n : typeof t12 == "number" && (r13 = BigInt(Number.MAX_SAFE_INTEGER));
  const u22 = typeof r13 == "bigint" && n13 ? -r13 - 1n : 0;
  if (r13 && i18 > r13 || i18 < u22) {
    const s15 = typeof t12 == "bigint" ? "n" : "";
    throw new a13({ max: r13 ? `${r13}${s15}` : void 0, min: `${u22}${s15}`, signed: n13, size: o13, value: `${t12}${s15}` });
  }
  const a24 = `0x${(n13 && i18 < 0 ? (1n << BigInt(o13 * 8)) + BigInt(i18) : i18).toString(16)}`;
  return o13 ? l11(a24, { size: o13 }) : a24;
}
var $5 = new TextEncoder();
function z5(t12, e17 = {}) {
  const n13 = $5.encode(t12);
  return g8(n13, e17);
}

// node_modules/@catalogfi/wallets/dist/index43.js
var import_dist1024 = __toESM(require_dist(), 1);
var import_dist1025 = __toESM(require_dist2(), 1);
var import_dist1026 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index44.js
var import_dist868 = __toESM(require_dist(), 1);
var import_dist869 = __toESM(require_dist2(), 1);
var import_dist870 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index68.js
var import_dist856 = __toESM(require_dist(), 1);
var import_dist857 = __toESM(require_dist2(), 1);
var import_dist858 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index95.js
var index95_exports = {};
__export(index95_exports, {
  abytes: () => p13,
  bitGet: () => H4,
  bitLen: () => C5,
  bitMask: () => V3,
  bitSet: () => q5,
  bytesToHex: () => d12,
  bytesToNumberBE: () => v5,
  bytesToNumberLE: () => S6,
  concatBytes: () => _8,
  createHmacDrbg: () => k6,
  ensureBytes: () => j3,
  equalBytes: () => F9,
  hexToBytes: () => b7,
  hexToNumber: () => w9,
  isBytes: () => l12,
  numberToBytesBE: () => A9,
  numberToBytesLE: () => L8,
  numberToHexUnpadded: () => B8,
  numberToVarBytesBE: () => N7,
  utf8ToBytes: () => O5,
  validateObject: () => G3
});
var import_dist853 = __toESM(require_dist(), 1);
var import_dist854 = __toESM(require_dist2(), 1);
var import_dist855 = __toESM(require_dist3(), 1);
var x10 = BigInt(0);
var h6 = BigInt(1);
var I6 = BigInt(2);
function l12(e17) {
  return e17 instanceof Uint8Array || e17 != null && typeof e17 == "object" && e17.constructor.name === "Uint8Array";
}
function p13(e17) {
  if (!l12(e17)) throw new Error("Uint8Array expected");
}
var T8 = Array.from({ length: 256 }, (e17, r13) => r13.toString(16).padStart(2, "0"));
function d12(e17) {
  p13(e17);
  let r13 = "";
  for (let o13 = 0; o13 < e17.length; o13++) r13 += T8[e17[o13]];
  return r13;
}
function B8(e17) {
  const r13 = e17.toString(16);
  return r13.length & 1 ? `0${r13}` : r13;
}
function w9(e17) {
  if (typeof e17 != "string") throw new Error("hex string expected, got " + typeof e17);
  return BigInt(e17 === "" ? "0" : `0x${e17}`);
}
var u12 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function E11(e17) {
  if (e17 >= u12._0 && e17 <= u12._9) return e17 - u12._0;
  if (e17 >= u12._A && e17 <= u12._F) return e17 - (u12._A - 10);
  if (e17 >= u12._a && e17 <= u12._f) return e17 - (u12._a - 10);
}
function b7(e17) {
  if (typeof e17 != "string") throw new Error("hex string expected, got " + typeof e17);
  const r13 = e17.length, o13 = r13 / 2;
  if (r13 % 2) throw new Error("padded hex string expected, got unpadded hex of length " + r13);
  const t12 = new Uint8Array(o13);
  for (let n13 = 0, i18 = 0; n13 < o13; n13++, i18 += 2) {
    const c10 = E11(e17.charCodeAt(i18)), s15 = E11(e17.charCodeAt(i18 + 1));
    if (c10 === void 0 || s15 === void 0) {
      const a24 = e17[i18] + e17[i18 + 1];
      throw new Error('hex string expected, got non-hex character "' + a24 + '" at index ' + i18);
    }
    t12[n13] = c10 * 16 + s15;
  }
  return t12;
}
function v5(e17) {
  return w9(d12(e17));
}
function S6(e17) {
  return p13(e17), w9(d12(Uint8Array.from(e17).reverse()));
}
function A9(e17, r13) {
  return b7(e17.toString(16).padStart(r13 * 2, "0"));
}
function L8(e17, r13) {
  return A9(e17, r13).reverse();
}
function N7(e17) {
  return b7(B8(e17));
}
function j3(e17, r13, o13) {
  let t12;
  if (typeof r13 == "string") try {
    t12 = b7(r13);
  } catch (i18) {
    throw new Error(`${e17} must be valid hex string, got "${r13}". Cause: ${i18}`);
  }
  else if (l12(r13)) t12 = Uint8Array.from(r13);
  else throw new Error(`${e17} must be hex string or Uint8Array`);
  const n13 = t12.length;
  if (typeof o13 == "number" && n13 !== o13) throw new Error(`${e17} expected ${o13} bytes, got ${n13}`);
  return t12;
}
function _8(...e17) {
  let r13 = 0;
  for (let t12 = 0; t12 < e17.length; t12++) {
    const n13 = e17[t12];
    p13(n13), r13 += n13.length;
  }
  const o13 = new Uint8Array(r13);
  for (let t12 = 0, n13 = 0; t12 < e17.length; t12++) {
    const i18 = e17[t12];
    o13.set(i18, n13), n13 += i18.length;
  }
  return o13;
}
function F9(e17, r13) {
  if (e17.length !== r13.length) return false;
  let o13 = 0;
  for (let t12 = 0; t12 < e17.length; t12++) o13 |= e17[t12] ^ r13[t12];
  return o13 === 0;
}
function O5(e17) {
  if (typeof e17 != "string") throw new Error(`utf8ToBytes expected string, got ${typeof e17}`);
  return new Uint8Array(new TextEncoder().encode(e17));
}
function C5(e17) {
  let r13;
  for (r13 = 0; e17 > x10; e17 >>= h6, r13 += 1) ;
  return r13;
}
function H4(e17, r13) {
  return e17 >> BigInt(r13) & h6;
}
function q5(e17, r13, o13) {
  return e17 | (o13 ? h6 : x10) << BigInt(r13);
}
var V3 = (e17) => (I6 << BigInt(e17 - 1)) - h6;
var m12 = (e17) => new Uint8Array(e17);
var $6 = (e17) => Uint8Array.from(e17);
function k6(e17, r13, o13) {
  if (typeof e17 != "number" || e17 < 2) throw new Error("hashLen must be a number");
  if (typeof r13 != "number" || r13 < 2) throw new Error("qByteLen must be a number");
  if (typeof o13 != "function") throw new Error("hmacFn must be a function");
  let t12 = m12(e17), n13 = m12(e17), i18 = 0;
  const c10 = () => {
    t12.fill(1), n13.fill(0), i18 = 0;
  }, s15 = (...f17) => o13(n13, t12, ...f17), a24 = (f17 = m12()) => {
    n13 = s15($6([0]), f17), t12 = s15(), f17.length !== 0 && (n13 = s15($6([1]), f17), t12 = s15());
  }, U6 = () => {
    if (i18++ >= 1e3) throw new Error("drbg: tried 1000 values");
    let f17 = 0;
    const g15 = [];
    for (; f17 < r13; ) {
      t12 = s15();
      const y13 = t12.slice();
      g15.push(y13), f17 += t12.length;
    }
    return _8(...g15);
  };
  return (f17, g15) => {
    c10(), a24(f17);
    let y13;
    for (; !(y13 = g15(U6())); ) a24();
    return c10(), y13;
  };
}
var D4 = { bigint: (e17) => typeof e17 == "bigint", function: (e17) => typeof e17 == "function", boolean: (e17) => typeof e17 == "boolean", string: (e17) => typeof e17 == "string", stringOrUint8Array: (e17) => typeof e17 == "string" || l12(e17), isSafeInteger: (e17) => Number.isSafeInteger(e17), array: (e17) => Array.isArray(e17), field: (e17, r13) => r13.Fp.isValid(e17), hash: (e17) => typeof e17 == "function" && Number.isSafeInteger(e17.outputLen) };
function G3(e17, r13, o13 = {}) {
  const t12 = (n13, i18, c10) => {
    const s15 = D4[i18];
    if (typeof s15 != "function") throw new Error(`Invalid validator "${i18}", expected function`);
    const a24 = e17[n13];
    if (!(c10 && a24 === void 0) && !s15(a24, e17)) throw new Error(`Invalid param ${String(n13)}=${a24} (${typeof a24}), expected ${i18}`);
  };
  for (const [n13, i18] of Object.entries(r13)) t12(n13, i18, false);
  for (const [n13, i18] of Object.entries(o13)) t12(n13, i18, true);
  return e17;
}

// node_modules/@catalogfi/wallets/dist/index68.js
var a15 = BigInt(0);
var l13 = BigInt(1);
var d13 = BigInt(2);
var A10 = BigInt(3);
var m13 = BigInt(4);
var I7 = BigInt(5);
var S7 = BigInt(8);
BigInt(9), BigInt(16);
function g9(n13, t12) {
  const e17 = n13 % t12;
  return e17 >= a15 ? e17 : t12 + e17;
}
function x11(n13, t12, e17) {
  if (e17 <= a15 || t12 < a15) throw new Error("Expected power/modulo > 0");
  if (e17 === l13) return a15;
  let o13 = l13;
  for (; t12 > a15; ) t12 & l13 && (o13 = o13 * n13 % e17), n13 = n13 * n13 % e17, t12 >>= l13;
  return o13;
}
function Z2(n13, t12, e17) {
  let o13 = n13;
  for (; t12-- > a15; ) o13 *= o13, o13 %= e17;
  return o13;
}
function B9(n13, t12) {
  if (n13 === a15 || t12 <= a15) throw new Error(`invert: expected positive integers, got n=${n13} mod=${t12}`);
  let e17 = g9(n13, t12), o13 = t12, s15 = a15, u22 = l13;
  for (; e17 !== a15; ) {
    const i18 = o13 / e17, c10 = o13 % e17, r13 = s15 - u22 * i18;
    o13 = e17, e17 = c10, s15 = u22, u22 = r13;
  }
  if (o13 !== l13) throw new Error("invert: does not exist");
  return g9(s15, t12);
}
function F10(n13) {
  const t12 = (n13 - l13) / d13;
  let e17, o13, s15;
  for (e17 = n13 - l13, o13 = 0; e17 % d13 === a15; e17 /= d13, o13++) ;
  for (s15 = d13; s15 < n13 && x11(s15, t12, n13) !== n13 - l13; s15++) ;
  if (o13 === 1) {
    const i18 = (n13 + l13) / m13;
    return function(c10, r13) {
      const f17 = c10.pow(r13, i18);
      if (!c10.eql(c10.sqr(f17), r13)) throw new Error("Cannot find square root");
      return f17;
    };
  }
  const u22 = (e17 + l13) / d13;
  return function(i18, c10) {
    if (i18.pow(c10, t12) === i18.neg(i18.ONE)) throw new Error("Cannot find square root");
    let r13 = o13, f17 = i18.pow(i18.mul(i18.ONE, s15), e17), w13 = i18.pow(c10, u22), h11 = i18.pow(c10, e17);
    for (; !i18.eql(h11, i18.ONE); ) {
      if (i18.eql(h11, i18.ZERO)) return i18.ZERO;
      let E14 = 1;
      for (let p20 = i18.sqr(h11); E14 < r13 && !i18.eql(p20, i18.ONE); E14++) p20 = i18.sqr(p20);
      const b10 = i18.pow(f17, l13 << BigInt(r13 - E14 - 1));
      f17 = i18.sqr(b10), w13 = i18.mul(w13, b10), h11 = i18.mul(h11, f17), r13 = E14;
    }
    return w13;
  };
}
function L9(n13) {
  if (n13 % m13 === A10) {
    const t12 = (n13 + l13) / m13;
    return function(e17, o13) {
      const s15 = e17.pow(o13, t12);
      if (!e17.eql(e17.sqr(s15), o13)) throw new Error("Cannot find square root");
      return s15;
    };
  }
  if (n13 % S7 === I7) {
    const t12 = (n13 - I7) / S7;
    return function(e17, o13) {
      const s15 = e17.mul(o13, d13), u22 = e17.pow(s15, t12), i18 = e17.mul(o13, u22), c10 = e17.mul(e17.mul(i18, d13), u22), r13 = e17.mul(i18, e17.sub(c10, e17.ONE));
      if (!e17.eql(e17.sqr(r13), o13)) throw new Error("Cannot find square root");
      return r13;
    };
  }
  return F10(n13);
}
var k7 = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function z6(n13) {
  const t12 = { ORDER: "bigint", MASK: "bigint", BYTES: "isSafeInteger", BITS: "isSafeInteger" }, e17 = k7.reduce((o13, s15) => (o13[s15] = "function", o13), t12);
  return G3(n13, e17);
}
function R3(n13, t12, e17) {
  if (e17 < a15) throw new Error("Expected power > 0");
  if (e17 === a15) return n13.ONE;
  if (e17 === l13) return t12;
  let o13 = n13.ONE, s15 = t12;
  for (; e17 > a15; ) e17 & l13 && (o13 = n13.mul(o13, s15)), s15 = n13.sqr(s15), e17 >>= l13;
  return o13;
}
function T9(n13, t12) {
  const e17 = new Array(t12.length), o13 = t12.reduce((u22, i18, c10) => n13.is0(i18) ? u22 : (e17[c10] = u22, n13.mul(u22, i18)), n13.ONE), s15 = n13.inv(o13);
  return t12.reduceRight((u22, i18, c10) => n13.is0(i18) ? u22 : (e17[c10] = n13.mul(u22, e17[c10]), n13.mul(u22, i18)), s15), e17;
}
function $7(n13, t12) {
  const e17 = t12 !== void 0 ? t12 : n13.toString(2).length, o13 = Math.ceil(e17 / 8);
  return { nBitLength: e17, nByteLength: o13 };
}
function D5(n13, t12, e17 = false, o13 = {}) {
  if (n13 <= a15) throw new Error(`Expected Field ORDER > 0, got ${n13}`);
  const { nBitLength: s15, nByteLength: u22 } = $7(n13, t12);
  if (u22 > 2048) throw new Error("Field lengths over 2048 bytes are not supported");
  const i18 = L9(n13), c10 = Object.freeze({ ORDER: n13, BITS: s15, BYTES: u22, MASK: V3(s15), ZERO: a15, ONE: l13, create: (r13) => g9(r13, n13), isValid: (r13) => {
    if (typeof r13 != "bigint") throw new Error(`Invalid field element: expected bigint, got ${typeof r13}`);
    return a15 <= r13 && r13 < n13;
  }, is0: (r13) => r13 === a15, isOdd: (r13) => (r13 & l13) === l13, neg: (r13) => g9(-r13, n13), eql: (r13, f17) => r13 === f17, sqr: (r13) => g9(r13 * r13, n13), add: (r13, f17) => g9(r13 + f17, n13), sub: (r13, f17) => g9(r13 - f17, n13), mul: (r13, f17) => g9(r13 * f17, n13), pow: (r13, f17) => R3(c10, r13, f17), div: (r13, f17) => g9(r13 * B9(f17, n13), n13), sqrN: (r13) => r13 * r13, addN: (r13, f17) => r13 + f17, subN: (r13, f17) => r13 - f17, mulN: (r13, f17) => r13 * f17, inv: (r13) => B9(r13, n13), sqrt: o13.sqrt || ((r13) => i18(c10, r13)), invertBatch: (r13) => T9(c10, r13), cmov: (r13, f17, w13) => w13 ? f17 : r13, toBytes: (r13) => e17 ? L8(r13, u22) : A9(r13, u22), fromBytes: (r13) => {
    if (r13.length !== u22) throw new Error(`Fp.fromBytes: expected ${u22}, got ${r13.length}`);
    return e17 ? S6(r13) : v5(r13);
  } });
  return Object.freeze(c10);
}
function q6(n13) {
  if (typeof n13 != "bigint") throw new Error("field order must be bigint");
  const t12 = n13.toString(2).length;
  return Math.ceil(t12 / 8);
}
function M5(n13) {
  const t12 = q6(n13);
  return t12 + Math.ceil(t12 / 2);
}
function H5(n13, t12, e17 = false) {
  const o13 = n13.length, s15 = q6(t12), u22 = M5(t12);
  if (o13 < 16 || o13 < u22 || o13 > 1024) throw new Error(`expected ${u22}-1024 bytes of input, got ${o13}`);
  const i18 = e17 ? v5(n13) : S6(n13), c10 = g9(i18, t12 - l13) + l13;
  return e17 ? L8(c10, s15) : A9(c10, s15);
}

// node_modules/@catalogfi/wallets/dist/index69.js
var import_dist865 = __toESM(require_dist(), 1);
var import_dist866 = __toESM(require_dist2(), 1);
var import_dist867 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index96.js
var import_dist862 = __toESM(require_dist(), 1);
var import_dist863 = __toESM(require_dist2(), 1);
var import_dist864 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index97.js
var import_dist859 = __toESM(require_dist(), 1);
var import_dist860 = __toESM(require_dist2(), 1);
var import_dist861 = __toESM(require_dist3(), 1);
var A11 = BigInt(0);
var u13 = BigInt(1);
function z7(r13, h11) {
  const l23 = (e17, t12) => {
    const n13 = t12.negate();
    return e17 ? n13 : t12;
  }, g15 = (e17) => {
    const t12 = Math.ceil(h11 / e17) + 1, n13 = 2 ** (e17 - 1);
    return { windows: t12, windowSize: n13 };
  };
  return { constTimeNegate: l23, unsafeLadder(e17, t12) {
    let n13 = r13.ZERO, d20 = e17;
    for (; t12 > A11; ) t12 & u13 && (n13 = n13.add(d20)), d20 = d20.double(), t12 >>= u13;
    return n13;
  }, precomputeWindow(e17, t12) {
    const { windows: n13, windowSize: d20 } = g15(t12), s15 = [];
    let o13 = e17, i18 = o13;
    for (let c10 = 0; c10 < n13; c10++) {
      i18 = o13, s15.push(i18);
      for (let w13 = 1; w13 < d20; w13++) i18 = i18.add(o13), s15.push(i18);
      o13 = i18.double();
    }
    return s15;
  }, wNAF(e17, t12, n13) {
    const { windows: d20, windowSize: s15 } = g15(e17);
    let o13 = r13.ZERO, i18 = r13.BASE;
    const c10 = BigInt(2 ** e17 - 1), w13 = 2 ** e17, B12 = BigInt(e17);
    for (let f17 = 0; f17 < d20; f17++) {
      const p20 = f17 * s15;
      let a24 = Number(n13 & c10);
      n13 >>= B12, a24 > s15 && (a24 -= w13, n13 += u13);
      const b10 = p20, m17 = p20 + Math.abs(a24) - 1, I10 = f17 % 2 !== 0, F11 = a24 < 0;
      a24 === 0 ? i18 = i18.add(l23(I10, t12[b10])) : o13 = o13.add(l23(F11, t12[m17]));
    }
    return { p: o13, f: i18 };
  }, wNAFCached(e17, t12, n13, d20) {
    const s15 = e17._WINDOW_SIZE || 1;
    let o13 = t12.get(e17);
    return o13 || (o13 = this.precomputeWindow(e17, s15), s15 !== 1 && t12.set(e17, d20(o13))), this.wNAF(s15, o13, n13);
  } };
}
function E12(r13) {
  return z6(r13.Fp), G3(r13, { n: "bigint", h: "bigint", Gx: "field", Gy: "field" }, { nBitLength: "isSafeInteger", nByteLength: "isSafeInteger" }), Object.freeze({ ...$7(r13.n, r13.nBitLength), ...r13, p: r13.Fp.ORDER });
}

// node_modules/@catalogfi/wallets/dist/index96.js
function Bt2(v8) {
  const n13 = E12(v8);
  G3(n13, { a: "field", b: "field" }, { allowedPrivateKeyLengths: "array", wrapPrivateKey: "boolean", isTorsionFree: "function", clearCofactor: "function", allowInfinityPoint: "boolean", fromBytes: "function", toBytes: "function" });
  const { endo: t12, Fp: B12, a: O9 } = n13;
  if (t12) {
    if (!B12.eql(O9, B12.ZERO)) throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof t12 != "object" || typeof t12.beta != "bigint" || typeof t12.splitScalar != "function") throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...n13 });
}
var { bytesToNumberBE: St2, hexToBytes: xt2 } = index95_exports;
var j4 = { Err: class extends Error {
  constructor(v8 = "") {
    super(v8);
  }
}, _parseInt(v8) {
  const { Err: n13 } = j4;
  if (v8.length < 2 || v8[0] !== 2) throw new n13("Invalid signature integer tag");
  const t12 = v8[1], B12 = v8.subarray(2, t12 + 2);
  if (!t12 || B12.length !== t12) throw new n13("Invalid signature integer: wrong length");
  if (B12[0] & 128) throw new n13("Invalid signature integer: negative");
  if (B12[0] === 0 && !(B12[1] & 128)) throw new n13("Invalid signature integer: unnecessary leading zero");
  return { d: St2(B12), l: v8.subarray(t12 + 2) };
}, toSig(v8) {
  const { Err: n13 } = j4, t12 = typeof v8 == "string" ? xt2(v8) : v8;
  p13(t12);
  let B12 = t12.length;
  if (B12 < 2 || t12[0] != 48) throw new n13("Invalid signature tag");
  if (t12[1] !== B12 - 2) throw new n13("Invalid signature: incorrect length");
  const { d: O9, l: T14 } = j4._parseInt(t12.subarray(2)), { d: K7, l: x15 } = j4._parseInt(T14);
  if (x15.length) throw new n13("Invalid signature: left bytes after parsing");
  return { r: O9, s: K7 };
}, hexFromSig(v8) {
  const n13 = (S8) => Number.parseInt(S8[0], 16) & 8 ? "00" + S8 : S8, t12 = (S8) => {
    const H7 = S8.toString(16);
    return H7.length & 1 ? `0${H7}` : H7;
  }, B12 = n13(t12(v8.s)), O9 = n13(t12(v8.r)), T14 = B12.length / 2, K7 = O9.length / 2, x15 = t12(T14), C7 = t12(K7);
  return `30${t12(K7 + T14 + 4)}02${C7}${O9}02${x15}${B12}`;
} };
var L10 = BigInt(0);
var z8 = BigInt(1);
BigInt(2);
var dt2 = BigInt(3);
BigInt(4);
function ht2(v8) {
  const n13 = Bt2(v8), { Fp: t12 } = n13, B12 = n13.toBytes || ((p20, r13, s15) => {
    const o13 = r13.toAffine();
    return _8(Uint8Array.from([4]), t12.toBytes(o13.x), t12.toBytes(o13.y));
  }), O9 = n13.fromBytes || ((p20) => {
    const r13 = p20.subarray(1), s15 = t12.fromBytes(r13.subarray(0, t12.BYTES)), o13 = t12.fromBytes(r13.subarray(t12.BYTES, 2 * t12.BYTES));
    return { x: s15, y: o13 };
  });
  function T14(p20) {
    const { a: r13, b: s15 } = n13, o13 = t12.sqr(p20), c10 = t12.mul(o13, p20);
    return t12.add(t12.add(c10, t12.mul(p20, r13)), s15);
  }
  if (!t12.eql(t12.sqr(n13.Gy), T14(n13.Gx))) throw new Error("bad generator point: equation left != right");
  function K7(p20) {
    return typeof p20 == "bigint" && L10 < p20 && p20 < n13.n;
  }
  function x15(p20) {
    if (!K7(p20)) throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function C7(p20) {
    const { allowedPrivateKeyLengths: r13, nByteLength: s15, wrapPrivateKey: o13, n: c10 } = n13;
    if (r13 && typeof p20 != "bigint") {
      if (l12(p20) && (p20 = d12(p20)), typeof p20 != "string" || !r13.includes(p20.length)) throw new Error("Invalid key");
      p20 = p20.padStart(s15 * 2, "0");
    }
    let f17;
    try {
      f17 = typeof p20 == "bigint" ? p20 : v5(j3("private key", p20, s15));
    } catch {
      throw new Error(`private key must be ${s15} bytes, hex or bigint, not ${typeof p20}`);
    }
    return o13 && (f17 = g9(f17, c10)), x15(f17), f17;
  }
  const S8 = /* @__PURE__ */ new Map();
  function H7(p20) {
    if (!(p20 instanceof w13)) throw new Error("ProjectivePoint expected");
  }
  class w13 {
    constructor(r13, s15, o13) {
      if (this.px = r13, this.py = s15, this.pz = o13, r13 == null || !t12.isValid(r13)) throw new Error("x required");
      if (s15 == null || !t12.isValid(s15)) throw new Error("y required");
      if (o13 == null || !t12.isValid(o13)) throw new Error("z required");
    }
    static fromAffine(r13) {
      const { x: s15, y: o13 } = r13 || {};
      if (!r13 || !t12.isValid(s15) || !t12.isValid(o13)) throw new Error("invalid affine point");
      if (r13 instanceof w13) throw new Error("projective point not allowed");
      const c10 = (f17) => t12.eql(f17, t12.ZERO);
      return c10(s15) && c10(o13) ? w13.ZERO : new w13(s15, o13, t12.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(r13) {
      const s15 = t12.invertBatch(r13.map((o13) => o13.pz));
      return r13.map((o13, c10) => o13.toAffine(s15[c10])).map(w13.fromAffine);
    }
    static fromHex(r13) {
      const s15 = w13.fromAffine(O9(j3("pointHex", r13)));
      return s15.assertValidity(), s15;
    }
    static fromPrivateKey(r13) {
      return w13.BASE.multiply(C7(r13));
    }
    _setWindowSize(r13) {
      this._WINDOW_SIZE = r13, S8.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (n13.allowInfinityPoint && !t12.is0(this.py)) return;
        throw new Error("bad point: ZERO");
      }
      const { x: r13, y: s15 } = this.toAffine();
      if (!t12.isValid(r13) || !t12.isValid(s15)) throw new Error("bad point: x or y not FE");
      const o13 = t12.sqr(s15), c10 = T14(r13);
      if (!t12.eql(o13, c10)) throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree()) throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: r13 } = this.toAffine();
      if (t12.isOdd) return !t12.isOdd(r13);
      throw new Error("Field doesn't support isOdd");
    }
    equals(r13) {
      H7(r13);
      const { px: s15, py: o13, pz: c10 } = this, { px: f17, py: g15, pz: h11 } = r13, a24 = t12.eql(t12.mul(s15, h11), t12.mul(f17, c10)), u22 = t12.eql(t12.mul(o13, h11), t12.mul(g15, c10));
      return a24 && u22;
    }
    negate() {
      return new w13(this.px, t12.neg(this.py), this.pz);
    }
    double() {
      const { a: r13, b: s15 } = n13, o13 = t12.mul(s15, dt2), { px: c10, py: f17, pz: g15 } = this;
      let h11 = t12.ZERO, a24 = t12.ZERO, u22 = t12.ZERO, d20 = t12.mul(c10, c10), Z3 = t12.mul(f17, f17), E14 = t12.mul(g15, g15), y13 = t12.mul(c10, f17);
      return y13 = t12.add(y13, y13), u22 = t12.mul(c10, g15), u22 = t12.add(u22, u22), h11 = t12.mul(r13, u22), a24 = t12.mul(o13, E14), a24 = t12.add(h11, a24), h11 = t12.sub(Z3, a24), a24 = t12.add(Z3, a24), a24 = t12.mul(h11, a24), h11 = t12.mul(y13, h11), u22 = t12.mul(o13, u22), E14 = t12.mul(r13, E14), y13 = t12.sub(d20, E14), y13 = t12.mul(r13, y13), y13 = t12.add(y13, u22), u22 = t12.add(d20, d20), d20 = t12.add(u22, d20), d20 = t12.add(d20, E14), d20 = t12.mul(d20, y13), a24 = t12.add(a24, d20), E14 = t12.mul(f17, g15), E14 = t12.add(E14, E14), d20 = t12.mul(E14, y13), h11 = t12.sub(h11, d20), u22 = t12.mul(E14, Z3), u22 = t12.add(u22, u22), u22 = t12.add(u22, u22), new w13(h11, a24, u22);
    }
    add(r13) {
      H7(r13);
      const { px: s15, py: o13, pz: c10 } = this, { px: f17, py: g15, pz: h11 } = r13;
      let a24 = t12.ZERO, u22 = t12.ZERO, d20 = t12.ZERO;
      const Z3 = n13.a, E14 = t12.mul(n13.b, dt2);
      let y13 = t12.mul(s15, f17), P6 = t12.mul(o13, g15), I10 = t12.mul(c10, h11), $9 = t12.add(s15, o13), e17 = t12.add(f17, g15);
      $9 = t12.mul($9, e17), e17 = t12.add(y13, P6), $9 = t12.sub($9, e17), e17 = t12.add(s15, c10);
      let i18 = t12.add(f17, h11);
      return e17 = t12.mul(e17, i18), i18 = t12.add(y13, I10), e17 = t12.sub(e17, i18), i18 = t12.add(o13, c10), a24 = t12.add(g15, h11), i18 = t12.mul(i18, a24), a24 = t12.add(P6, I10), i18 = t12.sub(i18, a24), d20 = t12.mul(Z3, e17), a24 = t12.mul(E14, I10), d20 = t12.add(a24, d20), a24 = t12.sub(P6, d20), d20 = t12.add(P6, d20), u22 = t12.mul(a24, d20), P6 = t12.add(y13, y13), P6 = t12.add(P6, y13), I10 = t12.mul(Z3, I10), e17 = t12.mul(E14, e17), P6 = t12.add(P6, I10), I10 = t12.sub(y13, I10), I10 = t12.mul(Z3, I10), e17 = t12.add(e17, I10), y13 = t12.mul(P6, e17), u22 = t12.add(u22, y13), y13 = t12.mul(i18, e17), a24 = t12.mul($9, a24), a24 = t12.sub(a24, y13), y13 = t12.mul($9, P6), d20 = t12.mul(i18, d20), d20 = t12.add(d20, y13), new w13(a24, u22, d20);
    }
    subtract(r13) {
      return this.add(r13.negate());
    }
    is0() {
      return this.equals(w13.ZERO);
    }
    wNAF(r13) {
      return U6.wNAFCached(this, S8, r13, (s15) => {
        const o13 = t12.invertBatch(s15.map((c10) => c10.pz));
        return s15.map((c10, f17) => c10.toAffine(o13[f17])).map(w13.fromAffine);
      });
    }
    multiplyUnsafe(r13) {
      const s15 = w13.ZERO;
      if (r13 === L10) return s15;
      if (x15(r13), r13 === z8) return this;
      const { endo: o13 } = n13;
      if (!o13) return U6.unsafeLadder(this, r13);
      let { k1neg: c10, k1: f17, k2neg: g15, k2: h11 } = o13.splitScalar(r13), a24 = s15, u22 = s15, d20 = this;
      for (; f17 > L10 || h11 > L10; ) f17 & z8 && (a24 = a24.add(d20)), h11 & z8 && (u22 = u22.add(d20)), d20 = d20.double(), f17 >>= z8, h11 >>= z8;
      return c10 && (a24 = a24.negate()), g15 && (u22 = u22.negate()), u22 = new w13(t12.mul(u22.px, o13.beta), u22.py, u22.pz), a24.add(u22);
    }
    multiply(r13) {
      x15(r13);
      let s15 = r13, o13, c10;
      const { endo: f17 } = n13;
      if (f17) {
        const { k1neg: g15, k1: h11, k2neg: a24, k2: u22 } = f17.splitScalar(s15);
        let { p: d20, f: Z3 } = this.wNAF(h11), { p: E14, f: y13 } = this.wNAF(u22);
        d20 = U6.constTimeNegate(g15, d20), E14 = U6.constTimeNegate(a24, E14), E14 = new w13(t12.mul(E14.px, f17.beta), E14.py, E14.pz), o13 = d20.add(E14), c10 = Z3.add(y13);
      } else {
        const { p: g15, f: h11 } = this.wNAF(s15);
        o13 = g15, c10 = h11;
      }
      return w13.normalizeZ([o13, c10])[0];
    }
    multiplyAndAddUnsafe(r13, s15, o13) {
      const c10 = w13.BASE, f17 = (h11, a24) => a24 === L10 || a24 === z8 || !h11.equals(c10) ? h11.multiplyUnsafe(a24) : h11.multiply(a24), g15 = f17(this, s15).add(f17(r13, o13));
      return g15.is0() ? void 0 : g15;
    }
    toAffine(r13) {
      const { px: s15, py: o13, pz: c10 } = this, f17 = this.is0();
      r13 == null && (r13 = f17 ? t12.ONE : t12.inv(c10));
      const g15 = t12.mul(s15, r13), h11 = t12.mul(o13, r13), a24 = t12.mul(c10, r13);
      if (f17) return { x: t12.ZERO, y: t12.ZERO };
      if (!t12.eql(a24, t12.ONE)) throw new Error("invZ was invalid");
      return { x: g15, y: h11 };
    }
    isTorsionFree() {
      const { h: r13, isTorsionFree: s15 } = n13;
      if (r13 === z8) return true;
      if (s15) return s15(w13, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: r13, clearCofactor: s15 } = n13;
      return r13 === z8 ? this : s15 ? s15(w13, this) : this.multiplyUnsafe(n13.h);
    }
    toRawBytes(r13 = true) {
      return this.assertValidity(), B12(w13, this, r13);
    }
    toHex(r13 = true) {
      return d12(this.toRawBytes(r13));
    }
  }
  w13.BASE = new w13(n13.Gx, n13.Gy, t12.ONE), w13.ZERO = new w13(t12.ZERO, t12.ONE, t12.ZERO);
  const W2 = n13.nBitLength, U6 = z7(w13, n13.endo ? Math.ceil(W2 / 2) : W2);
  return { CURVE: n13, ProjectivePoint: w13, normPrivateKeyToScalar: C7, weierstrassEquation: T14, isWithinCurveOrder: K7 };
}
function Rt2(v8) {
  const n13 = E12(v8);
  return G3(n13, { hash: "hash", hmac: "function", randomBytes: "function" }, { bits2int: "function", bits2int_modN: "function", lowS: "boolean" }), Object.freeze({ lowS: true, ...n13 });
}
function At2(v8) {
  const n13 = Rt2(v8), { Fp: t12, n: B12 } = n13, O9 = t12.BYTES + 1, T14 = 2 * t12.BYTES + 1;
  function K7(e17) {
    return L10 < e17 && e17 < t12.ORDER;
  }
  function x15(e17) {
    return g9(e17, B12);
  }
  function C7(e17) {
    return B9(e17, B12);
  }
  const { ProjectivePoint: S8, normPrivateKeyToScalar: H7, weierstrassEquation: w13, isWithinCurveOrder: W2 } = ht2({ ...n13, toBytes(e17, i18, l23) {
    const b10 = i18.toAffine(), m17 = t12.toBytes(b10.x), R5 = _8;
    return l23 ? R5(Uint8Array.from([i18.hasEvenY() ? 2 : 3]), m17) : R5(Uint8Array.from([4]), m17, t12.toBytes(b10.y));
  }, fromBytes(e17) {
    const i18 = e17.length, l23 = e17[0], b10 = e17.subarray(1);
    if (i18 === O9 && (l23 === 2 || l23 === 3)) {
      const m17 = v5(b10);
      if (!K7(m17)) throw new Error("Point is not on curve");
      const R5 = w13(m17);
      let q9;
      try {
        q9 = t12.sqrt(R5);
      } catch (F11) {
        const N10 = F11 instanceof Error ? ": " + F11.message : "";
        throw new Error("Point is not on curve" + N10);
      }
      const A13 = (q9 & z8) === z8;
      return (l23 & 1) === 1 !== A13 && (q9 = t12.neg(q9)), { x: m17, y: q9 };
    } else if (i18 === T14 && l23 === 4) {
      const m17 = t12.fromBytes(b10.subarray(0, t12.BYTES)), R5 = t12.fromBytes(b10.subarray(t12.BYTES, 2 * t12.BYTES));
      return { x: m17, y: R5 };
    } else throw new Error(`Point of length ${i18} was invalid. Expected ${O9} compressed bytes or ${T14} uncompressed bytes`);
  } }), U6 = (e17) => d12(A9(e17, n13.nByteLength));
  function p20(e17) {
    const i18 = B12 >> z8;
    return e17 > i18;
  }
  function r13(e17) {
    return p20(e17) ? x15(-e17) : e17;
  }
  const s15 = (e17, i18, l23) => v5(e17.slice(i18, l23));
  class o13 {
    constructor(i18, l23, b10) {
      this.r = i18, this.s = l23, this.recovery = b10, this.assertValidity();
    }
    static fromCompact(i18) {
      const l23 = n13.nByteLength;
      return i18 = j3("compactSignature", i18, l23 * 2), new o13(s15(i18, 0, l23), s15(i18, l23, 2 * l23));
    }
    static fromDER(i18) {
      const { r: l23, s: b10 } = j4.toSig(j3("DER", i18));
      return new o13(l23, b10);
    }
    assertValidity() {
      if (!W2(this.r)) throw new Error("r must be 0 < r < CURVE.n");
      if (!W2(this.s)) throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(i18) {
      return new o13(this.r, this.s, i18);
    }
    recoverPublicKey(i18) {
      const { r: l23, s: b10, recovery: m17 } = this, R5 = u22(j3("msgHash", i18));
      if (m17 == null || ![0, 1, 2, 3].includes(m17)) throw new Error("recovery id invalid");
      const q9 = m17 === 2 || m17 === 3 ? l23 + n13.n : l23;
      if (q9 >= t12.ORDER) throw new Error("recovery id 2 or 3 invalid");
      const A13 = m17 & 1 ? "03" : "02", F11 = S8.fromHex(A13 + U6(q9)), N10 = C7(q9), G6 = x15(-R5 * N10), X = x15(b10 * N10), Y = S8.BASE.multiplyAndAddUnsafe(F11, G6, X);
      if (!Y) throw new Error("point at infinify");
      return Y.assertValidity(), Y;
    }
    hasHighS() {
      return p20(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new o13(this.r, x15(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return b7(this.toDERHex());
    }
    toDERHex() {
      return j4.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return b7(this.toCompactHex());
    }
    toCompactHex() {
      return U6(this.r) + U6(this.s);
    }
  }
  const c10 = { isValidPrivateKey(e17) {
    try {
      return H7(e17), true;
    } catch {
      return false;
    }
  }, normPrivateKeyToScalar: H7, randomPrivateKey: () => {
    const e17 = M5(n13.n);
    return H5(n13.randomBytes(e17), n13.n);
  }, precompute(e17 = 8, i18 = S8.BASE) {
    return i18._setWindowSize(e17), i18.multiply(BigInt(3)), i18;
  } };
  function f17(e17, i18 = true) {
    return S8.fromPrivateKey(e17).toRawBytes(i18);
  }
  function g15(e17) {
    const i18 = l12(e17), l23 = typeof e17 == "string", b10 = (i18 || l23) && e17.length;
    return i18 ? b10 === O9 || b10 === T14 : l23 ? b10 === 2 * O9 || b10 === 2 * T14 : e17 instanceof S8;
  }
  function h11(e17, i18, l23 = true) {
    if (g15(e17)) throw new Error("first arg must be private key");
    if (!g15(i18)) throw new Error("second arg must be public key");
    return S8.fromHex(i18).multiply(H7(e17)).toRawBytes(l23);
  }
  const a24 = n13.bits2int || function(e17) {
    const i18 = v5(e17), l23 = e17.length * 8 - n13.nBitLength;
    return l23 > 0 ? i18 >> BigInt(l23) : i18;
  }, u22 = n13.bits2int_modN || function(e17) {
    return x15(a24(e17));
  }, d20 = V3(n13.nBitLength);
  function Z3(e17) {
    if (typeof e17 != "bigint") throw new Error("bigint expected");
    if (!(L10 <= e17 && e17 < d20)) throw new Error(`bigint expected < 2^${n13.nBitLength}`);
    return A9(e17, n13.nByteLength);
  }
  function E14(e17, i18, l23 = y13) {
    if (["recovered", "canonical"].some((D7) => D7 in l23)) throw new Error("sign() legacy options not supported");
    const { hash: b10, randomBytes: m17 } = n13;
    let { lowS: R5, prehash: q9, extraEntropy: A13 } = l23;
    R5 == null && (R5 = true), e17 = j3("msgHash", e17), q9 && (e17 = j3("prehashed msgHash", b10(e17)));
    const F11 = u22(e17), N10 = H7(i18), G6 = [Z3(N10), Z3(F11)];
    if (A13 != null && A13 !== false) {
      const D7 = A13 === true ? m17(t12.BYTES) : A13;
      G6.push(j3("extraEntropy", D7));
    }
    const X = _8(...G6), Y = F11;
    function et(D7) {
      const M8 = a24(D7);
      if (!W2(M8)) return;
      const J3 = C7(M8), V4 = S8.BASE.multiply(M8).toAffine(), Q2 = x15(V4.x);
      if (Q2 === L10) return;
      const _10 = x15(J3 * x15(Y + Q2 * N10));
      if (_10 === L10) return;
      let ot = (V4.x === Q2 ? 0 : 2) | Number(V4.y & z8), st = _10;
      return R5 && p20(_10) && (st = r13(_10), ot ^= 1), new o13(Q2, st, ot);
    }
    return { seed: X, k2sig: et };
  }
  const y13 = { lowS: n13.lowS, prehash: false }, P6 = { lowS: n13.lowS, prehash: false };
  function I10(e17, i18, l23 = y13) {
    const { seed: b10, k2sig: m17 } = E14(e17, i18, l23), R5 = n13;
    return k6(R5.hash.outputLen, R5.nByteLength, R5.hmac)(b10, m17);
  }
  S8.BASE._setWindowSize(8);
  function $9(e17, i18, l23, b10 = P6) {
    var J3;
    const m17 = e17;
    if (i18 = j3("msgHash", i18), l23 = j3("publicKey", l23), "strict" in b10) throw new Error("options.strict was renamed to lowS");
    const { lowS: R5, prehash: q9 } = b10;
    let A13, F11;
    try {
      if (typeof m17 == "string" || l12(m17)) try {
        A13 = o13.fromDER(m17);
      } catch (V4) {
        if (!(V4 instanceof j4.Err)) throw V4;
        A13 = o13.fromCompact(m17);
      }
      else if (typeof m17 == "object" && typeof m17.r == "bigint" && typeof m17.s == "bigint") {
        const { r: V4, s: Q2 } = m17;
        A13 = new o13(V4, Q2);
      } else throw new Error("PARSE");
      F11 = S8.fromHex(l23);
    } catch (V4) {
      if (V4.message === "PARSE") throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return false;
    }
    if (R5 && A13.hasHighS()) return false;
    q9 && (i18 = n13.hash(i18));
    const { r: N10, s: G6 } = A13, X = u22(i18), Y = C7(G6), et = x15(X * Y), D7 = x15(N10 * Y), M8 = (J3 = S8.BASE.multiplyAndAddUnsafe(F11, et, D7)) == null ? void 0 : J3.toAffine();
    return M8 ? x15(M8.x) === N10 : false;
  }
  return { CURVE: n13, getPublicKey: f17, getSharedSecret: h11, sign: I10, verify: $9, ProjectivePoint: S8, Signature: o13, utils: c10 };
}

// node_modules/@catalogfi/wallets/dist/index69.js
function a16(e17) {
  return { hash: e17, hmac: (t12, ...r13) => d6(e17, t12, U(...r13)), randomBytes: V };
}
function f7(e17, t12) {
  const r13 = (s15) => At2({ ...e17, ...a16(s15) });
  return Object.freeze({ ...r13(t12), create: r13 });
}

// node_modules/@catalogfi/wallets/dist/index44.js
var u14 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var q7 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var N8 = BigInt(1);
var l14 = BigInt(2);
var v6 = (t12, f17) => (t12 + f17 / l14) / f17;
function O6(t12) {
  const f17 = u14, o13 = BigInt(3), c10 = BigInt(6), d20 = BigInt(11), g15 = BigInt(22), a24 = BigInt(23), r13 = BigInt(44), B12 = BigInt(88), i18 = t12 * t12 * t12 % f17, n13 = i18 * i18 * t12 % f17, I10 = Z2(n13, o13, f17) * n13 % f17, s15 = Z2(I10, o13, f17) * n13 % f17, x15 = Z2(s15, l14, f17) * i18 % f17, p20 = Z2(x15, d20, f17) * x15 % f17, b10 = Z2(p20, g15, f17) * p20 % f17, k9 = Z2(b10, r13, f17) * b10 % f17, S8 = Z2(k9, B12, f17) * k9 % f17, C7 = Z2(S8, r13, f17) * b10 % f17, F11 = Z2(C7, o13, f17) * n13 % f17, G6 = Z2(F11, a24, f17) * p20 % f17, P6 = Z2(G6, c10, f17) * i18 % f17, w13 = Z2(P6, l14, f17);
  if (!m14.eql(m14.sqr(w13), t12)) throw new Error("Cannot find square root");
  return w13;
}
var m14 = D5(u14, void 0, void 0, { sqrt: O6 });
var E13 = f7({ a: BigInt(0), b: BigInt(7), Fp: m14, n: q7, Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"), Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"), h: BigInt(1), lowS: true, endo: { beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"), splitScalar: (t12) => {
  const f17 = q7, o13 = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), c10 = -N8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), d20 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), g15 = o13, a24 = BigInt("0x100000000000000000000000000000000"), r13 = v6(g15 * t12, f17), B12 = v6(-c10 * t12, f17);
  let i18 = g9(t12 - r13 * o13 - B12 * d20, f17), n13 = g9(-r13 * c10 - B12 * g15, f17);
  const I10 = i18 > a24, s15 = n13 > a24;
  if (I10 && (i18 = f17 - i18), s15 && (n13 = f17 - n13), i18 > a24 || n13 > a24) throw new Error("splitScalar: Endomorphism failed, k=" + t12);
  return { k1neg: I10, k1: i18, k2neg: s15, k2: n13 };
} } }, F5);
BigInt(0), E13.ProjectivePoint;

// node_modules/@catalogfi/wallets/dist/index45.js
var import_dist892 = __toESM(require_dist(), 1);
var import_dist893 = __toESM(require_dist2(), 1);
var import_dist894 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index52.js
var import_dist871 = __toESM(require_dist(), 1);
var import_dist872 = __toESM(require_dist2(), 1);
var import_dist873 = __toESM(require_dist3(), 1);
var e11 = class extends t3 {
  constructor({ address: s15 }) {
    super(`Address "${s15}" is invalid.`, { metaMessages: ["- Address must be a hex value of 20 bytes (40 hex characters).", "- Address must match its checksum counterpart."], name: "InvalidAddressError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index53.js
var import_dist889 = __toESM(require_dist(), 1);
var import_dist890 = __toESM(require_dist2(), 1);
var import_dist891 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index73.js
var import_dist874 = __toESM(require_dist(), 1);
var import_dist875 = __toESM(require_dist2(), 1);
var import_dist876 = __toESM(require_dist3(), 1);
var t4 = class extends Map {
  constructor(e17) {
    super(), Object.defineProperty(this, "maxSize", { enumerable: true, configurable: true, writable: true, value: void 0 }), this.maxSize = e17;
  }
  set(e17, s15) {
    return super.set(e17, s15), this.maxSize && this.size > this.maxSize && this.delete(this.keys().next().value), this;
  }
};

// node_modules/@catalogfi/wallets/dist/index62.js
var import_dist886 = __toESM(require_dist(), 1);
var import_dist887 = __toESM(require_dist2(), 1);
var import_dist888 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index56.js
var import_dist877 = __toESM(require_dist(), 1);
var import_dist878 = __toESM(require_dist2(), 1);
var import_dist879 = __toESM(require_dist3(), 1);
var B10 = new TextEncoder();
function T10(r13, e17 = {}) {
  return typeof r13 == "number" || typeof r13 == "bigint" ? d14(r13, e17) : typeof r13 == "boolean" ? p14(r13, e17) : e10(r13) ? u15(r13, e17) : l15(r13, e17);
}
function p14(r13, e17 = {}) {
  const t12 = new Uint8Array(1);
  return t12[0] = Number(r13), typeof e17.size == "number" ? (o8(t12, { size: e17.size }), l11(t12, { size: e17.size })) : t12;
}
var i10 = { zero: 48, nine: 57, A: 65, F: 70, a: 97, f: 102 };
function b8(r13) {
  if (r13 >= i10.zero && r13 <= i10.nine) return r13 - i10.zero;
  if (r13 >= i10.A && r13 <= i10.F) return r13 - (i10.A - 10);
  if (r13 >= i10.a && r13 <= i10.f) return r13 - (i10.a - 10);
}
function u15(r13, e17 = {}) {
  let t12 = r13;
  e17.size && (o8(t12, { size: e17.size }), t12 = l11(t12, { dir: "right", size: e17.size }));
  let o13 = t12.slice(2);
  o13.length % 2 && (o13 = `0${o13}`);
  const c10 = o13.length / 2, z10 = new Uint8Array(c10);
  for (let n13 = 0, s15 = 0; n13 < c10; n13++) {
    const m17 = b8(o13.charCodeAt(s15++)), y13 = b8(o13.charCodeAt(s15++));
    if (m17 === void 0 || y13 === void 0) throw new t3(`Invalid byte sequence ("${o13[s15 - 2]}${o13[s15 - 1]}" in "${o13}").`);
    z10[n13] = m17 * 16 + y13;
  }
  return z10;
}
function d14(r13, e17) {
  const t12 = p12(r13, e17);
  return u15(t12);
}
function l15(r13, e17 = {}) {
  const t12 = B10.encode(r13);
  return typeof e17.size == "number" ? (o8(t12, { size: e17.size }), l11(t12, { dir: "right", size: e17.size })) : t12;
}

// node_modules/@catalogfi/wallets/dist/index59.js
var import_dist883 = __toESM(require_dist(), 1);
var import_dist884 = __toESM(require_dist2(), 1);
var import_dist885 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index79.js
var import_dist880 = __toESM(require_dist(), 1);
var import_dist881 = __toESM(require_dist2(), 1);
var import_dist882 = __toESM(require_dist3(), 1);
var y9 = [];
var I8 = [];
var L11 = [];
var j5 = BigInt(0);
var u16 = BigInt(1);
var q8 = BigInt(2);
var v7 = BigInt(7);
var z9 = BigInt(256);
var D6 = BigInt(113);
for (let o13 = 0, t12 = u16, s15 = 1, n13 = 0; o13 < 24; o13++) {
  [s15, n13] = [n13, (2 * s15 + 3 * n13) % 5], y9.push(2 * (5 * n13 + s15)), I8.push((o13 + 1) * (o13 + 2) / 2 % 64);
  let e17 = j5;
  for (let r13 = 0; r13 < 7; r13++) t12 = (t12 << u16 ^ (t12 >> v7) * D6) % z9, t12 & q8 && (e17 ^= u16 << (u16 << BigInt(r13)) - u16);
  L11.push(e17);
}
var [G4, K5] = e9(L11, true);
var O7 = (o13, t12, s15) => s15 > 32 ? I3(o13, t12, s15) : m6(o13, t12, s15);
var g10 = (o13, t12, s15) => s15 > 32 ? N3(o13, t12, s15) : b4(o13, t12, s15);
function x12(o13, t12 = 24) {
  const s15 = new Uint32Array(10);
  for (let n13 = 24 - t12; n13 < 24; n13++) {
    for (let i18 = 0; i18 < 10; i18++) s15[i18] = o13[i18] ^ o13[i18 + 10] ^ o13[i18 + 20] ^ o13[i18 + 30] ^ o13[i18 + 40];
    for (let i18 = 0; i18 < 10; i18 += 2) {
      const h11 = (i18 + 8) % 10, c10 = (i18 + 2) % 10, f17 = s15[c10], a24 = s15[c10 + 1], B12 = O7(f17, a24, 1) ^ s15[h11], m17 = g10(f17, a24, 1) ^ s15[h11 + 1];
      for (let l23 = 0; l23 < 50; l23 += 10) o13[i18 + l23] ^= B12, o13[i18 + l23 + 1] ^= m17;
    }
    let e17 = o13[2], r13 = o13[3];
    for (let i18 = 0; i18 < 24; i18++) {
      const h11 = I8[i18], c10 = O7(e17, r13, h11), f17 = g10(e17, r13, h11), a24 = y9[i18];
      e17 = o13[a24], r13 = o13[a24 + 1], o13[a24] = c10, o13[a24 + 1] = f17;
    }
    for (let i18 = 0; i18 < 50; i18 += 10) {
      for (let h11 = 0; h11 < 10; h11++) s15[h11] = o13[i18 + h11];
      for (let h11 = 0; h11 < 10; h11++) o13[i18 + h11] ^= ~s15[(h11 + 2) % 10] & s15[(h11 + 4) % 10];
    }
    o13[0] ^= G4[n13], o13[1] ^= K5[n13];
  }
  s15.fill(0);
}
var p15 = class _p extends B {
  constructor(t12, s15, n13, e17 = false, r13 = 24) {
    if (super(), this.blockLen = t12, this.suffix = s15, this.outputLen = n13, this.enableXOF = e17, this.rounds = r13, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, e3(n13), 0 >= this.blockLen || this.blockLen >= 200) throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = p5(this.state);
  }
  keccak() {
    x3 || A2(this.state32), x12(this.state32, this.rounds), x3 || A2(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t12) {
    a8(this);
    const { blockLen: s15, state: n13 } = this;
    t12 = d4(t12);
    const e17 = t12.length;
    for (let r13 = 0; r13 < e17; ) {
      const i18 = Math.min(s15 - this.pos, e17 - r13);
      for (let h11 = 0; h11 < i18; h11++) n13[this.pos++] ^= t12[r13++];
      this.pos === s15 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished) return;
    this.finished = true;
    const { state: t12, suffix: s15, pos: n13, blockLen: e17 } = this;
    t12[n13] ^= s15, s15 & 128 && n13 === e17 - 1 && this.keccak(), t12[e17 - 1] ^= 128, this.keccak();
  }
  writeInto(t12) {
    a8(this, false), s4(t12), this.finish();
    const s15 = this.state, { blockLen: n13 } = this;
    for (let e17 = 0, r13 = t12.length; e17 < r13; ) {
      this.posOut >= n13 && this.keccak();
      const i18 = Math.min(n13 - this.posOut, r13 - e17);
      t12.set(s15.subarray(this.posOut, this.posOut + i18), e17), this.posOut += i18, e17 += i18;
    }
    return t12;
  }
  xofInto(t12) {
    if (!this.enableXOF) throw new Error("XOF is not possible for this instance");
    return this.writeInto(t12);
  }
  xof(t12) {
    return e3(t12), this.xofInto(new Uint8Array(t12));
  }
  digestInto(t12) {
    if (f3(t12, this), this.finished) throw new Error("digest() was already called");
    return this.writeInto(t12), this.destroy(), t12;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t12) {
    const { blockLen: s15, suffix: n13, outputLen: e17, rounds: r13, enableXOF: i18 } = this;
    return t12 || (t12 = new _p(s15, n13, e17, i18, r13)), t12.state32.set(this.state32), t12.pos = this.pos, t12.posOut = this.posOut, t12.finished = this.finished, t12.rounds = r13, t12.suffix = n13, t12.outputLen = e17, t12.enableXOF = i18, t12.destroyed = this.destroyed, t12;
  }
};
var Q = (o13, t12, s15) => T4(() => new p15(t12, o13, s15));
var R4 = Q(1, 136, 256 / 8);

// node_modules/@catalogfi/wallets/dist/index59.js
function a17(o13, t12) {
  const s15 = t12 || "hex", r13 = R4(e10(o13, { strict: false }) ? T10(o13) : o13);
  return s15 === "bytes" ? r13 : y8(r13);
}

// node_modules/@catalogfi/wallets/dist/index62.js
var o9 = new t4(8192);
function f8(e17, s15) {
  if (o9.has(`${e17}.${s15}`)) return o9.get(`${e17}.${s15}`);
  const n13 = e17.substring(2).toLowerCase(), a24 = a17(l15(n13), "bytes"), r13 = n13.split("");
  for (let t12 = 0; t12 < 40; t12 += 2) a24[t12 >> 1] >> 4 >= 8 && r13[t12] && (r13[t12] = r13[t12].toUpperCase()), (a24[t12 >> 1] & 15) >= 8 && r13[t12 + 1] && (r13[t12 + 1] = r13[t12 + 1].toUpperCase());
  const p20 = `0x${r13.join("")}`;
  return o9.set(`${e17}.${s15}`, p20), p20;
}

// node_modules/@catalogfi/wallets/dist/index53.js
var i11 = /^0x[a-fA-F0-9]{40}$/;
var r8 = new t4(8192);
function d15(s15, a24) {
  const { strict: o13 = true } = a24 ?? {}, e17 = `${s15}.${o13}`;
  if (r8.has(e17)) return r8.get(e17);
  const t12 = i11.test(s15) ? s15.toLowerCase() === s15 ? true : o13 ? f8(s15) === s15 : true : false;
  return r8.set(e17, t12), t12;
}

// node_modules/@catalogfi/wallets/dist/index45.js
function a18(s15) {
  if (typeof s15 == "string") {
    if (!d15(s15, { strict: false })) throw new e11({ address: s15 });
    return { address: s15, type: "json-rpc" };
  }
  if (!d15(s15.address, { strict: false })) throw new e11({ address: s15.address });
  return { address: s15.address, nonceManager: s15.nonceManager, sign: s15.sign, experimental_signAuthorization: s15.experimental_signAuthorization, signMessage: s15.signMessage, signTransaction: s15.signTransaction, signTypedData: s15.signTypedData, source: "custom", type: "local" };
}

// node_modules/@catalogfi/wallets/dist/index46.js
var import_dist895 = __toESM(require_dist(), 1);
var import_dist896 = __toESM(require_dist2(), 1);
var import_dist897 = __toESM(require_dist3(), 1);
function t5(s15) {
  const r13 = a17(`0x${s15.substring(4)}`).substring(26);
  return f8(`0x${r13}`);
}

// node_modules/@catalogfi/wallets/dist/index47.js
var import_dist901 = __toESM(require_dist(), 1);
var import_dist902 = __toESM(require_dist2(), 1);
var import_dist903 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index54.js
var import_dist898 = __toESM(require_dist(), 1);
var import_dist899 = __toESM(require_dist2(), 1);
var import_dist900 = __toESM(require_dist3(), 1);
function u17({ r: e17, s: i18, to: a24 = "hex", v: r13, yParity: t12 }) {
  const s15 = (() => {
    if (t12 === 0 || t12 === 1) return t12;
    if (r13 && (r13 === 27n || r13 === 28n || r13 >= 35n)) return r13 % 2n === 0n ? 1 : 0;
    throw new Error("Invalid `v` or `yParity` value");
  })(), n13 = `0x${new E13.Signature(s7(e17), s7(i18)).toCompactHex()}${s15 === 0 ? "1b" : "1c"}`;
  return a24 === "hex" ? n13 : u15(n13);
}

// node_modules/@catalogfi/wallets/dist/index47.js
async function y10({ hash: o13, privateKey: t12, to: e17 = "object" }) {
  const { r: n13, s: a24, recovery: s15 } = E13.sign(o13.slice(2), t12.slice(2)), i18 = { r: p12(n13, { size: 32 }), s: p12(a24, { size: 32 }), v: s15 ? 28n : 27n, yParity: s15 };
  return e17 === "bytes" || e17 === "hex" ? u17({ ...i18, to: e17 }) : i18;
}

// node_modules/@catalogfi/wallets/dist/index48.js
var import_dist919 = __toESM(require_dist(), 1);
var import_dist920 = __toESM(require_dist2(), 1);
var import_dist921 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index57.js
var import_dist916 = __toESM(require_dist(), 1);
var import_dist917 = __toESM(require_dist2(), 1);
var import_dist918 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index76.js
var import_dist904 = __toESM(require_dist(), 1);
var import_dist905 = __toESM(require_dist2(), 1);
var import_dist906 = __toESM(require_dist3(), 1);
function s8(n13) {
  return typeof n13[0] == "string" ? f9(n13) : r9(n13);
}
function r9(n13) {
  let e17 = 0;
  for (const o13 of n13) e17 += o13.length;
  const t12 = new Uint8Array(e17);
  let c10 = 0;
  for (const o13 of n13) t12.set(o13, c10), c10 += o13.length;
  return t12;
}
function f9(n13) {
  return `0x${n13.reduce((e17, t12) => e17 + t12.replace("0x", ""), "")}`;
}

// node_modules/@catalogfi/wallets/dist/index77.js
var import_dist913 = __toESM(require_dist(), 1);
var import_dist914 = __toESM(require_dist2(), 1);
var import_dist915 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index99.js
var import_dist910 = __toESM(require_dist(), 1);
var import_dist911 = __toESM(require_dist2(), 1);
var import_dist912 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index110.js
var import_dist907 = __toESM(require_dist(), 1);
var import_dist908 = __toESM(require_dist2(), 1);
var import_dist909 = __toESM(require_dist3(), 1);
var t6 = class extends t3 {
  constructor({ offset: e17 }) {
    super(`Offset \`${e17}\` cannot be negative.`, { name: "NegativeOffsetError" });
  }
};
var i12 = class extends t3 {
  constructor({ length: e17, position: r13 }) {
    super(`Position \`${r13}\` is out of bounds (\`0 < position < ${e17}\`).`, { name: "PositionOutOfBoundsError" });
  }
};
var n10 = class extends t3 {
  constructor({ count: e17, limit: r13 }) {
    super(`Recursive read limit of \`${r13}\` exceeded (recursive read count: \`${e17}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index99.js
var h7 = { bytes: new Uint8Array(), dataView: new DataView(new ArrayBuffer(0)), position: 0, positionReadCount: /* @__PURE__ */ new Map(), recursiveReadCount: 0, recursiveReadLimit: Number.POSITIVE_INFINITY, assertReadLimit() {
  if (this.recursiveReadCount >= this.recursiveReadLimit) throw new n10({ count: this.recursiveReadCount + 1, limit: this.recursiveReadLimit });
}, assertPosition(t12) {
  if (t12 < 0 || t12 > this.bytes.length - 1) throw new i12({ length: this.bytes.length, position: t12 });
}, decrementPosition(t12) {
  if (t12 < 0) throw new t6({ offset: t12 });
  const i18 = this.position - t12;
  this.assertPosition(i18), this.position = i18;
}, getReadCount(t12) {
  return this.positionReadCount.get(t12 || this.position) || 0;
}, incrementPosition(t12) {
  if (t12 < 0) throw new t6({ offset: t12 });
  const i18 = this.position + t12;
  this.assertPosition(i18), this.position = i18;
}, inspectByte(t12) {
  const i18 = t12 ?? this.position;
  return this.assertPosition(i18), this.bytes[i18];
}, inspectBytes(t12, i18) {
  const s15 = i18 ?? this.position;
  return this.assertPosition(s15 + t12 - 1), this.bytes.subarray(s15, s15 + t12);
}, inspectUint8(t12) {
  const i18 = t12 ?? this.position;
  return this.assertPosition(i18), this.bytes[i18];
}, inspectUint16(t12) {
  const i18 = t12 ?? this.position;
  return this.assertPosition(i18 + 1), this.dataView.getUint16(i18);
}, inspectUint24(t12) {
  const i18 = t12 ?? this.position;
  return this.assertPosition(i18 + 2), (this.dataView.getUint16(i18) << 8) + this.dataView.getUint8(i18 + 2);
}, inspectUint32(t12) {
  const i18 = t12 ?? this.position;
  return this.assertPosition(i18 + 3), this.dataView.getUint32(i18);
}, pushByte(t12) {
  this.assertPosition(this.position), this.bytes[this.position] = t12, this.position++;
}, pushBytes(t12) {
  this.assertPosition(this.position + t12.length - 1), this.bytes.set(t12, this.position), this.position += t12.length;
}, pushUint8(t12) {
  this.assertPosition(this.position), this.bytes[this.position] = t12, this.position++;
}, pushUint16(t12) {
  this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, t12), this.position += 2;
}, pushUint24(t12) {
  this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, t12 >> 8), this.dataView.setUint8(this.position + 2, t12 & 255), this.position += 3;
}, pushUint32(t12) {
  this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, t12), this.position += 4;
}, readByte() {
  this.assertReadLimit(), this._touch();
  const t12 = this.inspectByte();
  return this.position++, t12;
}, readBytes(t12, i18) {
  this.assertReadLimit(), this._touch();
  const s15 = this.inspectBytes(t12);
  return this.position += i18 ?? t12, s15;
}, readUint8() {
  this.assertReadLimit(), this._touch();
  const t12 = this.inspectUint8();
  return this.position += 1, t12;
}, readUint16() {
  this.assertReadLimit(), this._touch();
  const t12 = this.inspectUint16();
  return this.position += 2, t12;
}, readUint24() {
  this.assertReadLimit(), this._touch();
  const t12 = this.inspectUint24();
  return this.position += 3, t12;
}, readUint32() {
  this.assertReadLimit(), this._touch();
  const t12 = this.inspectUint32();
  return this.position += 4, t12;
}, get remaining() {
  return this.bytes.length - this.position;
}, setPosition(t12) {
  const i18 = this.position;
  return this.assertPosition(t12), this.position = t12, () => this.position = i18;
}, _touch() {
  if (this.recursiveReadLimit === Number.POSITIVE_INFINITY) return;
  const t12 = this.getReadCount();
  this.positionReadCount.set(this.position, t12 + 1), t12 > 0 && this.recursiveReadCount++;
} };
function r10(t12, { recursiveReadLimit: i18 = 8192 } = {}) {
  const s15 = Object.create(h7);
  return s15.bytes = t12, s15.dataView = new DataView(t12.buffer, t12.byteOffset, t12.byteLength), s15.positionReadCount = /* @__PURE__ */ new Map(), s15.recursiveReadLimit = i18, s15;
}

// node_modules/@catalogfi/wallets/dist/index77.js
function l16(n13, e17 = "hex") {
  const r13 = s9(n13), t12 = r10(new Uint8Array(r13.length));
  return r13.encode(t12), e17 === "hex" ? g8(t12.bytes) : t12.bytes;
}
function s9(n13) {
  return Array.isArray(n13) ? f10(n13.map((e17) => s9(e17))) : y11(n13);
}
function f10(n13) {
  const e17 = n13.reduce((t12, h11) => t12 + h11.length, 0), r13 = o10(e17);
  return { length: e17 <= 55 ? 1 + e17 : 1 + r13 + e17, encode(t12) {
    e17 <= 55 ? t12.pushByte(192 + e17) : (t12.pushByte(247 + r13), r13 === 1 ? t12.pushUint8(e17) : r13 === 2 ? t12.pushUint16(e17) : r13 === 3 ? t12.pushUint24(e17) : t12.pushUint32(e17));
    for (const { encode: h11 } of n13) h11(t12);
  } };
}
function y11(n13) {
  const e17 = typeof n13 == "string" ? u15(n13) : n13, r13 = o10(e17.length);
  return { length: e17.length === 1 && e17[0] < 128 ? 1 : e17.length <= 55 ? 1 + e17.length : 1 + r13 + e17.length, encode(t12) {
    e17.length === 1 && e17[0] < 128 ? t12.pushBytes(e17) : e17.length <= 55 ? (t12.pushByte(128 + e17.length), t12.pushBytes(e17)) : (t12.pushByte(183 + r13), r13 === 1 ? t12.pushUint8(e17.length) : r13 === 2 ? t12.pushUint16(e17.length) : r13 === 3 ? t12.pushUint24(e17.length) : t12.pushUint32(e17.length), t12.pushBytes(e17));
  } };
}
function o10(n13) {
  if (n13 < 2 ** 8) return 1;
  if (n13 < 2 ** 16) return 2;
  if (n13 < 2 ** 24) return 3;
  if (n13 < 2 ** 32) return 4;
  throw new t3("Length is too large.");
}

// node_modules/@catalogfi/wallets/dist/index57.js
function p16(r13) {
  const { chainId: a24, contractAddress: s15, nonce: e17, to: m17 } = r13, o13 = a17(f9(["0x05", l16([p12(a24), s15, p12(e17)])]));
  return m17 === "bytes" ? u15(o13) : o13;
}

// node_modules/@catalogfi/wallets/dist/index48.js
async function d16(c10) {
  const { contractAddress: t12, chainId: n13, nonce: o13, privateKey: e17, to: a24 = "object" } = c10, r13 = await y10({ hash: p16({ contractAddress: t12, chainId: n13, nonce: o13 }), privateKey: e17, to: a24 });
  return a24 === "object" ? { contractAddress: t12, chainId: n13, nonce: o13, ...r13 } : r13;
}

// node_modules/@catalogfi/wallets/dist/index49.js
var import_dist931 = __toESM(require_dist(), 1);
var import_dist932 = __toESM(require_dist2(), 1);
var import_dist933 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index58.js
var import_dist928 = __toESM(require_dist(), 1);
var import_dist929 = __toESM(require_dist2(), 1);
var import_dist930 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index78.js
var import_dist925 = __toESM(require_dist(), 1);
var import_dist926 = __toESM(require_dist2(), 1);
var import_dist927 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index100.js
var import_dist922 = __toESM(require_dist(), 1);
var import_dist923 = __toESM(require_dist2(), 1);
var import_dist924 = __toESM(require_dist3(), 1);
var e12 = `Ethereum Signed Message:
`;

// node_modules/@catalogfi/wallets/dist/index78.js
function n11(o13) {
  const e17 = typeof o13 == "string" ? z5(o13) : typeof o13.raw == "string" ? o13.raw : g8(o13.raw), t12 = z5(`${e12}${r7(e17)}`);
  return s8([t12, e17]);
}

// node_modules/@catalogfi/wallets/dist/index58.js
function a19(e17, o13) {
  return a17(n11(e17), o13);
}

// node_modules/@catalogfi/wallets/dist/index49.js
async function r11({ message: e17, privateKey: s15 }) {
  return await y10({ hash: a19(e17), privateKey: s15, to: "hex" });
}

// node_modules/@catalogfi/wallets/dist/index50.js
var import_dist1003 = __toESM(require_dist(), 1);
var import_dist1004 = __toESM(require_dist2(), 1);
var import_dist1005 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index60.js
var import_dist1000 = __toESM(require_dist(), 1);
var import_dist1001 = __toESM(require_dist2(), 1);
var import_dist1002 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index80.js
var import_dist934 = __toESM(require_dist(), 1);
var import_dist935 = __toESM(require_dist2(), 1);
var import_dist936 = __toESM(require_dist3(), 1);
function o11(t12) {
  const a24 = Object.entries(t12).map(([e17, r13]) => r13 === void 0 || r13 === false ? null : [e17, r13]).filter(Boolean), i18 = a24.reduce((e17, [r13]) => Math.max(e17, r13.length), 0);
  return a24.map(([e17, r13]) => `  ${`${e17}:`.padEnd(i18 + 1)}  ${r13}`).join(`
`);
}
var s10 = class extends t3 {
  constructor({ v: a24 }) {
    super(`Invalid \`v\` value "${a24}". Expected 27 or 28.`, { name: "InvalidLegacyVError" });
  }
};
var c7 = class extends t3 {
  constructor({ transaction: a24 }) {
    super("Cannot infer a transaction type from provided transaction.", { metaMessages: ["Provided Transaction:", "{", o11(a24), "}", "", "To infer the type, either provide:", "- a `type` to the Transaction, or", "- an EIP-1559 Transaction with `maxFeePerGas`, or", "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or", "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or", "- an EIP-7702 Transaction with `authorizationList`, or", "- a Legacy Transaction with `gasPrice`"], name: "InvalidSerializableTransactionError" });
  }
};
var l17 = class extends t3 {
  constructor({ storageKey: a24 }) {
    super(`Size for storage key "${a24}" is invalid. Expected 32 bytes. Got ${Math.floor((a24.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index81.js
var import_dist937 = __toESM(require_dist(), 1);
var import_dist938 = __toESM(require_dist2(), 1);
var import_dist939 = __toESM(require_dist3(), 1);
function f11(t12) {
  const { kzg: b10 } = t12, m17 = t12.to ?? (typeof t12.blobs[0] == "string" ? "hex" : "bytes"), e17 = typeof t12.blobs[0] == "string" ? t12.blobs.map((o13) => u15(o13)) : t12.blobs, s15 = [];
  for (const o13 of e17) s15.push(Uint8Array.from(b10.blobToKzgCommitment(o13)));
  return m17 === "bytes" ? s15 : s15.map((o13) => g8(o13));
}

// node_modules/@catalogfi/wallets/dist/index82.js
var import_dist940 = __toESM(require_dist(), 1);
var import_dist941 = __toESM(require_dist2(), 1);
var import_dist942 = __toESM(require_dist3(), 1);
function l18(s15) {
  const { kzg: r13 } = s15, b10 = s15.to ?? (typeof s15.blobs[0] == "string" ? "hex" : "bytes"), m17 = typeof s15.blobs[0] == "string" ? s15.blobs.map((o13) => u15(o13)) : s15.blobs, n13 = typeof s15.commitments[0] == "string" ? s15.commitments.map((o13) => u15(o13)) : s15.commitments, t12 = [];
  for (let o13 = 0; o13 < m17.length; o13++) {
    const f17 = m17[o13], i18 = n13[o13];
    t12.push(Uint8Array.from(r13.computeBlobKzgProof(f17, i18)));
  }
  return b10 === "bytes" ? t12 : t12.map((o13) => g8(o13));
}

// node_modules/@catalogfi/wallets/dist/index83.js
var import_dist949 = __toESM(require_dist(), 1);
var import_dist950 = __toESM(require_dist2(), 1);
var import_dist951 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index101.js
var import_dist946 = __toESM(require_dist(), 1);
var import_dist947 = __toESM(require_dist2(), 1);
var import_dist948 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index114.js
var import_dist943 = __toESM(require_dist(), 1);
var import_dist944 = __toESM(require_dist2(), 1);
var import_dist945 = __toESM(require_dist3(), 1);
function i13(r13, a24) {
  return F5(e10(r13, { strict: false }) ? T10(r13) : r13);
}

// node_modules/@catalogfi/wallets/dist/index101.js
function i14(t12) {
  const { commitment: e17, version: s15 = 1 } = t12, m17 = t12.to ?? (typeof e17 == "string" ? "hex" : "bytes"), o13 = i13(e17);
  return o13.set([s15], 0), m17 === "bytes" ? o13 : g8(o13);
}

// node_modules/@catalogfi/wallets/dist/index83.js
function r12(o13) {
  const { commitments: t12, version: s15 } = o13, m17 = o13.to ?? (typeof t12[0] == "string" ? "hex" : "bytes"), e17 = [];
  for (const n13 of t12) e17.push(i14({ commitment: n13, to: m17, version: s15 }));
  return e17;
}

// node_modules/@catalogfi/wallets/dist/index84.js
var import_dist964 = __toESM(require_dist(), 1);
var import_dist965 = __toESM(require_dist2(), 1);
var import_dist966 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index102.js
var import_dist961 = __toESM(require_dist(), 1);
var import_dist962 = __toESM(require_dist2(), 1);
var import_dist963 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index115.js
var import_dist952 = __toESM(require_dist(), 1);
var import_dist953 = __toESM(require_dist2(), 1);
var import_dist954 = __toESM(require_dist3(), 1);
var e13 = 32;
var s11 = 4096;
var t7 = 131072;
var a20 = 761855;

// node_modules/@catalogfi/wallets/dist/index104.js
var import_dist958 = __toESM(require_dist(), 1);
var import_dist959 = __toESM(require_dist2(), 1);
var import_dist960 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index103.js
var import_dist955 = __toESM(require_dist(), 1);
var import_dist956 = __toESM(require_dist2(), 1);
var import_dist957 = __toESM(require_dist3(), 1);
var e14 = 1;

// node_modules/@catalogfi/wallets/dist/index104.js
var i15 = class extends t3 {
  constructor({ maxSize: e17, size: s15 }) {
    super("Blob size is too large.", { metaMessages: [`Max: ${e17} bytes`, `Given: ${s15} bytes`], name: "BlobSizeTooLargeError" });
  }
};
var n12 = class extends t3 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var t8 = class extends t3 {
  constructor({ hash: e17, size: s15 }) {
    super(`Versioned hash "${e17}" size is invalid.`, { metaMessages: ["Expected: 32", `Received: ${s15}`], name: "InvalidVersionedHashSizeError" });
  }
};
var d17 = class extends t3 {
  constructor({ hash: e17, version: s15 }) {
    super(`Versioned hash "${e17}" version is invalid.`, { metaMessages: [`Expected: ${e14}`, `Received: ${s15}`], name: "InvalidVersionedHashVersionError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index102.js
function w10(e17) {
  const y13 = e17.to ?? (typeof e17.data == "string" ? "hex" : "bytes"), a24 = typeof e17.data == "string" ? u15(e17.data) : e17.data, o13 = r7(a24);
  if (!o13) throw new n12();
  if (o13 > a20) throw new i15({ maxSize: a20, size: o13 });
  const r13 = [];
  let i18 = true, s15 = 0;
  for (; i18; ) {
    const t12 = r10(new Uint8Array(t7));
    let m17 = 0;
    for (; m17 < s11; ) {
      const n13 = a24.slice(s15, s15 + (e13 - 1));
      if (t12.pushByte(0), t12.pushBytes(n13), n13.length < 31) {
        t12.pushByte(128), i18 = false;
        break;
      }
      m17++, s15 += 31;
    }
    r13.push(t12);
  }
  return y13 === "bytes" ? r13.map((t12) => t12.bytes) : r13.map((t12) => g8(t12.bytes));
}

// node_modules/@catalogfi/wallets/dist/index84.js
function p17(t12) {
  const { data: i18, kzg: b10, to: s15 } = t12, m17 = t12.blobs ?? w10({ data: i18, to: s15 }), r13 = t12.commitments ?? f11({ blobs: m17, kzg: b10, to: s15 }), n13 = t12.proofs ?? l18({ blobs: m17, commitments: r13, kzg: b10, to: s15 }), l23 = [];
  for (let o13 = 0; o13 < m17.length; o13++) l23.push({ blob: m17[o13], commitment: r13[o13], proof: n13[o13] });
  return l23;
}

// node_modules/@catalogfi/wallets/dist/index85.js
var import_dist967 = __toESM(require_dist(), 1);
var import_dist968 = __toESM(require_dist2(), 1);
var import_dist969 = __toESM(require_dist3(), 1);
function g11(e17, { dir: r13 = "left" } = {}) {
  let t12 = typeof e17 == "string" ? e17.replace("0x", "") : e17, i18 = 0;
  for (let l23 = 0; l23 < t12.length - 1 && t12[r13 === "left" ? l23 : t12.length - l23 - 1].toString() === "0"; l23++) i18++;
  return t12 = r13 === "left" ? t12.slice(i18) : t12.slice(0, t12.length - i18), typeof e17 == "string" ? (t12.length === 1 && r13 === "right" && (t12 = `${t12}0`), `0x${t12.length % 2 === 1 ? `0${t12}` : t12}`) : t12;
}

// node_modules/@catalogfi/wallets/dist/index86.js
var import_dist970 = __toESM(require_dist(), 1);
var import_dist971 = __toESM(require_dist2(), 1);
var import_dist972 = __toESM(require_dist3(), 1);
function f12(t12) {
  if (!t12 || t12.length === 0) return [];
  const o13 = [];
  for (const n13 of t12) {
    const { contractAddress: i18, chainId: s15, nonce: a24, ...e17 } = n13;
    o13.push([y8(s15), i18, y8(a24), ...g12({}, e17)]);
  }
  return o13;
}

// node_modules/@catalogfi/wallets/dist/index87.js
var import_dist991 = __toESM(require_dist(), 1);
var import_dist992 = __toESM(require_dist2(), 1);
var import_dist993 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index105.js
var import_dist973 = __toESM(require_dist(), 1);
var import_dist974 = __toESM(require_dist2(), 1);
var import_dist975 = __toESM(require_dist3(), 1);
var a21 = class extends t3 {
  constructor({ chainId: i18 }) {
    super(typeof i18 == "number" ? `Chain ID "${i18}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index106.js
var import_dist985 = __toESM(require_dist(), 1);
var import_dist986 = __toESM(require_dist2(), 1);
var import_dist987 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index111.js
var import_dist982 = __toESM(require_dist(), 1);
var import_dist983 = __toESM(require_dist2(), 1);
var import_dist984 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index112.js
var import_dist976 = __toESM(require_dist(), 1);
var import_dist977 = __toESM(require_dist2(), 1);
var import_dist978 = __toESM(require_dist3(), 1);
var e15 = { ether: -9, wei: 9 };

// node_modules/@catalogfi/wallets/dist/index113.js
var import_dist979 = __toESM(require_dist(), 1);
var import_dist980 = __toESM(require_dist2(), 1);
var import_dist981 = __toESM(require_dist3(), 1);
function a22(r13, l23) {
  let t12 = r13.toString();
  const i18 = t12.startsWith("-");
  i18 && (t12 = t12.slice(1)), t12 = t12.padStart(l23, "0");
  let [s15, e17] = [t12.slice(0, t12.length - l23), t12.slice(t12.length - l23)];
  return e17 = e17.replace(/(0+)$/, ""), `${i18 ? "-" : ""}${s15 || "0"}${e17 ? `.${e17}` : ""}`;
}

// node_modules/@catalogfi/wallets/dist/index111.js
function f13(i18, o13 = "wei") {
  return a22(i18, e15[o13]);
}

// node_modules/@catalogfi/wallets/dist/index106.js
var s12 = class extends t3 {
  constructor({ cause: a24, maxFeePerGas: e17 } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${e17 ? ` = ${f13(e17)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, { cause: a24, name: "FeeCapTooHighError" });
  }
};
Object.defineProperty(s12, "nodeMessage", { enumerable: true, configurable: true, writable: true, value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/ });
var t9 = class extends t3 {
  constructor({ cause: a24, maxPriorityFeePerGas: e17, maxFeePerGas: o13 } = {}) {
    super([`The provided tip (\`maxPriorityFeePerGas\`${e17 ? ` = ${f13(e17)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${o13 ? ` = ${f13(o13)} gwei` : ""}).`].join(`
`), { cause: a24, name: "TipAboveFeeCapError" });
  }
};
Object.defineProperty(t9, "nodeMessage", { enumerable: true, configurable: true, writable: true, value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/ });

// node_modules/@catalogfi/wallets/dist/index107.js
var import_dist988 = __toESM(require_dist(), 1);
var import_dist989 = __toESM(require_dist2(), 1);
var import_dist990 = __toESM(require_dist3(), 1);
function a23(s15, t12, r13, { strict: n13 } = {}) {
  return e10(s15, { strict: false }) ? p18(s15, t12, r13, { strict: n13 }) : f14(s15, t12, r13, { strict: n13 });
}
function c8(s15, t12) {
  if (typeof t12 == "number" && t12 > 0 && t12 > r7(s15) - 1) throw new i9({ offset: t12, position: "start", size: r7(s15) });
}
function u18(s15, t12, r13) {
  if (typeof t12 == "number" && typeof r13 == "number" && r7(s15) !== r13 - t12) throw new i9({ offset: r13, position: "end", size: r7(s15) });
}
function f14(s15, t12, r13, { strict: n13 } = {}) {
  c8(s15, t12);
  const o13 = s15.slice(t12, r13);
  return n13 && u18(o13, t12, r13), o13;
}
function p18(s15, t12, r13, { strict: n13 } = {}) {
  c8(s15, t12);
  const o13 = `0x${s15.replace("0x", "").slice((t12 ?? 0) * 2, (r13 ?? s15.length) * 2)}`;
  return n13 && u18(o13, t12, r13), o13;
}

// node_modules/@catalogfi/wallets/dist/index87.js
function G5(s15) {
  const { authorizationList: e17 } = s15;
  if (e17) for (const a24 of e17) {
    const { contractAddress: r13, chainId: o13 } = a24;
    if (!d15(r13)) throw new e11({ address: r13 });
    if (o13 <= 0) throw new a21({ chainId: o13 });
  }
  m15(s15);
}
function l19(s15) {
  const { blobVersionedHashes: e17 } = s15;
  if (e17) {
    if (e17.length === 0) throw new n12();
    for (const a24 of e17) {
      const r13 = r7(a24), o13 = u11(a23(a24, 0, 1));
      if (r13 !== 32) throw new t8({ hash: a24, size: r13 });
      if (o13 !== e14) throw new d17({ hash: a24, version: o13 });
    }
  }
  m15(s15);
}
function m15(s15) {
  const { chainId: e17, maxPriorityFeePerGas: a24, maxFeePerGas: r13, to: o13 } = s15;
  if (e17 <= 0) throw new a21({ chainId: e17 });
  if (o13 && !d15(o13)) throw new e11({ address: o13 });
  if (r13 && r13 > 2n ** 256n - 1n) throw new s12({ maxFeePerGas: r13 });
  if (a24 && r13 && a24 > r13) throw new t9({ maxFeePerGas: r13, maxPriorityFeePerGas: a24 });
}
function u19(s15) {
  const { chainId: e17, maxPriorityFeePerGas: a24, gasPrice: r13, maxFeePerGas: o13, to: i18 } = s15;
  if (e17 <= 0) throw new a21({ chainId: e17 });
  if (i18 && !d15(i18)) throw new e11({ address: i18 });
  if (a24 || o13) throw new t3("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r13 && r13 > 2n ** 256n - 1n) throw new s12({ maxFeePerGas: r13 });
}
function y12(s15) {
  const { chainId: e17, maxPriorityFeePerGas: a24, gasPrice: r13, maxFeePerGas: o13, to: i18 } = s15;
  if (i18 && !d15(i18)) throw new e11({ address: i18 });
  if (typeof e17 < "u" && e17 <= 0) throw new a21({ chainId: e17 });
  if (a24 || o13) throw new t3("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r13 && r13 > 2n ** 256n - 1n) throw new s12({ maxFeePerGas: r13 });
}

// node_modules/@catalogfi/wallets/dist/index88.js
var import_dist994 = __toESM(require_dist(), 1);
var import_dist995 = __toESM(require_dist2(), 1);
var import_dist996 = __toESM(require_dist3(), 1);
function t10(e17) {
  if (e17.type) return e17.type;
  if (typeof e17.authorizationList < "u") return "eip7702";
  if (typeof e17.blobs < "u" || typeof e17.blobVersionedHashes < "u" || typeof e17.maxFeePerBlobGas < "u" || typeof e17.sidecars < "u") return "eip4844";
  if (typeof e17.maxFeePerGas < "u" || typeof e17.maxPriorityFeePerGas < "u") return "eip1559";
  if (typeof e17.gasPrice < "u") return typeof e17.accessList < "u" ? "eip2930" : "legacy";
  throw new c7({ transaction: e17 });
}

// node_modules/@catalogfi/wallets/dist/index89.js
var import_dist997 = __toESM(require_dist(), 1);
var import_dist998 = __toESM(require_dist2(), 1);
var import_dist999 = __toESM(require_dist3(), 1);
function f15(r13) {
  if (!r13 || r13.length === 0) return [];
  const i18 = [];
  for (let t12 = 0; t12 < r13.length; t12++) {
    const { address: o13, storageKeys: e17 } = r13[t12];
    for (let s15 = 0; s15 < e17.length; s15++) if (e17[s15].length - 2 !== 64) throw new l17({ storageKey: e17[s15] });
    if (!d15(o13, { strict: false })) throw new e11({ address: o13 });
    i18.push([o13, e17]);
  }
  return i18;
}

// node_modules/@catalogfi/wallets/dist/index60.js
function J2(t12, o13) {
  const n13 = t10(t12);
  return n13 === "eip1559" ? N9(t12, o13) : n13 === "eip2930" ? _9(t12, o13) : n13 === "eip4844" ? M6(t12, o13) : n13 === "eip7702" ? K6(t12, o13) : O8(t12, o13);
}
function K6(t12, o13) {
  const { authorizationList: n13, chainId: a24, gas: i18, nonce: e17, to: c10, value: x15, maxFeePerGas: m17, maxPriorityFeePerGas: r13, accessList: l23, data: p20 } = t12;
  G5(t12);
  const u22 = f15(l23), f17 = f12(n13);
  return f9(["0x04", l16([y8(a24), e17 ? y8(e17) : "0x", r13 ? y8(r13) : "0x", m17 ? y8(m17) : "0x", i18 ? y8(i18) : "0x", c10 ?? "0x", x15 ? y8(x15) : "0x", p20 ?? "0x", u22, f17, ...g12(t12, o13)])]);
}
function M6(t12, o13) {
  const { chainId: n13, gas: a24, nonce: i18, to: e17, value: c10, maxFeePerBlobGas: x15, maxFeePerGas: m17, maxPriorityFeePerGas: r13, accessList: l23, data: p20 } = t12;
  l19(t12);
  let u22 = t12.blobVersionedHashes, f17 = t12.sidecars;
  if (t12.blobs && (typeof u22 > "u" || typeof f17 > "u")) {
    const b10 = typeof t12.blobs[0] == "string" ? t12.blobs : t12.blobs.map((d20) => g8(d20)), v8 = t12.kzg, P6 = f11({ blobs: b10, kzg: v8 });
    if (typeof u22 > "u" && (u22 = r12({ commitments: P6 })), typeof f17 > "u") {
      const d20 = l18({ blobs: b10, commitments: P6, kzg: v8 });
      f17 = p17({ blobs: b10, commitments: P6, proofs: d20 });
    }
  }
  const E14 = f15(l23), z10 = [y8(n13), i18 ? y8(i18) : "0x", r13 ? y8(r13) : "0x", m17 ? y8(m17) : "0x", a24 ? y8(a24) : "0x", e17 ?? "0x", c10 ? y8(c10) : "0x", p20 ?? "0x", E14, x15 ? y8(x15) : "0x", u22 ?? [], ...g12(t12, o13)], L12 = [], F11 = [], G6 = [];
  if (f17) for (let b10 = 0; b10 < f17.length; b10++) {
    const { blob: v8, commitment: P6, proof: d20 } = f17[b10];
    L12.push(v8), F11.push(P6), G6.push(d20);
  }
  return f9(["0x03", f17 ? l16([z10, L12, F11, G6]) : l16(z10)]);
}
function N9(t12, o13) {
  const { chainId: n13, gas: a24, nonce: i18, to: e17, value: c10, maxFeePerGas: x15, maxPriorityFeePerGas: m17, accessList: r13, data: l23 } = t12;
  m15(t12);
  const p20 = f15(r13), u22 = [y8(n13), i18 ? y8(i18) : "0x", m17 ? y8(m17) : "0x", x15 ? y8(x15) : "0x", a24 ? y8(a24) : "0x", e17 ?? "0x", c10 ? y8(c10) : "0x", l23 ?? "0x", p20, ...g12(t12, o13)];
  return f9(["0x02", l16(u22)]);
}
function _9(t12, o13) {
  const { chainId: n13, gas: a24, data: i18, nonce: e17, to: c10, value: x15, accessList: m17, gasPrice: r13 } = t12;
  u19(t12);
  const l23 = f15(m17), p20 = [y8(n13), e17 ? y8(e17) : "0x", r13 ? y8(r13) : "0x", a24 ? y8(a24) : "0x", c10 ?? "0x", x15 ? y8(x15) : "0x", i18 ?? "0x", l23, ...g12(t12, o13)];
  return f9(["0x01", l16(p20)]);
}
function O8(t12, o13) {
  const { chainId: n13 = 0, gas: a24, data: i18, nonce: e17, to: c10, value: x15, gasPrice: m17 } = t12;
  y12(t12);
  let r13 = [e17 ? y8(e17) : "0x", m17 ? y8(m17) : "0x", a24 ? y8(a24) : "0x", c10 ?? "0x", x15 ? y8(x15) : "0x", i18 ?? "0x"];
  if (o13) {
    const l23 = (() => {
      if (o13.v >= 35n) return (o13.v - 35n) / 2n > 0 ? o13.v : 27n + (o13.v === 35n ? 0n : 1n);
      if (n13 > 0) return BigInt(n13 * 2) + BigInt(35n + o13.v - 27n);
      const f17 = 27n + (o13.v === 27n ? 0n : 1n);
      if (o13.v !== f17) throw new s10({ v: o13.v });
      return f17;
    })(), p20 = g11(o13.r), u22 = g11(o13.s);
    r13 = [...r13, y8(l23), p20 === "0x00" ? "0x" : p20, u22 === "0x00" ? "0x" : u22];
  } else n13 > 0 && (r13 = [...r13, y8(n13), "0x", "0x"]);
  return l16(r13);
}
function g12(t12, o13) {
  const n13 = o13 ?? t12, { v: a24, yParity: i18 } = n13;
  if (typeof n13.r > "u") return [];
  if (typeof n13.s > "u") return [];
  if (typeof a24 > "u" && typeof i18 > "u") return [];
  const e17 = g11(n13.r), c10 = g11(n13.s);
  return [typeof i18 == "number" ? i18 ? y8(1) : "0x" : a24 === 0n ? "0x" : a24 === 1n ? y8(1) : a24 === 27n ? "0x" : y8(1), e17 === "0x00" ? "0x" : e17, c10 === "0x00" ? "0x" : c10];
}

// node_modules/@catalogfi/wallets/dist/index50.js
async function p19(r13) {
  const { privateKey: s15, transaction: a24, serializer: i18 = J2 } = r13, t12 = a24.type === "eip4844" ? { ...a24, sidecars: false } : a24, e17 = await y10({ hash: a17(i18(t12)), privateKey: s15 });
  return i18(a24, e17);
}

// node_modules/@catalogfi/wallets/dist/index51.js
var import_dist1021 = __toESM(require_dist(), 1);
var import_dist1022 = __toESM(require_dist2(), 1);
var import_dist1023 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index61.js
var import_dist1018 = __toESM(require_dist(), 1);
var import_dist1019 = __toESM(require_dist2(), 1);
var import_dist1020 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index90.js
var import_dist1009 = __toESM(require_dist(), 1);
var import_dist1010 = __toESM(require_dist2(), 1);
var import_dist1011 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index108.js
var import_dist1006 = __toESM(require_dist(), 1);
var import_dist1007 = __toESM(require_dist2(), 1);
var import_dist1008 = __toESM(require_dist3(), 1);
var i16 = class extends t3 {
  constructor({ expectedLength: e17, givenLength: r13, type: s15 }) {
    super([`ABI encoding array length mismatch for type ${s15}.`, `Expected length: ${e17}`, `Given length: ${r13}`].join(`
`), { name: "AbiEncodingArrayLengthMismatchError" });
  }
};
var o12 = class extends t3 {
  constructor({ expectedSize: e17, value: r13 }) {
    super(`Size of bytes "${r13}" (bytes${r7(r13)}) does not match expected size (bytes${e17}).`, { name: "AbiEncodingBytesSizeMismatchError" });
  }
};
var c9 = class extends t3 {
  constructor({ expectedLength: e17, givenLength: r13 }) {
    super(["ABI encoding params/values length mismatch.", `Expected length (params): ${e17}`, `Given length (values): ${r13}`].join(`
`), { name: "AbiEncodingLengthMismatchError" });
  }
};
var d18 = class extends t3 {
  constructor({ expectedSize: e17, givenSize: r13 }) {
    super(`Expected bytes${e17}, got bytes${r13}.`, { name: "BytesSizeMismatchError" });
  }
};
var g13 = class extends t3 {
  constructor(e17, { docsPath: r13 }) {
    super([`Type "${e17}" is not a valid encoding type.`, "Please provide a valid ABI type."].join(`
`), { docsPath: r13, name: "InvalidAbiEncodingType" });
  }
};
var h8 = class extends t3 {
  constructor(e17) {
    super([`Value "${e17}" is not a valid array.`].join(`
`), { name: "InvalidArrayError" });
  }
};

// node_modules/@catalogfi/wallets/dist/index90.js
function I9(n13, t12) {
  if (n13.length !== t12.length) throw new c9({ expectedLength: n13.length, givenLength: t12.length });
  const e17 = M7({ params: n13, values: t12 }), r13 = l20(e17);
  return r13.length === 0 ? "0x" : r13;
}
function M7({ params: n13, values: t12 }) {
  const e17 = [];
  for (let r13 = 0; r13 < n13.length; r13++) e17.push(u20({ param: n13[r13], value: t12[r13] }));
  return e17;
}
function u20({ param: n13, value: t12 }) {
  const e17 = h9(n13.type);
  if (e17) {
    const [r13, o13] = e17;
    return H6(t12, { length: r13, param: { ...n13, type: o13 } });
  }
  if (n13.type === "tuple") return C6(t12, { param: n13 });
  if (n13.type === "address") return $8(t12);
  if (n13.type === "bool") return P4(t12);
  if (n13.type.startsWith("uint") || n13.type.startsWith("int")) {
    const r13 = n13.type.startsWith("int");
    return W(t12, { signed: r13 });
  }
  if (n13.type.startsWith("bytes")) return T11(t12, { param: n13 });
  if (n13.type === "string") return B11(t12);
  throw new g13(n13.type, { docsPath: "/docs/contract/encodeAbiParameters" });
}
function l20(n13) {
  let t12 = 0;
  for (let i18 = 0; i18 < n13.length; i18++) {
    const { dynamic: a24, encoded: s15 } = n13[i18];
    a24 ? t12 += 32 : t12 += r7(s15);
  }
  const e17 = [], r13 = [];
  let o13 = 0;
  for (let i18 = 0; i18 < n13.length; i18++) {
    const { dynamic: a24, encoded: s15 } = n13[i18];
    a24 ? (e17.push(p12(t12 + o13, { size: 32 })), r13.push(s15), o13 += r7(s15)) : e17.push(s15);
  }
  return s8([...e17, ...r13]);
}
function $8(n13) {
  if (!d15(n13)) throw new e11({ address: n13 });
  return { dynamic: false, encoded: d11(n13.toLowerCase()) };
}
function H6(n13, { length: t12, param: e17 }) {
  const r13 = t12 === null;
  if (!Array.isArray(n13)) throw new h8(n13);
  if (!r13 && n13.length !== t12) throw new i16({ expectedLength: t12, givenLength: n13.length, type: `${e17.type}[${t12}]` });
  let o13 = false;
  const i18 = [];
  for (let a24 = 0; a24 < n13.length; a24++) {
    const s15 = u20({ param: e17, value: n13[a24] });
    s15.dynamic && (o13 = true), i18.push(s15);
  }
  if (r13 || o13) {
    const a24 = l20(i18);
    if (r13) {
      const s15 = p12(i18.length, { size: 32 });
      return { dynamic: true, encoded: i18.length > 0 ? s8([s15, a24]) : s15 };
    }
    if (o13) return { dynamic: true, encoded: a24 };
  }
  return { dynamic: false, encoded: s8(i18.map(({ encoded: a24 }) => a24)) };
}
function T11(n13, { param: t12 }) {
  const [, e17] = t12.type.split("bytes"), r13 = r7(n13);
  if (!e17) {
    let o13 = n13;
    return r13 % 32 !== 0 && (o13 = d11(o13, { dir: "right", size: Math.ceil((n13.length - 2) / 2 / 32) * 32 })), { dynamic: true, encoded: s8([d11(p12(r13, { size: 32 })), o13]) };
  }
  if (r13 !== Number.parseInt(e17)) throw new o12({ expectedSize: Number.parseInt(e17), value: n13 });
  return { dynamic: false, encoded: d11(n13, { dir: "right" }) };
}
function P4(n13) {
  if (typeof n13 != "boolean") throw new t3(`Invalid boolean value: "${n13}" (type: ${typeof n13}). Expected: \`true\` or \`false\`.`);
  return { dynamic: false, encoded: d11(m11(n13)) };
}
function W(n13, { signed: t12 }) {
  return { dynamic: false, encoded: p12(n13, { size: 32, signed: t12 }) };
}
function B11(n13) {
  const t12 = z5(n13), e17 = Math.ceil(r7(t12) / 32), r13 = [];
  for (let o13 = 0; o13 < e17; o13++) r13.push(d11(a23(t12, o13 * 32, (o13 + 1) * 32), { dir: "right" }));
  return { dynamic: true, encoded: s8([d11(p12(r7(t12), { size: 32 })), ...r13]) };
}
function C6(n13, { param: t12 }) {
  let e17 = false;
  const r13 = [];
  for (let o13 = 0; o13 < t12.components.length; o13++) {
    const i18 = t12.components[o13], a24 = Array.isArray(n13) ? o13 : i18.name, s15 = u20({ param: i18, value: n13[a24] });
    r13.push(s15), s15.dynamic && (e17 = true);
  }
  return { dynamic: e17, encoded: e17 ? l20(r13) : s8(r13.map(({ encoded: o13 }) => o13)) };
}
function h9(n13) {
  const t12 = n13.match(/^(.*)\[(\d+)?\]$/);
  return t12 ? [t12[2] ? Number(t12[2]) : null, t12[1]] : void 0;
}

// node_modules/@catalogfi/wallets/dist/index91.js
var import_dist1015 = __toESM(require_dist(), 1);
var import_dist1016 = __toESM(require_dist2(), 1);
var import_dist1017 = __toESM(require_dist3(), 1);

// node_modules/@catalogfi/wallets/dist/index109.js
var import_dist1012 = __toESM(require_dist(), 1);
var import_dist1013 = __toESM(require_dist2(), 1);
var import_dist1014 = __toESM(require_dist3(), 1);
var e16 = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
var t11 = /^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;

// node_modules/@catalogfi/wallets/dist/index91.js
function w11(e17) {
  const { domain: a24, message: d20, primaryType: m17, types: s15 } = e17, o13 = (c10, g15) => {
    for (const I10 of c10) {
      const { name: u22, type: i18 } = I10, n13 = g15[u22], t12 = i18.match(t11);
      if (t12 && (typeof n13 == "number" || typeof n13 == "bigint")) {
        const [b10, r13, h11] = t12;
        p12(n13, { signed: r13 === "int", size: Number.parseInt(h11) / 8 });
      }
      if (i18 === "address" && typeof n13 == "string" && !d15(n13)) throw new e11({ address: n13 });
      const p20 = i18.match(e16);
      if (p20) {
        const [b10, r13] = p20;
        if (r13 && r7(n13) !== Number.parseInt(r13)) throw new d18({ expectedSize: Number.parseInt(r13), givenSize: r7(n13) });
      }
      const f17 = s15[i18];
      f17 && o13(f17, n13);
    }
  };
  s15.EIP712Domain && a24 && o13(s15.EIP712Domain, a24), m17 !== "EIP712Domain" && o13(s15[m17], d20);
}
function P5({ domain: e17 }) {
  return [typeof (e17 == null ? void 0 : e17.name) == "string" && { name: "name", type: "string" }, (e17 == null ? void 0 : e17.version) && { name: "version", type: "string" }, typeof (e17 == null ? void 0 : e17.chainId) == "number" && { name: "chainId", type: "uint256" }, (e17 == null ? void 0 : e17.verifyingContract) && { name: "verifyingContract", type: "address" }, (e17 == null ? void 0 : e17.salt) && { name: "salt", type: "bytes32" }].filter(Boolean);
}

// node_modules/@catalogfi/wallets/dist/index61.js
function x13(r13) {
  const { domain: a24 = {}, message: t12, primaryType: e17 } = r13, y13 = { EIP712Domain: P5({ domain: a24 }), ...r13.types };
  w11({ domain: a24, message: t12, primaryType: e17, types: y13 });
  const p20 = ["0x1901"];
  return a24 && p20.push(u21({ domain: a24, types: y13 })), e17 !== "EIP712Domain" && p20.push(i17({ data: t12, primaryType: e17, types: y13 })), a17(s8(p20));
}
function u21({ domain: r13, types: a24 }) {
  return i17({ data: r13, primaryType: "EIP712Domain", types: a24 });
}
function i17({ data: r13, primaryType: a24, types: t12 }) {
  const e17 = f16({ data: r13, primaryType: a24, types: t12 });
  return a17(e17);
}
function f16({ data: r13, primaryType: a24, types: t12 }) {
  const e17 = [{ type: "bytes32" }], y13 = [g14({ primaryType: a24, types: t12 })];
  for (const p20 of t12[a24]) {
    const [s15, o13] = h10({ types: t12, name: p20.name, type: p20.type, value: r13[p20.name] });
    e17.push(s15), y13.push(o13);
  }
  return I9(e17, y13);
}
function g14({ primaryType: r13, types: a24 }) {
  const t12 = y8(d19({ primaryType: r13, types: a24 }));
  return a17(t12);
}
function d19({ primaryType: r13, types: a24 }) {
  let t12 = "";
  const e17 = T12({ primaryType: r13, types: a24 });
  e17.delete(r13);
  const y13 = [r13, ...Array.from(e17).sort()];
  for (const p20 of y13) t12 += `${p20}(${a24[p20].map(({ name: s15, type: o13 }) => `${o13} ${s15}`).join(",")})`;
  return t12;
}
function T12({ primaryType: r13, types: a24 }, t12 = /* @__PURE__ */ new Set()) {
  var y13;
  const e17 = (y13 = r13.match(/^\w*/u)) == null ? void 0 : y13[0];
  if (t12.has(e17) || a24[e17] === void 0) return t12;
  t12.add(e17);
  for (const p20 of a24[e17]) T12({ primaryType: p20.type, types: a24 }, t12);
  return t12;
}
function h10({ types: r13, name: a24, type: t12, value: e17 }) {
  if (r13[t12] !== void 0) return [{ type: "bytes32" }, a17(f16({ data: e17, primaryType: t12, types: r13 }))];
  if (t12 === "bytes") return e17 = `0x${(e17.length % 2 ? "0" : "") + e17.slice(2)}`, [{ type: "bytes32" }, a17(e17)];
  if (t12 === "string") return [{ type: "bytes32" }, a17(y8(e17))];
  if (t12.lastIndexOf("]") === t12.length - 1) {
    const y13 = t12.slice(0, t12.lastIndexOf("[")), p20 = e17.map((s15) => h10({ name: a24, type: y13, types: r13, value: s15 }));
    return [{ type: "bytes32" }, a17(I9(p20.map(([s15]) => s15), p20.map(([, s15]) => s15)))];
  }
  return [{ type: t12 }, e17];
}

// node_modules/@catalogfi/wallets/dist/index51.js
async function s13(a24) {
  const { privateKey: t12, ...e17 } = a24;
  return await y10({ hash: x13(e17), privateKey: t12, to: "hex" });
}

// node_modules/@catalogfi/wallets/dist/index43.js
function l21(r13, s15 = {}) {
  const { nonceManager: i18 } = s15, a24 = y8(E13.getPublicKey(r13.slice(2), false)), t12 = t5(a24);
  return { ...a18({ address: t12, nonceManager: i18, async sign({ hash: e17 }) {
    return y10({ hash: e17, privateKey: r13, to: "hex" });
  }, async experimental_signAuthorization(e17) {
    return d16({ ...e17, privateKey: r13 });
  }, async signMessage({ message: e17 }) {
    return r11({ message: e17, privateKey: r13 });
  }, async signTransaction(e17, { serializer: n13 } = {}) {
    return p19({ privateKey: r13, transaction: e17, serializer: n13 });
  }, async signTypedData(e17) {
    return s13({ ...e17, privateKey: r13 });
  } }), publicKey: a24, source: "privateKey" };
}

// node_modules/@catalogfi/wallets/dist/index28.js
function s14(o13, { accountIndex: t12 = 0, addressIndex: r13 = 0, changeIndex: n13 = 0, path: c10, ...d20 } = {}) {
  const e17 = o13.derive(c10 || `m/44'/60'/${t12}'/${n13}/${r13}`);
  return { ...l21(y8(e17.privateKey), d20), getHdKey: () => e17, source: "hd" };
}

// node_modules/@catalogfi/wallets/dist/index18.js
var T13 = class {
  constructor(t12) {
    this.endpoint = t12;
  }
  async getTransactions(t12) {
    for (let e17 = 1; e17 <= 10; e17++) {
      const a24 = await this._getTransactions(t12);
      if (typeof a24.result != "string") return a24.result;
      await d(1e3 * e17);
    }
    throw new Error("Unable to fetch transactions.");
  }
  async _getTransactions(t12) {
    try {
      const e17 = new URL(this.endpoint);
      return e17.searchParams.append("module", "account"), e17.searchParams.append("address", t12), e17.searchParams.append("startblock", "0"), e17.searchParams.append("endblock", "latest"), e17.searchParams.append("offset", "1"), e17.searchParams.append("action", "txlist"), await k.get(e17);
    } catch (e17) {
      return { status: "0", message: e17.message, result: "Failed to fetch transactions" };
    }
  }
};
var b9 = (s15, t12) => `m/44'/60'/${s15}'/0/${t12}`;
var l22 = (s15, t12, e17) => {
  const a24 = b9(t12, s15), r13 = s14(e17, { path: a24 });
  return { address: r13.address, path: a24, publicKey: r13.publicKey, privateKey: "0x" + Buffer.from(_(r13.getHdKey().privateKey, "HDKey doesn't have a private key")).toString("hex") };
};
var x14 = (s15, t12, e17, a24, r13) => {
  const o13 = [];
  for (let n13 = t12; n13 < e17; n13++) {
    const { address: c10, path: p20, privateKey: i18 } = l22(n13, s15, a24), f17 = new Promise((u22, y13) => {
      r13.getTransactions(c10).then((d20) => u22({ address: c10, path: p20, privateKey: i18, transactions: d20 })).catch((d20) => y13(d20));
    });
    o13.push(f17);
  }
  return o13;
};
var m16 = (s15) => p11.fromMasterSeed(w12.mnemonicToSeedSync(s15));
var k8 = async (s15, t12) => {
  const e17 = m16(s15);
  let a24 = [];
  for (let r13 = 0; ; r13++) {
    const o13 = [];
    let n13 = 0;
    for (let c10 = 0; n13 <= 20; c10 += 5) {
      const p20 = await Promise.all(x14(r13, c10, c10 + 5, e17, t12));
      await d(1500);
      for (const i18 of p20) i18.transactions.length === 0 ? n13++ : (o13.push(i18), n13 > 0 && (n13 = 0));
    }
    if (o13.length === 0) break;
    a24.push(...o13);
  }
  return a24;
};

export {
  a,
  e,
  n,
  s,
  p,
  d2 as d,
  s2,
  require_varuint_bitcoin,
  require_src5 as require_src,
  t,
  i2 as i,
  r,
  i3 as i2,
  A,
  l,
  F,
  r3 as r2,
  u4 as u,
  x,
  p4 as p2,
  k2 as k,
  I2 as I,
  i7 as i3,
  n7 as n2,
  r5 as r3,
  T13 as T,
  k8 as k2,
  import_bitcoinjs_lib10 as import_bitcoinjs_lib
};
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index38.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index67.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index40.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index93.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index92.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index66.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index39.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index41.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index27.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index95.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index68.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index97.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index96.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index69.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@catalogfi/wallets/dist/index44.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-IAEW6RMH.js.map
